webpackHotUpdate(0,{

/***/ 894:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _reactKonva = __webpack_require__(910);

var _semanticUiReact = __webpack_require__(18);

var _reactDimensions = __webpack_require__(917);

var _reactDimensions2 = _interopRequireDefault(_reactDimensions);

var _navbar = __webpack_require__(75);

var _navbar2 = _interopRequireDefault(_navbar);

var _reactRouterDom = __webpack_require__(74);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

exports.default = (0, _reactRouterDom.withRouter)(function (_Component) {
    _inherits(MyRect, _Component);

    function MyRect(props) {
        _classCallCheck(this, MyRect);

        // let shapes = []
        // shapes.push(<Rect
        //     x={Math.floor(Math.random() * 1600 + 1)}
        //     y={Math.floor(Math.random() * 900 + 1)}
        //     width={100}
        //     height={100}
        //     fill={this.state.color}
        //     shadowBlur={5}
        //     onClick={this.handleClick}
        // />)
        var _this = _possibleConstructorReturn(this, (MyRect.__proto__ || Object.getPrototypeOf(MyRect)).call(this, props));

        _this.state = {
            color: 'green',
            shapes: [],
            id: _this.props.match.params.mapId
        };
        _this.addShape = _this.addShape.bind(_this);
        _this.onDragStart = _this.onDragStart.bind(_this);
        _this.onDragMove = _this.onDragMove.bind(_this);
        _this.onMouseOver = _this.onMouseOver.bind(_this);
        _this.onMouseOut = _this.onMouseOut.bind(_this);
        _this.onDblClick = _this.onDblClick.bind(_this);
        _this.onDblTap = _this.onDblTap.bind(_this);
        _this.save = _this.save.bind(_this);
        return _this;
    }

    _createClass(MyRect, [{
        key: 'addShape',
        value: function addShape(e) {
            console.log('addShape ', e);
        }
    }, {
        key: 'onDragStart',
        value: function onDragStart(e) {
            console.log('onDragStart', e);
        }
    }, {
        key: 'onDragMove',
        value: function onDragMove(e) {
            console.log('onDragMove', e);
        }
    }, {
        key: 'onMouseOver',
        value: function onMouseOver(e) {
            console.log('onMouseOver', e);
            document.body.style.cursor = 'pointer';
        }
    }, {
        key: 'onMouseOut',
        value: function onMouseOut(e) {
            console.log('onMouseOut', e);
            document.body.style.cursor = 'default';
        }
    }, {
        key: 'onDblClick',
        value: function onDblClick(e) {
            console.log('onDblClick', e);
        }
    }, {
        key: 'onDblTap',
        value: function onDblTap(e) {
            console.log('onDblTap', e);
        }
    }, {
        key: 'componentDidMount',
        value: function componentDidMount() {
            this.setState({ color: 'green' });
        }
    }, {
        key: 'addShape',
        value: function addShape() {
            var shapes = this.state.shapes;
            shapes.push(_react2.default.createElement(_reactKonva.Rect, {
                x: Math.floor(Math.random() * 1600 + 1),
                y: Math.floor(Math.random() * 900 + 1),
                width: 100,
                height: 100,
                fill: this.state.color,
                shadowBlur: 5,
                draggable: true,
                onClick: this.handleClick,
                onDragStart: this.onDragStart,
                onDragMove: this.onDragMove,
                onMouseOver: this.onMouseOver,
                onMouseOut: this.onMouseOut,
                onDblClick: this.onDblClick,
                onDblTap: this.onDblClick
            }));
            this.setState({
                color: window.Konva.Util.getRandomColor(),
                shapes: shapes
            });
        }
    }, {
        key: 'save',
        value: function save() {
            alert('mapId:' + this.state.id);
        }
    }, {
        key: 'render',
        value: function render() {
            return _react2.default.createElement(
                'div',
                null,
                _react2.default.createElement(_navbar2.default, null),
                _react2.default.createElement(
                    _semanticUiReact.Button,
                    { onClick: this.addShape },
                    'Add'
                ),
                _react2.default.createElement(
                    _semanticUiReact.Button,
                    { onClick: this.save },
                    'Save'
                ),
                _react2.default.createElement(
                    _reactKonva.Stage,
                    { width: 1600, height: 900 },
                    _react2.default.createElement(
                        _reactKonva.Layer,
                        null,
                        this.state.shapes.map(function (shape) {
                            return shape;
                        })
                    )
                )
            );
        }
    }]);

    return MyRect;
}(_react.Component));

/***/ }),

/***/ 906:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),

/***/ 907:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (process.env.NODE_ENV !== 'production') {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),

/***/ 908:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ 909:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var emptyFunction = __webpack_require__(906);

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  var printWarning = function printWarning(format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function warning(condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

module.exports = warning;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),

/***/ 910:
/***/ (function(module, exports, __webpack_require__) {

// Adapted from ReactART:
// https://github.com/reactjs/react-art

var Konva = __webpack_require__(911);
var React = __webpack_require__(70);

var PropTypes = __webpack_require__(912);
var createClass = __webpack_require__(257);

var ReactInstanceMap = __webpack_require__(87);
var ReactMultiChild = __webpack_require__(538);
var ReactUpdates = __webpack_require__(41);

var assign = __webpack_require__(16);
var emptyObject = __webpack_require__(916);

// some patching to make Konva.Node looks like DOM nodes
var oldAdd = Konva.Container.prototype.add;
Konva.Container.prototype.add = function(child) {
  child.parentNode = this;
  oldAdd.apply(this, arguments);
};

Konva.Container.prototype.replaceChild = function(newChild, oldChild) {
  var index = oldChild.index;
  var parent = oldChild.parent;
  oldChild.destroy();
  oldChild.parentNode = null;
  parent.add(newChild);
  if (newChild.index !== index) {
    newChild.setZIndex(index);
  }
  parent.getLayer().batchDraw();
};

function createComponent(name) {
  var ReactKonvaComponent = function(element) {
    this.node = null;
    this.subscriptions = null;
    this.listeners = null;
    this._mountImage = null;
    this._renderedChildren = null;
    this._mostRecentlyPlacedChild = null;
    this._nativeContainerInfo = null;
    this._initialProps = element.props;
    this._currentElement = element;
  };

  ReactKonvaComponent.displayName = name;

  for (var i = 1, l = arguments.length; i < l; i++) {
    assign(ReactKonvaComponent.prototype, arguments[i]);
  }

  return ReactKonvaComponent;
}

var ContainerMixin = assign({}, ReactMultiChild.Mixin, {
  moveChild: function(prevChild, lastPlacedNode, nextIndex, lastIndex) {
    var childNode = prevChild._mountImage.node;
    if (childNode.index !== nextIndex) {
      childNode.setZIndex(nextIndex);
      var layer = childNode.getLayer();
      layer && layer.batchDraw();
    }
  },
  createChild: function(child, afterNode, mountImage) {
    child._mountImage = mountImage;
    var childNode = mountImage.node;
    childNode.moveTo(this.node);
    childNode.parentNode = this.node;
    if (child._mountIndex !== childNode.index) {
      childNode.setZIndex(child._mountIndex);
    }
    this._mostRecentlyPlacedChild = childNode;
    var layer = childNode.getLayer();
    layer && layer.batchDraw();
  },
  removeChild: function(child, node) {
    var layer = child._mountImage.node.getLayer();
    child._mountImage.node.destroy();
    child._mountImage.node.parentNode = null;
    layer && layer.batchDraw();
    child._mountImage = null;
  },
  updateChildrenAtRoot: function(nextChildren, transaction) {
    this.updateChildren(nextChildren, transaction, emptyObject);
  },
  mountAndInjectChildrenAtRoot: function(children, transaction) {
    this.mountAndInjectChildren(children, transaction, emptyObject);
  },
  updateChildren: function(nextChildren, transaction, context) {
    this._mostRecentlyPlacedChild = null;
    this._updateChildren(nextChildren, transaction, context);
  },
  mountAndInjectChildren: function(children, transaction, context) {
    var mountedImages = this.mountChildren(children, transaction, context);
    // Each mount image corresponds to one of the flattened children
    var i = 0;
    for (var key in this._renderedChildren) {
      if (this._renderedChildren.hasOwnProperty(key)) {
        var child = this._renderedChildren[key];
        child._mountImage = mountedImages[i];
        // runtime check for moveTo method
        // it is possible that child component with be not Konva.Node instance
        // for instance <noscript> for null element
        var node = mountedImages[i].node;
        if (!node instanceof Konva.Node) {
          var message = 'Looks like one of child element is not Konva.Node.' +
            'react-konva do not support in for now.';
          ('if you have empty(null) child, replace it with <Group/>');
          console.error(message, this);
          continue;
        }
        if (node.parent !== this.node) {
          node.moveTo(this.node);
        }
        i++;
      }
    }
  },
  mountAndAddChildren: function() {
    console.log('mountAndAddChildren');
  }
});

var propsToSkip = { children: true, ref: true, key: true, style: true };

var NodeMixin = {
  construct: function(element) {
    this._currentElement = element;
  },
  receiveComponent: function(nextComponent, transaction, context) {
    var props = nextComponent.props;
    var oldProps = this._currentElement.props || this._initialProps;
    this.applyNodeProps(oldProps, props);
    this.updateChildren(props.children, transaction, context);
    this._currentElement = nextComponent;
  },
  getPublicInstance: function() {
    return this.node;
  },
  putEventListener: function(type, listener) {
    // NOPE...
  },
  handleEvent: function(event) {
    // NOPE...
  },
  getNativeNode: function() {
    return this.node;
  },
  applyNodeProps: function(oldProps, props) {
    var updatedProps = {};
    var hasUpdates = false;
    for (var key in oldProps) {
      if (propsToSkip[key]) {
        continue;
      }
      var isEvent = key.slice(0, 2) === 'on';
      var propChanged = oldProps[key] !== props[key];
      if (isEvent && propChanged) {
        var eventName = key.substr(2).toLowerCase();
        if (eventName.substr(0, 7) === 'content') {
          eventName = 'content' +
            eventName.substr(7, 1).toUpperCase() +
            eventName.substr(8);
        }
        this.node.off(eventName, oldProps[key]);
      }
      var toRemove = !props.hasOwnProperty(key);
      if (toRemove) {
        this.node.setAttr(key, undefined);
      }
    }
    for (var key in props) {
      if (propsToSkip[key]) {
        continue;
      }
      var isEvent = key.slice(0, 2) === 'on';
      var toAdd = oldProps[key] !== props[key];
      if (isEvent && toAdd) {
        var eventName = key.substr(2).toLowerCase();
        if (eventName.substr(0, 7) === 'content') {
          eventName = 'content' +
            eventName.substr(7, 1).toUpperCase() +
            eventName.substr(8);
        }
        this.node.on(eventName, props[key]);
      }
      if (
        !isEvent &&
        (props[key] !== oldProps[key] || props[key] !== this.node.getAttr(key))
      ) {
        hasUpdates = true;
        updatedProps[key] = props[key];
      }
    }

    if (hasUpdates) {
      this.node.setAttrs(updatedProps);
      var drawingNode = this.node.getLayer() || this.node.getStage();
      drawingNode && drawingNode.batchDraw();
      var val, prop;
      for (prop in updatedProps) {
        val = updatedProps[prop];
        if (val instanceof window.Image && !val.complete) {
          var node = this.node;
          val.addEventListener('load', function() {
            var layer = node.getLayer();
            layer && layer.batchDraw();
          });
        }
      }
    }
  },
  unmountComponent: function() {},
  mountComponentIntoNode: function(rootID, container) {
    throw new Error(
      'You cannot render an ART component standalone. ' +
        'You need to wrap it in a Stage.'
    );
  }
};

var Stage = createClass({
  propTypes: {
    width: PropTypes.oneOfType([
      PropTypes.number,
      PropTypes.string
    ]),
    height: PropTypes.oneOfType([
      PropTypes.number,
      PropTypes.string
    ])
  },
  displayName: 'Stage',
  mixins: [ContainerMixin],
  componentDidMount: function() {
    this.node = new Konva.Stage({
      container: this.domNode,
      width: this.props.width,
      height: this.props.height
    });
    this.applyNodeProps(emptyObject, this.props);
    this._debugID = this._reactInternalInstance._debugID;
    var transaction = ReactUpdates.ReactReconcileTransaction.getPooled();

    transaction.perform(
      this.mountAndInjectChildren,
      this,
      this.props.children,
      transaction,
      ReactInstanceMap.get(this)._context
    );
    ReactUpdates.ReactReconcileTransaction.release(transaction);

    this.node.draw();
  },
  getStage: function() {
    return this.node;
  },
  componentDidUpdate: function(oldProps) {
    var node = this.node;

    this.applyNodeProps(oldProps, this.props);

    var transaction = ReactUpdates.ReactReconcileTransaction.getPooled();
    transaction.perform(
      this.updateChildren,
      this,
      this.props.children,
      transaction,
      ReactInstanceMap.get(this)._context
    );
    ReactUpdates.ReactReconcileTransaction.release(transaction);
  },
  componentWillUnmount: function() {
    this.unmountChildren();
    this.node.destroy();
    this.node.parentNode = null;
  },
  applyNodeProps: NodeMixin.applyNodeProps,
  render: function() {
    var props = this.props;

    return React.createElement('div', {
      ref: (function(c) {
        return (this.domNode = c);
      }).bind(this),
      className: props.className,
      role: props.role,
      style: props.style,
      tabIndex: props.tabIndex,
      title: props.title
    });
  }
});

var GroupMixin = {
  mountComponent: function(
    transaction,
    nativeParent,
    nativeContainerInfo,
    context
  ) {
    this._nativeContainerInfo = nativeContainerInfo;
    this.node = new Konva[this.constructor.displayName]();
    nativeParent.node.add(this.node);
    var props = this._initialProps;
    this.applyNodeProps(emptyObject, props);
    this.mountAndInjectChildren(props.children, transaction, context);
    return { children: [], node: this.node, html: null, text: null };
  },
  unmountComponent: function() {
    this.unmountChildren();
  }
};

var ShapeMixin = {
  construct: function(element) {
    this._currentElement = element;
    this._oldPath = null;
  },
  mountComponent: function(
    transaction,
    nativeParent,
    nativeContainerInfo,
    context
  ) {
    this._nativeContainerInfo = nativeContainerInfo;
    this.node = new Konva[this.constructor.displayName]();
    if (nativeParent) {
      nativeParent.node.add(this.node);
    }
    this.applyNodeProps(emptyObject, this._initialProps);
    return { children: [], node: this.node, html: null, text: null };
  },
  receiveComponent: function(nextComponent, transaction, context) {
    var props = nextComponent.props;
    var oldProps = this._currentElement.props || this._initialProps;
    this.applyNodeProps(oldProps, props);
    this._currentElement = nextComponent;
  }
};

var Group = createComponent('Group', NodeMixin, ContainerMixin, GroupMixin);
var Layer = createComponent('Layer', NodeMixin, ContainerMixin, GroupMixin);
var FastLayer = createComponent(
  'FastLayer',
  NodeMixin,
  ContainerMixin,
  GroupMixin
);

var Label = createComponent('Label', NodeMixin, ContainerMixin, GroupMixin);

var ReactKonva = {
  Stage: Stage,
  Group: Group,
  Layer: Layer,
  FastLayer: FastLayer,
  Label: Label
};

var shapes = [
  'Rect',
  'Circle',
  'Ellipse',
  'Wedge',
  'Line',
  'Sprite',
  'Image',
  'Text',
  'TextPath',
  'Star',
  'Ring',
  'Arc',
  'Tag',
  'Path',
  'RegularPolygon',
  'Arrow',
  'Shape'
];

shapes.forEach(function(shapeName) {
  ReactKonva[shapeName] = createComponent(shapeName, NodeMixin, ShapeMixin);
});

module.exports = ReactKonva;


/***/ }),

/***/ 911:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/*
 * Konva JavaScript Framework v1.7.6
 * http://konvajs.github.io/
 * Licensed under the MIT or GPL Version 2 licenses.
 * Date: Wed Nov 01 2017
 *
 * Original work Copyright (C) 2011 - 2013 by Eric Rowell (KineticJS)
 * Modified work Copyright (C) 2014 - 2017 by Anton Lavrenov (Konva)
 *
 * @license
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

// runtime check for already included Konva
(function() {
  'use strict';
  /**
     * @namespace Konva
     */

  var PI_OVER_180 = Math.PI / 180;

  var Konva = {
    // public
    version: '1.7.6',

    // private
    stages: [],
    idCounter: 0,
    ids: {},
    names: {},
    shapes: {},
    listenClickTap: false,
    inDblClickWindow: false,

    isBrowser:
      typeof window !== 'undefined' &&
      // browser case
      ({}.toString.call(window) === '[object Window]' ||
        // electron case
        {}.toString.call(window) === '[object global]'),

    // configurations
    enableTrace: false,
    traceArrMax: 100,
    dblClickWindow: 400,
    /**
         * Global pixel ratio configuration. KonvaJS automatically detect pixel ratio of current device.
         * But you may override such property, if you want to use your value.
         * @property pixelRatio
         * @default undefined
         * @memberof Konva
         * @example
         * Konva.pixelRatio = 1;
         */
    pixelRatio: undefined,
    /**
         * Drag distance property. If you start to drag a node you may want to wait until pointer is moved to some distance from start point,
         * only then start dragging. Default is 3px.
         * @property dragDistance
         * @default 0
         * @memberof Konva
         * @example
         * Konva.dragDistance = 10;
         */
    dragDistance: 3,
    /**
         * Use degree values for angle properties. You may set this property to false if you want to use radiant values.
         * @property angleDeg
         * @default true
         * @memberof Konva
         * @example
         * node.rotation(45); // 45 degrees
         * Konva.angleDeg = false;
         * node.rotation(Math.PI / 2); // PI/2 radian
         */
    angleDeg: true,
    /**
         * Show different warnings about errors or wrong API usage
         * @property showWarnings
         * @default true
         * @memberof Konva
         * @example
         * Konva.showWarnings = false;
         */
    showWarnings: true,

    /**
         * @namespace Filters
         * @memberof Konva
         */
    Filters: {},

    /**
         * returns whether or not drag and drop is currently active
         * @method
         * @memberof Konva
         */
    isDragging: function() {
      var dd = Konva.DD;

      // if DD is not included with the build, then
      // drag and drop is not even possible
      if (dd) {
        return dd.isDragging;
      }
      return false;
    },
    /**
        * returns whether or not a drag and drop operation is ready, but may
        *  not necessarily have started
        * @method
        * @memberof Konva
        */
    isDragReady: function() {
      var dd = Konva.DD;

      // if DD is not included with the build, then
      // drag and drop is not even possible
      if (dd) {
        return !!dd.node;
      }
      return false;
    },
    _addId: function(node, id) {
      if (id !== undefined) {
        this.ids[id] = node;
      }
    },
    _removeId: function(id) {
      if (id !== undefined) {
        delete this.ids[id];
      }
    },
    _addName: function(node, name) {
      if (name) {
        if (!this.names[name]) {
          this.names[name] = [];
        }
        this.names[name].push(node);
      }
    },
    _removeName: function(name, _id) {
      if (!name) {
        return;
      }
      var nodes = this.names[name];
      if (!nodes) {
        return;
      }
      for (var n = 0; n < nodes.length; n++) {
        var no = nodes[n];
        if (no._id === _id) {
          nodes.splice(n, 1);
        }
      }
      if (nodes.length === 0) {
        delete this.names[name];
      }
    },
    getAngle: function(angle) {
      return this.angleDeg ? angle * PI_OVER_180 : angle;
    },
    _detectIE: function(ua) {
      var msie = ua.indexOf('msie ');
      if (msie > 0) {
        // IE 10 or older => return version number
        return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
      }

      var trident = ua.indexOf('trident/');
      if (trident > 0) {
        // IE 11 => return version number
        var rv = ua.indexOf('rv:');
        return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
      }

      var edge = ua.indexOf('edge/');
      if (edge > 0) {
        // Edge (IE 12+) => return version number
        return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
      }

      // other browser
      return false;
    },
    _parseUA: function(userAgent) {
      var ua = userAgent.toLowerCase(),
        // jQuery UA regex
        match =
          /(chrome)[ /]([\w.]+)/.exec(ua) ||
          /(webkit)[ /]([\w.]+)/.exec(ua) ||
          /(opera)(?:.*version|)[ /]([\w.]+)/.exec(ua) ||
          /(msie) ([\w.]+)/.exec(ua) ||
          (ua.indexOf('compatible') < 0 &&
            /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua)) ||
          [],
        // adding mobile flag as well
        mobile = !!userAgent.match(
          /Android|BlackBerry|iPhone|iPad|iPod|Opera Mini|IEMobile/i
        ),
        ieMobile = !!userAgent.match(/IEMobile/i);

      return {
        browser: match[1] || '',
        version: match[2] || '0',
        isIE: Konva._detectIE(ua),
        // adding mobile flab
        mobile: mobile,
        ieMobile: ieMobile // If this is true (i.e., WP8), then Konva touch events are executed instead of equivalent Konva mouse events
      };
    },
    // user agent
    UA: undefined
  };

  var glob =
    typeof global !== 'undefined'
      ? global
      : typeof window !== 'undefined'
        ? window
        : typeof WorkerGlobalScope !== 'undefined' ? self : {};

  Konva.UA = Konva._parseUA((glob.navigator && glob.navigator.userAgent) || '');

  if (glob.Konva) {
    console.error(
      'Konva instance is already exist in current eviroment. ' +
        'Please use only one instance.'
    );
  }
  glob.Konva = Konva;
  Konva.global = glob;
  Konva.window = glob;
  Konva.document = glob.document;

  if (true) {
    module.exports = Konva;
  } else if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define(function() {
      return Konva;
    });
  }
})();

/*eslint-disable  eqeqeq, no-cond-assign, no-empty*/
(function() {
  'use strict';
  /**
     * Collection constructor.  Collection extends
     *  Array.  This class is used in conjunction with {@link Konva.Container#get}
     * @constructor
     * @memberof Konva
     */
  Konva.Collection = function() {
    var args = [].slice.call(arguments),
      length = args.length,
      i = 0;

    this.length = length;
    for (; i < length; i++) {
      this[i] = args[i];
    }
    return this;
  };
  Konva.Collection.prototype = [];
  /**
     * iterate through node array and run a function for each node.
     *  The node and index is passed into the function
     * @method
     * @memberof Konva.Collection.prototype
     * @param {Function} func
     * @example
     * // get all nodes with name foo inside layer, and set x to 10 for each
     * layer.get('.foo').each(function(shape, n) {
     *   shape.setX(10);
     * });
     */
  Konva.Collection.prototype.each = function(func) {
    for (var n = 0; n < this.length; n++) {
      func(this[n], n);
    }
  };
  /**
     * convert collection into an array
     * @method
     * @memberof Konva.Collection.prototype
     */
  Konva.Collection.prototype.toArray = function() {
    var arr = [],
      len = this.length,
      n;

    for (n = 0; n < len; n++) {
      arr.push(this[n]);
    }
    return arr;
  };
  /**
     * convert array into a collection
     * @method
     * @memberof Konva.Collection
     * @param {Array} arr
     */
  Konva.Collection.toCollection = function(arr) {
    var collection = new Konva.Collection(),
      len = arr.length,
      n;

    for (n = 0; n < len; n++) {
      collection.push(arr[n]);
    }
    return collection;
  };

  // map one method by it's name
  Konva.Collection._mapMethod = function(methodName) {
    Konva.Collection.prototype[methodName] = function() {
      var len = this.length,
        i;

      var args = [].slice.call(arguments);
      for (i = 0; i < len; i++) {
        this[i][methodName].apply(this[i], args);
      }

      return this;
    };
  };

  Konva.Collection.mapMethods = function(constructor) {
    var prot = constructor.prototype;
    for (var methodName in prot) {
      Konva.Collection._mapMethod(methodName);
    }
  };

  /*
    * Last updated November 2011
    * By Simon Sarris
    * www.simonsarris.com
    * sarris@acm.org
    *
    * Free to use and distribute at will
    * So long as you are nice to people, etc
    */

  /*
    * The usage of this class was inspired by some of the work done by a forked
    * project, KineticJS-Ext by Wappworks, which is based on Simon's Transform
    * class.  Modified by Eric Rowell
    */

  /**
     * Transform constructor
     * @constructor
     * @param {Array} [m] Optional six-element matrix
     * @memberof Konva
     */
  Konva.Transform = function(m) {
    this.m = (m && m.slice()) || [1, 0, 0, 1, 0, 0];
  };

  Konva.Transform.prototype = {
    /**
         * Copy Konva.Transform object
         * @method
         * @memberof Konva.Transform.prototype
         * @returns {Konva.Transform}
         */
    copy: function() {
      return new Konva.Transform(this.m);
    },
    /**
         * Transform point
         * @method
         * @memberof Konva.Transform.prototype
         * @param {Object} point 2D point(x, y)
         * @returns {Object} 2D point(x, y)
         */
    point: function(point) {
      var m = this.m;
      return {
        x: m[0] * point.x + m[2] * point.y + m[4],
        y: m[1] * point.x + m[3] * point.y + m[5]
      };
    },
    /**
         * Apply translation
         * @method
         * @memberof Konva.Transform.prototype
         * @param {Number} x
         * @param {Number} y
         * @returns {Konva.Transform}
         */
    translate: function(x, y) {
      this.m[4] += this.m[0] * x + this.m[2] * y;
      this.m[5] += this.m[1] * x + this.m[3] * y;
      return this;
    },
    /**
         * Apply scale
         * @method
         * @memberof Konva.Transform.prototype
         * @param {Number} sx
         * @param {Number} sy
         * @returns {Konva.Transform}
         */
    scale: function(sx, sy) {
      this.m[0] *= sx;
      this.m[1] *= sx;
      this.m[2] *= sy;
      this.m[3] *= sy;
      return this;
    },
    /**
         * Apply rotation
         * @method
         * @memberof Konva.Transform.prototype
         * @param {Number} rad  Angle in radians
         * @returns {Konva.Transform}
         */
    rotate: function(rad) {
      var c = Math.cos(rad);
      var s = Math.sin(rad);
      var m11 = this.m[0] * c + this.m[2] * s;
      var m12 = this.m[1] * c + this.m[3] * s;
      var m21 = this.m[0] * -s + this.m[2] * c;
      var m22 = this.m[1] * -s + this.m[3] * c;
      this.m[0] = m11;
      this.m[1] = m12;
      this.m[2] = m21;
      this.m[3] = m22;
      return this;
    },
    /**
         * Returns the translation
         * @method
         * @memberof Konva.Transform.prototype
         * @returns {Object} 2D point(x, y)
         */
    getTranslation: function() {
      return {
        x: this.m[4],
        y: this.m[5]
      };
    },
    /**
         * Apply skew
         * @method
         * @memberof Konva.Transform.prototype
         * @param {Number} sx
         * @param {Number} sy
         * @returns {Konva.Transform}
         */
    skew: function(sx, sy) {
      var m11 = this.m[0] + this.m[2] * sy;
      var m12 = this.m[1] + this.m[3] * sy;
      var m21 = this.m[2] + this.m[0] * sx;
      var m22 = this.m[3] + this.m[1] * sx;
      this.m[0] = m11;
      this.m[1] = m12;
      this.m[2] = m21;
      this.m[3] = m22;
      return this;
    },
    /**
         * Transform multiplication
         * @method
         * @memberof Konva.Transform.prototype
         * @param {Konva.Transform} matrix
         * @returns {Konva.Transform}
         */
    multiply: function(matrix) {
      var m11 = this.m[0] * matrix.m[0] + this.m[2] * matrix.m[1];
      var m12 = this.m[1] * matrix.m[0] + this.m[3] * matrix.m[1];

      var m21 = this.m[0] * matrix.m[2] + this.m[2] * matrix.m[3];
      var m22 = this.m[1] * matrix.m[2] + this.m[3] * matrix.m[3];

      var dx = this.m[0] * matrix.m[4] + this.m[2] * matrix.m[5] + this.m[4];
      var dy = this.m[1] * matrix.m[4] + this.m[3] * matrix.m[5] + this.m[5];

      this.m[0] = m11;
      this.m[1] = m12;
      this.m[2] = m21;
      this.m[3] = m22;
      this.m[4] = dx;
      this.m[5] = dy;
      return this;
    },
    /**
         * Invert the matrix
         * @method
         * @memberof Konva.Transform.prototype
         * @returns {Konva.Transform}
         */
    invert: function() {
      var d = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]);
      var m0 = this.m[3] * d;
      var m1 = -this.m[1] * d;
      var m2 = -this.m[2] * d;
      var m3 = this.m[0] * d;
      var m4 = d * (this.m[2] * this.m[5] - this.m[3] * this.m[4]);
      var m5 = d * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
      this.m[0] = m0;
      this.m[1] = m1;
      this.m[2] = m2;
      this.m[3] = m3;
      this.m[4] = m4;
      this.m[5] = m5;
      return this;
    },
    /**
         * return matrix
         * @method
         * @memberof Konva.Transform.prototype
         */
    getMatrix: function() {
      return this.m;
    },
    /**
         * set to absolute position via translation
         * @method
         * @memberof Konva.Transform.prototype
         * @returns {Konva.Transform}
         * @author ericdrowell
         */
    setAbsolutePosition: function(x, y) {
      var m0 = this.m[0],
        m1 = this.m[1],
        m2 = this.m[2],
        m3 = this.m[3],
        m4 = this.m[4],
        m5 = this.m[5],
        yt = (m0 * (y - m5) - m1 * (x - m4)) / (m0 * m3 - m1 * m2),
        xt = (x - m4 - m2 * yt) / m0;

      return this.translate(xt, yt);
    }
  };

  // CONSTANTS
  var CONTEXT_2D = '2d',
    OBJECT_ARRAY = '[object Array]',
    OBJECT_NUMBER = '[object Number]',
    OBJECT_STRING = '[object String]',
    PI_OVER_DEG180 = Math.PI / 180,
    DEG180_OVER_PI = 180 / Math.PI,
    HASH = '#',
    EMPTY_STRING = '',
    ZERO = '0',
    KONVA_WARNING = 'Konva warning: ',
    KONVA_ERROR = 'Konva error: ',
    RGB_PAREN = 'rgb(',
    COLORS = {
      aliceblue: [240, 248, 255],
      antiquewhite: [250, 235, 215],
      aqua: [0, 255, 255],
      aquamarine: [127, 255, 212],
      azure: [240, 255, 255],
      beige: [245, 245, 220],
      bisque: [255, 228, 196],
      black: [0, 0, 0],
      blanchedalmond: [255, 235, 205],
      blue: [0, 0, 255],
      blueviolet: [138, 43, 226],
      brown: [165, 42, 42],
      burlywood: [222, 184, 135],
      cadetblue: [95, 158, 160],
      chartreuse: [127, 255, 0],
      chocolate: [210, 105, 30],
      coral: [255, 127, 80],
      cornflowerblue: [100, 149, 237],
      cornsilk: [255, 248, 220],
      crimson: [220, 20, 60],
      cyan: [0, 255, 255],
      darkblue: [0, 0, 139],
      darkcyan: [0, 139, 139],
      darkgoldenrod: [184, 132, 11],
      darkgray: [169, 169, 169],
      darkgreen: [0, 100, 0],
      darkgrey: [169, 169, 169],
      darkkhaki: [189, 183, 107],
      darkmagenta: [139, 0, 139],
      darkolivegreen: [85, 107, 47],
      darkorange: [255, 140, 0],
      darkorchid: [153, 50, 204],
      darkred: [139, 0, 0],
      darksalmon: [233, 150, 122],
      darkseagreen: [143, 188, 143],
      darkslateblue: [72, 61, 139],
      darkslategray: [47, 79, 79],
      darkslategrey: [47, 79, 79],
      darkturquoise: [0, 206, 209],
      darkviolet: [148, 0, 211],
      deeppink: [255, 20, 147],
      deepskyblue: [0, 191, 255],
      dimgray: [105, 105, 105],
      dimgrey: [105, 105, 105],
      dodgerblue: [30, 144, 255],
      firebrick: [178, 34, 34],
      floralwhite: [255, 255, 240],
      forestgreen: [34, 139, 34],
      fuchsia: [255, 0, 255],
      gainsboro: [220, 220, 220],
      ghostwhite: [248, 248, 255],
      gold: [255, 215, 0],
      goldenrod: [218, 165, 32],
      gray: [128, 128, 128],
      green: [0, 128, 0],
      greenyellow: [173, 255, 47],
      grey: [128, 128, 128],
      honeydew: [240, 255, 240],
      hotpink: [255, 105, 180],
      indianred: [205, 92, 92],
      indigo: [75, 0, 130],
      ivory: [255, 255, 240],
      khaki: [240, 230, 140],
      lavender: [230, 230, 250],
      lavenderblush: [255, 240, 245],
      lawngreen: [124, 252, 0],
      lemonchiffon: [255, 250, 205],
      lightblue: [173, 216, 230],
      lightcoral: [240, 128, 128],
      lightcyan: [224, 255, 255],
      lightgoldenrodyellow: [250, 250, 210],
      lightgray: [211, 211, 211],
      lightgreen: [144, 238, 144],
      lightgrey: [211, 211, 211],
      lightpink: [255, 182, 193],
      lightsalmon: [255, 160, 122],
      lightseagreen: [32, 178, 170],
      lightskyblue: [135, 206, 250],
      lightslategray: [119, 136, 153],
      lightslategrey: [119, 136, 153],
      lightsteelblue: [176, 196, 222],
      lightyellow: [255, 255, 224],
      lime: [0, 255, 0],
      limegreen: [50, 205, 50],
      linen: [250, 240, 230],
      magenta: [255, 0, 255],
      maroon: [128, 0, 0],
      mediumaquamarine: [102, 205, 170],
      mediumblue: [0, 0, 205],
      mediumorchid: [186, 85, 211],
      mediumpurple: [147, 112, 219],
      mediumseagreen: [60, 179, 113],
      mediumslateblue: [123, 104, 238],
      mediumspringgreen: [0, 250, 154],
      mediumturquoise: [72, 209, 204],
      mediumvioletred: [199, 21, 133],
      midnightblue: [25, 25, 112],
      mintcream: [245, 255, 250],
      mistyrose: [255, 228, 225],
      moccasin: [255, 228, 181],
      navajowhite: [255, 222, 173],
      navy: [0, 0, 128],
      oldlace: [253, 245, 230],
      olive: [128, 128, 0],
      olivedrab: [107, 142, 35],
      orange: [255, 165, 0],
      orangered: [255, 69, 0],
      orchid: [218, 112, 214],
      palegoldenrod: [238, 232, 170],
      palegreen: [152, 251, 152],
      paleturquoise: [175, 238, 238],
      palevioletred: [219, 112, 147],
      papayawhip: [255, 239, 213],
      peachpuff: [255, 218, 185],
      peru: [205, 133, 63],
      pink: [255, 192, 203],
      plum: [221, 160, 203],
      powderblue: [176, 224, 230],
      purple: [128, 0, 128],
      rebeccapurple: [102, 51, 153],
      red: [255, 0, 0],
      rosybrown: [188, 143, 143],
      royalblue: [65, 105, 225],
      saddlebrown: [139, 69, 19],
      salmon: [250, 128, 114],
      sandybrown: [244, 164, 96],
      seagreen: [46, 139, 87],
      seashell: [255, 245, 238],
      sienna: [160, 82, 45],
      silver: [192, 192, 192],
      skyblue: [135, 206, 235],
      slateblue: [106, 90, 205],
      slategray: [119, 128, 144],
      slategrey: [119, 128, 144],
      snow: [255, 255, 250],
      springgreen: [0, 255, 127],
      steelblue: [70, 130, 180],
      tan: [210, 180, 140],
      teal: [0, 128, 128],
      thistle: [216, 191, 216],
      transparent: [255, 255, 255, 0],
      tomato: [255, 99, 71],
      turquoise: [64, 224, 208],
      violet: [238, 130, 238],
      wheat: [245, 222, 179],
      white: [255, 255, 255],
      whitesmoke: [245, 245, 245],
      yellow: [255, 255, 0],
      yellowgreen: [154, 205, 5]
    },
    RGB_REGEX = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/;

  /**
     * @namespace Util
     * @memberof Konva
     */
  Konva.Util = {
    /*
         * cherry-picked utilities from underscore.js
         */
    _isElement: function(obj) {
      return !!(obj && obj.nodeType == 1);
    },
    _isFunction: function(obj) {
      return !!(obj && obj.constructor && obj.call && obj.apply);
    },
    _isObject: function(obj) {
      return !!obj && obj.constructor === Object;
    },
    _isArray: function(obj) {
      return Object.prototype.toString.call(obj) === OBJECT_ARRAY;
    },
    _isNumber: function(obj) {
      return Object.prototype.toString.call(obj) === OBJECT_NUMBER;
    },
    _isString: function(obj) {
      return Object.prototype.toString.call(obj) === OBJECT_STRING;
    },
    // Returns a function, that, when invoked, will only be triggered at most once
    // during a given window of time. Normally, the throttled function will run
    // as much as it can, without ever going more than once per `wait` duration;
    // but if you'd like to disable the execution on the leading edge, pass
    // `{leading: false}`. To disable execution on the trailing edge, ditto.
    _throttle: function(func, wait, opts) {
      var context, args, result;
      var timeout = null;
      var previous = 0;
      var options = opts || {};
      var later = function() {
        previous = options.leading === false ? 0 : new Date().getTime();
        timeout = null;
        result = func.apply(context, args);
        context = args = null;
      };
      return function() {
        var now = new Date().getTime();
        if (!previous && options.leading === false) {
          previous = now;
        }
        var remaining = wait - (now - previous);
        context = this;
        args = arguments;
        if (remaining <= 0) {
          clearTimeout(timeout);
          timeout = null;
          previous = now;
          result = func.apply(context, args);
          context = args = null;
        } else if (!timeout && options.trailing !== false) {
          timeout = setTimeout(later, remaining);
        }
        return result;
      };
    },
    /*
         * other utils
         */
    _hasMethods: function(obj) {
      var names = [],
        key;

      for (key in obj) {
        if (!obj.hasOwnProperty(key)) {
          continue;
        }
        if (this._isFunction(obj[key])) {
          names.push(key);
        }
      }
      return names.length > 0;
    },
    isValidSelector: function(selector) {
      if (typeof selector !== 'string') {
        return false;
      }
      var firstChar = selector[0];
      return (
        firstChar === '#' ||
        firstChar === '.' ||
        firstChar === firstChar.toUpperCase()
      );
    },
    createCanvasElement: function() {
      var canvas = Konva.isBrowser
        ? Konva.document.createElement('canvas')
        : new Konva._nodeCanvas();
      // on some environments canvas.style is readonly
      try {
        canvas.style = canvas.style || {};
      } catch (e) {}
      return canvas;
    },
    _isInDocument: function(el) {
      while ((el = el.parentNode)) {
        if (el == Konva.document) {
          return true;
        }
      }
      return false;
    },
    _simplifyArray: function(arr) {
      var retArr = [],
        len = arr.length,
        util = Konva.Util,
        n,
        val;

      for (n = 0; n < len; n++) {
        val = arr[n];
        if (util._isNumber(val)) {
          val = Math.round(val * 1000) / 1000;
        } else if (!util._isString(val)) {
          val = val.toString();
        }

        retArr.push(val);
      }

      return retArr;
    },
    /*
         * arg can be an image object or image data
         */
    _getImage: function(arg, callback) {
      var imageObj, canvas;

      // if arg is null or undefined
      if (!arg) {
        callback(null);
      } else if (this._isElement(arg)) {
        // if arg is already an image object
        callback(arg);
      } else if (this._isString(arg)) {
        // if arg is a string, then it's a data url
        imageObj = new Konva.window.Image();
        imageObj.onload = function() {
          callback(imageObj);
        };
        imageObj.src = arg;
      } else if (arg.data) {
        //if arg is an object that contains the data property, it's an image object
        canvas = Konva.Util.createCanvasElement();
        canvas.width = arg.width;
        canvas.height = arg.height;
        var _context = canvas.getContext(CONTEXT_2D);
        _context.putImageData(arg, 0, 0);
        this._getImage(canvas.toDataURL(), callback);
      } else {
        callback(null);
      }
    },
    _getRGBAString: function(obj) {
      var red = obj.red || 0,
        green = obj.green || 0,
        blue = obj.blue || 0,
        alpha = obj.alpha || 1;

      return ['rgba(', red, ',', green, ',', blue, ',', alpha, ')'].join(
        EMPTY_STRING
      );
    },
    _rgbToHex: function(r, g, b) {
      return ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    },
    _hexToRgb: function(hex) {
      hex = hex.replace(HASH, EMPTY_STRING);
      var bigint = parseInt(hex, 16);
      return {
        r: (bigint >> 16) & 255,
        g: (bigint >> 8) & 255,
        b: bigint & 255
      };
    },
    /**
         * return random hex color
         * @method
         * @memberof Konva.Util.prototype
         */
    getRandomColor: function() {
      var randColor = ((Math.random() * 0xffffff) << 0).toString(16);
      while (randColor.length < 6) {
        randColor = ZERO + randColor;
      }
      return HASH + randColor;
    },
    /**
         * return value with default fallback
         * @method
         * @memberof Konva.Util.prototype
         */
    get: function(val, def) {
      if (val === undefined) {
        return def;
      } else {
        return val;
      }
    },
    /**
         * get RGB components of a color
         * @method
         * @memberof Konva.Util.prototype
         * @param {String} color
         * @example
         * // each of the following examples return {r:0, g:0, b:255}
         * var rgb = Konva.Util.getRGB('blue');
         * var rgb = Konva.Util.getRGB('#0000ff');
         * var rgb = Konva.Util.getRGB('rgb(0,0,255)');
         */
    getRGB: function(color) {
      var rgb;
      // color string
      if (color in COLORS) {
        rgb = COLORS[color];
        return {
          r: rgb[0],
          g: rgb[1],
          b: rgb[2]
        };
      } else if (color[0] === HASH) {
        // hex
        return this._hexToRgb(color.substring(1));
      } else if (color.substr(0, 4) === RGB_PAREN) {
        // rgb string
        rgb = RGB_REGEX.exec(color.replace(/ /g, ''));
        return {
          r: parseInt(rgb[1], 10),
          g: parseInt(rgb[2], 10),
          b: parseInt(rgb[3], 10)
        };
      } else {
        // default
        return {
          r: 0,
          g: 0,
          b: 0
        };
      }
    },
    // convert any color string to RGBA object
    // from https://github.com/component/color-parser
    colorToRGBA: function(str) {
      str = str || 'black';
      return (
        Konva.Util._namedColorToRBA(str) ||
        Konva.Util._hex3ColorToRGBA(str) ||
        Konva.Util._hex6ColorToRGBA(str) ||
        Konva.Util._rgbColorToRGBA(str) ||
        Konva.Util._rgbaColorToRGBA(str)
      );
    },
    // Parse named css color. Like "green"
    _namedColorToRBA: function(str) {
      var c = COLORS[str.toLowerCase()];
      if (!c) {
        return null;
      }
      return {
        r: c[0],
        g: c[1],
        b: c[2],
        a: 1
      };
    },
    // Parse rgb(n, n, n)
    _rgbColorToRGBA: function(str) {
      if (str.indexOf('rgb(') === 0) {
        str = str.match(/rgb\(([^)]+)\)/)[1];
        var parts = str.split(/ *, */).map(Number);
        return {
          r: parts[0],
          g: parts[1],
          b: parts[2],
          a: 1
        };
      }
    },
    // Parse rgba(n, n, n, n)
    _rgbaColorToRGBA: function(str) {
      if (str.indexOf('rgba(') === 0) {
        str = str.match(/rgba\(([^)]+)\)/)[1];
        var parts = str.split(/ *, */).map(Number);
        return {
          r: parts[0],
          g: parts[1],
          b: parts[2],
          a: parts[3]
        };
      }
    },
    // Parse #nnnnnn
    _hex6ColorToRGBA: function(str) {
      if (str[0] === '#' && str.length === 7) {
        return {
          r: parseInt(str.slice(1, 3), 16),
          g: parseInt(str.slice(3, 5), 16),
          b: parseInt(str.slice(5, 7), 16),
          a: 1
        };
      }
    },
    // Parse #nnn
    _hex3ColorToRGBA: function(str) {
      if (str[0] === '#' && str.length === 4) {
        return {
          r: parseInt(str[1] + str[1], 16),
          g: parseInt(str[2] + str[2], 16),
          b: parseInt(str[3] + str[3], 16),
          a: 1
        };
      }
    },
    // o1 takes precedence over o2
    _merge: function(o1, o2) {
      var retObj = this._clone(o2);
      for (var key in o1) {
        if (this._isObject(o1[key])) {
          retObj[key] = this._merge(o1[key], retObj[key]);
        } else {
          retObj[key] = o1[key];
        }
      }
      return retObj;
    },
    cloneObject: function(obj) {
      var retObj = {};
      for (var key in obj) {
        if (this._isObject(obj[key])) {
          retObj[key] = this.cloneObject(obj[key]);
        } else if (this._isArray(obj[key])) {
          retObj[key] = this.cloneArray(obj[key]);
        } else {
          retObj[key] = obj[key];
        }
      }
      return retObj;
    },
    cloneArray: function(arr) {
      return arr.slice(0);
    },
    _degToRad: function(deg) {
      return deg * PI_OVER_DEG180;
    },
    _radToDeg: function(rad) {
      return rad * DEG180_OVER_PI;
    },
    _capitalize: function(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    },
    throw: function(str) {
      throw new Error(KONVA_ERROR + str);
    },
    error: function(str) {
      console.error(KONVA_ERROR + str);
    },
    warn: function(str) {
      /*
             * IE9 on Windows7 64bit will throw a JS error
             * if we don't use window.console in the conditional
             */
      if (Konva.global.console && console.warn && Konva.showWarnings) {
        console.warn(KONVA_WARNING + str);
      }
    },
    extend: function(child, parent) {
      function Ctor() {
        this.constructor = child;
      }
      Ctor.prototype = parent.prototype;
      var oldProto = child.prototype;
      child.prototype = new Ctor();
      for (var key in oldProto) {
        if (oldProto.hasOwnProperty(key)) {
          child.prototype[key] = oldProto[key];
        }
      }
      child.__super__ = parent.prototype;
      // create reference to parent
      child.super = parent;
    },
    /**
         * adds methods to a constructor prototype
         * @method
         * @memberof Konva.Util.prototype
         * @param {Function} constructor
         * @param {Object} methods
         */
    addMethods: function(constructor, methods) {
      var key;

      for (key in methods) {
        constructor.prototype[key] = methods[key];
      }
    },
    _getControlPoints: function(x0, y0, x1, y1, x2, y2, t) {
      var d01 = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2)),
        d12 = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)),
        fa = t * d01 / (d01 + d12),
        fb = t * d12 / (d01 + d12),
        p1x = x1 - fa * (x2 - x0),
        p1y = y1 - fa * (y2 - y0),
        p2x = x1 + fb * (x2 - x0),
        p2y = y1 + fb * (y2 - y0);

      return [p1x, p1y, p2x, p2y];
    },
    _expandPoints: function(p, tension) {
      var len = p.length,
        allPoints = [],
        n,
        cp;

      for (n = 2; n < len - 2; n += 2) {
        cp = Konva.Util._getControlPoints(
          p[n - 2],
          p[n - 1],
          p[n],
          p[n + 1],
          p[n + 2],
          p[n + 3],
          tension
        );
        allPoints.push(cp[0]);
        allPoints.push(cp[1]);
        allPoints.push(p[n]);
        allPoints.push(p[n + 1]);
        allPoints.push(cp[2]);
        allPoints.push(cp[3]);
      }

      return allPoints;
    },
    _removeLastLetter: function(str) {
      return str.substring(0, str.length - 1);
    },
    each: function(obj, func) {
      for (var key in obj) {
        func(key, obj[key]);
      }
    },
    _getProjectionToSegment: function(x1, y1, x2, y2, x3, y3) {
      var x, y, dist;

      var pd2 = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
      if (pd2 == 0) {
        x = x1;
        y = y1;
        dist = (x3 - x2) * (x3 - x2) + (y3 - y2) * (y3 - y2);
      } else {
        var u = ((x3 - x1) * (x2 - x1) + (y3 - y1) * (y2 - y1)) / pd2;
        if (u < 0) {
          x = x1;
          y = y1;
          dist = (x1 - x3) * (x1 - x3) + (y1 - y3) * (y1 - y3);
        } else if (u > 1.0) {
          x = x2;
          y = y2;
          dist = (x2 - x3) * (x2 - x3) + (y2 - y3) * (y2 - y3);
        } else {
          x = x1 + u * (x2 - x1);
          y = y1 + u * (y2 - y1);
          dist = (x - x3) * (x - x3) + (y - y3) * (y - y3);
        }
      }
      return [x, y, dist];
    },
    // line as array of points.
    // line might be closed
    _getProjectionToLine: function(pt, line, isClosed) {
      var pc = Konva.Util.cloneObject(pt);
      var dist = Number.MAX_VALUE;
      line.forEach(function(p1, i) {
        if (!isClosed && i === line.length - 1) {
          return;
        }
        var p2 = line[(i + 1) % line.length];
        var proj = Konva.Util._getProjectionToSegment(
          p1.x,
          p1.y,
          p2.x,
          p2.y,
          pt.x,
          pt.y
        );
        var px = proj[0],
          py = proj[1],
          pdist = proj[2];
        if (pdist < dist) {
          pc.x = px;
          pc.y = py;
          dist = pdist;
        }
      });
      return pc;
    },
    _prepareArrayForTween: function(startArray, endArray, isClosed) {
      var n,
        start = [],
        end = [];
      if (startArray.length > endArray.length) {
        var temp = endArray;
        endArray = startArray;
        startArray = temp;
      }
      for (n = 0; n < startArray.length; n += 2) {
        start.push({
          x: startArray[n],
          y: startArray[n + 1]
        });
      }
      for (n = 0; n < endArray.length; n += 2) {
        end.push({
          x: endArray[n],
          y: endArray[n + 1]
        });
      }

      var newStart = [];
      end.forEach(function(point) {
        var pr = Konva.Util._getProjectionToLine(point, start, isClosed);
        newStart.push(pr.x);
        newStart.push(pr.y);
      });
      return newStart;
    },
    _prepareToStringify: function(obj) {
      var desc;

      obj.visitedByCircularReferenceRemoval = true;

      for (var key in obj) {
        if (
          !(obj.hasOwnProperty(key) && obj[key] && typeof obj[key] == 'object')
        ) {
          continue;
        }
        desc = Object.getOwnPropertyDescriptor(obj, key);
        if (
          obj[key].visitedByCircularReferenceRemoval ||
          Konva.Util._isElement(obj[key])
        ) {
          if (desc.configurable) {
            delete obj[key];
          } else {
            return null;
          }
        } else if (Konva.Util._prepareToStringify(obj[key]) === null) {
          if (desc.configurable) {
            delete obj[key];
          } else {
            return null;
          }
        }
      }

      delete obj.visitedByCircularReferenceRemoval;

      return obj;
    }
  };
})();

(function() {
  'use strict';
  // calculate pixel ratio

  var _pixelRatio;
  function getDevicePixelRatio() {
    if (_pixelRatio) {
      return _pixelRatio;
    }
    var canvas = Konva.Util.createCanvasElement();
    var context = canvas.getContext('2d');
    _pixelRatio = (function() {
      var devicePixelRatio = Konva.window.devicePixelRatio || 1,
        backingStoreRatio =
          context.webkitBackingStorePixelRatio ||
          context.mozBackingStorePixelRatio ||
          context.msBackingStorePixelRatio ||
          context.oBackingStorePixelRatio ||
          context.backingStorePixelRatio ||
          1;
      return devicePixelRatio / backingStoreRatio;
    })();
    return _pixelRatio;
  }

  /**
     * Canvas Renderer constructor
     * @constructor
     * @abstract
     * @memberof Konva
     * @param {Object} config
     * @param {Number} config.width
     * @param {Number} config.height
     * @param {Number} config.pixelRatio KonvaJS automatically handles pixel ratio adjustments in order to render crisp drawings
     *  on all devices. Most desktops, low end tablets, and low end phones, have device pixel ratios
     *  of 1.  Some high end tablets and phones, like iPhones and iPads (not the mini) have a device pixel ratio
     *  of 2.  Some Macbook Pros, and iMacs also have a device pixel ratio of 2.  Some high end Android devices have pixel
     *  ratios of 2 or 3.  Some browsers like Firefox allow you to configure the pixel ratio of the viewport.  Unless otherwise
     *  specified, the pixel ratio will be defaulted to the actual device pixel ratio.  You can override the device pixel
     *  ratio for special situations, or, if you don't want the pixel ratio to be taken into account, you can set it to 1.
     */
  Konva.Canvas = function(config) {
    this.init(config);
  };

  Konva.Canvas.prototype = {
    init: function(config) {
      var conf = config || {};

      var pixelRatio =
        conf.pixelRatio || Konva.pixelRatio || getDevicePixelRatio();

      this.pixelRatio = pixelRatio;
      this._canvas = Konva.Util.createCanvasElement();

      // set inline styles
      this._canvas.style.padding = 0;
      this._canvas.style.margin = 0;
      this._canvas.style.border = 0;
      this._canvas.style.background = 'transparent';
      this._canvas.style.position = 'absolute';
      this._canvas.style.top = 0;
      this._canvas.style.left = 0;
    },
    /**
         * get canvas context
         * @method
         * @memberof Konva.Canvas.prototype
         * @returns {CanvasContext} context
         */
    getContext: function() {
      return this.context;
    },
    /**
         * get pixel ratio
         * @method
         * @memberof Konva.Canvas.prototype
         * @returns {Number} pixel ratio
         */
    getPixelRatio: function() {
      return this.pixelRatio;
    },
    /**
         * get pixel ratio
         * @method
         * @memberof Konva.Canvas.prototype
         * @param {Number} pixelRatio KonvaJS automatically handles pixel ratio adustments in order to render crisp drawings
         *  on all devices. Most desktops, low end tablets, and low end phones, have device pixel ratios
         *  of 1.  Some high end tablets and phones, like iPhones and iPads have a device pixel ratio
         *  of 2.  Some Macbook Pros, and iMacs also have a device pixel ratio of 2.  Some high end Android devices have pixel
         *  ratios of 2 or 3.  Some browsers like Firefox allow you to configure the pixel ratio of the viewport.  Unless otherwise
         *  specificed, the pixel ratio will be defaulted to the actual device pixel ratio.  You can override the device pixel
         *  ratio for special situations, or, if you don't want the pixel ratio to be taken into account, you can set it to 1.
         */
    setPixelRatio: function(pixelRatio) {
      var previousRatio = this.pixelRatio;
      this.pixelRatio = pixelRatio;
      this.setSize(
        this.getWidth() / previousRatio,
        this.getHeight() / previousRatio
      );
    },
    /**
         * set width
         * @method
         * @memberof Konva.Canvas.prototype
         * @param {Number} width
         */
    setWidth: function(width) {
      // take into account pixel ratio
      this.width = this._canvas.width = width * this.pixelRatio;
      this._canvas.style.width = width + 'px';

      var pixelRatio = this.pixelRatio,
        _context = this.getContext()._context;
      _context.scale(pixelRatio, pixelRatio);
    },
    /**
         * set height
         * @method
         * @memberof Konva.Canvas.prototype
         * @param {Number} height
         */
    setHeight: function(height) {
      // take into account pixel ratio
      this.height = this._canvas.height = height * this.pixelRatio;
      this._canvas.style.height = height + 'px';
      var pixelRatio = this.pixelRatio,
        _context = this.getContext()._context;
      _context.scale(pixelRatio, pixelRatio);
    },
    /**
         * get width
         * @method
         * @memberof Konva.Canvas.prototype
         * @returns {Number} width
         */
    getWidth: function() {
      return this.width;
    },
    /**
         * get height
         * @method
         * @memberof Konva.Canvas.prototype
         * @returns {Number} height
         */
    getHeight: function() {
      return this.height;
    },
    /**
         * set size
         * @method
         * @memberof Konva.Canvas.prototype
         * @param {Number} width
         * @param {Number} height
         */
    setSize: function(width, height) {
      this.setWidth(width);
      this.setHeight(height);
    },
    /**
         * to data url
         * @method
         * @memberof Konva.Canvas.prototype
         * @param {String} mimeType
         * @param {Number} quality between 0 and 1 for jpg mime types
         * @returns {String} data url string
         */
    toDataURL: function(mimeType, quality) {
      try {
        // If this call fails (due to browser bug, like in Firefox 3.6),
        // then revert to previous no-parameter image/png behavior
        return this._canvas.toDataURL(mimeType, quality);
      } catch (e) {
        try {
          return this._canvas.toDataURL();
        } catch (err) {
          Konva.Util.warn('Unable to get data URL. ' + err.message);
          return '';
        }
      }
    }
  };

  Konva.SceneCanvas = function(config) {
    var conf = config || {};
    var width = conf.width || 0,
      height = conf.height || 0;

    Konva.Canvas.call(this, conf);
    this.context = new Konva.SceneContext(this);
    this.setSize(width, height);
  };

  Konva.Util.extend(Konva.SceneCanvas, Konva.Canvas);

  Konva.HitCanvas = function(config) {
    var conf = config || {};
    var width = conf.width || 0,
      height = conf.height || 0;

    Konva.Canvas.call(this, conf);
    this.context = new Konva.HitContext(this);
    this.setSize(width, height);
    this.hitCanvas = true;
  };
  Konva.Util.extend(Konva.HitCanvas, Konva.Canvas);
})();

(function() {
  'use strict';
  var COMMA = ',',
    OPEN_PAREN = '(',
    CLOSE_PAREN = ')',
    OPEN_PAREN_BRACKET = '([',
    CLOSE_BRACKET_PAREN = '])',
    SEMICOLON = ';',
    DOUBLE_PAREN = '()',
    // EMPTY_STRING = '',
    EQUALS = '=',
    // SET = 'set',
    CONTEXT_METHODS = [
      'arc',
      'arcTo',
      'beginPath',
      'bezierCurveTo',
      'clearRect',
      'clip',
      'closePath',
      'createLinearGradient',
      'createPattern',
      'createRadialGradient',
      'drawImage',
      'fill',
      'fillText',
      'getImageData',
      'createImageData',
      'lineTo',
      'moveTo',
      'putImageData',
      'quadraticCurveTo',
      'rect',
      'restore',
      'rotate',
      'save',
      'scale',
      'setLineDash',
      'setTransform',
      'stroke',
      'strokeText',
      'transform',
      'translate'
    ];

  var CONTEXT_PROPERTIES = [
    'fillStyle',
    'strokeStyle',
    'shadowColor',
    'shadowBlur',
    'shadowOffsetX',
    'shadowOffsetY',
    'lineCap',
    'lineDashOffset',
    'lineJoin',
    'lineWidth',
    'miterLimit',
    'font',
    'textAlign',
    'textBaseline',
    'globalAlpha',
    'globalCompositeOperation'
  ];

  /**
     * Canvas Context constructor
     * @constructor
     * @abstract
     * @memberof Konva
     */
  Konva.Context = function(canvas) {
    this.init(canvas);
  };

  Konva.Context.prototype = {
    init: function(canvas) {
      this.canvas = canvas;
      this._context = canvas._canvas.getContext('2d');

      if (Konva.enableTrace) {
        this.traceArr = [];
        this._enableTrace();
      }
    },
    /**
         * fill shape
         * @method
         * @memberof Konva.Context.prototype
         * @param {Konva.Shape} shape
         */
    fillShape: function(shape) {
      if (shape.getFillEnabled()) {
        this._fill(shape);
      }
    },
    /**
         * stroke shape
         * @method
         * @memberof Konva.Context.prototype
         * @param {Konva.Shape} shape
         */
    strokeShape: function(shape) {
      if (shape.getStrokeEnabled()) {
        this._stroke(shape);
      }
    },
    /**
         * fill then stroke
         * @method
         * @memberof Konva.Context.prototype
         * @param {Konva.Shape} shape
         */
    fillStrokeShape: function(shape) {
      var fillEnabled = shape.getFillEnabled();
      if (fillEnabled) {
        this._fill(shape);
      }
      if (shape.getStrokeEnabled()) {
        this._stroke(shape);
      }
    },
    /**
         * get context trace if trace is enabled
         * @method
         * @memberof Konva.Context.prototype
         * @param {Boolean} relaxed if false, return strict context trace, which includes method names, method parameters
         *  properties, and property values.  If true, return relaxed context trace, which only returns method names and
         *  properites.
         * @returns {String}
         */
    getTrace: function(relaxed) {
      var traceArr = this.traceArr,
        len = traceArr.length,
        str = '',
        n,
        trace,
        method,
        args;

      for (n = 0; n < len; n++) {
        trace = traceArr[n];
        method = trace.method;

        // methods
        if (method) {
          args = trace.args;
          str += method;
          if (relaxed) {
            str += DOUBLE_PAREN;
          } else {
            if (Konva.Util._isArray(args[0])) {
              str +=
                OPEN_PAREN_BRACKET + args.join(COMMA) + CLOSE_BRACKET_PAREN;
            } else {
              str += OPEN_PAREN + args.join(COMMA) + CLOSE_PAREN;
            }
          }
        } else {
          // properties
          str += trace.property;
          if (!relaxed) {
            str += EQUALS + trace.val;
          }
        }

        str += SEMICOLON;
      }

      return str;
    },
    /**
         * clear trace if trace is enabled
         * @method
         * @memberof Konva.Context.prototype
         */
    clearTrace: function() {
      this.traceArr = [];
    },
    _trace: function(str) {
      var traceArr = this.traceArr, len;

      traceArr.push(str);
      len = traceArr.length;

      if (len >= Konva.traceArrMax) {
        traceArr.shift();
      }
    },
    /**
         * reset canvas context transform
         * @method
         * @memberof Konva.Context.prototype
         */
    reset: function() {
      var pixelRatio = this.getCanvas().getPixelRatio();
      this.setTransform(1 * pixelRatio, 0, 0, 1 * pixelRatio, 0, 0);
    },
    /**
         * get canvas
         * @method
         * @memberof Konva.Context.prototype
         * @returns {Konva.Canvas}
         */
    getCanvas: function() {
      return this.canvas;
    },
    /**
         * clear canvas
         * @method
         * @memberof Konva.Context.prototype
         * @param {Object} [bounds]
         * @param {Number} [bounds.x]
         * @param {Number} [bounds.y]
         * @param {Number} [bounds.width]
         * @param {Number} [bounds.height]
         */
    clear: function(bounds) {
      var canvas = this.getCanvas();

      if (bounds) {
        this.clearRect(
          bounds.x || 0,
          bounds.y || 0,
          bounds.width || 0,
          bounds.height || 0
        );
      } else {
        this.clearRect(
          0,
          0,
          canvas.getWidth() / canvas.pixelRatio,
          canvas.getHeight() / canvas.pixelRatio
        );
      }
    },
    _applyLineCap: function(shape) {
      var lineCap = shape.getLineCap();
      if (lineCap) {
        this.setAttr('lineCap', lineCap);
      }
    },
    _applyOpacity: function(shape) {
      var absOpacity = shape.getAbsoluteOpacity();
      if (absOpacity !== 1) {
        this.setAttr('globalAlpha', absOpacity);
      }
    },
    _applyLineJoin: function(shape) {
      var lineJoin = shape.getLineJoin();
      if (lineJoin) {
        this.setAttr('lineJoin', lineJoin);
      }
    },
    setAttr: function(attr, val) {
      this._context[attr] = val;
    },

    // context pass through methods
    arc: function() {
      var a = arguments;
      this._context.arc(a[0], a[1], a[2], a[3], a[4], a[5]);
    },
    beginPath: function() {
      this._context.beginPath();
    },
    bezierCurveTo: function() {
      var a = arguments;
      this._context.bezierCurveTo(a[0], a[1], a[2], a[3], a[4], a[5]);
    },
    clearRect: function() {
      var a = arguments;
      this._context.clearRect(a[0], a[1], a[2], a[3]);
    },
    clip: function() {
      this._context.clip();
    },
    closePath: function() {
      this._context.closePath();
    },
    createImageData: function() {
      var a = arguments;
      if (a.length === 2) {
        return this._context.createImageData(a[0], a[1]);
      } else if (a.length === 1) {
        return this._context.createImageData(a[0]);
      }
    },
    createLinearGradient: function() {
      var a = arguments;
      return this._context.createLinearGradient(a[0], a[1], a[2], a[3]);
    },
    createPattern: function() {
      var a = arguments;
      return this._context.createPattern(a[0], a[1]);
    },
    createRadialGradient: function() {
      var a = arguments;
      return this._context.createRadialGradient(
        a[0],
        a[1],
        a[2],
        a[3],
        a[4],
        a[5]
      );
    },
    drawImage: function() {
      var a = arguments, _context = this._context;

      if (a.length === 3) {
        _context.drawImage(a[0], a[1], a[2]);
      } else if (a.length === 5) {
        _context.drawImage(a[0], a[1], a[2], a[3], a[4]);
      } else if (a.length === 9) {
        _context.drawImage(
          a[0],
          a[1],
          a[2],
          a[3],
          a[4],
          a[5],
          a[6],
          a[7],
          a[8]
        );
      }
    },
    isPointInPath: function(x, y) {
      return this._context.isPointInPath(x, y);
    },
    fill: function() {
      this._context.fill();
    },
    fillRect: function(x, y, width, height) {
      this._context.fillRect(x, y, width, height);
    },
    strokeRect: function(x, y, width, height) {
      this._context.strokeRect(x, y, width, height);
    },
    fillText: function() {
      var a = arguments;
      this._context.fillText(a[0], a[1], a[2]);
    },
    measureText: function(text) {
      return this._context.measureText(text);
    },
    getImageData: function() {
      var a = arguments;
      return this._context.getImageData(a[0], a[1], a[2], a[3]);
    },
    lineTo: function() {
      var a = arguments;
      this._context.lineTo(a[0], a[1]);
    },
    moveTo: function() {
      var a = arguments;
      this._context.moveTo(a[0], a[1]);
    },
    rect: function() {
      var a = arguments;
      this._context.rect(a[0], a[1], a[2], a[3]);
    },
    putImageData: function() {
      var a = arguments;
      this._context.putImageData(a[0], a[1], a[2]);
    },
    quadraticCurveTo: function() {
      var a = arguments;
      this._context.quadraticCurveTo(a[0], a[1], a[2], a[3]);
    },
    restore: function() {
      this._context.restore();
    },
    rotate: function() {
      var a = arguments;
      this._context.rotate(a[0]);
    },
    save: function() {
      this._context.save();
    },
    scale: function() {
      var a = arguments;
      this._context.scale(a[0], a[1]);
    },
    setLineDash: function() {
      var a = arguments, _context = this._context;

      // works for Chrome and IE11
      if (this._context.setLineDash) {
        _context.setLineDash(a[0]);
      } else if ('mozDash' in _context) {
        // verified that this works in firefox
        _context.mozDash = a[0];
      } else if ('webkitLineDash' in _context) {
        // does not currently work for Safari
        _context.webkitLineDash = a[0];
      }

      // no support for IE9 and IE10
    },
    getLineDash: function() {
      return this._context.getLineDash();
    },
    setTransform: function() {
      var a = arguments;
      this._context.setTransform(a[0], a[1], a[2], a[3], a[4], a[5]);
    },
    stroke: function() {
      this._context.stroke();
    },
    strokeText: function() {
      var a = arguments;
      this._context.strokeText(a[0], a[1], a[2]);
    },
    transform: function() {
      var a = arguments;
      this._context.transform(a[0], a[1], a[2], a[3], a[4], a[5]);
    },
    translate: function() {
      var a = arguments;
      this._context.translate(a[0], a[1]);
    },
    _enableTrace: function() {
      var that = this,
        len = CONTEXT_METHODS.length,
        _simplifyArray = Konva.Util._simplifyArray,
        origSetter = this.setAttr,
        n,
        args;

      // to prevent creating scope function at each loop
      var func = function(methodName) {
        var origMethod = that[methodName], ret;

        that[methodName] = function() {
          args = _simplifyArray(Array.prototype.slice.call(arguments, 0));
          ret = origMethod.apply(that, arguments);

          that._trace({
            method: methodName,
            args: args
          });

          return ret;
        };
      };
      // methods
      for (n = 0; n < len; n++) {
        func(CONTEXT_METHODS[n]);
      }

      // attrs
      that.setAttr = function() {
        origSetter.apply(that, arguments);
        var prop = arguments[0];
        var val = arguments[1];
        if (
          prop === 'shadowOffsetX' ||
          prop === 'shadowOffsetY' ||
          prop === 'shadowBlur'
        ) {
          val = val / this.canvas.getPixelRatio();
        }
        that._trace({
          property: prop,
          val: val
        });
      };
    }
  };

  CONTEXT_PROPERTIES.forEach(function(prop) {
    Object.defineProperty(Konva.Context.prototype, prop, {
      get: function() {
        return this._context[prop];
      },
      set: function(val) {
        this._context[prop] = val;
      }
    });
  });

  Konva.SceneContext = function(canvas) {
    Konva.Context.call(this, canvas);
  };

  Konva.SceneContext.prototype = {
    _fillColor: function(shape) {
      var fill = shape.fill();

      this.setAttr('fillStyle', fill);
      shape._fillFunc(this);
    },
    _fillPattern: function(shape) {
      var fillPatternX = shape.getFillPatternX(),
        fillPatternY = shape.getFillPatternY(),
        fillPatternScale = shape.getFillPatternScale(),
        fillPatternRotation = Konva.getAngle(shape.getFillPatternRotation()),
        fillPatternOffset = shape.getFillPatternOffset();

      if (fillPatternX || fillPatternY) {
        this.translate(fillPatternX || 0, fillPatternY || 0);
      }
      if (fillPatternRotation) {
        this.rotate(fillPatternRotation);
      }
      if (fillPatternScale) {
        this.scale(fillPatternScale.x, fillPatternScale.y);
      }
      if (fillPatternOffset) {
        this.translate(-1 * fillPatternOffset.x, -1 * fillPatternOffset.y);
      }

      this.setAttr(
        'fillStyle',
        this.createPattern(
          shape.getFillPatternImage(),
          shape.getFillPatternRepeat() || 'repeat'
        )
      );
      this.fill();
    },
    _fillLinearGradient: function(shape) {
      var start = shape.getFillLinearGradientStartPoint(),
        end = shape.getFillLinearGradientEndPoint(),
        colorStops = shape.getFillLinearGradientColorStops(),
        grd = this.createLinearGradient(start.x, start.y, end.x, end.y);

      if (colorStops) {
        // build color stops
        for (var n = 0; n < colorStops.length; n += 2) {
          grd.addColorStop(colorStops[n], colorStops[n + 1]);
        }
        this.setAttr('fillStyle', grd);
        shape._fillFunc(this);
      }
    },
    _fillRadialGradient: function(shape) {
      var start = shape.getFillRadialGradientStartPoint(),
        end = shape.getFillRadialGradientEndPoint(),
        startRadius = shape.getFillRadialGradientStartRadius(),
        endRadius = shape.getFillRadialGradientEndRadius(),
        colorStops = shape.getFillRadialGradientColorStops(),
        grd = this.createRadialGradient(
          start.x,
          start.y,
          startRadius,
          end.x,
          end.y,
          endRadius
        );

      // build color stops
      for (var n = 0; n < colorStops.length; n += 2) {
        grd.addColorStop(colorStops[n], colorStops[n + 1]);
      }
      this.setAttr('fillStyle', grd);
      this.fill();
    },
    _fill: function(shape) {
      var hasColor = shape.fill(),
        hasPattern = shape.getFillPatternImage(),
        hasLinearGradient = shape.getFillLinearGradientColorStops(),
        hasRadialGradient = shape.getFillRadialGradientColorStops(),
        fillPriority = shape.getFillPriority();

      // priority fills
      if (hasColor && fillPriority === 'color') {
        this._fillColor(shape);
      } else if (hasPattern && fillPriority === 'pattern') {
        this._fillPattern(shape);
      } else if (hasLinearGradient && fillPriority === 'linear-gradient') {
        this._fillLinearGradient(shape);
      } else if (hasRadialGradient && fillPriority === 'radial-gradient') {
        this._fillRadialGradient(shape);
      } else if (hasColor) {
        // now just try and fill with whatever is available
        this._fillColor(shape);
      } else if (hasPattern) {
        this._fillPattern(shape);
      } else if (hasLinearGradient) {
        this._fillLinearGradient(shape);
      } else if (hasRadialGradient) {
        this._fillRadialGradient(shape);
      }
    },
    _stroke: function(shape) {
      var dash = shape.dash(),
        // ignore strokeScaleEnabled for Text
        strokeScaleEnabled =
          shape.getStrokeScaleEnabled() || shape instanceof Konva.Text;

      if (shape.hasStroke()) {
        if (!strokeScaleEnabled) {
          this.save();
          this.setTransform(1, 0, 0, 1, 0, 0);
        }

        this._applyLineCap(shape);
        if (dash && shape.dashEnabled()) {
          this.setLineDash(dash);
          this.setAttr('lineDashOffset', shape.dashOffset());
        }

        this.setAttr('lineWidth', shape.strokeWidth());
        this.setAttr('strokeStyle', shape.stroke());

        if (!shape.getShadowForStrokeEnabled()) {
          this.setAttr('shadowColor', 'rgba(0,0,0,0)');
        }
        shape._strokeFunc(this);

        if (!strokeScaleEnabled) {
          this.restore();
        }
      }
    },
    _applyShadow: function(shape) {
      var util = Konva.Util,
        color = util.get(shape.getShadowRGBA(), 'black'),
        blur = util.get(shape.getShadowBlur(), 5),
        offset = util.get(shape.getShadowOffset(), {
          x: 0,
          y: 0
        }),
        // TODO: get this info from transform??
        scale = shape.getAbsoluteScale(),
        ratio = this.canvas.getPixelRatio(),
        scaleX = scale.x * ratio,
        scaleY = scale.y * ratio;

      this.setAttr('shadowColor', color);
      this.setAttr(
        'shadowBlur',
        blur * ratio * Math.min(Math.abs(scaleX), Math.abs(scaleY))
      );
      this.setAttr('shadowOffsetX', offset.x * scaleX);
      this.setAttr('shadowOffsetY', offset.y * scaleY);
    },
    _applyGlobalCompositeOperation: function(shape) {
      var globalCompositeOperation = shape.getGlobalCompositeOperation();
      if (globalCompositeOperation !== 'source-over') {
        this.setAttr('globalCompositeOperation', globalCompositeOperation);
      }
    }
  };
  Konva.Util.extend(Konva.SceneContext, Konva.Context);

  Konva.HitContext = function(canvas) {
    Konva.Context.call(this, canvas);
  };

  Konva.HitContext.prototype = {
    _fill: function(shape) {
      this.save();
      this.setAttr('fillStyle', shape.colorKey);
      shape._fillFuncHit(this);
      this.restore();
    },
    _stroke: function(shape) {
      if (shape.hasStroke() && shape.strokeHitEnabled()) {
        // ignore strokeScaleEnabled for Text
        var strokeScaleEnabled =
          shape.getStrokeScaleEnabled() || shape instanceof Konva.Text;
        if (!strokeScaleEnabled) {
          this.save();
          this.setTransform(1, 0, 0, 1, 0, 0);
        }
        this._applyLineCap(shape);
        this.setAttr('lineWidth', shape.strokeWidth());
        this.setAttr('strokeStyle', shape.colorKey);
        shape._strokeFuncHit(this);
        if (!strokeScaleEnabled) {
          this.restore();
        }
      }
    }
  };
  Konva.Util.extend(Konva.HitContext, Konva.Context);
})();

(function() {
  'use strict';
  // CONSTANTS
  var GET = 'get', SET = 'set';

  Konva.Factory = {
    addGetterSetter: function(constructor, attr, def, validator, after) {
      this.addGetter(constructor, attr, def);
      this.addSetter(constructor, attr, validator, after);
      this.addOverloadedGetterSetter(constructor, attr);
    },
    addGetter: function(constructor, attr, def) {
      var method = GET + Konva.Util._capitalize(attr);

      constructor.prototype[method] = function() {
        var val = this.attrs[attr];
        return val === undefined ? def : val;
      };
    },
    addSetter: function(constructor, attr, validator, after) {
      var method = SET + Konva.Util._capitalize(attr);

      constructor.prototype[method] = function(val) {
        if (validator) {
          val = validator.call(this, val);
        }

        this._setAttr(attr, val);

        if (after) {
          after.call(this);
        }

        return this;
      };
    },
    addComponentsGetterSetter: function(
      constructor,
      attr,
      components,
      validator,
      after
    ) {
      var len = components.length,
        capitalize = Konva.Util._capitalize,
        getter = GET + capitalize(attr),
        setter = SET + capitalize(attr),
        n,
        component;

      // getter
      constructor.prototype[getter] = function() {
        var ret = {};

        for (n = 0; n < len; n++) {
          component = components[n];
          ret[component] = this.getAttr(attr + capitalize(component));
        }

        return ret;
      };

      // setter
      constructor.prototype[setter] = function(val) {
        var oldVal = this.attrs[attr], key;

        if (validator) {
          val = validator.call(this, val);
        }

        for (key in val) {
          if (!val.hasOwnProperty(key)) {
            continue;
          }
          this._setAttr(attr + capitalize(key), val[key]);
        }

        this._fireChangeEvent(attr, oldVal, val);

        if (after) {
          after.call(this);
        }

        return this;
      };

      this.addOverloadedGetterSetter(constructor, attr);
    },
    addOverloadedGetterSetter: function(constructor, attr) {
      var capitalizedAttr = Konva.Util._capitalize(attr),
        setter = SET + capitalizedAttr,
        getter = GET + capitalizedAttr;

      constructor.prototype[attr] = function() {
        // setting
        if (arguments.length) {
          this[setter](arguments[0]);
          return this;
        }
        // getting
        return this[getter]();
      };
    },
    addDeprecatedGetterSetter: function(constructor, attr, def, validator) {
      var method = GET + Konva.Util._capitalize(attr);
      var message =
        attr +
        ' property is deprecated and will be removed soon. Look at Konva change log for more information.';
      constructor.prototype[method] = function() {
        Konva.Util.error(message);
        var val = this.attrs[attr];
        return val === undefined ? def : val;
      };
      this.addSetter(constructor, attr, validator, function() {
        Konva.Util.error(message);
      });
      this.addOverloadedGetterSetter(constructor, attr);
    },
    backCompat: function(constructor, methods) {
      Konva.Util.each(methods, function(oldMethodName, newMethodName) {
        var method = constructor.prototype[newMethodName];
        constructor.prototype[oldMethodName] = function() {
          method.apply(this, arguments);
          Konva.Util.error(
            oldMethodName +
              ' method is deprecated and will be removed soon. Use ' +
              newMethodName +
              ' instead'
          );
        };
      });
    },
    afterSetFilter: function() {
      this._filterUpToDate = false;
    }
  };

  Konva.Validators = {
    /**
         * @return {number}
         */
    RGBComponent: function(val) {
      if (val > 255) {
        return 255;
      } else if (val < 0) {
        return 0;
      }
      return Math.round(val);
    },
    alphaComponent: function(val) {
      if (val > 1) {
        return 1;
      } else if (val < 0.0001) {
        // chrome does not honor alpha values of 0
        return 0.0001;
      }

      return val;
    }
  };
})();

(function(Konva) {
  'use strict';
  // CONSTANTS
  var ABSOLUTE_OPACITY = 'absoluteOpacity',
    ABSOLUTE_TRANSFORM = 'absoluteTransform',
    ABSOLUTE_SCALE = 'absoluteScale',
    CHANGE = 'Change',
    CHILDREN = 'children',
    DOT = '.',
    EMPTY_STRING = '',
    GET = 'get',
    ID = 'id',
    KONVA = 'konva',
    LISTENING = 'listening',
    MOUSEENTER = 'mouseenter',
    MOUSELEAVE = 'mouseleave',
    NAME = 'name',
    SET = 'set',
    SHAPE = 'Shape',
    SPACE = ' ',
    STAGE = 'stage',
    TRANSFORM = 'transform',
    UPPER_STAGE = 'Stage',
    VISIBLE = 'visible',
    CLONE_BLACK_LIST = ['id'],
    TRANSFORM_CHANGE_STR = [
      'xChange.konva',
      'yChange.konva',
      'scaleXChange.konva',
      'scaleYChange.konva',
      'skewXChange.konva',
      'skewYChange.konva',
      'rotationChange.konva',
      'offsetXChange.konva',
      'offsetYChange.konva',
      'transformsEnabledChange.konva'
    ].join(SPACE),
    SCALE_CHANGE_STR = ['scaleXChange.konva', 'scaleYChange.konva'].join(SPACE);

  /**
     * Node constructor. Nodes are entities that can be transformed, layered,
     * and have bound events. The stage, layers, groups, and shapes all extend Node.
     * @constructor
     * @memberof Konva
     * @abstract
     * @param {Object} config
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     */
  Konva.Node = function(config) {
    this._init(config);
  };

  Konva.Util.addMethods(Konva.Node, {
    _init: function(config) {
      var that = this;
      this._id = Konva.idCounter++;
      this.eventListeners = {};
      this.attrs = {};
      this._cache = {};
      this._filterUpToDate = false;
      this._isUnderCache = false;
      this.setAttrs(config);

      // event bindings for cache handling
      this.on(TRANSFORM_CHANGE_STR, function() {
        this._clearCache(TRANSFORM);
        that._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
      });

      this.on(SCALE_CHANGE_STR, function() {
        that._clearSelfAndDescendantCache(ABSOLUTE_SCALE);
      });

      this.on('visibleChange.konva', function() {
        that._clearSelfAndDescendantCache(VISIBLE);
      });
      this.on('listeningChange.konva', function() {
        that._clearSelfAndDescendantCache(LISTENING);
      });
      this.on('opacityChange.konva', function() {
        that._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);
      });
    },
    _clearCache: function(attr) {
      if (attr) {
        delete this._cache[attr];
      } else {
        this._cache = {};
      }
    },
    _getCache: function(attr, privateGetter) {
      var cache = this._cache[attr];

      // if not cached, we need to set it using the private getter method.
      if (cache === undefined) {
        this._cache[attr] = privateGetter.call(this);
      }

      return this._cache[attr];
    },
    /*
         * when the logic for a cached result depends on ancestor propagation, use this
         * method to clear self and children cache
         */
    _clearSelfAndDescendantCache: function(attr) {
      this._clearCache(attr);

      if (this.children) {
        this.getChildren().each(function(node) {
          node._clearSelfAndDescendantCache(attr);
        });
      }
    },
    /**
        * clear cached canvas
        * @method
        * @memberof Konva.Node.prototype
        * @returns {Konva.Node}
        * @example
        * node.clearCache();
        */
    clearCache: function() {
      delete this._cache.canvas;
      this._filterUpToDate = false;
      return this;
    },
    /**
        *  cache node to improve drawing performance, apply filters, or create more accurate
        *  hit regions. For all basic shapes size of cache canvas will be automatically detected.
        *  If you need to cache your custom `Konva.Shape` instance you have to pass shape's bounding box
        *  properties. Look at [link to demo page](link to demo page) for more information.
        * @method
        * @memberof Konva.Node.prototype
        * @param {Object} [config]
        * @param {Number} [config.x]
        * @param {Number} [config.y]
        * @param {Number} [config.width]
        * @param {Number} [config.height]
        * @param {Number} [config.offset]  increase canvas size by `offset` pixel in all directions.
        * @param {Boolean} [config.drawBorder] when set to true, a red border will be drawn around the cached
        *  region for debugging purposes
        * @param {Number} [config.pixelRatio] change quality (or pixel ratio) of cached image. pixelRatio = 2 will produce 2x sized cache.
        * @returns {Konva.Node}
        * @example
        * // cache a shape with the x,y position of the bounding box at the center and
        * // the width and height of the bounding box equal to the width and height of
        * // the shape obtained from shape.width() and shape.height()
        * image.cache();
        *
        * // cache a node and define the bounding box position and size
        * node.cache({
        *   x: -30,
        *   y: -30,
        *   width: 100,
        *   height: 200
        * });
        *
        * // cache a node and draw a red border around the bounding box
        * // for debugging purposes
        * node.cache({
        *   x: -30,
        *   y: -30,
        *   width: 100,
        *   height: 200,
        *   offset : 10,
        *   drawBorder: true
        * });
        */
    cache: function(config) {
      var conf = config || {},
        rect = this.getClientRect({
          skipTransform: true,
          relativeTo: this.getParent()
        }),
        width = conf.width || rect.width,
        height = conf.height || rect.height,
        pixelRatio = conf.pixelRatio,
        x = conf.x || rect.x,
        y = conf.y || rect.y,
        offset = conf.offset || 0,
        drawBorder = conf.drawBorder || false;

      if (!width || !height) {
        // make throw async, because we don't need to stop funcion
        setTimeout(function() {
          Konva.Util.throw(
            'Width or height of caching configuration equals 0. Caching is ignored.'
          );
        });
        return;
      }

      width += offset * 2;
      height += offset * 2;

      x -= offset;
      y -= offset;

      var cachedSceneCanvas = new Konva.SceneCanvas({
          pixelRatio: pixelRatio,
          width: width,
          height: height
        }),
        cachedFilterCanvas = new Konva.SceneCanvas({
          pixelRatio: pixelRatio,
          width: width,
          height: height
        }),
        cachedHitCanvas = new Konva.HitCanvas({
          pixelRatio: 1,
          width: width,
          height: height
        }),
        sceneContext = cachedSceneCanvas.getContext(),
        hitContext = cachedHitCanvas.getContext();

      cachedHitCanvas.isCache = true;

      this.clearCache();

      sceneContext.save();
      hitContext.save();

      sceneContext.translate(-x, -y);
      hitContext.translate(-x, -y);

      // extra flag to skip on getAbsolute opacity calc
      this._isUnderCache = true;
      this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);
      this._clearSelfAndDescendantCache(ABSOLUTE_SCALE);

      this.drawScene(cachedSceneCanvas, this, true);
      this.drawHit(cachedHitCanvas, this, true);
      this._isUnderCache = false;

      sceneContext.restore();
      hitContext.restore();

      // this will draw a red border around the cached box for
      // debugging purposes
      if (drawBorder) {
        sceneContext.save();
        sceneContext.beginPath();
        sceneContext.rect(0, 0, width, height);
        sceneContext.closePath();
        sceneContext.setAttr('strokeStyle', 'red');
        sceneContext.setAttr('lineWidth', 5);
        sceneContext.stroke();
        sceneContext.restore();
      }

      this._cache.canvas = {
        scene: cachedSceneCanvas,
        filter: cachedFilterCanvas,
        hit: cachedHitCanvas,
        x: x,
        y: y
      };

      return this;
    },
    /**
         * Return client rectangle {x, y, width, height} of node. This rectangle also include all styling (strokes, shadows, etc).
         * The rectangle position is relative to parent container.
         * @method
         * @memberof Konva.Node.prototype
         * @param {Object} config
         * @param {Boolean} [config.skipTransform] should we apply transform to node for calculating rect?
         * @param {Object} [config.relativeTo] calculate client rect relative to one of the parents
         * @returns {Object} rect with {x, y, width, height} properties
         * @example
         * var rect = new Konva.Rect({
         *      width : 100,
         *      height : 100,
         *      x : 50,
         *      y : 50,
         *      strokeWidth : 4,
         *      stroke : 'black',
         *      offsetX : 50,
         *      scaleY : 2
         * });
         *
         * // get client rect without think off transformations (position, rotation, scale, offset, etc)
         * rect.getClientRect({ skipTransform: true});
         * // returns {
         * //     x : -2,   // two pixels for stroke / 2
         * //     y : -2,
         * //     width : 104, // increased by 4 for stroke
         * //     height : 104
         * //}
         *
         * // get client rect with transformation applied
         * rect.getClientRect();
         * // returns Object {x: -2, y: 46, width: 104, height: 208}
         */
    getClientRect: function() {
      // abstract method
      // redefine in Container and Shape
      throw new Error('abstract "getClientRect" method call');
    },
    _transformedRect: function(rect, top) {
      var points = [
        { x: rect.x, y: rect.y },
        { x: rect.x + rect.width, y: rect.y },
        { x: rect.x + rect.width, y: rect.y + rect.height },
        { x: rect.x, y: rect.y + rect.height }
      ];
      var minX, minY, maxX, maxY;
      var trans = this.getAbsoluteTransform(top);
      points.forEach(function(point) {
        var transformed = trans.point(point);
        if (minX === undefined) {
          minX = maxX = transformed.x;
          minY = maxY = transformed.y;
        }
        minX = Math.min(minX, transformed.x);
        minY = Math.min(minY, transformed.y);
        maxX = Math.max(maxX, transformed.x);
        maxY = Math.max(maxY, transformed.y);
      });
      return {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
      };
    },
    _drawCachedSceneCanvas: function(context) {
      context.save();
      context._applyOpacity(this);
      context._applyGlobalCompositeOperation(this);
      context.translate(this._cache.canvas.x, this._cache.canvas.y);

      var cacheCanvas = this._getCachedSceneCanvas();
      var ratio = cacheCanvas.pixelRatio;

      context.drawImage(
        cacheCanvas._canvas,
        0,
        0,
        cacheCanvas.width / ratio,
        cacheCanvas.height / ratio
      );
      context.restore();
    },
    _drawCachedHitCanvas: function(context) {
      var cachedCanvas = this._cache.canvas,
        hitCanvas = cachedCanvas.hit;
      context.save();
      context.translate(this._cache.canvas.x, this._cache.canvas.y);
      context.drawImage(hitCanvas._canvas, 0, 0);
      context.restore();
    },
    _getCachedSceneCanvas: function() {
      var filters = this.filters(),
        cachedCanvas = this._cache.canvas,
        sceneCanvas = cachedCanvas.scene,
        filterCanvas = cachedCanvas.filter,
        filterContext = filterCanvas.getContext(),
        len,
        imageData,
        n,
        filter;

      if (filters) {
        if (!this._filterUpToDate) {
          var ratio = sceneCanvas.pixelRatio;

          try {
            len = filters.length;
            filterContext.clear();

            // copy cached canvas onto filter context
            filterContext.drawImage(
              sceneCanvas._canvas,
              0,
              0,
              sceneCanvas.getWidth() / ratio,
              sceneCanvas.getHeight() / ratio
            );
            imageData = filterContext.getImageData(
              0,
              0,
              filterCanvas.getWidth(),
              filterCanvas.getHeight()
            );

            // apply filters to filter context
            for (n = 0; n < len; n++) {
              filter = filters[n];
              if (typeof filter !== 'function') {
                Konva.Util.error(
                  'Filter should be type of function, but got ' +
                    typeof filter +
                    ' insted. Please check correct filters'
                );
                continue;
              }
              filter.call(this, imageData);
              filterContext.putImageData(imageData, 0, 0);
            }
          } catch (e) {
            Konva.Util.error('Unable to apply filter. ' + e.message);
          }

          this._filterUpToDate = true;
        }

        return filterCanvas;
      }
      return sceneCanvas;
    },
    /**
         * bind events to the node. KonvaJS supports mouseover, mousemove,
         *  mouseout, mouseenter, mouseleave, mousedown, mouseup, wheel, click, dblclick, touchstart, touchmove,
         *  touchend, tap, dbltap, dragstart, dragmove, and dragend events. The Konva Stage supports
         *  contentMouseover, contentMousemove, contentMouseout, contentMousedown, contentMouseup, contentWheel, contentContextmenu
         *  contentClick, contentDblclick, contentTouchstart, contentTouchmove, contentTouchend, contentTap,
         *  and contentDblTap.  Pass in a string of events delimmited by a space to bind multiple events at once
         *  such as 'mousedown mouseup mousemove'. Include a namespace to bind an
         *  event by name such as 'click.foobar'.
         * @method
         * @memberof Konva.Node.prototype
         * @param {String} evtStr e.g. 'click', 'mousedown touchstart', 'mousedown.foo touchstart.foo'
         * @param {Function} handler The handler function is passed an event object
         * @returns {Konva.Node}
         * @example
         * // add click listener
         * node.on('click', function() {
         *   console.log('you clicked me!');
         * });
         *
         * // get the target node
         * node.on('click', function(evt) {
         *   console.log(evt.target);
         * });
         *
         * // stop event propagation
         * node.on('click', function(evt) {
         *   evt.cancelBubble = true;
         * });
         *
         * // bind multiple listeners
         * node.on('click touchstart', function() {
         *   console.log('you clicked/touched me!');
         * });
         *
         * // namespace listener
         * node.on('click.foo', function() {
         *   console.log('you clicked/touched me!');
         * });
         *
         * // get the event type
         * node.on('click tap', function(evt) {
         *   var eventType = evt.type;
         * });
         *
         * // get native event object
         * node.on('click tap', function(evt) {
         *   var nativeEvent = evt.evt;
         * });
         *
         * // for change events, get the old and new val
         * node.on('xChange', function(evt) {
         *   var oldVal = evt.oldVal;
         *   var newVal = evt.newVal;
         * });
         *
         * // get event targets
         * // with event delegations
         * layer.on('click', 'Group', function(evt) {
         *   var shape = evt.target;
         *   var group = evtn.currentTarger;
         * });
         */
    on: function(evtStr, handler) {
      if (arguments.length === 3) {
        return this._delegate.apply(this, arguments);
      }
      var events = evtStr.split(SPACE),
        len = events.length,
        n,
        event,
        parts,
        baseEvent,
        name;

      /*
             * loop through types and attach event listeners to
             * each one.  eg. 'click mouseover.namespace mouseout'
             * will create three event bindings
             */
      for (n = 0; n < len; n++) {
        event = events[n];
        parts = event.split(DOT);
        baseEvent = parts[0];
        name = parts[1] || EMPTY_STRING;

        // create events array if it doesn't exist
        if (!this.eventListeners[baseEvent]) {
          this.eventListeners[baseEvent] = [];
        }

        this.eventListeners[baseEvent].push({
          name: name,
          handler: handler
        });
      }

      return this;
    },
    /**
         * remove event bindings from the node. Pass in a string of
         *  event types delimmited by a space to remove multiple event
         *  bindings at once such as 'mousedown mouseup mousemove'.
         *  include a namespace to remove an event binding by name
         *  such as 'click.foobar'. If you only give a name like '.foobar',
         *  all events in that namespace will be removed.
         * @method
         * @memberof Konva.Node.prototype
         * @param {String} evtStr e.g. 'click', 'mousedown touchstart', '.foobar'
         * @returns {Konva.Node}
         * @example
         * // remove listener
         * node.off('click');
         *
         * // remove multiple listeners
         * node.off('click touchstart');
         *
         * // remove listener by name
         * node.off('click.foo');
         */
    off: function(evtStr) {
      var events = (evtStr || '').split(SPACE),
        len = events.length,
        n,
        t,
        event,
        parts,
        baseEvent,
        name;

      if (!evtStr) {
        // remove all events
        for (t in this.eventListeners) {
          this._off(t);
        }
      }
      for (n = 0; n < len; n++) {
        event = events[n];
        parts = event.split(DOT);
        baseEvent = parts[0];
        name = parts[1];

        if (baseEvent) {
          if (this.eventListeners[baseEvent]) {
            this._off(baseEvent, name);
          }
        } else {
          for (t in this.eventListeners) {
            this._off(t, name);
          }
        }
      }
      return this;
    },
    // some event aliases for third party integration like HammerJS
    dispatchEvent: function(evt) {
      var e = {
        target: this,
        type: evt.type,
        evt: evt
      };
      this.fire(evt.type, e);
      return this;
    },
    addEventListener: function(type, handler) {
      // we have to pass native event to handler
      this.on(type, function(evt) {
        handler.call(this, evt.evt);
      });
      return this;
    },
    removeEventListener: function(type) {
      this.off(type);
      return this;
    },
    // like node.on
    _delegate: function(event, selector, handler) {
      var stopNode = this;
      this.on(event, function(evt) {
        var targets = evt.target.findAncestors(selector, true, stopNode);
        for (var i = 0; i < targets.length; i++) {
          evt = Konva.Util.cloneObject(evt);
          evt.currentTarget = targets[i];
          handler.call(targets[i], evt);
        }
      });
    },
    /**
         * remove self from parent, but don't destroy
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Konva.Node}
         * @example
         * node.remove();
         */
    remove: function() {
      var parent = this.getParent();

      if (parent && parent.children) {
        parent.children.splice(this.index, 1);
        parent._setChildrenIndices();
        delete this.parent;
      }

      // every cached attr that is calculated via node tree
      // traversal must be cleared when removing a node
      this._clearSelfAndDescendantCache(STAGE);
      this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
      this._clearSelfAndDescendantCache(VISIBLE);
      this._clearSelfAndDescendantCache(LISTENING);
      this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);

      return this;
    },
    /**
         * remove and destroy self
         * @method
         * @memberof Konva.Node.prototype
         * @example
         * node.destroy();
         */
    destroy: function() {
      // remove from ids and names hashes
      Konva._removeId(this.getId());

      // remove all names
      var names = (this.getName() || '').split(/\s/g);
      for (var i = 0; i < names.length; i++) {
        var subname = names[i];
        Konva._removeName(subname, this._id);
      }

      this.remove();
      return this;
    },
    /**
         * get attr
         * @method
         * @memberof Konva.Node.prototype
         * @param {String} attr
         * @returns {Integer|String|Object|Array}
         * @example
         * var x = node.getAttr('x');
         */
    getAttr: function(attr) {
      var method = GET + Konva.Util._capitalize(attr);
      if (Konva.Util._isFunction(this[method])) {
        return this[method]();
      }
      // otherwise get directly
      return this.attrs[attr];
    },
    /**
        * get ancestors
        * @method
        * @memberof Konva.Node.prototype
        * @returns {Konva.Collection}
        * @example
        * shape.getAncestors().each(function(node) {
        *   console.log(node.getId());
        * })
        */
    getAncestors: function() {
      var parent = this.getParent(),
        ancestors = new Konva.Collection();

      while (parent) {
        ancestors.push(parent);
        parent = parent.getParent();
      }

      return ancestors;
    },
    /**
         * get attrs object literal
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Object}
         */
    getAttrs: function() {
      return this.attrs || {};
    },
    /**
         * set multiple attrs at once using an object literal
         * @method
         * @memberof Konva.Node.prototype
         * @param {Object} config object containing key value pairs
         * @returns {Konva.Node}
         * @example
         * node.setAttrs({
         *   x: 5,
         *   fill: 'red'
         * });
         */
    setAttrs: function(config) {
      var key, method;

      if (!config) {
        return this;
      }
      for (key in config) {
        if (key === CHILDREN) {
          continue;
        }
        method = SET + Konva.Util._capitalize(key);
        // use setter if available
        if (Konva.Util._isFunction(this[method])) {
          this[method](config[key]);
        } else {
          // otherwise set directly
          this._setAttr(key, config[key]);
        }
      }
      return this;
    },
    /**
         * determine if node is listening for events by taking into account ancestors.
         *
         * Parent    | Self      | isListening
         * listening | listening |
         * ----------+-----------+------------
         * T         | T         | T
         * T         | F         | F
         * F         | T         | T
         * F         | F         | F
         * ----------+-----------+------------
         * T         | I         | T
         * F         | I         | F
         * I         | I         | T
         *
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Boolean}
         */
    isListening: function() {
      return this._getCache(LISTENING, this._isListening);
    },
    _isListening: function() {
      var listening = this.getListening(),
        parent = this.getParent();

      // the following conditions are a simplification of the truth table above.
      // please modify carefully
      if (listening === 'inherit') {
        if (parent) {
          return parent.isListening();
        } else {
          return true;
        }
      } else {
        return listening;
      }
    },
    /**
         * determine if node is visible by taking into account ancestors.
         *
         * Parent    | Self      | isVisible
         * visible   | visible   |
         * ----------+-----------+------------
         * T         | T         | T
         * T         | F         | F
         * F         | T         | T
         * F         | F         | F
         * ----------+-----------+------------
         * T         | I         | T
         * F         | I         | F
         * I         | I         | T

         * @method
         * @memberof Konva.Node.prototype
         * @returns {Boolean}
         */
    isVisible: function() {
      return this._getCache(VISIBLE, this._isVisible);
    },
    _isVisible: function() {
      var visible = this.getVisible(),
        parent = this.getParent();

      // the following conditions are a simplification of the truth table above.
      // please modify carefully
      if (visible === 'inherit') {
        if (parent) {
          return parent.isVisible();
        } else {
          return true;
        }
      } else {
        return visible;
      }
    },
    /**
         * determine if listening is enabled by taking into account descendants.  If self or any children
         * have _isListeningEnabled set to true, then self also has listening enabled.
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Boolean}
         */
    shouldDrawHit: function(canvas) {
      var layer = this.getLayer();
      return (
        (canvas && canvas.isCache) ||
        (layer &&
          layer.hitGraphEnabled() &&
          this.isListening() &&
          this.isVisible())
      );
    },
    /**
         * show node
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Konva.Node}
         */
    show: function() {
      this.setVisible(true);
      return this;
    },
    /**
         * hide node.  Hidden nodes are no longer detectable
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Konva.Node}
         */
    hide: function() {
      this.setVisible(false);
      return this;
    },
    /**
         * get zIndex relative to the node's siblings who share the same parent
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Integer}
         */
    getZIndex: function() {
      return this.index || 0;
    },
    /**
         * get absolute z-index which takes into account sibling
         *  and ancestor indices
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Integer}
         */
    getAbsoluteZIndex: function() {
      var depth = this.getDepth(),
        that = this,
        index = 0,
        nodes,
        len,
        n,
        child;

      function addChildren(children) {
        nodes = [];
        len = children.length;
        for (n = 0; n < len; n++) {
          child = children[n];
          index++;

          if (child.nodeType !== SHAPE) {
            nodes = nodes.concat(child.getChildren().toArray());
          }

          if (child._id === that._id) {
            n = len;
          }
        }

        if (nodes.length > 0 && nodes[0].getDepth() <= depth) {
          addChildren(nodes);
        }
      }
      if (that.nodeType !== UPPER_STAGE) {
        addChildren(that.getStage().getChildren());
      }

      return index;
    },
    /**
         * get node depth in node tree.  Returns an integer.
         *  e.g. Stage depth will always be 0.  Layers will always be 1.  Groups and Shapes will always
         *  be >= 2
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Integer}
         */
    getDepth: function() {
      var depth = 0,
        parent = this.parent;

      while (parent) {
        depth++;
        parent = parent.parent;
      }
      return depth;
    },
    setPosition: function(pos) {
      this.setX(pos.x);
      this.setY(pos.y);
      return this;
    },
    getPosition: function() {
      return {
        x: this.getX(),
        y: this.getY()
      };
    },
    /**
         * get absolute position relative to the top left corner of the stage container div
         * or relative to passed node
         * @method
         * @param {Object} [top] optional parent node
         * @memberof Konva.Node.prototype
         * @returns {Object}
         */
    getAbsolutePosition: function(top) {
      var absoluteMatrix = this.getAbsoluteTransform(top).getMatrix(),
        absoluteTransform = new Konva.Transform(),
        offset = this.offset();

      // clone the matrix array
      absoluteTransform.m = absoluteMatrix.slice();
      absoluteTransform.translate(offset.x, offset.y);

      return absoluteTransform.getTranslation();
    },
    /**
         * set absolute position
         * @method
         * @memberof Konva.Node.prototype
         * @param {Object} pos
         * @param {Number} pos.x
         * @param {Number} pos.y
         * @returns {Konva.Node}
         */
    setAbsolutePosition: function(pos) {
      var origTrans = this._clearTransform(),
        it;

      // don't clear translation
      this.attrs.x = origTrans.x;
      this.attrs.y = origTrans.y;
      delete origTrans.x;
      delete origTrans.y;

      // unravel transform
      it = this.getAbsoluteTransform();

      it.invert();
      it.translate(pos.x, pos.y);
      pos = {
        x: this.attrs.x + it.getTranslation().x,
        y: this.attrs.y + it.getTranslation().y
      };

      this.setPosition({ x: pos.x, y: pos.y });
      this._setTransform(origTrans);

      return this;
    },
    _setTransform: function(trans) {
      var key;

      for (key in trans) {
        this.attrs[key] = trans[key];
      }

      this._clearCache(TRANSFORM);
      this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
    },
    _clearTransform: function() {
      var trans = {
        x: this.getX(),
        y: this.getY(),
        rotation: this.getRotation(),
        scaleX: this.getScaleX(),
        scaleY: this.getScaleY(),
        offsetX: this.getOffsetX(),
        offsetY: this.getOffsetY(),
        skewX: this.getSkewX(),
        skewY: this.getSkewY()
      };

      this.attrs.x = 0;
      this.attrs.y = 0;
      this.attrs.rotation = 0;
      this.attrs.scaleX = 1;
      this.attrs.scaleY = 1;
      this.attrs.offsetX = 0;
      this.attrs.offsetY = 0;
      this.attrs.skewX = 0;
      this.attrs.skewY = 0;

      this._clearCache(TRANSFORM);
      this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);

      // return original transform
      return trans;
    },
    /**
         * move node by an amount relative to its current position
         * @method
         * @memberof Konva.Node.prototype
         * @param {Object} change
         * @param {Number} change.x
         * @param {Number} change.y
         * @returns {Konva.Node}
         * @example
         * // move node in x direction by 1px and y direction by 2px
         * node.move({
         *   x: 1,
         *   y: 2)
         * });
         */
    move: function(change) {
      var changeX = change.x,
        changeY = change.y,
        x = this.getX(),
        y = this.getY();

      if (changeX !== undefined) {
        x += changeX;
      }

      if (changeY !== undefined) {
        y += changeY;
      }

      this.setPosition({ x: x, y: y });
      return this;
    },
    _eachAncestorReverse: function(func, top) {
      var family = [],
        parent = this.getParent(),
        len,
        n;

      // if top node is defined, and this node is top node,
      // there's no need to build a family tree.  just execute
      // func with this because it will be the only node
      if (top && top._id === this._id) {
        func(this);
        return true;
      }

      family.unshift(this);

      while (parent && (!top || parent._id !== top._id)) {
        family.unshift(parent);
        parent = parent.parent;
      }

      len = family.length;
      for (n = 0; n < len; n++) {
        func(family[n]);
      }
    },
    /**
         * rotate node by an amount in degrees relative to its current rotation
         * @method
         * @memberof Konva.Node.prototype
         * @param {Number} theta
         * @returns {Konva.Node}
         */
    rotate: function(theta) {
      this.setRotation(this.getRotation() + theta);
      return this;
    },
    /**
         * move node to the top of its siblings
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Boolean}
         */
    moveToTop: function() {
      if (!this.parent) {
        Konva.Util.warn('Node has no parent. moveToTop function is ignored.');
        return false;
      }
      var index = this.index;
      this.parent.children.splice(index, 1);
      this.parent.children.push(this);
      this.parent._setChildrenIndices();
      return true;
    },
    /**
         * move node up
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Boolean} flag is moved or not
         */
    moveUp: function() {
      if (!this.parent) {
        Konva.Util.warn('Node has no parent. moveUp function is ignored.');
        return false;
      }
      var index = this.index,
        len = this.parent.getChildren().length;
      if (index < len - 1) {
        this.parent.children.splice(index, 1);
        this.parent.children.splice(index + 1, 0, this);
        this.parent._setChildrenIndices();
        return true;
      }
      return false;
    },
    /**
         * move node down
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Boolean}
         */
    moveDown: function() {
      if (!this.parent) {
        Konva.Util.warn('Node has no parent. moveDown function is ignored.');
        return false;
      }
      var index = this.index;
      if (index > 0) {
        this.parent.children.splice(index, 1);
        this.parent.children.splice(index - 1, 0, this);
        this.parent._setChildrenIndices();
        return true;
      }
      return false;
    },
    /**
         * move node to the bottom of its siblings
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Boolean}
         */
    moveToBottom: function() {
      if (!this.parent) {
        Konva.Util.warn(
          'Node has no parent. moveToBottom function is ignored.'
        );
        return false;
      }
      var index = this.index;
      if (index > 0) {
        this.parent.children.splice(index, 1);
        this.parent.children.unshift(this);
        this.parent._setChildrenIndices();
        return true;
      }
      return false;
    },
    /**
         * set zIndex relative to siblings
         * @method
         * @memberof Konva.Node.prototype
         * @param {Integer} zIndex
         * @returns {Konva.Node}
         */
    setZIndex: function(zIndex) {
      if (!this.parent) {
        Konva.Util.warn('Node has no parent. zIndex parameter is ignored.');
        return false;
      }
      var index = this.index;
      this.parent.children.splice(index, 1);
      this.parent.children.splice(zIndex, 0, this);
      this.parent._setChildrenIndices();
      return this;
    },
    /**
         * get absolute opacity
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Number}
         */
    getAbsoluteOpacity: function() {
      return this._getCache(ABSOLUTE_OPACITY, this._getAbsoluteOpacity);
    },
    _getAbsoluteOpacity: function() {
      var absOpacity = this.getOpacity();
      var parent = this.getParent();
      if (parent && !parent._isUnderCache) {
        absOpacity *= this.getParent().getAbsoluteOpacity();
      }
      return absOpacity;
    },
    /**
         * move node to another container
         * @method
         * @memberof Konva.Node.prototype
         * @param {Container} newContainer
         * @returns {Konva.Node}
         * @example
         * // move node from current layer into layer2
         * node.moveTo(layer2);
         */
    moveTo: function(newContainer) {
      // do nothing if new container is already parent
      if (this.getParent() !== newContainer) {
        // this.remove my be overrided by drag and drop
        // buy we need original
        (this.__originalRemove || this.remove).call(this);
        newContainer.add(this);
      }
      return this;
    },
    /**
         * convert Node into an object for serialization.  Returns an object.
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Object}
         */
    toObject: function() {
      var obj = {},
        attrs = this.getAttrs(),
        key,
        val,
        getter,
        defaultValue;

      obj.attrs = {};

      for (key in attrs) {
        val = attrs[key];
        getter = this[key];
        // remove attr value so that we can extract the default value from the getter
        delete attrs[key];
        defaultValue = getter ? getter.call(this) : null;
        // restore attr value
        attrs[key] = val;
        if (defaultValue !== val) {
          obj.attrs[key] = val;
        }
      }

      obj.className = this.getClassName();
      return Konva.Util._prepareToStringify(obj);
    },
    /**
         * convert Node into a JSON string.  Returns a JSON string.
         * @method
         * @memberof Konva.Node.prototype
         * @returns {String}}
         */
    toJSON: function() {
      return JSON.stringify(this.toObject());
    },
    /**
         * get parent container
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Konva.Node}
         */
    getParent: function() {
      return this.parent;
    },
    /**
         * get all ancestros (parent then parent of the parent, etc) of the node
         * @method
         * @memberof Konva.Node.prototype
         * @param {String} [selector] selector for search
         * @param {Boolean} [includeSelf] show we think that node is ancestro itself?
         * @param {Konva.Node} [stopNode] optional node where we need to stop searching (one of ancestors)
         * @returns {Array} [ancestors]
         * @example
         * // get one of the parent group
         * var parentGroups = node.findAncestors('Group');
         */
    findAncestors: function(selector, includeSelf, stopNode) {
      var res = [];

      if (includeSelf && this._isMatch(selector)) {
        res.push(this);
      }
      var ancestor = this.parent;
      while (ancestor) {
        if (ancestor === stopNode) {
          return res;
        }
        if (ancestor._isMatch(selector)) {
          res.push(ancestor);
        }
        ancestor = ancestor.parent;
      }
      return res;
    },
    /**
         * get ancestor (parent or parent of the parent, etc) of the node that match passed selector
         * @method
         * @memberof Konva.Node.prototype
         * @param {String} [selector] selector for search
         * @param {Boolean} [includeSelf] show we think that node is ancestro itself?
         * @param {Konva.Node} [stopNode] optional node where we need to stop searching (one of ancestors)
         * @returns {Konva.Node} ancestor
         * @example
         * // get one of the parent group
         * var group = node.findAncestors('.mygroup');
         */
    findAncestor: function(selector, includeSelf, stopNode) {
      return this.findAncestors(selector, includeSelf, stopNode)[0];
    },
    // is current node match passed selector?
    _isMatch: function(selector) {
      if (!selector) {
        return false;
      }
      var selectorArr = selector.replace(/ /g, '').split(','),
        len = selectorArr.length,
        n,
        sel;

      for (n = 0; n < len; n++) {
        sel = selectorArr[n];
        if (!Konva.Util.isValidSelector(sel)) {
          Konva.Util.warn(
            'Selector "' +
              sel +
              '" is invalid. Allowed selectors examples are "#foo", ".bar" or "Group".'
          );
          Konva.Util.warn(
            'If you have a custom shape with such className, please change it to start with upper letter like "Triangle".'
          );
          Konva.Util.warn('Konva is awesome, right?');
        }
        // id selector
        if (sel.charAt(0) === '#') {
          if (this.id() === sel.slice(1)) {
            return true;
          }
        } else if (sel.charAt(0) === '.') {
          // name selector
          if (this.hasName(sel.slice(1))) {
            return true;
          }
        } else if (this._get(sel).length !== 0) {
          return true;
        }
      }
      return false;
    },
    /**
         * get layer ancestor
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Konva.Layer}
         */
    getLayer: function() {
      var parent = this.getParent();
      return parent ? parent.getLayer() : null;
    },
    /**
         * get stage ancestor
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Konva.Stage}
         */
    getStage: function() {
      return this._getCache(STAGE, this._getStage);
    },
    _getStage: function() {
      var parent = this.getParent();
      if (parent) {
        return parent.getStage();
      } else {
        return undefined;
      }
    },
    /**
         * fire event
         * @method
         * @memberof Konva.Node.prototype
         * @param {String} eventType event type.  can be a regular event, like click, mouseover, or mouseout, or it can be a custom event, like myCustomEvent
         * @param {Event} [evt] event object
         * @param {Boolean} [bubble] setting the value to false, or leaving it undefined, will result in the event
         *  not bubbling.  Setting the value to true will result in the event bubbling.
         * @returns {Konva.Node}
         * @example
         * // manually fire click event
         * node.fire('click');
         *
         * // fire custom event
         * node.fire('foo');
         *
         * // fire custom event with custom event object
         * node.fire('foo', {
         *   bar: 10
         * });
         *
         * // fire click event that bubbles
         * node.fire('click', null, true);
         */
    fire: function(eventType, evt, bubble) {
      evt = evt || {};
      evt.target = evt.target || this;
      // bubble
      if (bubble) {
        this._fireAndBubble(eventType, evt);
      } else {
        // no bubble
        this._fire(eventType, evt);
      }
      return this;
    },
    /**
         * get absolute transform of the node which takes into
         *  account its ancestor transforms
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Konva.Transform}
         */
    getAbsoluteTransform: function(top) {
      // if using an argument, we can't cache the result.
      if (top) {
        return this._getAbsoluteTransform(top);
      } else {
        // if no argument, we can cache the result
        return this._getCache(ABSOLUTE_TRANSFORM, this._getAbsoluteTransform);
      }
    },
    _getAbsoluteTransform: function(top) {
      var at = new Konva.Transform(),
        transformsEnabled,
        trans;

      // start with stage and traverse downwards to self
      this._eachAncestorReverse(function(node) {
        transformsEnabled = node.transformsEnabled();
        trans = node.getTransform();

        if (transformsEnabled === 'all') {
          at.multiply(trans);
        } else if (transformsEnabled === 'position') {
          at.translate(node.x(), node.y());
        }
      }, top);
      return at;
    },
    /**
         * get absolute scale of the node which takes into
         *  account its ancestor scales
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Konva.Transform}
         */
    getAbsoluteScale: function(top) {
      // if using an argument, we can't cache the result.
      if (top) {
        return this._getAbsoluteScale(top);
      } else {
        // if no argument, we can cache the result
        return this._getCache(ABSOLUTE_SCALE, this._getAbsoluteScale);
      }
    },
    _getAbsoluteScale: function(top) {
      // this is special logic for caching with some shapes with shadow
      var parent = this;
      while (parent) {
        if (parent._isUnderCache) {
          top = parent;
        }
        parent = parent.getParent();
      }

      var scaleX = 1,
        scaleY = 1;

      // start with stage and traverse downwards to self
      this._eachAncestorReverse(function(node) {
        scaleX *= node.scaleX();
        scaleY *= node.scaleY();
      }, top);
      return {
        x: scaleX,
        y: scaleY
      };
    },
    /**
         * get transform of the node
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Konva.Transform}
         */
    getTransform: function() {
      return this._getCache(TRANSFORM, this._getTransform);
    },
    _getTransform: function() {
      var m = new Konva.Transform(),
        x = this.getX(),
        y = this.getY(),
        rotation = Konva.getAngle(this.getRotation()),
        scaleX = this.getScaleX(),
        scaleY = this.getScaleY(),
        skewX = this.getSkewX(),
        skewY = this.getSkewY(),
        offsetX = this.getOffsetX(),
        offsetY = this.getOffsetY();

      if (x !== 0 || y !== 0) {
        m.translate(x, y);
      }
      if (rotation !== 0) {
        m.rotate(rotation);
      }
      if (skewX !== 0 || skewY !== 0) {
        m.skew(skewX, skewY);
      }
      if (scaleX !== 1 || scaleY !== 1) {
        m.scale(scaleX, scaleY);
      }
      if (offsetX !== 0 || offsetY !== 0) {
        m.translate(-1 * offsetX, -1 * offsetY);
      }

      return m;
    },
    /**
         * clone node.  Returns a new Node instance with identical attributes.  You can also override
         *  the node properties with an object literal, enabling you to use an existing node as a template
         *  for another node
         * @method
         * @memberof Konva.Node.prototype
         * @param {Object} obj override attrs
         * @returns {Konva.Node}
         * @example
         * // simple clone
         * var clone = node.clone();
         *
         * // clone a node and override the x position
         * var clone = rect.clone({
         *   x: 5
         * });
         */
    clone: function(obj) {
      // instantiate new node
      var attrs = Konva.Util.cloneObject(this.attrs),
        key,
        allListeners,
        len,
        n,
        listener;
      // filter black attrs
      for (var i in CLONE_BLACK_LIST) {
        var blockAttr = CLONE_BLACK_LIST[i];
        delete attrs[blockAttr];
      }
      // apply attr overrides
      for (key in obj) {
        attrs[key] = obj[key];
      }

      var node = new this.constructor(attrs);
      // copy over listeners
      for (key in this.eventListeners) {
        allListeners = this.eventListeners[key];
        len = allListeners.length;
        for (n = 0; n < len; n++) {
          listener = allListeners[n];
          /*
                     * don't include konva namespaced listeners because
                     *  these are generated by the constructors
                     */
          if (listener.name.indexOf(KONVA) < 0) {
            // if listeners array doesn't exist, then create it
            if (!node.eventListeners[key]) {
              node.eventListeners[key] = [];
            }
            node.eventListeners[key].push(listener);
          }
        }
      }
      return node;
    },
    _toKonvaCanvas: function(config) {
      config = config || {};

      var stage = this.getStage(),
        x = config.x || 0,
        y = config.y || 0,
        pixelRatio = config.pixelRatio || 1,
        canvas = new Konva.SceneCanvas({
          width:
            config.width || this.getWidth() || (stage ? stage.getWidth() : 0),
          height:
            config.height ||
            this.getHeight() ||
            (stage ? stage.getHeight() : 0),
          pixelRatio: pixelRatio
        }),
        context = canvas.getContext();

      context.save();

      if (x || y) {
        context.translate(-1 * x, -1 * y);
      }

      this.drawScene(canvas);
      context.restore();

      return canvas;
    },
    /**
         * converts node into an canvas element.
         * @method
         * @memberof Konva.Node.prototype
         * @param {Object} config
         * @param {Function} config.callback function executed when the composite has completed
         * @param {Number} [config.x] x position of canvas section
         * @param {Number} [config.y] y position of canvas section
         * @param {Number} [config.width] width of canvas section
         * @param {Number} [config.height] height of canvas section
         * @paremt {Number} [config.pixelRatio] pixelRatio of ouput image.  Default is 1.
         * @example
         * var canvas = node.toCanvas();
         */
    toCanvas: function(config) {
      return this._toKonvaCanvas(config)._canvas;
    },
    /**
         * Creates a composite data URL. If MIME type is not
         * specified, then "image/png" will result. For "image/jpeg", specify a quality
         * level as quality (range 0.0 - 1.0)
         * @method
         * @memberof Konva.Node.prototype
         * @param {Object} config
         * @param {String} [config.mimeType] can be "image/png" or "image/jpeg".
         *  "image/png" is the default
         * @param {Number} [config.x] x position of canvas section
         * @param {Number} [config.y] y position of canvas section
         * @param {Number} [config.width] width of canvas section
         * @param {Number} [config.height] height of canvas section
         * @param {Number} [config.quality] jpeg quality.  If using an "image/jpeg" mimeType,
         *  you can specify the quality from 0 to 1, where 0 is very poor quality and 1
         *  is very high quality
         * @paremt {Number} [config.pixelRatio] pixelRatio of ouput image url. Default is 1
         * @returns {String}
         */
    toDataURL: function(config) {
      config = config || {};
      var mimeType = config.mimeType || null,
        quality = config.quality || null;
      return this._toKonvaCanvas(config).toDataURL(mimeType, quality);
    },
    /**
         * converts node into an image.  Since the toImage
         *  method is asynchronous, a callback is required.  toImage is most commonly used
         *  to cache complex drawings as an image so that they don't have to constantly be redrawn
         * @method
         * @memberof Konva.Node.prototype
         * @param {Object} config
         * @param {Function} config.callback function executed when the composite has completed
         * @param {String} [config.mimeType] can be "image/png" or "image/jpeg".
         *  "image/png" is the default
         * @param {Number} [config.x] x position of canvas section
         * @param {Number} [config.y] y position of canvas section
         * @param {Number} [config.width] width of canvas section
         * @param {Number} [config.height] height of canvas section
         * @param {Number} [config.quality] jpeg quality.  If using an "image/jpeg" mimeType,
         *  you can specify the quality from 0 to 1, where 0 is very poor quality and 1
         *  is very high quality
         * @paremt {Number} [config.pixelRatio] pixelRatio of ouput image.  Default is 1.
         * @example
         * var image = node.toImage({
         *   callback: function(img) {
         *     // do stuff with img
         *   }
         * });
         */
    toImage: function(config) {
      if (!config || !config.callback) {
        throw 'callback required for toImage method config argument';
      }
      Konva.Util._getImage(this.toDataURL(config), function(img) {
        config.callback(img);
      });
    },
    setSize: function(size) {
      this.setWidth(size.width);
      this.setHeight(size.height);
      return this;
    },
    getSize: function() {
      return {
        width: this.getWidth(),
        height: this.getHeight()
      };
    },
    getWidth: function() {
      return this.attrs.width || 0;
    },
    getHeight: function() {
      return this.attrs.height || 0;
    },
    /**
         * get class name, which may return Stage, Layer, Group, or shape class names like Rect, Circle, Text, etc.
         * @method
         * @memberof Konva.Node.prototype
         * @returns {String}
         */
    getClassName: function() {
      return this.className || this.nodeType;
    },
    /**
         * get the node type, which may return Stage, Layer, Group, or Node
         * @method
         * @memberof Konva.Node.prototype
         * @returns {String}
         */
    getType: function() {
      return this.nodeType;
    },
    getDragDistance: function() {
      // compare with undefined because we need to track 0 value
      if (this.attrs.dragDistance !== undefined) {
        return this.attrs.dragDistance;
      } else if (this.parent) {
        return this.parent.getDragDistance();
      } else {
        return Konva.dragDistance;
      }
    },
    _get: function(selector) {
      return this.className === selector || this.nodeType === selector
        ? [this]
        : [];
    },
    _off: function(type, name) {
      var evtListeners = this.eventListeners[type],
        i,
        evtName;

      for (i = 0; i < evtListeners.length; i++) {
        evtName = evtListeners[i].name;
        // the following two conditions must be true in order to remove a handler:
        // 1) the current event name cannot be konva unless the event name is konva
        //    this enables developers to force remove a konva specific listener for whatever reason
        // 2) an event name is not specified, or if one is specified, it matches the current event name
        if (
          (evtName !== 'konva' || name === 'konva') &&
          (!name || evtName === name)
        ) {
          evtListeners.splice(i, 1);
          if (evtListeners.length === 0) {
            delete this.eventListeners[type];
            break;
          }
          i--;
        }
      }
    },
    _fireChangeEvent: function(attr, oldVal, newVal) {
      this._fire(attr + CHANGE, {
        oldVal: oldVal,
        newVal: newVal
      });
    },
    setId: function(id) {
      var oldId = this.getId();

      Konva._removeId(oldId);
      Konva._addId(this, id);
      this._setAttr(ID, id);
      return this;
    },
    setName: function(name) {
      var oldNames = (this.getName() || '').split(/\s/g);
      var newNames = (name || '').split(/\s/g);
      var subname, i;
      // remove all subnames
      for (i = 0; i < oldNames.length; i++) {
        subname = oldNames[i];
        if (newNames.indexOf(subname) === -1 && subname) {
          Konva._removeName(subname, this._id);
        }
      }

      // add new names
      for (i = 0; i < newNames.length; i++) {
        subname = newNames[i];
        if (oldNames.indexOf(subname) === -1 && subname) {
          Konva._addName(this, subname);
        }
      }

      this._setAttr(NAME, name);
      return this;
    },
    // naming methods
    /**
         * add name to node
         * @method
         * @memberof Konva.Node.prototype
         * @param {String} name
         * @returns {Konva.Node}
         * @example
         * node.name('red');
         * node.addName('selected');
         * node.name(); // return 'red selected'
         */
    addName: function(name) {
      if (!this.hasName(name)) {
        var oldName = this.name();
        var newName = oldName ? oldName + ' ' + name : name;
        this.setName(newName);
      }
      return this;
    },
    /**
         * check is node has name
         * @method
         * @memberof Konva.Node.prototype
         * @param {String} name
         * @returns {Boolean}
         * @example
         * node.name('red');
         * node.hasName('red');   // return true
         * node.hasName('selected'); // return false
         */
    hasName: function(name) {
      var names = (this.name() || '').split(/\s/g);
      return names.indexOf(name) !== -1;
    },
    /**
         * remove name from node
         * @method
         * @memberof Konva.Node.prototype
         * @param {String} name
         * @returns {Konva.Node}
         * @example
         * node.name('red selected');
         * node.removeName('selected');
         * node.hasName('selected'); // return false
         * node.name(); // return 'red'
         */
    removeName: function(name) {
      var names = (this.name() || '').split(/\s/g);
      var index = names.indexOf(name);
      if (index !== -1) {
        names.splice(index, 1);
        this.setName(names.join(' '));
      }
      return this;
    },
    /**
         * set attr
         * @method
         * @memberof Konva.Node.prototype
         * @param {String} attr
         * @param {*} val
         * @returns {Konva.Node}
         * @example
         * node.setAttr('x', 5);
         */
    setAttr: function(attr, val) {
      var method = SET + Konva.Util._capitalize(attr),
        func = this[method];

      if (Konva.Util._isFunction(func)) {
        func.call(this, val);
      } else {
        // otherwise set directly
        this._setAttr(attr, val);
      }
      return this;
    },
    _setAttr: function(key, val) {
      var oldVal;
      oldVal = this.attrs[key];
      if (oldVal === val) {
        return;
      }
      if (val === undefined || val === null) {
        delete this.attrs[key];
      } else {
        this.attrs[key] = val;
      }
      this._fireChangeEvent(key, oldVal, val);
    },
    _setComponentAttr: function(key, component, val) {
      var oldVal;
      if (val !== undefined) {
        oldVal = this.attrs[key];

        if (!oldVal) {
          // set value to default value using getAttr
          this.attrs[key] = this.getAttr(key);
        }

        this.attrs[key][component] = val;
        this._fireChangeEvent(key, oldVal, val);
      }
    },
    _fireAndBubble: function(eventType, evt, compareShape) {
      var okayToRun = true;

      if (evt && this.nodeType === SHAPE) {
        evt.target = this;
      }

      if (
        eventType === MOUSEENTER &&
        compareShape &&
        (this._id === compareShape._id ||
          (this.isAncestorOf && this.isAncestorOf(compareShape)))
      ) {
        okayToRun = false;
      } else if (
        eventType === MOUSELEAVE &&
        compareShape &&
        (this._id === compareShape._id ||
          (this.isAncestorOf && this.isAncestorOf(compareShape)))
      ) {
        okayToRun = false;
      }
      if (okayToRun) {
        this._fire(eventType, evt);

        // simulate event bubbling
        var stopBubble =
          (eventType === MOUSEENTER || eventType === MOUSELEAVE) &&
          (compareShape &&
            compareShape.isAncestorOf &&
            compareShape.isAncestorOf(this) &&
            !compareShape.isAncestorOf(this.parent));
        if (
          ((evt && !evt.cancelBubble) || !evt) &&
          this.parent &&
          this.parent.isListening() &&
          !stopBubble
        ) {
          if (compareShape && compareShape.parent) {
            this._fireAndBubble.call(
              this.parent,
              eventType,
              evt,
              compareShape.parent
            );
          } else {
            this._fireAndBubble.call(this.parent, eventType, evt);
          }
        }
      }
    },
    _fire: function(eventType, evt) {
      var events = this.eventListeners[eventType],
        i;

      evt = evt || {};
      evt.currentTarget = this;
      evt.type = eventType;

      if (events) {
        for (i = 0; i < events.length; i++) {
          events[i].handler.call(this, evt);
        }
      }
    },
    /**
         * draw both scene and hit graphs.  If the node being drawn is the stage, all of the layers will be cleared and redrawn
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Konva.Node}
         */
    draw: function() {
      this.drawScene();
      this.drawHit();
      return this;
    }
  });

  /**
     * create node with JSON string or an Object.  De-serializtion does not generate custom
     *  shape drawing functions, images, or event handlers (this would make the
     *  serialized object huge).  If your app uses custom shapes, images, and
     *  event handlers (it probably does), then you need to select the appropriate
     *  shapes after loading the stage and set these properties via on(), setDrawFunc(),
     *  and setImage() methods
     * @method
     * @memberof Konva.Node
     * @param {String|Object} json string or object
     * @param {Element} [container] optional container dom element used only if you're
     *  creating a stage node
     */
  Konva.Node.create = function(data, container) {
    if (Konva.Util._isString(data)) {
      data = JSON.parse(data);
    }
    return this._createNode(data, container);
  };
  Konva.Node._createNode = function(obj, container) {
    var className = Konva.Node.prototype.getClassName.call(obj),
      children = obj.children,
      no,
      len,
      n;

    // if container was passed in, add it to attrs
    if (container) {
      obj.attrs.container = container;
    }

    no = new Konva[className](obj.attrs);
    if (children) {
      len = children.length;
      for (n = 0; n < len; n++) {
        no.add(this._createNode(children[n]));
      }
    }

    return no;
  };

  // =========================== add getters setters ===========================

  Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'position');
  /**
     * get/set node position relative to parent
     * @name position
     * @method
     * @memberof Konva.Node.prototype
     * @param {Object} pos
     * @param {Number} pos.x
     * @param {Number} pos.y
     * @returns {Object}
     * @example
     * // get position
     * var position = node.position();
     *
     * // set position
     * node.position({
     *   x: 5
     *   y: 10
     * });
     */

  Konva.Factory.addGetterSetter(Konva.Node, 'x', 0);

  /**
     * get/set x position
     * @name x
     * @method
     * @memberof Konva.Node.prototype
     * @param {Number} x
     * @returns {Object}
     * @example
     * // get x
     * var x = node.x();
     *
     * // set x
     * node.x(5);
     */

  Konva.Factory.addGetterSetter(Konva.Node, 'y', 0);

  /**
     * get/set y position
     * @name y
     * @method
     * @memberof Konva.Node.prototype
     * @param {Number} y
     * @returns {Integer}
     * @example
     * // get y
     * var y = node.y();
     *
     * // set y
     * node.y(5);
     */

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'globalCompositeOperation',
    'source-over'
  );

  /**
     * get/set globalCompositeOperation of a shape
     * @name globalCompositeOperation
     * @method
     * @memberof Konva.Node.prototype
     * @param {Number} blur
     * @returns {Number}
     * @example
     * // get shadow blur
     * var globalCompositeOperation = shape.globalCompositeOperation();
     *
     * // set shadow blur
     * shape.globalCompositeOperation('source-in');
     */
  Konva.Factory.addGetterSetter(Konva.Node, 'opacity', 1);

  /**
     * get/set opacity.  Opacity values range from 0 to 1.
     *  A node with an opacity of 0 is fully transparent, and a node
     *  with an opacity of 1 is fully opaque
     * @name opacity
     * @method
     * @memberof Konva.Node.prototype
     * @param {Object} opacity
     * @returns {Number}
     * @example
     * // get opacity
     * var opacity = node.opacity();
     *
     * // set opacity
     * node.opacity(0.5);
     */

  Konva.Factory.addGetter(Konva.Node, 'name');
  Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'name');

  /**
     * get/set name
     * @name name
     * @method
     * @memberof Konva.Node.prototype
     * @param {String} name
     * @returns {String}
     * @example
     * // get name
     * var name = node.name();
     *
     * // set name
     * node.name('foo');
     *
     * // also node may have multiple names (as css classes)
     * node.name('foo bar');
     */

  Konva.Factory.addGetter(Konva.Node, 'id');
  Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'id');

  /**
     * get/set id. Id is global for whole page.
     * @name id
     * @method
     * @memberof Konva.Node.prototype
     * @param {String} id
     * @returns {String}
     * @example
     * // get id
     * var name = node.id();
     *
     * // set id
     * node.id('foo');
     */

  Konva.Factory.addGetterSetter(Konva.Node, 'rotation', 0);

  /**
     * get/set rotation in degrees
     * @name rotation
     * @method
     * @memberof Konva.Node.prototype
     * @param {Number} rotation
     * @returns {Number}
     * @example
     * // get rotation in degrees
     * var rotation = node.rotation();
     *
     * // set rotation in degrees
     * node.rotation(45);
     */

  Konva.Factory.addComponentsGetterSetter(Konva.Node, 'scale', ['x', 'y']);

  /**
     * get/set scale
     * @name scale
     * @param {Object} scale
     * @param {Number} scale.x
     * @param {Number} scale.y
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Object}
     * @example
     * // get scale
     * var scale = node.scale();
     *
     * // set scale
     * shape.scale({
     *   x: 2
     *   y: 3
     * });
     */

  Konva.Factory.addGetterSetter(Konva.Node, 'scaleX', 1);

  /**
     * get/set scale x
     * @name scaleX
     * @param {Number} x
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Number}
     * @example
     * // get scale x
     * var scaleX = node.scaleX();
     *
     * // set scale x
     * node.scaleX(2);
     */

  Konva.Factory.addGetterSetter(Konva.Node, 'scaleY', 1);

  /**
     * get/set scale y
     * @name scaleY
     * @param {Number} y
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Number}
     * @example
     * // get scale y
     * var scaleY = node.scaleY();
     *
     * // set scale y
     * node.scaleY(2);
     */

  Konva.Factory.addComponentsGetterSetter(Konva.Node, 'skew', ['x', 'y']);

  /**
     * get/set skew
     * @name skew
     * @param {Object} skew
     * @param {Number} skew.x
     * @param {Number} skew.y
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Object}
     * @example
     * // get skew
     * var skew = node.skew();
     *
     * // set skew
     * node.skew({
     *   x: 20
     *   y: 10
     * });
     */

  Konva.Factory.addGetterSetter(Konva.Node, 'skewX', 0);

  /**
     * get/set skew x
     * @name skewX
     * @param {Number} x
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Number}
     * @example
     * // get skew x
     * var skewX = node.skewX();
     *
     * // set skew x
     * node.skewX(3);
     */

  Konva.Factory.addGetterSetter(Konva.Node, 'skewY', 0);

  /**
     * get/set skew y
     * @name skewY
     * @param {Number} y
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Number}
     * @example
     * // get skew y
     * var skewY = node.skewY();
     *
     * // set skew y
     * node.skewY(3);
     */

  Konva.Factory.addComponentsGetterSetter(Konva.Node, 'offset', ['x', 'y']);

  /**
     * get/set offset.  Offsets the default position and rotation point
     * @method
     * @memberof Konva.Node.prototype
     * @param {Object} offset
     * @param {Number} offset.x
     * @param {Number} offset.y
     * @returns {Object}
     * @example
     * // get offset
     * var offset = node.offset();
     *
     * // set offset
     * node.offset({
     *   x: 20
     *   y: 10
     * });
     */

  Konva.Factory.addGetterSetter(Konva.Node, 'offsetX', 0);

  /**
     * get/set offset x
     * @name offsetX
     * @method
     * @memberof Konva.Node.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get offset x
     * var offsetX = node.offsetX();
     *
     * // set offset x
     * node.offsetX(3);
     */

  Konva.Factory.addGetterSetter(Konva.Node, 'offsetY', 0);

  /**
     * get/set offset y
     * @name offsetY
     * @method
     * @memberof Konva.Node.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get offset y
     * var offsetY = node.offsetY();
     *
     * // set offset y
     * node.offsetY(3);
     */

  Konva.Factory.addSetter(Konva.Node, 'dragDistance');
  Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'dragDistance');

  /**
     * get/set drag distance
     * @name dragDistance
     * @method
     * @memberof Konva.Node.prototype
     * @param {Number} distance
     * @returns {Number}
     * @example
     * // get drag distance
     * var dragDistance = node.dragDistance();
     *
     * // set distance
     * // node starts dragging only if pointer moved more then 3 pixels
     * node.dragDistance(3);
     * // or set globally
     * Konva.dragDistance = 3;
     */

  Konva.Factory.addSetter(Konva.Node, 'width', 0);
  Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'width');
  /**
     * get/set width
     * @name width
     * @method
     * @memberof Konva.Node.prototype
     * @param {Number} width
     * @returns {Number}
     * @example
     * // get width
     * var width = node.width();
     *
     * // set width
     * node.width(100);
     */

  Konva.Factory.addSetter(Konva.Node, 'height', 0);
  Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'height');
  /**
     * get/set height
     * @name height
     * @method
     * @memberof Konva.Node.prototype
     * @param {Number} height
     * @returns {Number}
     * @example
     * // get height
     * var height = node.height();
     *
     * // set height
     * node.height(100);
     */

  Konva.Factory.addGetterSetter(Konva.Node, 'listening', 'inherit');
  /**
     * get/set listenig attr.  If you need to determine if a node is listening or not
     *   by taking into account its parents, use the isListening() method
     * @name listening
     * @method
     * @memberof Konva.Node.prototype
     * @param {Boolean|String} listening Can be "inherit", true, or false.  The default is "inherit".
     * @returns {Boolean|String}
     * @example
     * // get listening attr
     * var listening = node.listening();
     *
     * // stop listening for events
     * node.listening(false);
     *
     * // listen for events
     * node.listening(true);
     *
     * // listen to events according to the parent
     * node.listening('inherit');
     */

  /**
      * get/set preventDefault
      * By default all shapes will prevent default behaviour
      * of a browser on a pointer move or tap.
      * that will prevent native scrolling when you are trying to drag&drop a node
      * but sometimes you may need to enable default actions
      * in that case you can set the property to false
      * @name preventDefault
      * @method
      * @memberof Konva.Node.prototype
      * @param {Number} preventDefault
      * @returns {Number}
      * @example
      * // get preventDefault
      * var shouldPrevent = shape.preventDefault();
      *
      * // set preventDefault
      * shape.preventDefault(false);
      */

  Konva.Factory.addGetterSetter(Konva.Node, 'preventDefault', true);

  Konva.Factory.addGetterSetter(Konva.Node, 'filters', undefined, function(
    val
  ) {
    this._filterUpToDate = false;
    return val;
  });
  /**
     * get/set filters.  Filters are applied to cached canvases
     * @name filters
     * @method
     * @memberof Konva.Node.prototype
     * @param {Array} filters array of filters
     * @returns {Array}
     * @example
     * // get filters
     * var filters = node.filters();
     *
     * // set a single filter
     * node.cache();
     * node.filters([Konva.Filters.Blur]);
     *
     * // set multiple filters
     * node.cache();
     * node.filters([
     *   Konva.Filters.Blur,
     *   Konva.Filters.Sepia,
     *   Konva.Filters.Invert
     * ]);
     */

  Konva.Factory.addGetterSetter(Konva.Node, 'visible', 'inherit');
  /**
     * get/set visible attr.  Can be "inherit", true, or false.  The default is "inherit".
     *   If you need to determine if a node is visible or not
     *   by taking into account its parents, use the isVisible() method
     * @name visible
     * @method
     * @memberof Konva.Node.prototype
     * @param {Boolean|String} visible
     * @returns {Boolean|String}
     * @example
     * // get visible attr
     * var visible = node.visible();
     *
     * // make invisible
     * node.visible(false);
     *
     * // make visible
     * node.visible(true);
     *
     * // make visible according to the parent
     * node.visible('inherit');
     */

  Konva.Factory.addGetterSetter(Konva.Node, 'transformsEnabled', 'all');

  /**
     * get/set transforms that are enabled.  Can be "all", "none", or "position".  The default
     *  is "all"
     * @name transformsEnabled
     * @method
     * @memberof Konva.Node.prototype
     * @param {String} enabled
     * @returns {String}
     * @example
     * // enable position transform only to improve draw performance
     * node.transformsEnabled('position');
     *
     * // enable all transforms
     * node.transformsEnabled('all');
     */

  /**
     * get/set node size
     * @name size
     * @method
     * @memberof Konva.Node.prototype
     * @param {Object} size
     * @param {Number} size.width
     * @param {Number} size.height
     * @returns {Object}
     * @example
     * // get node size
     * var size = node.size();
     * var x = size.x;
     * var y = size.y;
     *
     * // set size
     * node.size({
     *   width: 100,
     *   height: 200
     * });
     */
  Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'size');

  Konva.Factory.backCompat(Konva.Node, {
    rotateDeg: 'rotate',
    setRotationDeg: 'setRotation',
    getRotationDeg: 'getRotation'
  });

  Konva.Collection.mapMethods(Konva.Node);
})(Konva);

(function() {
  'use strict';
  /**
    * Grayscale Filter
    * @function
    * @memberof Konva.Filters
    * @param {Object} imageData
    * @example
    * node.cache();
    * node.filters([Konva.Filters.Grayscale]);
    */
  Konva.Filters.Grayscale = function(imageData) {
    var data = imageData.data, len = data.length, i, brightness;

    for (i = 0; i < len; i += 4) {
      brightness = 0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2];
      // red
      data[i] = brightness;
      // green
      data[i + 1] = brightness;
      // blue
      data[i + 2] = brightness;
    }
  };
})();

(function(Konva) {
  'use strict';
  /**
     * Brighten Filter.
     * @function
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Brighten]);
     * node.brightness(0.8);
     */
  Konva.Filters.Brighten = function(imageData) {
    var brightness = this.brightness() * 255,
      data = imageData.data,
      len = data.length,
      i;

    for (i = 0; i < len; i += 4) {
      // red
      data[i] += brightness;
      // green
      data[i + 1] += brightness;
      // blue
      data[i + 2] += brightness;
    }
  };

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'brightness',
    0,
    null,
    Konva.Factory.afterSetFilter
  );
  /**
    * get/set filter brightness.  The brightness is a number between -1 and 1.&nbsp; Positive values
    *  brighten the pixels and negative values darken them. Use with {@link Konva.Filters.Brighten} filter.
    * @name brightness
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} brightness value between -1 and 1
    * @returns {Number}
    */
})(Konva);

(function() {
  'use strict';
  /**
    * Invert Filter
    * @function
    * @memberof Konva.Filters
    * @param {Object} imageData
    * @example
    * node.cache();
    * node.filters([Konva.Filters.Invert]);
    */
  Konva.Filters.Invert = function(imageData) {
    var data = imageData.data, len = data.length, i;

    for (i = 0; i < len; i += 4) {
      // red
      data[i] = 255 - data[i];
      // green
      data[i + 1] = 255 - data[i + 1];
      // blue
      data[i + 2] = 255 - data[i + 2];
    }
  };
})();

/*
 the Gauss filter
 master repo: https://github.com/pavelpower/kineticjsGaussFilter
*/
(function(Konva) {
  'use strict';
  /*

     StackBlur - a fast almost Gaussian Blur For Canvas

     Version:   0.5
     Author:    Mario Klingemann
     Contact:   mario@quasimondo.com
     Website:   http://www.quasimondo.com/StackBlurForCanvas
     Twitter:   @quasimondo

     In case you find this class useful - especially in commercial projects -
     I am not totally unhappy for a small donation to my PayPal account
     mario@quasimondo.de

     Or support me on flattr:
     https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript

     Copyright (c) 2010 Mario Klingemann

     Permission is hereby granted, free of charge, to any person
     obtaining a copy of this software and associated documentation
     files (the "Software"), to deal in the Software without
     restriction, including without limitation the rights to use,
     copy, modify, merge, publish, distribute, sublicense, and/or sell
     copies of the Software, and to permit persons to whom the
     Software is furnished to do so, subject to the following
     conditions:

     The above copyright notice and this permission notice shall be
     included in all copies or substantial portions of the Software.

     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
     OTHER DEALINGS IN THE SOFTWARE.
     */

  function BlurStack() {
    this.r = 0;
    this.g = 0;
    this.b = 0;
    this.a = 0;
    this.next = null;
  }

  var mul_table = [
    512,
    512,
    456,
    512,
    328,
    456,
    335,
    512,
    405,
    328,
    271,
    456,
    388,
    335,
    292,
    512,
    454,
    405,
    364,
    328,
    298,
    271,
    496,
    456,
    420,
    388,
    360,
    335,
    312,
    292,
    273,
    512,
    482,
    454,
    428,
    405,
    383,
    364,
    345,
    328,
    312,
    298,
    284,
    271,
    259,
    496,
    475,
    456,
    437,
    420,
    404,
    388,
    374,
    360,
    347,
    335,
    323,
    312,
    302,
    292,
    282,
    273,
    265,
    512,
    497,
    482,
    468,
    454,
    441,
    428,
    417,
    405,
    394,
    383,
    373,
    364,
    354,
    345,
    337,
    328,
    320,
    312,
    305,
    298,
    291,
    284,
    278,
    271,
    265,
    259,
    507,
    496,
    485,
    475,
    465,
    456,
    446,
    437,
    428,
    420,
    412,
    404,
    396,
    388,
    381,
    374,
    367,
    360,
    354,
    347,
    341,
    335,
    329,
    323,
    318,
    312,
    307,
    302,
    297,
    292,
    287,
    282,
    278,
    273,
    269,
    265,
    261,
    512,
    505,
    497,
    489,
    482,
    475,
    468,
    461,
    454,
    447,
    441,
    435,
    428,
    422,
    417,
    411,
    405,
    399,
    394,
    389,
    383,
    378,
    373,
    368,
    364,
    359,
    354,
    350,
    345,
    341,
    337,
    332,
    328,
    324,
    320,
    316,
    312,
    309,
    305,
    301,
    298,
    294,
    291,
    287,
    284,
    281,
    278,
    274,
    271,
    268,
    265,
    262,
    259,
    257,
    507,
    501,
    496,
    491,
    485,
    480,
    475,
    470,
    465,
    460,
    456,
    451,
    446,
    442,
    437,
    433,
    428,
    424,
    420,
    416,
    412,
    408,
    404,
    400,
    396,
    392,
    388,
    385,
    381,
    377,
    374,
    370,
    367,
    363,
    360,
    357,
    354,
    350,
    347,
    344,
    341,
    338,
    335,
    332,
    329,
    326,
    323,
    320,
    318,
    315,
    312,
    310,
    307,
    304,
    302,
    299,
    297,
    294,
    292,
    289,
    287,
    285,
    282,
    280,
    278,
    275,
    273,
    271,
    269,
    267,
    265,
    263,
    261,
    259
  ];

  var shg_table = [
    9,
    11,
    12,
    13,
    13,
    14,
    14,
    15,
    15,
    15,
    15,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24
  ];

  function filterGaussBlurRGBA(imageData, radius) {
    var pixels = imageData.data,
      width = imageData.width,
      height = imageData.height;

    var x,
      y,
      i,
      p,
      yp,
      yi,
      yw,
      r_sum,
      g_sum,
      b_sum,
      a_sum,
      r_out_sum,
      g_out_sum,
      b_out_sum,
      a_out_sum,
      r_in_sum,
      g_in_sum,
      b_in_sum,
      a_in_sum,
      pr,
      pg,
      pb,
      pa,
      rbs;

    var div = radius + radius + 1,
      widthMinus1 = width - 1,
      heightMinus1 = height - 1,
      radiusPlus1 = radius + 1,
      sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2,
      stackStart = new BlurStack(),
      stackEnd = null,
      stack = stackStart,
      stackIn = null,
      stackOut = null,
      mul_sum = mul_table[radius],
      shg_sum = shg_table[radius];

    for (i = 1; i < div; i++) {
      stack = stack.next = new BlurStack();
      if (i === radiusPlus1) {
        stackEnd = stack;
      }
    }

    stack.next = stackStart;

    yw = yi = 0;

    for (y = 0; y < height; y++) {
      r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;

      r_out_sum = radiusPlus1 * (pr = pixels[yi]);
      g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
      b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
      a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);

      r_sum += sumFactor * pr;
      g_sum += sumFactor * pg;
      b_sum += sumFactor * pb;
      a_sum += sumFactor * pa;

      stack = stackStart;

      for (i = 0; i < radiusPlus1; i++) {
        stack.r = pr;
        stack.g = pg;
        stack.b = pb;
        stack.a = pa;
        stack = stack.next;
      }

      for (i = 1; i < radiusPlus1; i++) {
        p = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2);
        r_sum += (stack.r = pr = pixels[p]) * (rbs = radiusPlus1 - i);
        g_sum += (stack.g = pg = pixels[p + 1]) * rbs;
        b_sum += (stack.b = pb = pixels[p + 2]) * rbs;
        a_sum += (stack.a = pa = pixels[p + 3]) * rbs;

        r_in_sum += pr;
        g_in_sum += pg;
        b_in_sum += pb;
        a_in_sum += pa;

        stack = stack.next;
      }

      stackIn = stackStart;
      stackOut = stackEnd;
      for (x = 0; x < width; x++) {
        pixels[yi + 3] = pa = (a_sum * mul_sum) >> shg_sum;
        if (pa !== 0) {
          pa = 255 / pa;
          pixels[yi] = ((r_sum * mul_sum) >> shg_sum) * pa;
          pixels[yi + 1] = ((g_sum * mul_sum) >> shg_sum) * pa;
          pixels[yi + 2] = ((b_sum * mul_sum) >> shg_sum) * pa;
        } else {
          pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
        }

        r_sum -= r_out_sum;
        g_sum -= g_out_sum;
        b_sum -= b_out_sum;
        a_sum -= a_out_sum;

        r_out_sum -= stackIn.r;
        g_out_sum -= stackIn.g;
        b_out_sum -= stackIn.b;
        a_out_sum -= stackIn.a;

        p = (yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1)) << 2;

        r_in_sum += stackIn.r = pixels[p];
        g_in_sum += stackIn.g = pixels[p + 1];
        b_in_sum += stackIn.b = pixels[p + 2];
        a_in_sum += stackIn.a = pixels[p + 3];

        r_sum += r_in_sum;
        g_sum += g_in_sum;
        b_sum += b_in_sum;
        a_sum += a_in_sum;

        stackIn = stackIn.next;

        r_out_sum += pr = stackOut.r;
        g_out_sum += pg = stackOut.g;
        b_out_sum += pb = stackOut.b;
        a_out_sum += pa = stackOut.a;

        r_in_sum -= pr;
        g_in_sum -= pg;
        b_in_sum -= pb;
        a_in_sum -= pa;

        stackOut = stackOut.next;

        yi += 4;
      }
      yw += width;
    }

    for (x = 0; x < width; x++) {
      g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;

      yi = x << 2;
      r_out_sum = radiusPlus1 * (pr = pixels[yi]);
      g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
      b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
      a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);

      r_sum += sumFactor * pr;
      g_sum += sumFactor * pg;
      b_sum += sumFactor * pb;
      a_sum += sumFactor * pa;

      stack = stackStart;

      for (i = 0; i < radiusPlus1; i++) {
        stack.r = pr;
        stack.g = pg;
        stack.b = pb;
        stack.a = pa;
        stack = stack.next;
      }

      yp = width;

      for (i = 1; i <= radius; i++) {
        yi = (yp + x) << 2;

        r_sum += (stack.r = pr = pixels[yi]) * (rbs = radiusPlus1 - i);
        g_sum += (stack.g = pg = pixels[yi + 1]) * rbs;
        b_sum += (stack.b = pb = pixels[yi + 2]) * rbs;
        a_sum += (stack.a = pa = pixels[yi + 3]) * rbs;

        r_in_sum += pr;
        g_in_sum += pg;
        b_in_sum += pb;
        a_in_sum += pa;

        stack = stack.next;

        if (i < heightMinus1) {
          yp += width;
        }
      }

      yi = x;
      stackIn = stackStart;
      stackOut = stackEnd;
      for (y = 0; y < height; y++) {
        p = yi << 2;
        pixels[p + 3] = pa = (a_sum * mul_sum) >> shg_sum;
        if (pa > 0) {
          pa = 255 / pa;
          pixels[p] = ((r_sum * mul_sum) >> shg_sum) * pa;
          pixels[p + 1] = ((g_sum * mul_sum) >> shg_sum) * pa;
          pixels[p + 2] = ((b_sum * mul_sum) >> shg_sum) * pa;
        } else {
          pixels[p] = pixels[p + 1] = pixels[p + 2] = 0;
        }

        r_sum -= r_out_sum;
        g_sum -= g_out_sum;
        b_sum -= b_out_sum;
        a_sum -= a_out_sum;

        r_out_sum -= stackIn.r;
        g_out_sum -= stackIn.g;
        b_out_sum -= stackIn.b;
        a_out_sum -= stackIn.a;

        p =
          (x +
            ((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) *
              width) <<
          2;

        r_sum += r_in_sum += stackIn.r = pixels[p];
        g_sum += g_in_sum += stackIn.g = pixels[p + 1];
        b_sum += b_in_sum += stackIn.b = pixels[p + 2];
        a_sum += a_in_sum += stackIn.a = pixels[p + 3];

        stackIn = stackIn.next;

        r_out_sum += pr = stackOut.r;
        g_out_sum += pg = stackOut.g;
        b_out_sum += pb = stackOut.b;
        a_out_sum += pa = stackOut.a;

        r_in_sum -= pr;
        g_in_sum -= pg;
        b_in_sum -= pb;
        a_in_sum -= pa;

        stackOut = stackOut.next;

        yi += width;
      }
    }
  }

  /**
     * Blur Filter
     * @function
     * @name Blur
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Blur]);
     * node.blurRadius(10);
     */
  Konva.Filters.Blur = function Blur(imageData) {
    var radius = Math.round(this.blurRadius());

    if (radius > 0) {
      filterGaussBlurRGBA(imageData, radius);
    }
  };

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'blurRadius',
    0,
    null,
    Konva.Factory.afterSetFilter
  );

  /**
    * get/set blur radius. Use with {@link Konva.Filters.Blur} filter
    * @name blurRadius
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} radius
    * @returns {Integer}
    */
})(Konva);

/*eslint-disable  max-depth */
(function() {
  'use strict';
  function pixelAt(idata, x, y) {
    var idx = (y * idata.width + x) * 4;
    var d = [];
    d.push(
      idata.data[idx++],
      idata.data[idx++],
      idata.data[idx++],
      idata.data[idx++]
    );
    return d;
  }

  function rgbDistance(p1, p2) {
    return Math.sqrt(
      Math.pow(p1[0] - p2[0], 2) +
        Math.pow(p1[1] - p2[1], 2) +
        Math.pow(p1[2] - p2[2], 2)
    );
  }

  function rgbMean(pTab) {
    var m = [0, 0, 0];

    for (var i = 0; i < pTab.length; i++) {
      m[0] += pTab[i][0];
      m[1] += pTab[i][1];
      m[2] += pTab[i][2];
    }

    m[0] /= pTab.length;
    m[1] /= pTab.length;
    m[2] /= pTab.length;

    return m;
  }

  function backgroundMask(idata, threshold) {
    var rgbv_no = pixelAt(idata, 0, 0);
    var rgbv_ne = pixelAt(idata, idata.width - 1, 0);
    var rgbv_so = pixelAt(idata, 0, idata.height - 1);
    var rgbv_se = pixelAt(idata, idata.width - 1, idata.height - 1);

    var thres = threshold || 10;
    if (
      rgbDistance(rgbv_no, rgbv_ne) < thres &&
      rgbDistance(rgbv_ne, rgbv_se) < thres &&
      rgbDistance(rgbv_se, rgbv_so) < thres &&
      rgbDistance(rgbv_so, rgbv_no) < thres
    ) {
      // Mean color
      var mean = rgbMean([rgbv_ne, rgbv_no, rgbv_se, rgbv_so]);

      // Mask based on color distance
      var mask = [];
      for (var i = 0; i < idata.width * idata.height; i++) {
        var d = rgbDistance(mean, [
          idata.data[i * 4],
          idata.data[i * 4 + 1],
          idata.data[i * 4 + 2]
        ]);
        mask[i] = d < thres ? 0 : 255;
      }

      return mask;
    }
  }

  function applyMask(idata, mask) {
    for (var i = 0; i < idata.width * idata.height; i++) {
      idata.data[4 * i + 3] = mask[i];
    }
  }

  function erodeMask(mask, sw, sh) {
    var weights = [1, 1, 1, 1, 0, 1, 1, 1, 1];
    var side = Math.round(Math.sqrt(weights.length));
    var halfSide = Math.floor(side / 2);

    var maskResult = [];
    for (var y = 0; y < sh; y++) {
      for (var x = 0; x < sw; x++) {
        var so = y * sw + x;
        var a = 0;
        for (var cy = 0; cy < side; cy++) {
          for (var cx = 0; cx < side; cx++) {
            var scy = y + cy - halfSide;
            var scx = x + cx - halfSide;

            if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
              var srcOff = scy * sw + scx;
              var wt = weights[cy * side + cx];

              a += mask[srcOff] * wt;
            }
          }
        }

        maskResult[so] = a === 255 * 8 ? 255 : 0;
      }
    }

    return maskResult;
  }

  function dilateMask(mask, sw, sh) {
    var weights = [1, 1, 1, 1, 1, 1, 1, 1, 1];
    var side = Math.round(Math.sqrt(weights.length));
    var halfSide = Math.floor(side / 2);

    var maskResult = [];
    for (var y = 0; y < sh; y++) {
      for (var x = 0; x < sw; x++) {
        var so = y * sw + x;
        var a = 0;
        for (var cy = 0; cy < side; cy++) {
          for (var cx = 0; cx < side; cx++) {
            var scy = y + cy - halfSide;
            var scx = x + cx - halfSide;

            if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
              var srcOff = scy * sw + scx;
              var wt = weights[cy * side + cx];

              a += mask[srcOff] * wt;
            }
          }
        }

        maskResult[so] = a >= 255 * 4 ? 255 : 0;
      }
    }

    return maskResult;
  }

  function smoothEdgeMask(mask, sw, sh) {
    var weights = [
      1 / 9,
      1 / 9,
      1 / 9,
      1 / 9,
      1 / 9,
      1 / 9,
      1 / 9,
      1 / 9,
      1 / 9
    ];
    var side = Math.round(Math.sqrt(weights.length));
    var halfSide = Math.floor(side / 2);

    var maskResult = [];
    for (var y = 0; y < sh; y++) {
      for (var x = 0; x < sw; x++) {
        var so = y * sw + x;
        var a = 0;
        for (var cy = 0; cy < side; cy++) {
          for (var cx = 0; cx < side; cx++) {
            var scy = y + cy - halfSide;
            var scx = x + cx - halfSide;

            if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
              var srcOff = scy * sw + scx;
              var wt = weights[cy * side + cx];

              a += mask[srcOff] * wt;
            }
          }
        }

        maskResult[so] = a;
      }
    }

    return maskResult;
  }

  /**
	 * Mask Filter
	 * @function
	 * @name Mask
	 * @memberof Konva.Filters
	 * @param {Object} imageData
	 * @example
     * node.cache();
     * node.filters([Konva.Filters.Mask]);
     * node.threshold(200);
	 */
  Konva.Filters.Mask = function(imageData) {
    // Detect pixels close to the background color
    var threshold = this.threshold(),
      mask = backgroundMask(imageData, threshold);
    if (mask) {
      // Erode
      mask = erodeMask(mask, imageData.width, imageData.height);

      // Dilate
      mask = dilateMask(mask, imageData.width, imageData.height);

      // Gradient
      mask = smoothEdgeMask(mask, imageData.width, imageData.height);

      // Apply mask
      applyMask(imageData, mask);

      // todo : Update hit region function according to mask
    }

    return imageData;
  };

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'threshold',
    0,
    null,
    Konva.Factory.afterSetFilter
  );
})();

(function() {
  'use strict';
  /**
     * RGB Filter
     * @function
     * @name RGB
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @author ippo615
     * @example
     * node.cache();
     * node.filters([Konva.Filters.RGB]);
     * node.blue(120);
     * node.green(200);
     */
  Konva.Filters.RGB = function(imageData) {
    var data = imageData.data,
      nPixels = data.length,
      red = this.red(),
      green = this.green(),
      blue = this.blue(),
      i,
      brightness;

    for (i = 0; i < nPixels; i += 4) {
      brightness =
        (0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2]) / 255;
      data[i] = brightness * red; // r
      data[i + 1] = brightness * green; // g
      data[i + 2] = brightness * blue; // b
      data[i + 3] = data[i + 3]; // alpha
    }
  };

  Konva.Factory.addGetterSetter(Konva.Node, 'red', 0, function(val) {
    this._filterUpToDate = false;
    if (val > 255) {
      return 255;
    } else if (val < 0) {
      return 0;
    } else {
      return Math.round(val);
    }
  });
  /**
    * get/set filter red value. Use with {@link Konva.Filters.RGB} filter.
    * @name red
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} red value between 0 and 255
    * @returns {Integer}
    */

  Konva.Factory.addGetterSetter(Konva.Node, 'green', 0, function(val) {
    this._filterUpToDate = false;
    if (val > 255) {
      return 255;
    } else if (val < 0) {
      return 0;
    } else {
      return Math.round(val);
    }
  });
  /**
    * get/set filter green value. Use with {@link Konva.Filters.RGB} filter.
    * @name green
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} green value between 0 and 255
    * @returns {Integer}
    */

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'blue',
    0,
    Konva.Validators.RGBComponent,
    Konva.Factory.afterSetFilter
  );
  /**
    * get/set filter blue value. Use with {@link Konva.Filters.RGB} filter.
    * @name blue
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} blue value between 0 and 255
    * @returns {Integer}
    */
})();

(function() {
  'use strict';
  /**
     * RGBA Filter
     * @function
     * @name RGBA
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @author codefo
     * @example
     * node.cache();
     * node.filters([Konva.Filters.RGBA]);
     * node.blue(120);
     * node.green(200);
     * node.alpha(0.3);
     */
  Konva.Filters.RGBA = function(imageData) {
    var data = imageData.data,
      nPixels = data.length,
      red = this.red(),
      green = this.green(),
      blue = this.blue(),
      alpha = this.alpha(),
      i,
      ia;

    for (i = 0; i < nPixels; i += 4) {
      ia = 1 - alpha;

      data[i] = red * alpha + data[i] * ia; // r
      data[i + 1] = green * alpha + data[i + 1] * ia; // g
      data[i + 2] = blue * alpha + data[i + 2] * ia; // b
    }
  };

  Konva.Factory.addGetterSetter(Konva.Node, 'red', 0, function(val) {
    this._filterUpToDate = false;
    if (val > 255) {
      return 255;
    } else if (val < 0) {
      return 0;
    } else {
      return Math.round(val);
    }
  });
  /**
    * get/set filter red value. Use with {@link Konva.Filters.RGBA} filter.
    * @name red
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} red value between 0 and 255
    * @returns {Integer}
    */

  Konva.Factory.addGetterSetter(Konva.Node, 'green', 0, function(val) {
    this._filterUpToDate = false;
    if (val > 255) {
      return 255;
    } else if (val < 0) {
      return 0;
    } else {
      return Math.round(val);
    }
  });
  /**
    * get/set filter green value. Use with {@link Konva.Filters.RGBA} filter.
    * @name green
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} green value between 0 and 255
    * @returns {Integer}
    */

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'blue',
    0,
    Konva.Validators.RGBComponent,
    Konva.Factory.afterSetFilter
  );
  /**
    * get/set filter blue value. Use with {@link Konva.Filters.RGBA} filter.
    * @name blue
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} blue value between 0 and 255
    * @returns {Integer}
    */

  Konva.Factory.addGetterSetter(Konva.Node, 'alpha', 1, function(val) {
    this._filterUpToDate = false;
    if (val > 1) {
      return 1;
    } else if (val < 0) {
      return 0;
    } else {
      return val;
    }
  });
  /**
     * get/set filter alpha value. Use with {@link Konva.Filters.RGBA} filter.
     * @name alpha
     * @method
     * @memberof Konva.Node.prototype
     * @param {Float} alpha value between 0 and 1
     * @returns {Float}
     */
})();

(function() {
  'use strict';
  /**
    * HSV Filter. Adjusts the hue, saturation and value
    * @function
    * @name HSV
    * @memberof Konva.Filters
    * @param {Object} imageData
    * @author ippo615
    * @example
    * image.filters([Konva.Filters.HSV]);
    * image.value(200);
    */

  Konva.Filters.HSV = function(imageData) {
    var data = imageData.data,
      nPixels = data.length,
      v = Math.pow(2, this.value()),
      s = Math.pow(2, this.saturation()),
      h = Math.abs(this.hue() + 360) % 360,
      i;

    // Basis for the technique used:
    // http://beesbuzz.biz/code/hsv_color_transforms.php
    // V is the value multiplier (1 for none, 2 for double, 0.5 for half)
    // S is the saturation multiplier (1 for none, 2 for double, 0.5 for half)
    // H is the hue shift in degrees (0 to 360)
    // vsu = V*S*cos(H*PI/180);
    // vsw = V*S*sin(H*PI/180);
    //[ .299V+.701vsu+.168vsw    .587V-.587vsu+.330vsw    .114V-.114vsu-.497vsw ] [R]
    //[ .299V-.299vsu-.328vsw    .587V+.413vsu+.035vsw    .114V-.114vsu+.292vsw ]*[G]
    //[ .299V-.300vsu+1.25vsw    .587V-.588vsu-1.05vsw    .114V+.886vsu-.203vsw ] [B]

    // Precompute the values in the matrix:
    var vsu = v * s * Math.cos(h * Math.PI / 180),
      vsw = v * s * Math.sin(h * Math.PI / 180);
    // (result spot)(source spot)
    var rr = 0.299 * v + 0.701 * vsu + 0.167 * vsw,
      rg = 0.587 * v - 0.587 * vsu + 0.330 * vsw,
      rb = 0.114 * v - 0.114 * vsu - 0.497 * vsw;
    var gr = 0.299 * v - 0.299 * vsu - 0.328 * vsw,
      gg = 0.587 * v + 0.413 * vsu + 0.035 * vsw,
      gb = 0.114 * v - 0.114 * vsu + 0.293 * vsw;
    var br = 0.299 * v - 0.300 * vsu + 1.250 * vsw,
      bg = 0.587 * v - 0.586 * vsu - 1.050 * vsw,
      bb = 0.114 * v + 0.886 * vsu - 0.200 * vsw;

    var r, g, b, a;

    for (i = 0; i < nPixels; i += 4) {
      r = data[i + 0];
      g = data[i + 1];
      b = data[i + 2];
      a = data[i + 3];

      data[i + 0] = rr * r + rg * g + rb * b;
      data[i + 1] = gr * r + gg * g + gb * b;
      data[i + 2] = br * r + bg * g + bb * b;
      data[i + 3] = a; // alpha
    }
  };

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'hue',
    0,
    null,
    Konva.Factory.afterSetFilter
  );
  /**
    * get/set hsv hue in degrees. Use with {@link Konva.Filters.HSV} or {@link Konva.Filters.HSL} filter.
    * @name hue
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} hue value between 0 and 359
    * @returns {Number}
    */

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'saturation',
    0,
    null,
    Konva.Factory.afterSetFilter
  );
  /**
    * get/set hsv saturation. Use with {@link Konva.Filters.HSV} or {@link Konva.Filters.HSL} filter.
    * @name saturation
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} saturation 0 is no change, -1.0 halves the saturation, 1.0 doubles, etc..
    * @returns {Number}
    */

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'value',
    0,
    null,
    Konva.Factory.afterSetFilter
  );
  /**
    * get/set hsv value. Use with {@link Konva.Filters.HSV} filter.
    * @name value
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} value 0 is no change, -1.0 halves the value, 1.0 doubles, etc..
    * @returns {Number}
    */
})();

(function() {
  'use strict';
  Konva.Factory.addGetterSetter(
    Konva.Node,
    'hue',
    0,
    null,
    Konva.Factory.afterSetFilter
  );
  /**
    * get/set hsv hue in degrees. Use with {@link Konva.Filters.HSV} or {@link Konva.Filters.HSL} filter.
    * @name hue
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} hue value between 0 and 359
    * @returns {Number}
    */

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'saturation',
    0,
    null,
    Konva.Factory.afterSetFilter
  );
  /**
    * get/set hsv saturation. Use with {@link Konva.Filters.HSV} or {@link Konva.Filters.HSL} filter.
    * @name saturation
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} saturation 0 is no change, -1.0 halves the saturation, 1.0 doubles, etc..
    * @returns {Number}
    */

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'luminance',
    0,
    null,
    Konva.Factory.afterSetFilter
  );
  /**
    * get/set hsl luminance. Use with {@link Konva.Filters.HSL} filter.
    * @name value
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} value 0 is no change, -1.0 halves the value, 1.0 doubles, etc..
    * @returns {Number}
    */

  /**
    * HSL Filter. Adjusts the hue, saturation and luminance (or lightness)
    * @function
    * @memberof Konva.Filters
    * @param {Object} imageData
    * @author ippo615
    * @example
    * image.filters([Konva.Filters.HSL]);
    * image.luminance(200);
    */

  Konva.Filters.HSL = function(imageData) {
    var data = imageData.data,
      nPixels = data.length,
      v = 1,
      s = Math.pow(2, this.saturation()),
      h = Math.abs(this.hue() + 360) % 360,
      l = this.luminance() * 127,
      i;

    // Basis for the technique used:
    // http://beesbuzz.biz/code/hsv_color_transforms.php
    // V is the value multiplier (1 for none, 2 for double, 0.5 for half)
    // S is the saturation multiplier (1 for none, 2 for double, 0.5 for half)
    // H is the hue shift in degrees (0 to 360)
    // vsu = V*S*cos(H*PI/180);
    // vsw = V*S*sin(H*PI/180);
    //[ .299V+.701vsu+.168vsw    .587V-.587vsu+.330vsw    .114V-.114vsu-.497vsw ] [R]
    //[ .299V-.299vsu-.328vsw    .587V+.413vsu+.035vsw    .114V-.114vsu+.292vsw ]*[G]
    //[ .299V-.300vsu+1.25vsw    .587V-.588vsu-1.05vsw    .114V+.886vsu-.203vsw ] [B]

    // Precompute the values in the matrix:
    var vsu = v * s * Math.cos(h * Math.PI / 180),
      vsw = v * s * Math.sin(h * Math.PI / 180);
    // (result spot)(source spot)
    var rr = 0.299 * v + 0.701 * vsu + 0.167 * vsw,
      rg = 0.587 * v - 0.587 * vsu + 0.330 * vsw,
      rb = 0.114 * v - 0.114 * vsu - 0.497 * vsw;
    var gr = 0.299 * v - 0.299 * vsu - 0.328 * vsw,
      gg = 0.587 * v + 0.413 * vsu + 0.035 * vsw,
      gb = 0.114 * v - 0.114 * vsu + 0.293 * vsw;
    var br = 0.299 * v - 0.300 * vsu + 1.250 * vsw,
      bg = 0.587 * v - 0.586 * vsu - 1.050 * vsw,
      bb = 0.114 * v + 0.886 * vsu - 0.200 * vsw;

    var r, g, b, a;

    for (i = 0; i < nPixels; i += 4) {
      r = data[i + 0];
      g = data[i + 1];
      b = data[i + 2];
      a = data[i + 3];

      data[i + 0] = rr * r + rg * g + rb * b + l;
      data[i + 1] = gr * r + gg * g + gb * b + l;
      data[i + 2] = br * r + bg * g + bb * b + l;
      data[i + 3] = a; // alpha
    }
  };
})();

(function() {
  'use strict';
  /**
     * Emboss Filter.
     * Pixastic Lib - Emboss filter - v0.1.0
     * Copyright (c) 2008 Jacob Seidelin, jseidelin@nihilogic.dk, http://blog.nihilogic.dk/
     * License: [http://www.pixastic.com/lib/license.txt]
     * @function
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Emboss]);
     * node.embossStrength(0.8);
     * node.embossWhiteLevel(0.3);
     * node.embossDirection('right');
     * node.embossBlend(true);
     */
  Konva.Filters.Emboss = function(imageData) {
    // pixastic strength is between 0 and 10.  I want it between 0 and 1
    // pixastic greyLevel is between 0 and 255.  I want it between 0 and 1.  Also,
    // a max value of greyLevel yields a white emboss, and the min value yields a black
    // emboss.  Therefore, I changed greyLevel to whiteLevel
    var strength = this.embossStrength() * 10,
      greyLevel = this.embossWhiteLevel() * 255,
      direction = this.embossDirection(),
      blend = this.embossBlend(),
      dirY = 0,
      dirX = 0,
      data = imageData.data,
      w = imageData.width,
      h = imageData.height,
      w4 = w * 4,
      y = h;

    switch (direction) {
      case 'top-left':
        dirY = -1;
        dirX = -1;
        break;
      case 'top':
        dirY = -1;
        dirX = 0;
        break;
      case 'top-right':
        dirY = -1;
        dirX = 1;
        break;
      case 'right':
        dirY = 0;
        dirX = 1;
        break;
      case 'bottom-right':
        dirY = 1;
        dirX = 1;
        break;
      case 'bottom':
        dirY = 1;
        dirX = 0;
        break;
      case 'bottom-left':
        dirY = 1;
        dirX = -1;
        break;
      case 'left':
        dirY = 0;
        dirX = -1;
        break;
      default:
        Konva.Util.error('Unknown emboss direction: ' + direction);
    }

    do {
      var offsetY = (y - 1) * w4;

      var otherY = dirY;
      if (y + otherY < 1) {
        otherY = 0;
      }
      if (y + otherY > h) {
        otherY = 0;
      }

      var offsetYOther = (y - 1 + otherY) * w * 4;

      var x = w;
      do {
        var offset = offsetY + (x - 1) * 4;

        var otherX = dirX;
        if (x + otherX < 1) {
          otherX = 0;
        }
        if (x + otherX > w) {
          otherX = 0;
        }

        var offsetOther = offsetYOther + (x - 1 + otherX) * 4;

        var dR = data[offset] - data[offsetOther];
        var dG = data[offset + 1] - data[offsetOther + 1];
        var dB = data[offset + 2] - data[offsetOther + 2];

        var dif = dR;
        var absDif = dif > 0 ? dif : -dif;

        var absG = dG > 0 ? dG : -dG;
        var absB = dB > 0 ? dB : -dB;

        if (absG > absDif) {
          dif = dG;
        }
        if (absB > absDif) {
          dif = dB;
        }

        dif *= strength;

        if (blend) {
          var r = data[offset] + dif;
          var g = data[offset + 1] + dif;
          var b = data[offset + 2] + dif;

          data[offset] = r > 255 ? 255 : r < 0 ? 0 : r;
          data[offset + 1] = g > 255 ? 255 : g < 0 ? 0 : g;
          data[offset + 2] = b > 255 ? 255 : b < 0 ? 0 : b;
        } else {
          var grey = greyLevel - dif;
          if (grey < 0) {
            grey = 0;
          } else if (grey > 255) {
            grey = 255;
          }

          data[offset] = data[offset + 1] = data[offset + 2] = grey;
        }
      } while (--x);
    } while (--y);
  };

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'embossStrength',
    0.5,
    null,
    Konva.Factory.afterSetFilter
  );
  /**
    * get/set emboss strength. Use with {@link Konva.Filters.Emboss} filter.
    * @name embossStrength
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} level between 0 and 1.  Default is 0.5
    * @returns {Number}
    */

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'embossWhiteLevel',
    0.5,
    null,
    Konva.Factory.afterSetFilter
  );
  /**
    * get/set emboss white level. Use with {@link Konva.Filters.Emboss} filter.
    * @name embossWhiteLevel
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} embossWhiteLevel between 0 and 1.  Default is 0.5
    * @returns {Number}
    */

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'embossDirection',
    'top-left',
    null,
    Konva.Factory.afterSetFilter
  );
  /**
    * get/set emboss direction. Use with {@link Konva.Filters.Emboss} filter.
    * @name embossDirection
    * @method
    * @memberof Konva.Node.prototype
    * @param {String} embossDirection can be top-left, top, top-right, right, bottom-right, bottom, bottom-left or left
    *   The default is top-left
    * @returns {String}
    */

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'embossBlend',
    false,
    null,
    Konva.Factory.afterSetFilter
  );
  /**
    * get/set emboss blend. Use with {@link Konva.Filters.Emboss} filter.
    * @name embossBlend
    * @method
    * @memberof Konva.Node.prototype
    * @param {Boolean} embossBlend
    * @returns {Boolean}
    */
})();

(function() {
  'use strict';
  function remap(fromValue, fromMin, fromMax, toMin, toMax) {
    // Compute the range of the data
    var fromRange = fromMax - fromMin, toRange = toMax - toMin, toValue;

    // If either range is 0, then the value can only be mapped to 1 value
    if (fromRange === 0) {
      return toMin + toRange / 2;
    }
    if (toRange === 0) {
      return toMin;
    }

    // (1) untranslate, (2) unscale, (3) rescale, (4) retranslate
    toValue = (fromValue - fromMin) / fromRange;
    toValue = toRange * toValue + toMin;

    return toValue;
  }

  /**
    * Enhance Filter. Adjusts the colors so that they span the widest
    *  possible range (ie 0-255). Performs w*h pixel reads and w*h pixel
    *  writes.
    * @function
    * @name Enhance
    * @memberof Konva.Filters
    * @param {Object} imageData
    * @author ippo615
    * @example
    * node.cache();
    * node.filters([Konva.Filters.Enhance]);
    * node.enhance(0.4);
    */
  Konva.Filters.Enhance = function(imageData) {
    var data = imageData.data,
      nSubPixels = data.length,
      rMin = data[0],
      rMax = rMin,
      r,
      gMin = data[1],
      gMax = gMin,
      g,
      bMin = data[2],
      bMax = bMin,
      b,
      i;

    // If we are not enhancing anything - don't do any computation
    var enhanceAmount = this.enhance();
    if (enhanceAmount === 0) {
      return;
    }

    // 1st Pass - find the min and max for each channel:
    for (i = 0; i < nSubPixels; i += 4) {
      r = data[i + 0];
      if (r < rMin) {
        rMin = r;
      } else if (r > rMax) {
        rMax = r;
      }
      g = data[i + 1];
      if (g < gMin) {
        gMin = g;
      } else if (g > gMax) {
        gMax = g;
      }
      b = data[i + 2];
      if (b < bMin) {
        bMin = b;
      } else if (b > bMax) {
        bMax = b;
      }
      //a = data[i + 3];
      //if (a < aMin) { aMin = a; } else
      //if (a > aMax) { aMax = a; }
    }

    // If there is only 1 level - don't remap
    if (rMax === rMin) {
      rMax = 255;
      rMin = 0;
    }
    if (gMax === gMin) {
      gMax = 255;
      gMin = 0;
    }
    if (bMax === bMin) {
      bMax = 255;
      bMin = 0;
    }

    var rMid,
      rGoalMax,
      rGoalMin,
      gMid,
      gGoalMax,
      gGoalMin,
      bMid,
      bGoalMax,
      bGoalMin;

    // If the enhancement is positive - stretch the histogram
    if (enhanceAmount > 0) {
      rGoalMax = rMax + enhanceAmount * (255 - rMax);
      rGoalMin = rMin - enhanceAmount * (rMin - 0);
      gGoalMax = gMax + enhanceAmount * (255 - gMax);
      gGoalMin = gMin - enhanceAmount * (gMin - 0);
      bGoalMax = bMax + enhanceAmount * (255 - bMax);
      bGoalMin = bMin - enhanceAmount * (bMin - 0);
      // If the enhancement is negative -   compress the histogram
    } else {
      rMid = (rMax + rMin) * 0.5;
      rGoalMax = rMax + enhanceAmount * (rMax - rMid);
      rGoalMin = rMin + enhanceAmount * (rMin - rMid);
      gMid = (gMax + gMin) * 0.5;
      gGoalMax = gMax + enhanceAmount * (gMax - gMid);
      gGoalMin = gMin + enhanceAmount * (gMin - gMid);
      bMid = (bMax + bMin) * 0.5;
      bGoalMax = bMax + enhanceAmount * (bMax - bMid);
      bGoalMin = bMin + enhanceAmount * (bMin - bMid);
    }

    // Pass 2 - remap everything, except the alpha
    for (i = 0; i < nSubPixels; i += 4) {
      data[i + 0] = remap(data[i + 0], rMin, rMax, rGoalMin, rGoalMax);
      data[i + 1] = remap(data[i + 1], gMin, gMax, gGoalMin, gGoalMax);
      data[i + 2] = remap(data[i + 2], bMin, bMax, bGoalMin, bGoalMax);
      //data[i + 3] = remap(data[i + 3], aMin, aMax, aGoalMin, aGoalMax);
    }
  };

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'enhance',
    0,
    null,
    Konva.Factory.afterSetFilter
  );

  /**
    * get/set enhance. Use with {@link Konva.Filters.Enhance} filter.
    * @name enhance
    * @method
    * @memberof Konva.Node.prototype
    * @param {Float} amount
    * @returns {Float}
    */
})();

(function() {
  'use strict';
  /**
     * Posterize Filter. Adjusts the channels so that there are no more
     *  than n different values for that channel. This is also applied
     *  to the alpha channel.
     * @function
     * @name Posterize
     * @author ippo615
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Posterize]);
     * node.levels(0.8); // between 0 and 1
     */

  Konva.Filters.Posterize = function(imageData) {
    // level must be between 1 and 255
    var levels = Math.round(this.levels() * 254) + 1,
      data = imageData.data,
      len = data.length,
      scale = 255 / levels,
      i;

    for (i = 0; i < len; i += 1) {
      data[i] = Math.floor(data[i] / scale) * scale;
    }
  };

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'levels',
    0.5,
    null,
    Konva.Factory.afterSetFilter
  );

  /**
    * get/set levels.  Must be a number between 0 and 1.  Use with {@link Konva.Filters.Posterize} filter.
    * @name levels
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} level between 0 and 1
    * @returns {Number}
    */
})();

(function() {
  'use strict';
  /**
     * Noise Filter. Randomly adds or substracts to the color channels
     * @function
     * @name Noise
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @author ippo615
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Noise]);
     * node.noise(0.8);
     */
  Konva.Filters.Noise = function(imageData) {
    var amount = this.noise() * 255,
      data = imageData.data,
      nPixels = data.length,
      half = amount / 2,
      i;

    for (i = 0; i < nPixels; i += 4) {
      data[i + 0] += half - 2 * half * Math.random();
      data[i + 1] += half - 2 * half * Math.random();
      data[i + 2] += half - 2 * half * Math.random();
    }
  };

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'noise',
    0.2,
    null,
    Konva.Factory.afterSetFilter
  );
  /**
    * get/set noise amount.  Must be a value between 0 and 1. Use with {@link Konva.Filters.Noise} filter.
    * @name noise
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} noise
    * @returns {Number}
    */
})();

/*eslint-disable max-depth */
(function() {
  'use strict';
  /**
     * Pixelate Filter. Averages groups of pixels and redraws
     *  them as larger pixels
     * @function
     * @name Pixelate
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @author ippo615
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Pixelate]);
     * node.pixelSize(10);
     */

  Konva.Filters.Pixelate = function(imageData) {
    var pixelSize = Math.ceil(this.pixelSize()),
      width = imageData.width,
      height = imageData.height,
      x,
      y,
      i,
      //pixelsPerBin = pixelSize * pixelSize,
      red,
      green,
      blue,
      alpha,
      nBinsX = Math.ceil(width / pixelSize),
      nBinsY = Math.ceil(height / pixelSize),
      xBinStart,
      xBinEnd,
      yBinStart,
      yBinEnd,
      xBin,
      yBin,
      pixelsInBin;
    imageData = imageData.data;

    if (pixelSize <= 0) {
      Konva.Util.error('pixelSize value can not be <= 0');
      return;
    }

    for (xBin = 0; xBin < nBinsX; xBin += 1) {
      for (yBin = 0; yBin < nBinsY; yBin += 1) {
        // Initialize the color accumlators to 0
        red = 0;
        green = 0;
        blue = 0;
        alpha = 0;

        // Determine which pixels are included in this bin
        xBinStart = xBin * pixelSize;
        xBinEnd = xBinStart + pixelSize;
        yBinStart = yBin * pixelSize;
        yBinEnd = yBinStart + pixelSize;

        // Add all of the pixels to this bin!
        pixelsInBin = 0;
        for (x = xBinStart; x < xBinEnd; x += 1) {
          if (x >= width) {
            continue;
          }
          for (y = yBinStart; y < yBinEnd; y += 1) {
            if (y >= height) {
              continue;
            }
            i = (width * y + x) * 4;
            red += imageData[i + 0];
            green += imageData[i + 1];
            blue += imageData[i + 2];
            alpha += imageData[i + 3];
            pixelsInBin += 1;
          }
        }

        // Make sure the channels are between 0-255
        red = red / pixelsInBin;
        green = green / pixelsInBin;
        blue = blue / pixelsInBin;

        // Draw this bin
        for (x = xBinStart; x < xBinEnd; x += 1) {
          if (x >= width) {
            continue;
          }
          for (y = yBinStart; y < yBinEnd; y += 1) {
            if (y >= height) {
              continue;
            }
            i = (width * y + x) * 4;
            imageData[i + 0] = red;
            imageData[i + 1] = green;
            imageData[i + 2] = blue;
            imageData[i + 3] = alpha;
          }
        }
      }
    }
  };

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'pixelSize',
    8,
    null,
    Konva.Factory.afterSetFilter
  );
  /**
    * get/set pixel size. Use with {@link Konva.Filters.Pixelate} filter.
    * @name pixelSize
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} pixelSize
    * @returns {Integer}
    */
})();

(function() {
  'use strict';
  /**
     * Threshold Filter. Pushes any value above the mid point to
     *  the max and any value below the mid point to the min.
     *  This affects the alpha channel.
     * @function
     * @name Threshold
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @author ippo615
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Threshold]);
     * node.threshold(0.1);
     */

  Konva.Filters.Threshold = function(imageData) {
    var level = this.threshold() * 255,
      data = imageData.data,
      len = data.length,
      i;

    for (i = 0; i < len; i += 1) {
      data[i] = data[i] < level ? 0 : 255;
    }
  };

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'threshold',
    0.5,
    null,
    Konva.Factory.afterSetFilter
  );
  /**
    * get/set threshold.  Must be a value between 0 and 1. Use with {@link Konva.Filters.Threshold} or {@link Konva.Filters.Mask} filter.
    * @name threshold
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} threshold
    * @returns {Number}
    */
})();

(function() {
  'use strict';
  /**
     * Sepia Filter
     * Based on: Pixastic Lib - Sepia filter - v0.1.0
     * Copyright (c) 2008 Jacob Seidelin, jseidelin@nihilogic.dk, http://blog.nihilogic.dk/
     * @function
     * @name Sepia
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @author Jacob Seidelin <jseidelin@nihilogic.dk>
     * @license MPL v1.1 [http://www.pixastic.com/lib/license.txt]
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Sepia]);
     */
  Konva.Filters.Sepia = function(imageData) {
    var data = imageData.data,
      w = imageData.width,
      y = imageData.height,
      w4 = w * 4,
      offsetY,
      x,
      offset,
      or,
      og,
      ob,
      r,
      g,
      b;

    do {
      offsetY = (y - 1) * w4;
      x = w;
      do {
        offset = offsetY + (x - 1) * 4;

        or = data[offset];
        og = data[offset + 1];
        ob = data[offset + 2];

        r = or * 0.393 + og * 0.769 + ob * 0.189;
        g = or * 0.349 + og * 0.686 + ob * 0.168;
        b = or * 0.272 + og * 0.534 + ob * 0.131;

        data[offset] = r > 255 ? 255 : r;
        data[offset + 1] = g > 255 ? 255 : g;
        data[offset + 2] = b > 255 ? 255 : b;
        data[offset + 3] = data[offset + 3];
      } while (--x);
    } while (--y);
  };
})();

(function() {
  'use strict';
  /**
     * Solarize Filter
     * Pixastic Lib - Solarize filter - v0.1.0
     * Copyright (c) 2008 Jacob Seidelin, jseidelin@nihilogic.dk, http://blog.nihilogic.dk/
     * License: [http://www.pixastic.com/lib/license.txt]
     * @function
     * @name Solarize
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Solarize]);
     */
  Konva.Filters.Solarize = function(imageData) {
    var data = imageData.data,
      w = imageData.width,
      h = imageData.height,
      w4 = w * 4,
      y = h;

    do {
      var offsetY = (y - 1) * w4;
      var x = w;
      do {
        var offset = offsetY + (x - 1) * 4;
        var r = data[offset];
        var g = data[offset + 1];
        var b = data[offset + 2];

        if (r > 127) {
          r = 255 - r;
        }
        if (g > 127) {
          g = 255 - g;
        }
        if (b > 127) {
          b = 255 - b;
        }

        data[offset] = r;
        data[offset + 1] = g;
        data[offset + 2] = b;
      } while (--x);
    } while (--y);
  };
})();

(function() {
  'use strict';
  /*
   * ToPolar Filter. Converts image data to polar coordinates. Performs
   *  w*h*4 pixel reads and w*h pixel writes. The r axis is placed along
   *  what would be the y axis and the theta axis along the x axis.
   * @function
   * @author ippo615
   * @memberof Konva.Filters
   * @param {ImageData} src, the source image data (what will be transformed)
   * @param {ImageData} dst, the destination image data (where it will be saved)
   * @param {Object} opt
   * @param {Number} [opt.polarCenterX] horizontal location for the center of the circle,
   *  default is in the middle
   * @param {Number} [opt.polarCenterY] vertical location for the center of the circle,
   *  default is in the middle
   */

  var ToPolar = function(src, dst, opt) {
    var srcPixels = src.data,
      dstPixels = dst.data,
      xSize = src.width,
      ySize = src.height,
      xMid = opt.polarCenterX || xSize / 2,
      yMid = opt.polarCenterY || ySize / 2,
      i,
      x,
      y,
      r = 0,
      g = 0,
      b = 0,
      a = 0;

    // Find the largest radius
    var rad,
      rMax = Math.sqrt(xMid * xMid + yMid * yMid);
    x = xSize - xMid;
    y = ySize - yMid;
    rad = Math.sqrt(x * x + y * y);
    rMax = rad > rMax ? rad : rMax;

    // We'll be uisng y as the radius, and x as the angle (theta=t)
    var rSize = ySize,
      tSize = xSize,
      radius,
      theta;

    // We want to cover all angles (0-360) and we need to convert to
    // radians (*PI/180)
    var conversion = 360 / tSize * Math.PI / 180,
      sin,
      cos;

    // var x1, x2, x1i, x2i, y1, y2, y1i, y2i, scale;

    for (theta = 0; theta < tSize; theta += 1) {
      sin = Math.sin(theta * conversion);
      cos = Math.cos(theta * conversion);
      for (radius = 0; radius < rSize; radius += 1) {
        x = Math.floor(xMid + rMax * radius / rSize * cos);
        y = Math.floor(yMid + rMax * radius / rSize * sin);
        i = (y * xSize + x) * 4;
        r = srcPixels[i + 0];
        g = srcPixels[i + 1];
        b = srcPixels[i + 2];
        a = srcPixels[i + 3];

        // Store it
        //i = (theta * xSize  +  radius) * 4;
        i = (theta + radius * xSize) * 4;
        dstPixels[i + 0] = r;
        dstPixels[i + 1] = g;
        dstPixels[i + 2] = b;
        dstPixels[i + 3] = a;
      }
    }
  };

  /*
     * FromPolar Filter. Converts image data from polar coordinates back to rectangular.
     *  Performs w*h*4 pixel reads and w*h pixel writes.
     * @function
     * @author ippo615
     * @memberof Konva.Filters
     * @param {ImageData} src, the source image data (what will be transformed)
     * @param {ImageData} dst, the destination image data (where it will be saved)
     * @param {Object} opt
     * @param {Number} [opt.polarCenterX] horizontal location for the center of the circle,
     *  default is in the middle
     * @param {Number} [opt.polarCenterY] vertical location for the center of the circle,
     *  default is in the middle
     * @param {Number} [opt.polarRotation] amount to rotate the image counterclockwis,
     *  0 is no rotation, 360 degrees is a full rotation
     */

  var FromPolar = function(src, dst, opt) {
    var srcPixels = src.data,
      dstPixels = dst.data,
      xSize = src.width,
      ySize = src.height,
      xMid = opt.polarCenterX || xSize / 2,
      yMid = opt.polarCenterY || ySize / 2,
      i,
      x,
      y,
      dx,
      dy,
      r = 0,
      g = 0,
      b = 0,
      a = 0;

    // Find the largest radius
    var rad,
      rMax = Math.sqrt(xMid * xMid + yMid * yMid);
    x = xSize - xMid;
    y = ySize - yMid;
    rad = Math.sqrt(x * x + y * y);
    rMax = rad > rMax ? rad : rMax;

    // We'll be uisng x as the radius, and y as the angle (theta=t)
    var rSize = ySize,
      tSize = xSize,
      radius,
      theta,
      phaseShift = opt.polarRotation || 0;

    // We need to convert to degrees and we need to make sure
    // it's between (0-360)
    // var conversion = tSize/360*180/Math.PI;
    //var conversion = tSize/360*180/Math.PI;

    var x1, y1;

    for (x = 0; x < xSize; x += 1) {
      for (y = 0; y < ySize; y += 1) {
        dx = x - xMid;
        dy = y - yMid;
        radius = Math.sqrt(dx * dx + dy * dy) * rSize / rMax;
        theta = (Math.atan2(dy, dx) * 180 / Math.PI + 360 + phaseShift) % 360;
        theta = theta * tSize / 360;
        x1 = Math.floor(theta);
        y1 = Math.floor(radius);
        i = (y1 * xSize + x1) * 4;
        r = srcPixels[i + 0];
        g = srcPixels[i + 1];
        b = srcPixels[i + 2];
        a = srcPixels[i + 3];

        // Store it
        i = (y * xSize + x) * 4;
        dstPixels[i + 0] = r;
        dstPixels[i + 1] = g;
        dstPixels[i + 2] = b;
        dstPixels[i + 3] = a;
      }
    }
  };

  //Konva.Filters.ToPolar = Konva.Util._FilterWrapDoubleBuffer(ToPolar);
  //Konva.Filters.FromPolar = Konva.Util._FilterWrapDoubleBuffer(FromPolar);

  // create a temporary canvas for working - shared between multiple calls

  /*
     * Kaleidoscope Filter.
     * @function
     * @name Kaleidoscope
     * @author ippo615
     * @memberof Konva.Filters
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Kaleidoscope]);
     * node.kaleidoscopePower(3);
     * node.kaleidoscopeAngle(45);
     */
  Konva.Filters.Kaleidoscope = function(imageData) {
    var xSize = imageData.width,
      ySize = imageData.height;

    var x, y, xoff, i, r, g, b, a, srcPos, dstPos;
    var power = Math.round(this.kaleidoscopePower());
    var angle = Math.round(this.kaleidoscopeAngle());
    var offset = Math.floor(xSize * (angle % 360) / 360);

    if (power < 1) {
      return;
    }

    // Work with our shared buffer canvas
    var tempCanvas = Konva.Util.createCanvasElement();
    tempCanvas.width = xSize;
    tempCanvas.height = ySize;
    var scratchData = tempCanvas
      .getContext('2d')
      .getImageData(0, 0, xSize, ySize);

    // Convert thhe original to polar coordinates
    ToPolar(imageData, scratchData, {
      polarCenterX: xSize / 2,
      polarCenterY: ySize / 2
    });

    // Determine how big each section will be, if it's too small
    // make it bigger
    var minSectionSize = xSize / Math.pow(2, power);
    while (minSectionSize <= 8) {
      minSectionSize = minSectionSize * 2;
      power -= 1;
    }
    minSectionSize = Math.ceil(minSectionSize);
    var sectionSize = minSectionSize;

    // Copy the offset region to 0
    // Depending on the size of filter and location of the offset we may need
    // to copy the section backwards to prevent it from rewriting itself
    var xStart = 0,
      xEnd = sectionSize,
      xDelta = 1;
    if (offset + minSectionSize > xSize) {
      xStart = sectionSize;
      xEnd = 0;
      xDelta = -1;
    }
    for (y = 0; y < ySize; y += 1) {
      for (x = xStart; x !== xEnd; x += xDelta) {
        xoff = Math.round(x + offset) % xSize;
        srcPos = (xSize * y + xoff) * 4;
        r = scratchData.data[srcPos + 0];
        g = scratchData.data[srcPos + 1];
        b = scratchData.data[srcPos + 2];
        a = scratchData.data[srcPos + 3];
        dstPos = (xSize * y + x) * 4;
        scratchData.data[dstPos + 0] = r;
        scratchData.data[dstPos + 1] = g;
        scratchData.data[dstPos + 2] = b;
        scratchData.data[dstPos + 3] = a;
      }
    }

    // Perform the actual effect
    for (y = 0; y < ySize; y += 1) {
      sectionSize = Math.floor(minSectionSize);
      for (i = 0; i < power; i += 1) {
        for (x = 0; x < sectionSize + 1; x += 1) {
          srcPos = (xSize * y + x) * 4;
          r = scratchData.data[srcPos + 0];
          g = scratchData.data[srcPos + 1];
          b = scratchData.data[srcPos + 2];
          a = scratchData.data[srcPos + 3];
          dstPos = (xSize * y + sectionSize * 2 - x - 1) * 4;
          scratchData.data[dstPos + 0] = r;
          scratchData.data[dstPos + 1] = g;
          scratchData.data[dstPos + 2] = b;
          scratchData.data[dstPos + 3] = a;
        }
        sectionSize *= 2;
      }
    }

    // Convert back from polar coordinates
    FromPolar(scratchData, imageData, { polarRotation: 0 });
  };

  /**
    * get/set kaleidoscope power. Use with {@link Konva.Filters.Kaleidoscope} filter.
    * @name kaleidoscopePower
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} power of kaleidoscope
    * @returns {Integer}
    */
  Konva.Factory.addGetterSetter(
    Konva.Node,
    'kaleidoscopePower',
    2,
    null,
    Konva.Factory.afterSetFilter
  );

  /**
    * get/set kaleidoscope angle. Use with {@link Konva.Filters.Kaleidoscope} filter.
    * @name kaleidoscopeAngle
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} degrees
    * @returns {Integer}
    */
  Konva.Factory.addGetterSetter(
    Konva.Node,
    'kaleidoscopeAngle',
    0,
    null,
    Konva.Factory.afterSetFilter
  );
})();

(function() {
  'use strict';
  /**
     * Container constructor.&nbsp; Containers are used to contain nodes or other containers
     * @constructor
     * @memberof Konva
     * @augments Konva.Node
     * @abstract
     * @param {Object} config
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * * @param {Object} [config.clip] set clip
     * @param {Number} [config.clipX] set clip x
     * @param {Number} [config.clipY] set clip y
     * @param {Number} [config.clipWidth] set clip width
     * @param {Number} [config.clipHeight] set clip height
     * @param {Function} [config.clipFunc] set clip func

     */
  Konva.Container = function(config) {
    this.__init(config);
  };

  Konva.Util.addMethods(Konva.Container, {
    __init: function(config) {
      this.children = new Konva.Collection();
      Konva.Node.call(this, config);
    },
    /**
         * returns a {@link Konva.Collection} of direct descendant nodes
         * @method
         * @memberof Konva.Container.prototype
         * @param {Function} [filterFunc] filter function
         * @returns {Konva.Collection}
         * @example
         * // get all children
         * var children = layer.getChildren();
         *
         * // get only circles
         * var circles = layer.getChildren(function(node){
         *    return node.getClassName() === 'Circle';
         * });
         */
    getChildren: function(filterFunc) {
      if (!filterFunc) {
        return this.children;
      }

      var results = new Konva.Collection();
      this.children.each(function(child) {
        if (filterFunc(child)) {
          results.push(child);
        }
      });
      return results;
    },
    /**
         * determine if node has children
         * @method
         * @memberof Konva.Container.prototype
         * @returns {Boolean}
         */
    hasChildren: function() {
      return this.getChildren().length > 0;
    },
    /**
         * remove all children
         * @method
         * @memberof Konva.Container.prototype
         */
    removeChildren: function() {
      var children = Konva.Collection.toCollection(this.children);
      var child;
      for (var i = 0; i < children.length; i++) {
        child = children[i];
        // reset parent to prevent many _setChildrenIndices calls
        delete child.parent;
        child.index = 0;
        child.remove();
      }
      children = null;
      this.children = new Konva.Collection();
      return this;
    },
    /**
         * destroy all children
         * @method
         * @memberof Konva.Container.prototype
         */
    destroyChildren: function() {
      var children = Konva.Collection.toCollection(this.children);
      var child;
      for (var i = 0; i < children.length; i++) {
        child = children[i];
        // reset parent to prevent many _setChildrenIndices calls
        delete child.parent;
        child.index = 0;
        child.destroy();
      }
      children = null;
      this.children = new Konva.Collection();
      return this;
    },
    /**
         * Add node or nodes to container.
         * @method
         * @memberof Konva.Container.prototype
         * @param {...Konva.Node} child
         * @returns {Container}
         * @example
         * layer.add(shape1, shape2, shape3);
         */
    add: function(child) {
      if (arguments.length > 1) {
        for (var i = 0; i < arguments.length; i++) {
          this.add(arguments[i]);
        }
        return this;
      }
      if (child.getParent()) {
        child.moveTo(this);
        return this;
      }
      var children = this.children;
      this._validateAdd(child);
      child.index = children.length;
      child.parent = this;
      children.push(child);
      this._fire('add', {
        child: child
      });

      // if node under drag we need to update drag animation
      if (Konva.DD && child.isDragging()) {
        Konva.DD.anim.setLayers(child.getLayer());
      }

      // chainable
      return this;
    },
    destroy: function() {
      // destroy children
      if (this.hasChildren()) {
        this.destroyChildren();
      }
      // then destroy self
      Konva.Node.prototype.destroy.call(this);
      return this;
    },
    /**
         * return a {@link Konva.Collection} of nodes that match the selector.  Use '#' for id selections
         * and '.' for name selections.  You can also select by type or class name. Pass multiple selectors
         * separated by a space.
         * @method
         * @memberof Konva.Container.prototype
         * @param {String} selector
         * @returns {Collection}
         * @example
         * // select node with id foo
         * var node = stage.find('#foo');
         *
         * // select nodes with name bar inside layer
         * var nodes = layer.find('.bar');
         *
         * // select all groups inside layer
         * var nodes = layer.find('Group');
         *
         * // select all rectangles inside layer
         * var nodes = layer.find('Rect');
         *
         * // select node with an id of foo or a name of bar inside layer
         * var nodes = layer.find('#foo, .bar');
         */
    find: function(selector) {
      var retArr = [],
        selectorArr = selector.replace(/ /g, '').split(','),
        len = selectorArr.length,
        n,
        i,
        sel,
        arr,
        node,
        children,
        clen;

      for (n = 0; n < len; n++) {
        sel = selectorArr[n];
        if (!Konva.Util.isValidSelector(sel)) {
          Konva.Util.warn(
            'Selector "' +
              sel +
              '" is invalid. Allowed selectors examples are "#foo", ".bar" or "Group".'
          );
          Konva.Util.warn(
            'If you have a custom shape with such className, please change it to start with upper letter like "Triangle".'
          );
          Konva.Util.warn('Konva is awesome, right?');
        }
        // id selector
        if (sel.charAt(0) === '#') {
          node = this._getNodeById(sel.slice(1));
          if (node) {
            retArr.push(node);
          }
        } else if (sel.charAt(0) === '.') {
          // name selector
          arr = this._getNodesByName(sel.slice(1));
          retArr = retArr.concat(arr);
        } else {
          // unrecognized selector, pass to children
          children = this.getChildren();
          clen = children.length;
          for (i = 0; i < clen; i++) {
            retArr = retArr.concat(children[i]._get(sel));
          }
        }
      }

      return Konva.Collection.toCollection(retArr);
    },
    /**
         * return a first node from `find` method
         * @method
         * @memberof Konva.Container.prototype
         * @param {String} selector
         * @returns {Konva.Node}
         * @example
         * // select node with id foo
         * var node = stage.findOne('#foo');
         *
         * // select node with name bar inside layer
         * var nodes = layer.findOne('.bar');
         */
    findOne: function(selector) {
      return this.find(selector)[0];
    },
    _getNodeById: function(key) {
      var node = Konva.ids[key];

      if (node !== undefined && this.isAncestorOf(node)) {
        return node;
      }
      return null;
    },
    _getNodesByName: function(key) {
      var arr = Konva.names[key] || [];
      return this._getDescendants(arr);
    },
    _get: function(selector) {
      var retArr = Konva.Node.prototype._get.call(this, selector);
      var children = this.getChildren();
      var len = children.length;
      for (var n = 0; n < len; n++) {
        retArr = retArr.concat(children[n]._get(selector));
      }
      return retArr;
    },
    // extenders
    toObject: function() {
      var obj = Konva.Node.prototype.toObject.call(this);

      obj.children = [];

      var children = this.getChildren();
      var len = children.length;
      for (var n = 0; n < len; n++) {
        var child = children[n];
        obj.children.push(child.toObject());
      }

      return obj;
    },
    _getDescendants: function(arr) {
      var retArr = [];
      var len = arr.length;
      for (var n = 0; n < len; n++) {
        var node = arr[n];
        if (this.isAncestorOf(node)) {
          retArr.push(node);
        }
      }

      return retArr;
    },
    /**
         * determine if node is an ancestor
         * of descendant
         * @method
         * @memberof Konva.Container.prototype
         * @param {Konva.Node} node
         */
    isAncestorOf: function(node) {
      var parent = node.getParent();
      while (parent) {
        if (parent._id === this._id) {
          return true;
        }
        parent = parent.getParent();
      }

      return false;
    },
    clone: function(obj) {
      // call super method
      var node = Konva.Node.prototype.clone.call(this, obj);

      this.getChildren().each(function(no) {
        node.add(no.clone());
      });
      return node;
    },
    /**
         * get all shapes that intersect a point.  Note: because this method must clear a temporary
         * canvas and redraw every shape inside the container, it should only be used for special sitations
         * because it performs very poorly.  Please use the {@link Konva.Stage#getIntersection} method if at all possible
         * because it performs much better
         * @method
         * @memberof Konva.Container.prototype
         * @param {Object} pos
         * @param {Number} pos.x
         * @param {Number} pos.y
         * @returns {Array} array of shapes
         */
    getAllIntersections: function(pos) {
      var arr = [];

      this.find('Shape').each(function(shape) {
        if (shape.isVisible() && shape.intersects(pos)) {
          arr.push(shape);
        }
      });

      return arr;
    },
    _setChildrenIndices: function() {
      this.children.each(function(child, n) {
        child.index = n;
      });
    },
    drawScene: function(can, top, caching) {
      var layer = this.getLayer(),
        canvas = can || (layer && layer.getCanvas()),
        context = canvas && canvas.getContext(),
        cachedCanvas = this._cache.canvas,
        cachedSceneCanvas = cachedCanvas && cachedCanvas.scene;

      if (this.isVisible()) {
        if (!caching && cachedSceneCanvas) {
          context.save();
          layer._applyTransform(this, context, top);
          this._drawCachedSceneCanvas(context);
          context.restore();
        } else {
          this._drawChildren(canvas, 'drawScene', top, false, caching);
        }
      }
      return this;
    },
    drawHit: function(can, top, caching) {
      var layer = this.getLayer(),
        canvas = can || (layer && layer.hitCanvas),
        context = canvas && canvas.getContext(),
        cachedCanvas = this._cache.canvas,
        cachedHitCanvas = cachedCanvas && cachedCanvas.hit;

      if (this.shouldDrawHit(canvas)) {
        if (layer) {
          layer.clearHitCache();
        }
        if (!caching && cachedHitCanvas) {
          context.save();
          layer._applyTransform(this, context, top);
          this._drawCachedHitCanvas(context);
          context.restore();
        } else {
          this._drawChildren(canvas, 'drawHit', top);
        }
      }
      return this;
    },
    _drawChildren: function(canvas, drawMethod, top, caching, skipBuffer) {
      var layer = this.getLayer(),
        context = canvas && canvas.getContext(),
        clipWidth = this.getClipWidth(),
        clipHeight = this.getClipHeight(),
        clipFunc = this.getClipFunc(),
        hasClip = (clipWidth && clipHeight) || clipFunc,
        clipX,
        clipY;

      if (hasClip && layer) {
        context.save();
        var transform = this.getAbsoluteTransform(top);
        var m = transform.getMatrix();
        context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
        context.beginPath();
        if (clipFunc) {
          clipFunc.call(this, context, this);
        } else {
          clipX = this.getClipX();
          clipY = this.getClipY();
          context.rect(clipX, clipY, clipWidth, clipHeight);
        }
        context.clip();
        m = transform.copy().invert().getMatrix();
        context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
      }

      this.children.each(function(child) {
        child[drawMethod](canvas, top, caching, skipBuffer);
      });

      if (hasClip) {
        context.restore();
      }
    },
    shouldDrawHit: function(canvas) {
      var layer = this.getLayer();
      var dd = Konva.DD;
      var layerUnderDrag =
        dd &&
        Konva.isDragging() &&
        Konva.DD.anim.getLayers().indexOf(layer) !== -1;
      return (
        (canvas && canvas.isCache) ||
        (layer &&
          layer.hitGraphEnabled() &&
          this.isVisible() &&
          !layerUnderDrag)
      );
    },
    getClientRect: function(attrs) {
      attrs = attrs || {};
      var skipTransform = attrs.skipTransform;
      var relativeTo = attrs.relativeTo;

      var minX, minY, maxX, maxY;
      var selfRect = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      };
      var that = this;
      this.children.each(function(child) {
        // skip invisible children
        if (!child.isVisible()) {
          return;
        }
        var rect = child.getClientRect({ relativeTo: that });

        // skip invisible children (like empty groups)
        // or don't skip... hmmm...
        // if (rect.width === 0 && rect.height === 0) {
        //     return;
        // }

        if (minX === undefined) {
          // initial value for first child
          minX = rect.x;
          minY = rect.y;
          maxX = rect.x + rect.width;
          maxY = rect.y + rect.height;
        } else {
          minX = Math.min(minX, rect.x);
          minY = Math.min(minY, rect.y);
          maxX = Math.max(maxX, rect.x + rect.width);
          maxY = Math.max(maxY, rect.y + rect.height);
        }
      });

      if (this.children.length !== 0) {
        selfRect = {
          x: minX,
          y: minY,
          width: maxX - minX,
          height: maxY - minY
        };
      }

      if (!skipTransform) {
        return this._transformedRect(selfRect, relativeTo);
      }
      return selfRect;
    }
  });

  Konva.Util.extend(Konva.Container, Konva.Node);
  // deprecated methods
  Konva.Container.prototype.get = Konva.Container.prototype.find;

  // add getters setters
  Konva.Factory.addComponentsGetterSetter(Konva.Container, 'clip', [
    'x',
    'y',
    'width',
    'height'
  ]);
  /**
     * get/set clip
     * @method
     * @name clip
     * @memberof Konva.Container.prototype
     * @param {Object} clip
     * @param {Number} clip.x
     * @param {Number} clip.y
     * @param {Number} clip.width
     * @param {Number} clip.height
     * @returns {Object}
     * @example
     * // get clip
     * var clip = container.clip();
     *
     * // set clip
     * container.setClip({
     *   x: 20,
     *   y: 20,
     *   width: 20,
     *   height: 20
     * });
     */

  Konva.Factory.addGetterSetter(Konva.Container, 'clipX');
  /**
     * get/set clip x
     * @name clipX
     * @method
     * @memberof Konva.Container.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get clip x
     * var clipX = container.clipX();
     *
     * // set clip x
     * container.clipX(10);
     */

  Konva.Factory.addGetterSetter(Konva.Container, 'clipY');
  /**
     * get/set clip y
     * @name clipY
     * @method
     * @memberof Konva.Container.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get clip y
     * var clipY = container.clipY();
     *
     * // set clip y
     * container.clipY(10);
     */

  Konva.Factory.addGetterSetter(Konva.Container, 'clipWidth');
  /**
     * get/set clip width
     * @name clipWidth
     * @method
     * @memberof Konva.Container.prototype
     * @param {Number} width
     * @returns {Number}
     * @example
     * // get clip width
     * var clipWidth = container.clipWidth();
     *
     * // set clip width
     * container.clipWidth(100);
     */

  Konva.Factory.addGetterSetter(Konva.Container, 'clipHeight');
  /**
     * get/set clip height
     * @name clipHeight
     * @method
     * @memberof Konva.Container.prototype
     * @param {Number} height
     * @returns {Number}
     * @example
     * // get clip height
     * var clipHeight = container.clipHeight();
     *
     * // set clip height
     * container.clipHeight(100);
     */

  Konva.Factory.addGetterSetter(Konva.Container, 'clipFunc');
  /**
      * get/set clip function
      * @name clipFunc
      * @method
      * @memberof Konva.Container.prototype
      * @param {Function} function
      * @returns {Function}
      * @example
      * // get clip function
      * var clipFunction = container.clipFunc();
      *
      * // set clip height
      * container.clipFunc(function(ctx) {
      *   ctx.rect(0, 0, 100, 100);
      * });
      */

  Konva.Collection.mapMethods(Konva.Container);
})();

(function(Konva) {
  'use strict';
  var HAS_SHADOW = 'hasShadow';
  var SHADOW_RGBA = 'shadowRGBA';

  function _fillFunc(context) {
    context.fill();
  }
  function _strokeFunc(context) {
    context.stroke();
  }
  function _fillFuncHit(context) {
    context.fill();
  }
  function _strokeFuncHit(context) {
    context.stroke();
  }

  function _clearHasShadowCache() {
    this._clearCache(HAS_SHADOW);
  }

  function _clearGetShadowRGBACache() {
    this._clearCache(SHADOW_RGBA);
  }

  /**
     * Shape constructor.  Shapes are primitive objects such as rectangles,
     *  circles, text, lines, etc.
     * @constructor
     * @memberof Konva
     * @augments Konva.Node
     * @param {Object} config
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var customShape = new Konva.Shape({
         *   x: 5,
         *   y: 10,
         *   fill: 'red',
         *   // a Konva.Canvas renderer is passed into the drawFunc function
         *   drawFunc: function(context) {
         *     context.beginPath();
         *     context.moveTo(200, 50);
         *     context.lineTo(420, 80);
         *     context.quadraticCurveTo(300, 100, 260, 170);
         *     context.closePath();
         *     context.fillStrokeShape(this);
         *   }
         *});
     */
  Konva.Shape = function(config) {
    this.__init(config);
  };

  Konva.Util.addMethods(Konva.Shape, {
    __init: function(config) {
      this.nodeType = 'Shape';
      this._fillFunc = _fillFunc;
      this._strokeFunc = _strokeFunc;
      this._fillFuncHit = _fillFuncHit;
      this._strokeFuncHit = _strokeFuncHit;

      // set colorKey
      var shapes = Konva.shapes;
      var key;

      while (true) {
        key = Konva.Util.getRandomColor();
        if (key && !(key in shapes)) {
          break;
        }
      }

      this.colorKey = key;
      shapes[key] = this;

      // call super constructor
      Konva.Node.call(this, config);

      this.on(
        'shadowColorChange.konva shadowBlurChange.konva shadowOffsetChange.konva shadowOpacityChange.konva shadowEnabledChange.konva',
        _clearHasShadowCache
      );

      this.on(
        'shadowColorChange.konva shadowOpacityChange.konva shadowEnabledChange.konva',
        _clearGetShadowRGBACache
      );
    },
    hasChildren: function() {
      return false;
    },
    getChildren: function() {
      return [];
    },
    /**
         * get canvas context tied to the layer
         * @method
         * @memberof Konva.Shape.prototype
         * @returns {Konva.Context}
         */
    getContext: function() {
      return this.getLayer().getContext();
    },
    /**
         * get canvas renderer tied to the layer.  Note that this returns a canvas renderer, not a canvas element
         * @method
         * @memberof Konva.Shape.prototype
         * @returns {Konva.Canvas}
         */
    getCanvas: function() {
      return this.getLayer().getCanvas();
    },
    /**
         * returns whether or not a shadow will be rendered
         * @method
         * @memberof Konva.Shape.prototype
         * @returns {Boolean}
         */
    hasShadow: function() {
      return this._getCache(HAS_SHADOW, this._hasShadow);
    },
    _hasShadow: function() {
      return (
        this.getShadowEnabled() &&
        (this.getShadowOpacity() !== 0 &&
          !!(this.getShadowColor() ||
            this.getShadowBlur() ||
            this.getShadowOffsetX() ||
            this.getShadowOffsetY()))
      );
    },
    getShadowRGBA: function() {
      return this._getCache(SHADOW_RGBA, this._getShadowRGBA);
    },
    _getShadowRGBA: function() {
      if (this.hasShadow()) {
        var rgba = Konva.Util.colorToRGBA(this.shadowColor());
        return (
          'rgba(' +
          rgba.r +
          ',' +
          rgba.g +
          ',' +
          rgba.b +
          ',' +
          rgba.a * (this.getShadowOpacity() || 1) +
          ')'
        );
      }
    },
    /**
         * returns whether or not the shape will be filled
         * @method
         * @memberof Konva.Shape.prototype
         * @returns {Boolean}
         */
    hasFill: function() {
      return !!(this.getFill() ||
        this.getFillPatternImage() ||
        this.getFillLinearGradientColorStops() ||
        this.getFillRadialGradientColorStops());
    },
    /**
         * returns whether or not the shape will be stroked
         * @method
         * @memberof Konva.Shape.prototype
         * @returns {Boolean}
         */
    hasStroke: function() {
      return this.strokeEnabled() && !!this.stroke();
    },
    /**
         * determines if point is in the shape, regardless if other shapes are on top of it.  Note: because
         *  this method clears a temporary canvas and then redraws the shape, it performs very poorly if executed many times
         *  consecutively.  Please use the {@link Konva.Stage#getIntersection} method if at all possible
         *  because it performs much better
         * @method
         * @memberof Konva.Shape.prototype
         * @param {Object} point
         * @param {Number} point.x
         * @param {Number} point.y
         * @returns {Boolean}
         */
    intersects: function(point) {
      var stage = this.getStage(), bufferHitCanvas = stage.bufferHitCanvas, p;

      bufferHitCanvas.getContext().clear();
      this.drawHit(bufferHitCanvas);
      p = bufferHitCanvas.context.getImageData(
        Math.round(point.x),
        Math.round(point.y),
        1,
        1
      ).data;
      return p[3] > 0;
    },
    // extends Node.prototype.destroy
    destroy: function() {
      Konva.Node.prototype.destroy.call(this);
      delete Konva.shapes[this.colorKey];
      return this;
    },
    _useBufferCanvas: function(caching) {
      return (
        (!caching &&
          (this.perfectDrawEnabled() &&
            this.getAbsoluteOpacity() !== 1 &&
            this.hasFill() &&
            this.hasStroke() &&
            this.getStage())) ||
        (this.perfectDrawEnabled() &&
          this.hasShadow() &&
          this.getAbsoluteOpacity() !== 1 &&
          this.hasFill() &&
          this.hasStroke() &&
          this.getStage())
      );
    },
    /**
         * return self rectangle (x, y, width, height) of shape.
         * This method are not taken into account transformation and styles.
         * @method
         * @memberof Konva.Shape.prototype
         * @returns {Object} rect with {x, y, width, height} properties
         * @example
         *
         * rect.getSelfRect();  // return {x:0, y:0, width:rect.width(), height:rect.height()}
         * circle.getSelfRect();  // return {x: - circle.width() / 2, y: - circle.height() / 2, width:circle.width(), height:circle.height()}
         *
         */
    getSelfRect: function() {
      var size = this.getSize();
      return {
        x: this._centroid ? Math.round(-size.width / 2) : 0,
        y: this._centroid ? Math.round(-size.height / 2) : 0,
        width: size.width,
        height: size.height
      };
    },
    getClientRect: function(attrs) {
      attrs = attrs || {};
      var skipTransform = attrs.skipTransform;
      var relativeTo = attrs.relativeTo;

      var fillRect = this.getSelfRect();

      var strokeWidth = (this.hasStroke() && this.strokeWidth()) || 0;
      var fillAndStrokeWidth = fillRect.width + strokeWidth;
      var fillAndStrokeHeight = fillRect.height + strokeWidth;

      var shadowOffsetX = this.hasShadow() ? this.shadowOffsetX() : 0;
      var shadowOffsetY = this.hasShadow() ? this.shadowOffsetY() : 0;

      var preWidth = fillAndStrokeWidth + Math.abs(shadowOffsetX);
      var preHeight = fillAndStrokeHeight + Math.abs(shadowOffsetY);

      var blurRadius = (this.hasShadow() && this.shadowBlur()) || 0;

      var width = preWidth + blurRadius * 2;
      var height = preHeight + blurRadius * 2;

      // if stroke, for example = 3
      // we need to set x to 1.5, but after Math.round it will be 2
      // as we have additional offset we need to increase width and height by 1 pixel
      var roundingOffset = 0;
      if (Math.round(strokeWidth / 2) !== strokeWidth / 2) {
        roundingOffset = 1;
      }
      var rect = {
        width: width + roundingOffset,
        height: height + roundingOffset,
        x: -Math.round(strokeWidth / 2 + blurRadius) +
          Math.min(shadowOffsetX, 0) +
          fillRect.x,
        y: -Math.round(strokeWidth / 2 + blurRadius) +
          Math.min(shadowOffsetY, 0) +
          fillRect.y
      };
      if (!skipTransform) {
        return this._transformedRect(rect, relativeTo);
      }
      return rect;
    },
    drawScene: function(can, top, caching, skipBuffer) {
      var layer = this.getLayer(),
        canvas = can || layer.getCanvas(),
        context = canvas.getContext(),
        cachedCanvas = this._cache.canvas,
        drawFunc = this.sceneFunc(),
        hasShadow = this.hasShadow(),
        hasStroke = this.hasStroke(),
        stage,
        bufferCanvas,
        bufferContext;

      if (!this.isVisible()) {
        return this;
      }
      if (cachedCanvas) {
        context.save();
        layer._applyTransform(this, context, top);
        this._drawCachedSceneCanvas(context);
        context.restore();
        return this;
      }
      if (!drawFunc) {
        return this;
      }
      context.save();
      // if buffer canvas is needed
      if (this._useBufferCanvas(caching) && !skipBuffer) {
        stage = this.getStage();
        bufferCanvas = stage.bufferCanvas;
        bufferContext = bufferCanvas.getContext();
        bufferContext.clear();
        bufferContext.save();
        bufferContext._applyLineJoin(this);
        // layer might be undefined if we are using cache before adding to layer
        if (!caching) {
          if (layer) {
            layer._applyTransform(this, bufferContext, top);
          } else {
            var m = this.getAbsoluteTransform(top).getMatrix();
            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
          }
        }

        drawFunc.call(this, bufferContext);
        bufferContext.restore();

        var ratio = bufferCanvas.pixelRatio;
        if (hasShadow && !canvas.hitCanvas) {
          context.save();

          context._applyShadow(this);
          context._applyOpacity(this);
          context._applyGlobalCompositeOperation(this);
          context.drawImage(
            bufferCanvas._canvas,
            0,
            0,
            bufferCanvas.width / ratio,
            bufferCanvas.height / ratio
          );
          context.restore();
        } else {
          context._applyOpacity(this);
          context._applyGlobalCompositeOperation(this);
          context.drawImage(
            bufferCanvas._canvas,
            0,
            0,
            bufferCanvas.width / ratio,
            bufferCanvas.height / ratio
          );
        }
      } else {
        // if buffer canvas is not needed
        context._applyLineJoin(this);
        // layer might be undefined if we are using cache before adding to layer
        if (!caching) {
          if (layer) {
            layer._applyTransform(this, context, top);
          } else {
            var o = this.getAbsoluteTransform(top).getMatrix();
            context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);
          }
        }

        if (hasShadow && hasStroke && !canvas.hitCanvas) {
          context.save();
          // apply shadow
          if (!caching) {
            context._applyOpacity(this);
            context._applyGlobalCompositeOperation(this);
          }
          context._applyShadow(this);

          drawFunc.call(this, context);
          context.restore();
          // if shape has stroke we need to redraw shape
          // otherwise we will see a shadow under stroke (and over fill)
          // but I think this is unexpected behavior
          if (this.hasFill() && this.getShadowForStrokeEnabled()) {
            drawFunc.call(this, context);
          }
        } else if (hasShadow && !canvas.hitCanvas) {
          context.save();
          if (!caching) {
            context._applyOpacity(this);
            context._applyGlobalCompositeOperation(this);
          }
          context._applyShadow(this);
          drawFunc.call(this, context);
          context.restore();
        } else {
          if (!caching) {
            context._applyOpacity(this);
            context._applyGlobalCompositeOperation(this);
          }
          drawFunc.call(this, context);
        }
      }
      context.restore();
      return this;
    },
    drawHit: function(can, top, caching) {
      var layer = this.getLayer(),
        canvas = can || layer.hitCanvas,
        context = canvas.getContext(),
        drawFunc = this.hitFunc() || this.sceneFunc(),
        cachedCanvas = this._cache.canvas,
        cachedHitCanvas = cachedCanvas && cachedCanvas.hit;

      if (!this.shouldDrawHit(canvas)) {
        return this;
      }
      if (layer) {
        layer.clearHitCache();
      }
      if (cachedHitCanvas) {
        context.save();
        layer._applyTransform(this, context, top);
        this._drawCachedHitCanvas(context);
        context.restore();
        return this;
      }
      if (!drawFunc) {
        return this;
      }
      context.save();
      context._applyLineJoin(this);
      if (!caching) {
        if (layer) {
          layer._applyTransform(this, context, top);
        } else {
          var o = this.getAbsoluteTransform(top).getMatrix();
          context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);
        }
      }
      drawFunc.call(this, context);
      context.restore();
      return this;
    },
    /**
        * draw hit graph using the cached scene canvas
        * @method
        * @memberof Konva.Shape.prototype
        * @param {Integer} alphaThreshold alpha channel threshold that determines whether or not
        *  a pixel should be drawn onto the hit graph.  Must be a value between 0 and 255.
        *  The default is 0
        * @returns {Konva.Shape}
        * @example
        * shape.cache();
        * shape.drawHitFromCache();
        */
    drawHitFromCache: function(alphaThreshold) {
      var threshold = alphaThreshold || 0,
        cachedCanvas = this._cache.canvas,
        sceneCanvas = this._getCachedSceneCanvas(),
        hitCanvas = cachedCanvas.hit,
        hitContext = hitCanvas.getContext(),
        hitWidth = hitCanvas.getWidth(),
        hitHeight = hitCanvas.getHeight(),
        hitImageData,
        hitData,
        len,
        rgbColorKey,
        i,
        alpha;

      hitContext.clear();
      hitContext.drawImage(sceneCanvas._canvas, 0, 0, hitWidth, hitHeight);

      try {
        hitImageData = hitContext.getImageData(0, 0, hitWidth, hitHeight);
        hitData = hitImageData.data;
        len = hitData.length;
        rgbColorKey = Konva.Util._hexToRgb(this.colorKey);

        // replace non transparent pixels with color key
        for (i = 0; i < len; i += 4) {
          alpha = hitData[i + 3];
          if (alpha > threshold) {
            hitData[i] = rgbColorKey.r;
            hitData[i + 1] = rgbColorKey.g;
            hitData[i + 2] = rgbColorKey.b;
            hitData[i + 3] = 255;
          } else {
            hitData[i + 3] = 0;
          }
        }
        hitContext.putImageData(hitImageData, 0, 0);
      } catch (e) {
        Konva.Util.error(
          'Unable to draw hit graph from cached scene canvas. ' + e.message
        );
      }

      return this;
    }
  });
  Konva.Util.extend(Konva.Shape, Konva.Node);

  // add getters and setters
  Konva.Factory.addGetterSetter(Konva.Shape, 'stroke');

  /**
     * get/set stroke color
     * @name stroke
     * @method
     * @memberof Konva.Shape.prototype
     * @param {String} color
     * @returns {String}
     * @example
     * // get stroke color
     * var stroke = shape.stroke();
     *
     * // set stroke color with color string
     * shape.stroke('green');
     *
     * // set stroke color with hex
     * shape.stroke('#00ff00');
     *
     * // set stroke color with rgb
     * shape.stroke('rgb(0,255,0)');
     *
     * // set stroke color with rgba and make it 50% opaque
     * shape.stroke('rgba(0,255,0,0.5');
     */

  Konva.Factory.addDeprecatedGetterSetter(
    Konva.Shape,
    'strokeRed',
    0,
    Konva.Validators.RGBComponent
  );
  Konva.Factory.addDeprecatedGetterSetter(
    Konva.Shape,
    'strokeGreen',
    0,
    Konva.Validators.RGBComponent
  );
  Konva.Factory.addDeprecatedGetterSetter(
    Konva.Shape,
    'strokeBlue',
    0,
    Konva.Validators.RGBComponent
  );
  Konva.Factory.addDeprecatedGetterSetter(
    Konva.Shape,
    'strokeAlpha',
    1,
    Konva.Validators.alphaComponent
  );

  Konva.Factory.addGetterSetter(Konva.Shape, 'strokeWidth', 2);

  /**
     * get/set stroke width
     * @name strokeWidth
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} strokeWidth
     * @returns {Number}
     * @example
     * // get stroke width
     * var strokeWidth = shape.strokeWidth();
     *
     * // set stroke width
     * shape.strokeWidth();
     */

  Konva.Factory.addGetterSetter(Konva.Shape, 'strokeHitEnabled', true);

  /**
     * get/set strokeHitEnabled property. Useful for performance optimization.
     * You may set `shape.strokeHitEnabled(false)`. In this case stroke will be no draw on hit canvas, so hit area
     * of shape will be decreased (by lineWidth / 2). Remember that non closed line with `strokeHitEnabled = false`
     * will be not drawn on hit canvas, that is mean line will no trigger pointer events (like mouseover)
     * Default value is true
     * @name strokeHitEnabled
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Boolean} strokeHitEnabled
     * @returns {Boolean}
     * @example
     * // get strokeHitEnabled
     * var strokeHitEnabled = shape.strokeHitEnabled();
     *
     * // set strokeHitEnabled
     * shape.strokeHitEnabled();
     */

  Konva.Factory.addGetterSetter(Konva.Shape, 'perfectDrawEnabled', true);

  /**
     * get/set perfectDrawEnabled. If a shape has fill, stroke and opacity you may set `perfectDrawEnabled` to false to improve performance.
     * See http://konvajs.github.io/docs/performance/Disable_Perfect_Draw.html for more information.
     * Default value is true
     * @name perfectDrawEnabled
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Boolean} perfectDrawEnabled
     * @returns {Boolean}
     * @example
     * // get perfectDrawEnabled
     * var perfectDrawEnabled = shape.perfectDrawEnabled();
     *
     * // set perfectDrawEnabled
     * shape.perfectDrawEnabled();
     */

  Konva.Factory.addGetterSetter(Konva.Shape, 'shadowForStrokeEnabled', true);

  /**
     * get/set shadowForStrokeEnabled. Useful for performance optimization.
     * You may set `shape.shadowForStrokeEnabled(false)`. In this case stroke will be no draw shadow for stroke.
     * Remember if you set `shadowForStrokeEnabled = false` for non closed line - that line with have no shadow!.
     * Default value is true
     * @name shadowForStrokeEnabled
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Boolean} shadowForStrokeEnabled
     * @returns {Boolean}
     * @example
     * // get shadowForStrokeEnabled
     * var shadowForStrokeEnabled = shape.shadowForStrokeEnabled();
     *
     * // set shadowForStrokeEnabled
     * shape.shadowForStrokeEnabled();
     */

  Konva.Factory.addGetterSetter(Konva.Shape, 'lineJoin');

  /**
     * get/set line join.  Can be miter, round, or bevel.  The
     *  default is miter
     * @name lineJoin
     * @method
     * @memberof Konva.Shape.prototype
     * @param {String} lineJoin
     * @returns {String}
     * @example
     * // get line join
     * var lineJoin = shape.lineJoin();
     *
     * // set line join
     * shape.lineJoin('round');
     */

  Konva.Factory.addGetterSetter(Konva.Shape, 'lineCap');

  /**
     * get/set line cap.  Can be butt, round, or square
     * @name lineCap
     * @method
     * @memberof Konva.Shape.prototype
     * @param {String} lineCap
     * @returns {String}
     * @example
     * // get line cap
     * var lineCap = shape.lineCap();
     *
     * // set line cap
     * shape.lineCap('round');
     */

  Konva.Factory.addGetterSetter(Konva.Shape, 'sceneFunc');

  /**
     * get/set scene draw function
     * @name sceneFunc
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Function} drawFunc drawing function
     * @returns {Function}
     * @example
     * // get scene draw function
     * var sceneFunc = shape.sceneFunc();
     *
     * // set scene draw function
     * shape.sceneFunc(function(context) {
     *   context.beginPath();
     *   context.rect(0, 0, this.width(), this.height());
     *   context.closePath();
     *   context.fillStrokeShape(this);
     * });
     */

  Konva.Factory.addGetterSetter(Konva.Shape, 'hitFunc');

  /**
     * get/set hit draw function
     * @name hitFunc
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Function} drawFunc drawing function
     * @returns {Function}
     * @example
     * // get hit draw function
     * var hitFunc = shape.hitFunc();
     *
     * // set hit draw function
     * shape.hitFunc(function(context) {
     *   context.beginPath();
     *   context.rect(0, 0, this.width(), this.height());
     *   context.closePath();
     *   context.fillStrokeShape(this);
     * });
     */

  Konva.Factory.addGetterSetter(Konva.Shape, 'dash');

  /**
     * get/set dash array for stroke.
     * @name dash
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Array} dash
     * @returns {Array}
     * @example
     *  // apply dashed stroke that is 10px long and 5 pixels apart
     *  line.dash([10, 5]);
     *  // apply dashed stroke that is made up of alternating dashed
     *  // lines that are 10px long and 20px apart, and dots that have
     *  // a radius of 5px and are 20px apart
     *  line.dash([10, 20, 0.001, 20]);
     */

  Konva.Factory.addGetterSetter(Konva.Shape, 'dashOffset', 0);

  /**
     * get/set dash offset for stroke.
     * @name dash
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} dash offset
     * @returns {Number}
     * @example
     *  // apply dashed stroke that is 10px long and 5 pixels apart with an offset of 5px
     *  line.dash([10, 5]);
     *  line.dashOffset(5);
     */

  Konva.Factory.addGetterSetter(Konva.Shape, 'shadowColor');

  /**
     * get/set shadow color
     * @name shadowColor
     * @method
     * @memberof Konva.Shape.prototype
     * @param {String} color
     * @returns {String}
     * @example
     * // get shadow color
     * var shadow = shape.shadowColor();
     *
     * // set shadow color with color string
     * shape.shadowColor('green');
     *
     * // set shadow color with hex
     * shape.shadowColor('#00ff00');
     *
     * // set shadow color with rgb
     * shape.shadowColor('rgb(0,255,0)');
     *
     * // set shadow color with rgba and make it 50% opaque
     * shape.shadowColor('rgba(0,255,0,0.5');
     */

  Konva.Factory.addDeprecatedGetterSetter(
    Konva.Shape,
    'shadowRed',
    0,
    Konva.Validators.RGBComponent
  );
  Konva.Factory.addDeprecatedGetterSetter(
    Konva.Shape,
    'shadowGreen',
    0,
    Konva.Validators.RGBComponent
  );
  Konva.Factory.addDeprecatedGetterSetter(
    Konva.Shape,
    'shadowBlue',
    0,
    Konva.Validators.RGBComponent
  );
  Konva.Factory.addDeprecatedGetterSetter(
    Konva.Shape,
    'shadowAlpha',
    1,
    Konva.Validators.alphaComponent
  );

  Konva.Factory.addGetterSetter(Konva.Shape, 'shadowBlur');

  /**
     * get/set shadow blur
     * @name shadowBlur
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} blur
     * @returns {Number}
     * @example
     * // get shadow blur
     * var shadowBlur = shape.shadowBlur();
     *
     * // set shadow blur
     * shape.shadowBlur(10);
     */

  Konva.Factory.addGetterSetter(Konva.Shape, 'shadowOpacity');

  /**
     * get/set shadow opacity.  must be a value between 0 and 1
     * @name shadowOpacity
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} opacity
     * @returns {Number}
     * @example
     * // get shadow opacity
     * var shadowOpacity = shape.shadowOpacity();
     *
     * // set shadow opacity
     * shape.shadowOpacity(0.5);
     */

  Konva.Factory.addComponentsGetterSetter(Konva.Shape, 'shadowOffset', [
    'x',
    'y'
  ]);

  /**
     * get/set shadow offset
     * @name shadowOffset
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Object} offset
     * @param {Number} offset.x
     * @param {Number} offset.y
     * @returns {Object}
     * @example
     * // get shadow offset
     * var shadowOffset = shape.shadowOffset();
     *
     * // set shadow offset
     * shape.shadowOffset({
     *   x: 20
     *   y: 10
     * });
     */

  Konva.Factory.addGetterSetter(Konva.Shape, 'shadowOffsetX', 0);

  /**
     * get/set shadow offset x
     * @name shadowOffsetX
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get shadow offset x
     * var shadowOffsetX = shape.shadowOffsetX();
     *
     * // set shadow offset x
     * shape.shadowOffsetX(5);
     */

  Konva.Factory.addGetterSetter(Konva.Shape, 'shadowOffsetY', 0);

  /**
     * get/set shadow offset y
     * @name shadowOffsetY
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get shadow offset y
     * var shadowOffsetY = shape.shadowOffsetY();
     *
     * // set shadow offset y
     * shape.shadowOffsetY(5);
     */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternImage');

  /**
     * get/set fill pattern image
     * @name fillPatternImage
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Image} image object
     * @returns {Image}
     * @example
     * // get fill pattern image
     * var fillPatternImage = shape.fillPatternImage();
     *
     * // set fill pattern image
     * var imageObj = new Image();
     * imageObj.onload = function() {
     *   shape.fillPatternImage(imageObj);
     * };
     * imageObj.src = 'path/to/image/jpg';
     */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fill');

  /**
     * get/set fill color
     * @name fill
     * @method
     * @memberof Konva.Shape.prototype
     * @param {String} color
     * @returns {String}
     * @example
     * // get fill color
     * var fill = shape.fill();
     *
     * // set fill color with color string
     * shape.fill('green');
     *
     * // set fill color with hex
     * shape.fill('#00ff00');
     *
     * // set fill color with rgb
     * shape.fill('rgb(0,255,0)');
     *
     * // set fill color with rgba and make it 50% opaque
     * shape.fill('rgba(0,255,0,0.5');
     *
     * // shape without fill
     * shape.fill(null);
     */

  Konva.Factory.addDeprecatedGetterSetter(
    Konva.Shape,
    'fillRed',
    0,
    Konva.Validators.RGBComponent
  );
  Konva.Factory.addDeprecatedGetterSetter(
    Konva.Shape,
    'fillGreen',
    0,
    Konva.Validators.RGBComponent
  );
  Konva.Factory.addDeprecatedGetterSetter(
    Konva.Shape,
    'fillBlue',
    0,
    Konva.Validators.RGBComponent
  );
  Konva.Factory.addDeprecatedGetterSetter(
    Konva.Shape,
    'fillAlpha',
    1,
    Konva.Validators.alphaComponent
  );

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternX', 0);

  /**
     * get/set fill pattern x
     * @name fillPatternX
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get fill pattern x
     * var fillPatternX = shape.fillPatternX();
     * // set fill pattern x
     * shape.fillPatternX(20);
     */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternY', 0);

  /**
     * get/set fill pattern y
     * @name fillPatternY
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get fill pattern y
     * var fillPatternY = shape.fillPatternY();
     * // set fill pattern y
     * shape.fillPatternY(20);
     */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillLinearGradientColorStops');

  /**
     * get/set fill linear gradient color stops
     * @name fillLinearGradientColorStops
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Array} colorStops
     * @returns {Array} colorStops
     * @example
     * // get fill linear gradient color stops
     * var colorStops = shape.fillLinearGradientColorStops();
     *
     * // create a linear gradient that starts with red, changes to blue
     * // halfway through, and then changes to green
     * shape.fillLinearGradientColorStops(0, 'red', 0.5, 'blue', 1, 'green');
     */

  Konva.Factory.addGetterSetter(
    Konva.Shape,
    'fillRadialGradientStartRadius',
    0
  );

  /**
     * get/set fill radial gradient start radius
     * @name fillRadialGradientStartRadius
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} radius
     * @returns {Number}
     * @example
     * // get radial gradient start radius
     * var startRadius = shape.fillRadialGradientStartRadius();
     *
     * // set radial gradient start radius
     * shape.fillRadialGradientStartRadius(0);
     */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillRadialGradientEndRadius', 0);

  /**
     * get/set fill radial gradient end radius
     * @name fillRadialGradientEndRadius
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} radius
     * @returns {Number}
     * @example
     * // get radial gradient end radius
     * var endRadius = shape.fillRadialGradientEndRadius();
     *
     * // set radial gradient end radius
     * shape.fillRadialGradientEndRadius(100);
     */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillRadialGradientColorStops');

  /**
     * get/set fill radial gradient color stops
     * @name fillRadialGradientColorStops
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} colorStops
     * @returns {Array}
     * @example
     * // get fill radial gradient color stops
     * var colorStops = shape.fillRadialGradientColorStops();
     *
     * // create a radial gradient that starts with red, changes to blue
     * // halfway through, and then changes to green
     * shape.fillRadialGradientColorStops(0, 'red', 0.5, 'blue', 1, 'green');
     */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternRepeat', 'repeat');

  /**
     * get/set fill pattern repeat.  Can be 'repeat', 'repeat-x', 'repeat-y', or 'no-repeat'.  The default is 'repeat'
     * @name fillPatternRepeat
     * @method
     * @memberof Konva.Shape.prototype
     * @param {String} repeat
     * @returns {String}
     * @example
     * // get fill pattern repeat
     * var repeat = shape.fillPatternRepeat();
     *
     * // repeat pattern in x direction only
     * shape.fillPatternRepeat('repeat-x');
     *
     * // do not repeat the pattern
     * shape.fillPatternRepeat('no repeat');
     */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillEnabled', true);

  /**
     * get/set fill enabled flag
     * @name fillEnabled
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Boolean} enabled
     * @returns {Boolean}
     * @example
     * // get fill enabled flag
     * var fillEnabled = shape.fillEnabled();
     *
     * // disable fill
     * shape.fillEnabled(false);
     *
     * // enable fill
     * shape.fillEnabled(true);
     */

  Konva.Factory.addGetterSetter(Konva.Shape, 'strokeEnabled', true);

  /**
     * get/set stroke enabled flag
     * @name strokeEnabled
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Boolean} enabled
     * @returns {Boolean}
     * @example
     * // get stroke enabled flag
     * var strokeEnabled = shape.strokeEnabled();
     *
     * // disable stroke
     * shape.strokeEnabled(false);
     *
     * // enable stroke
     * shape.strokeEnabled(true);
     */

  Konva.Factory.addGetterSetter(Konva.Shape, 'shadowEnabled', true);

  /**
     * get/set shadow enabled flag
     * @name shadowEnabled
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Boolean} enabled
     * @returns {Boolean}
     * @example
     * // get shadow enabled flag
     * var shadowEnabled = shape.shadowEnabled();
     *
     * // disable shadow
     * shape.shadowEnabled(false);
     *
     * // enable shadow
     * shape.shadowEnabled(true);
     */

  Konva.Factory.addGetterSetter(Konva.Shape, 'dashEnabled', true);

  /**
     * get/set dash enabled flag
     * @name dashEnabled
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Boolean} enabled
     * @returns {Boolean}
     * @example
     * // get dash enabled flag
     * var dashEnabled = shape.dashEnabled();
     *
     * // disable dash
     * shape.dashEnabled(false);
     *
     * // enable dash
     * shape.dashEnabled(true);
     */

  Konva.Factory.addGetterSetter(Konva.Shape, 'strokeScaleEnabled', true);

  /**
     * get/set strokeScale enabled flag
     * @name strokeScaleEnabled
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Boolean} enabled
     * @returns {Boolean}
     * @example
     * // get stroke scale enabled flag
     * var strokeScaleEnabled = shape.strokeScaleEnabled();
     *
     * // disable stroke scale
     * shape.strokeScaleEnabled(false);
     *
     * // enable stroke scale
     * shape.strokeScaleEnabled(true);
     */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillPriority', 'color');

  /**
     * get/set fill priority.  can be color, pattern, linear-gradient, or radial-gradient.  The default is color.
     *   This is handy if you want to toggle between different fill types.
     * @name fillPriority
     * @method
     * @memberof Konva.Shape.prototype
     * @param {String} priority
     * @returns {String}
     * @example
     * // get fill priority
     * var fillPriority = shape.fillPriority();
     *
     * // set fill priority
     * shape.fillPriority('linear-gradient');
     */

  Konva.Factory.addComponentsGetterSetter(Konva.Shape, 'fillPatternOffset', [
    'x',
    'y'
  ]);

  /**
     * get/set fill pattern offset
     * @name fillPatternOffset
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Object} offset
     * @param {Number} offset.x
     * @param {Number} offset.y
     * @returns {Object}
     * @example
     * // get fill pattern offset
     * var patternOffset = shape.fillPatternOffset();
     *
     * // set fill pattern offset
     * shape.fillPatternOffset({
     *   x: 20
     *   y: 10
     * });
     */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternOffsetX', 0);
  /**
     * get/set fill pattern offset x
     * @name fillPatternOffsetX
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get fill pattern offset x
     * var patternOffsetX = shape.fillPatternOffsetX();
     *
     * // set fill pattern offset x
     * shape.fillPatternOffsetX(20);
     */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternOffsetY', 0);
  /**
     * get/set fill pattern offset y
     * @name fillPatternOffsetY
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get fill pattern offset y
     * var patternOffsetY = shape.fillPatternOffsetY();
     *
     * // set fill pattern offset y
     * shape.fillPatternOffsetY(10);
     */

  Konva.Factory.addComponentsGetterSetter(Konva.Shape, 'fillPatternScale', [
    'x',
    'y'
  ]);

  /**
     * get/set fill pattern scale
     * @name fillPatternScale
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Object} scale
     * @param {Number} scale.x
     * @param {Number} scale.y
     * @returns {Object}
     * @example
     * // get fill pattern scale
     * var patternScale = shape.fillPatternScale();
     *
     * // set fill pattern scale
     * shape.fillPatternScale({
     *   x: 2
     *   y: 2
     * });
     */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternScaleX', 1);
  /**
     * get/set fill pattern scale x
     * @name fillPatternScaleX
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get fill pattern scale x
     * var patternScaleX = shape.fillPatternScaleX();
     *
     * // set fill pattern scale x
     * shape.fillPatternScaleX(2);
     */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternScaleY', 1);
  /**
     * get/set fill pattern scale y
     * @name fillPatternScaleY
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get fill pattern scale y
     * var patternScaleY = shape.fillPatternScaleY();
     *
     * // set fill pattern scale y
     * shape.fillPatternScaleY(2);
     */

  Konva.Factory.addComponentsGetterSetter(
    Konva.Shape,
    'fillLinearGradientStartPoint',
    ['x', 'y']
  );

  /**
     * get/set fill linear gradient start point
     * @name fillLinearGradientStartPoint
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Object} startPoint
     * @param {Number} startPoint.x
     * @param {Number} startPoint.y
     * @returns {Object}
     * @example
     * // get fill linear gradient start point
     * var startPoint = shape.fillLinearGradientStartPoint();
     *
     * // set fill linear gradient start point
     * shape.fillLinearGradientStartPoint({
     *   x: 20
     *   y: 10
     * });
     */

  Konva.Factory.addGetterSetter(
    Konva.Shape,
    'fillLinearGradientStartPointX',
    0
  );
  /**
     * get/set fill linear gradient start point x
     * @name fillLinearGradientStartPointX
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get fill linear gradient start point x
     * var startPointX = shape.fillLinearGradientStartPointX();
     *
     * // set fill linear gradient start point x
     * shape.fillLinearGradientStartPointX(20);
     */

  Konva.Factory.addGetterSetter(
    Konva.Shape,
    'fillLinearGradientStartPointY',
    0
  );
  /**
     * get/set fill linear gradient start point y
     * @name fillLinearGradientStartPointY
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get fill linear gradient start point y
     * var startPointY = shape.fillLinearGradientStartPointY();
     *
     * // set fill linear gradient start point y
     * shape.fillLinearGradientStartPointY(20);
     */

  Konva.Factory.addComponentsGetterSetter(
    Konva.Shape,
    'fillLinearGradientEndPoint',
    ['x', 'y']
  );

  /**
     * get/set fill linear gradient end point
     * @name fillLinearGradientEndPoint
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Object} endPoint
     * @param {Number} endPoint.x
     * @param {Number} endPoint.y
     * @returns {Object}
     * @example
     * // get fill linear gradient end point
     * var endPoint = shape.fillLinearGradientEndPoint();
     *
     * // set fill linear gradient end point
     * shape.fillLinearGradientEndPoint({
     *   x: 20
     *   y: 10
     * });
     */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillLinearGradientEndPointX', 0);
  /**
     * get/set fill linear gradient end point x
     * @name fillLinearGradientEndPointX
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get fill linear gradient end point x
     * var endPointX = shape.fillLinearGradientEndPointX();
     *
     * // set fill linear gradient end point x
     * shape.fillLinearGradientEndPointX(20);
     */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillLinearGradientEndPointY', 0);
  /**
     * get/set fill linear gradient end point y
     * @name fillLinearGradientEndPointY
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get fill linear gradient end point y
     * var endPointY = shape.fillLinearGradientEndPointY();
     *
     * // set fill linear gradient end point y
     * shape.fillLinearGradientEndPointY(20);
     */

  Konva.Factory.addComponentsGetterSetter(
    Konva.Shape,
    'fillRadialGradientStartPoint',
    ['x', 'y']
  );

  /**
     * get/set fill radial gradient start point
     * @name fillRadialGradientStartPoint
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Object} startPoint
     * @param {Number} startPoint.x
     * @param {Number} startPoint.y
     * @returns {Object}
     * @example
     * // get fill radial gradient start point
     * var startPoint = shape.fillRadialGradientStartPoint();
     *
     * // set fill radial gradient start point
     * shape.fillRadialGradientStartPoint({
     *   x: 20
     *   y: 10
     * });
     */

  Konva.Factory.addGetterSetter(
    Konva.Shape,
    'fillRadialGradientStartPointX',
    0
  );
  /**
     * get/set fill radial gradient start point x
     * @name fillRadialGradientStartPointX
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get fill radial gradient start point x
     * var startPointX = shape.fillRadialGradientStartPointX();
     *
     * // set fill radial gradient start point x
     * shape.fillRadialGradientStartPointX(20);
     */

  Konva.Factory.addGetterSetter(
    Konva.Shape,
    'fillRadialGradientStartPointY',
    0
  );
  /**
     * get/set fill radial gradient start point y
     * @name fillRadialGradientStartPointY
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get fill radial gradient start point y
     * var startPointY = shape.fillRadialGradientStartPointY();
     *
     * // set fill radial gradient start point y
     * shape.fillRadialGradientStartPointY(20);
     */

  Konva.Factory.addComponentsGetterSetter(
    Konva.Shape,
    'fillRadialGradientEndPoint',
    ['x', 'y']
  );

  /**
     * get/set fill radial gradient end point
     * @name fillRadialGradientEndPoint
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Object} endPoint
     * @param {Number} endPoint.x
     * @param {Number} endPoint.y
     * @returns {Object}
     * @example
     * // get fill radial gradient end point
     * var endPoint = shape.fillRadialGradientEndPoint();
     *
     * // set fill radial gradient end point
     * shape.fillRadialGradientEndPoint({
     *   x: 20
     *   y: 10
     * });
     */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillRadialGradientEndPointX', 0);
  /**
     * get/set fill radial gradient end point x
     * @name fillRadialGradientEndPointX
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get fill radial gradient end point x
     * var endPointX = shape.fillRadialGradientEndPointX();
     *
     * // set fill radial gradient end point x
     * shape.fillRadialGradientEndPointX(20);
     */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillRadialGradientEndPointY', 0);
  /**
     * get/set fill radial gradient end point y
     * @name fillRadialGradientEndPointY
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get fill radial gradient end point y
     * var endPointY = shape.fillRadialGradientEndPointY();
     *
     * // set fill radial gradient end point y
     * shape.fillRadialGradientEndPointY(20);
     */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternRotation', 0);

  /**
     * get/set fill pattern rotation in degrees
     * @name fillPatternRotation
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} rotation
     * @returns {Konva.Shape}
     * @example
     * // get fill pattern rotation
     * var patternRotation = shape.fillPatternRotation();
     *
     * // set fill pattern rotation
     * shape.fillPatternRotation(20);
     */

  Konva.Factory.backCompat(Konva.Shape, {
    dashArray: 'dash',
    getDashArray: 'getDash',
    setDashArray: 'getDash',

    drawFunc: 'sceneFunc',
    getDrawFunc: 'getSceneFunc',
    setDrawFunc: 'setSceneFunc',

    drawHitFunc: 'hitFunc',
    getDrawHitFunc: 'getHitFunc',
    setDrawHitFunc: 'setHitFunc'
  });

  Konva.Collection.mapMethods(Konva.Shape);
})(Konva);

(function() {
  'use strict';
  // CONSTANTS
  var STAGE = 'Stage',
    STRING = 'string',
    PX = 'px',
    MOUSEOUT = 'mouseout',
    MOUSELEAVE = 'mouseleave',
    MOUSEOVER = 'mouseover',
    MOUSEENTER = 'mouseenter',
    MOUSEMOVE = 'mousemove',
    MOUSEDOWN = 'mousedown',
    MOUSEUP = 'mouseup',
    CONTEXTMENU = 'contextmenu',
    CLICK = 'click',
    DBL_CLICK = 'dblclick',
    TOUCHSTART = 'touchstart',
    TOUCHEND = 'touchend',
    TAP = 'tap',
    DBL_TAP = 'dbltap',
    TOUCHMOVE = 'touchmove',
    WHEEL = 'wheel',
    CONTENT_MOUSEOUT = 'contentMouseout',
    CONTENT_MOUSEOVER = 'contentMouseover',
    CONTENT_MOUSEMOVE = 'contentMousemove',
    CONTENT_MOUSEDOWN = 'contentMousedown',
    CONTENT_MOUSEUP = 'contentMouseup',
    CONTENT_CONTEXTMENU = 'contentContextmenu',
    CONTENT_CLICK = 'contentClick',
    CONTENT_DBL_CLICK = 'contentDblclick',
    CONTENT_TOUCHSTART = 'contentTouchstart',
    CONTENT_TOUCHEND = 'contentTouchend',
    CONTENT_DBL_TAP = 'contentDbltap',
    CONTENT_TAP = 'contentTap',
    CONTENT_TOUCHMOVE = 'contentTouchmove',
    CONTENT_WHEEL = 'contentWheel',
    DIV = 'div',
    RELATIVE = 'relative',
    KONVA_CONTENT = 'konvajs-content',
    SPACE = ' ',
    UNDERSCORE = '_',
    CONTAINER = 'container',
    EMPTY_STRING = '',
    EVENTS = [
      MOUSEDOWN,
      MOUSEMOVE,
      MOUSEUP,
      MOUSEOUT,
      TOUCHSTART,
      TOUCHMOVE,
      TOUCHEND,
      MOUSEOVER,
      WHEEL,
      CONTEXTMENU
    ],
    // cached variables
    eventsLength = EVENTS.length;

  function addEvent(ctx, eventName) {
    ctx.content.addEventListener(
      eventName,
      function(evt) {
        ctx[UNDERSCORE + eventName](evt);
      },
      false
    );
  }

  /**
     * Stage constructor.  A stage is used to contain multiple layers
     * @constructor
     * @memberof Konva
     * @augments Konva.Container
     * @param {Object} config
     * @param {String|Element} config.container Container selector or DOM element
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var stage = new Konva.Stage({
         *   width: 500,
         *   height: 800,
         *   container: 'containerId' // or "#containerId" or ".containerClass"
         * });
     */
  Konva.Stage = function(config) {
    this.___init(config);
  };

  Konva.Util.addMethods(Konva.Stage, {
    ___init: function(config) {
      this.nodeType = STAGE;
      // call super constructor
      Konva.Container.call(this, config);
      this._id = Konva.idCounter++;
      this._buildDOM();
      this._bindContentEvents();
      this._enableNestedTransforms = false;
      Konva.stages.push(this);
    },
    _validateAdd: function(child) {
      if (child.getType() !== 'Layer') {
        Konva.Util.throw('You may only add layers to the stage.');
      }
    },
    /**
         * set container dom element which contains the stage wrapper div element
         * @method
         * @memberof Konva.Stage.prototype
         * @param {DomElement} container can pass in a dom element or id string
         */
    setContainer: function(container) {
      if (typeof container === STRING) {
        if (container.charAt(0) === '.') {
          var className = container.slice(1);
          container = Konva.document.getElementsByClassName(className)[0];
        } else {
          var id;
          if (container.charAt(0) !== '#') {
            id = container;
          } else {
            id = container.slice(1);
          }
          container = Konva.document.getElementById(id);
        }
        if (!container) {
          throw 'Can not find container in document with id ' + id;
        }
      }
      this._setAttr(CONTAINER, container);
      return this;
    },
    shouldDrawHit: function() {
      return true;
    },
    draw: function() {
      Konva.Node.prototype.draw.call(this);
      return this;
    },
    /**
         * draw layer scene graphs
         * @name draw
         * @method
         * @memberof Konva.Stage.prototype
         */

    /**
         * draw layer hit graphs
         * @name drawHit
         * @method
         * @memberof Konva.Stage.prototype
         */

    /**
         * set height
         * @method
         * @memberof Konva.Stage.prototype
         * @param {Number} height
         */
    setHeight: function(height) {
      Konva.Node.prototype.setHeight.call(this, height);
      this._resizeDOM();
      return this;
    },
    /**
         * set width
         * @method
         * @memberof Konva.Stage.prototype
         * @param {Number} width
         */
    setWidth: function(width) {
      Konva.Node.prototype.setWidth.call(this, width);
      this._resizeDOM();
      return this;
    },
    /**
         * clear all layers
         * @method
         * @memberof Konva.Stage.prototype
         */
    clear: function() {
      var layers = this.children,
        len = layers.length,
        n;

      for (n = 0; n < len; n++) {
        layers[n].clear();
      }
      return this;
    },
    clone: function(obj) {
      if (!obj) {
        obj = {};
      }
      obj.container = Konva.document.createElement(DIV);
      return Konva.Container.prototype.clone.call(this, obj);
    },
    /**
         * destroy stage
         * @method
         * @memberof Konva.Stage.prototype
         */
    destroy: function() {
      var content = this.content;
      Konva.Container.prototype.destroy.call(this);

      if (content && Konva.Util._isInDocument(content)) {
        this.getContainer().removeChild(content);
      }
      var index = Konva.stages.indexOf(this);
      if (index > -1) {
        Konva.stages.splice(index, 1);
      }
      return this;
    },
    /**
         * get pointer position which can be a touch position or mouse position
         * @method
         * @memberof Konva.Stage.prototype
         * @returns {Object}
         */
    getPointerPosition: function() {
      return this.pointerPos;
    },
    getStage: function() {
      return this;
    },
    /**
         * get stage content div element which has the
         *  the class name "konvajs-content"
         * @method
         * @memberof Konva.Stage.prototype
         */
    getContent: function() {
      return this.content;
    },
    /**
         * Creates a composite data URL
         * @method
         * @memberof Konva.Stage.prototype
         * @param {Object} config
         * @param {Function} [config.callback] function executed when the composite has completed. Deprecated as method is sync now.
         * @param {String} [config.mimeType] can be "image/png" or "image/jpeg".
         *  "image/png" is the default
         * @param {Number} [config.x] x position of canvas section
         * @param {Number} [config.y] y position of canvas section
         * @param {Number} [config.width] width of canvas section
         * @param {Number} [config.height] height of canvas section
         * @param {Number} [config.quality] jpeg quality.  If using an "image/jpeg" mimeType,
         *  you can specify the quality from 0 to 1, where 0 is very poor quality and 1
         *  is very high quality
         */
    toDataURL: function(config) {
      config = config || {};

      var mimeType = config.mimeType || null,
        quality = config.quality || null,
        x = config.x || 0,
        y = config.y || 0,
        canvas = new Konva.SceneCanvas({
          width: config.width || this.getWidth(),
          height: config.height || this.getHeight(),
          pixelRatio: config.pixelRatio
        }),
        _context = canvas.getContext()._context,
        layers = this.children;

      if (x || y) {
        _context.translate(-1 * x, -1 * y);
      }

      layers.each(function(layer) {
        var width = layer.getCanvas().getWidth();
        var height = layer.getCanvas().getHeight();
        var ratio = layer.getCanvas().getPixelRatio();
        _context.drawImage(
          layer.getCanvas()._canvas,
          0,
          0,
          width / ratio,
          height / ratio
        );
      });
      var src = canvas.toDataURL(mimeType, quality);

      if (config.callback) {
        config.callback(src);
      }

      return src;
    },
    /**
         * converts stage into an image.
         * @method
         * @memberof Konva.Stage.prototype
         * @param {Object} config
         * @param {Function} config.callback function executed when the composite has completed
         * @param {String} [config.mimeType] can be "image/png" or "image/jpeg".
         *  "image/png" is the default
         * @param {Number} [config.x] x position of canvas section
         * @param {Number} [config.y] y position of canvas section
         * @param {Number} [config.width] width of canvas section
         * @param {Number} [config.height] height of canvas section
         * @param {Number} [config.quality] jpeg quality.  If using an "image/jpeg" mimeType,
         *  you can specify the quality from 0 to 1, where 0 is very poor quality and 1
         *  is very high quality
         */
    toImage: function(config) {
      var cb = config.callback;

      config.callback = function(dataUrl) {
        Konva.Util._getImage(dataUrl, function(img) {
          cb(img);
        });
      };
      this.toDataURL(config);
    },
    /**
         * get visible intersection shape. This is the preferred
         *  method for determining if a point intersects a shape or not
         * @method
         * @memberof Konva.Stage.prototype
         * @param {Object} pos
         * @param {Number} pos.x
         * @param {Number} pos.y
         * @param {String} [selector]
         * @returns {Konva.Node}
         * @example
         * var shape = stage.getIntersection({x: 50, y: 50});
         * // or if you interested in shape parent:
         * var group = stage.getIntersection({x: 50, y: 50}, 'Group');
         */
    getIntersection: function(pos, selector) {
      var layers = this.getChildren(),
        len = layers.length,
        end = len - 1,
        n,
        shape;

      for (n = end; n >= 0; n--) {
        shape = layers[n].getIntersection(pos, selector);
        if (shape) {
          return shape;
        }
      }

      return null;
    },
    _resizeDOM: function() {
      if (this.content) {
        var width = this.getWidth(),
          height = this.getHeight(),
          layers = this.getChildren(),
          len = layers.length,
          n,
          layer;

        // set content dimensions
        this.content.style.width = width + PX;
        this.content.style.height = height + PX;

        this.bufferCanvas.setSize(width, height);
        this.bufferHitCanvas.setSize(width, height);

        // set layer dimensions
        for (n = 0; n < len; n++) {
          layer = layers[n];
          layer.setSize(width, height);
          layer.draw();
        }
      }
    },
    /**
         * add layer or layers to stage
         * @method
         * @memberof Konva.Stage.prototype
         * @param {...Konva.Layer} layer
         * @example
         * stage.add(layer1, layer2, layer3);
         */
    add: function(layer) {
      if (arguments.length > 1) {
        for (var i = 0; i < arguments.length; i++) {
          this.add(arguments[i]);
        }
        return this;
      }
      Konva.Container.prototype.add.call(this, layer);
      layer._setCanvasSize(this.width(), this.height());

      // draw layer and append canvas to container
      layer.draw();

      if (Konva.isBrowser) {
        this.content.appendChild(layer.canvas._canvas);
      }

      // chainable
      return this;
    },
    getParent: function() {
      return null;
    },
    getLayer: function() {
      return null;
    },
    /**
         * returns a {@link Konva.Collection} of layers
         * @method
         * @memberof Konva.Stage.prototype
         */
    getLayers: function() {
      return this.getChildren();
    },
    _bindContentEvents: function() {
      if (!Konva.isBrowser) {
        return;
      }
      for (var n = 0; n < eventsLength; n++) {
        addEvent(this, EVENTS[n]);
      }
    },
    _mouseover: function(evt) {
      if (!Konva.UA.mobile) {
        this._setPointerPosition(evt);
        this._fire(CONTENT_MOUSEOVER, { evt: evt });
      }
    },
    _mouseout: function(evt) {
      if (!Konva.UA.mobile) {
        this._setPointerPosition(evt);
        var targetShape = this.targetShape;

        if (targetShape && !Konva.isDragging()) {
          targetShape._fireAndBubble(MOUSEOUT, { evt: evt });
          targetShape._fireAndBubble(MOUSELEAVE, { evt: evt });
          this.targetShape = null;
        }
        this.pointerPos = undefined;

        this._fire(CONTENT_MOUSEOUT, { evt: evt });
      }
    },
    _mousemove: function(evt) {
      // workaround for mobile IE to force touch event when unhandled pointer event elevates into a mouse event
      if (Konva.UA.ieMobile) {
        return this._touchmove(evt);
      }
      // workaround fake mousemove event in chrome browser https://code.google.com/p/chromium/issues/detail?id=161464
      if (
        (typeof evt.movementX !== 'undefined' ||
          typeof evt.movementY !== 'undefined') &&
        evt.movementY === 0 &&
        evt.movementX === 0
      ) {
        return null;
      }
      if (Konva.UA.mobile) {
        return null;
      }
      this._setPointerPosition(evt);
      var shape;

      if (!Konva.isDragging()) {
        shape = this.getIntersection(this.getPointerPosition());
        if (shape && shape.isListening()) {
          if (
            !Konva.isDragging() &&
            (!this.targetShape || this.targetShape._id !== shape._id)
          ) {
            if (this.targetShape) {
              this.targetShape._fireAndBubble(MOUSEOUT, { evt: evt }, shape);
              this.targetShape._fireAndBubble(MOUSELEAVE, { evt: evt }, shape);
            }
            shape._fireAndBubble(MOUSEOVER, { evt: evt }, this.targetShape);
            shape._fireAndBubble(MOUSEENTER, { evt: evt }, this.targetShape);
            this.targetShape = shape;
          } else {
            shape._fireAndBubble(MOUSEMOVE, { evt: evt });
          }
        } else {
          /*
                 * if no shape was detected, clear target shape and try
                 * to run mouseout from previous target shape
                 */
          if (this.targetShape && !Konva.isDragging()) {
            this.targetShape._fireAndBubble(MOUSEOUT, { evt: evt });
            this.targetShape._fireAndBubble(MOUSELEAVE, { evt: evt });
            this.targetShape = null;
          }
        }

        // content event
        this._fire(CONTENT_MOUSEMOVE, { evt: evt });
      }

      // always call preventDefault for desktop events because some browsers
      // try to drag and drop the canvas element
      if (evt.preventDefault) {
        evt.preventDefault();
      }
    },
    _mousedown: function(evt) {
      // workaround for mobile IE to force touch event when unhandled pointer event elevates into a mouse event
      if (Konva.UA.ieMobile) {
        return this._touchstart(evt);
      }
      if (!Konva.UA.mobile) {
        this._setPointerPosition(evt);
        var shape = this.getIntersection(this.getPointerPosition());

        Konva.listenClickTap = true;

        if (shape && shape.isListening()) {
          this.clickStartShape = shape;
          shape._fireAndBubble(MOUSEDOWN, { evt: evt });
        }

        // content event
        this._fire(CONTENT_MOUSEDOWN, { evt: evt });
      }

      // always call preventDefault for desktop events because some browsers
      // try to drag and drop the canvas element
      if (evt.preventDefault) {
        evt.preventDefault();
      }
    },
    _mouseup: function(evt) {
      // workaround for mobile IE to force touch event when unhandled pointer event elevates into a mouse event
      if (Konva.UA.ieMobile) {
        return this._touchend(evt);
      }
      if (!Konva.UA.mobile) {
        this._setPointerPosition(evt);
        var shape = this.getIntersection(this.getPointerPosition()),
          clickStartShape = this.clickStartShape,
          clickEndShape = this.clickEndShape,
          fireDblClick = false,
          dd = Konva.DD;

        if (Konva.inDblClickWindow) {
          fireDblClick = true;
          Konva.inDblClickWindow = false;
        } else if (!dd || !dd.justDragged) {
          // don't set inDblClickWindow after dragging
          Konva.inDblClickWindow = true;
        } else if (dd) {
          dd.justDragged = false;
        }

        setTimeout(function() {
          Konva.inDblClickWindow = false;
        }, Konva.dblClickWindow);

        if (shape && shape.isListening()) {
          this.clickEndShape = shape;
          shape._fireAndBubble(MOUSEUP, { evt: evt });

          // detect if click or double click occurred
          if (
            Konva.listenClickTap &&
            clickStartShape &&
            clickStartShape._id === shape._id
          ) {
            shape._fireAndBubble(CLICK, { evt: evt });

            if (
              fireDblClick &&
              clickEndShape &&
              clickEndShape._id === shape._id
            ) {
              shape._fireAndBubble(DBL_CLICK, { evt: evt });
            }
          }
        }
        // content events
        this._fire(CONTENT_MOUSEUP, { evt: evt });
        if (Konva.listenClickTap) {
          this._fire(CONTENT_CLICK, { evt: evt });
          if (fireDblClick) {
            this._fire(CONTENT_DBL_CLICK, { evt: evt });
          }
        }

        Konva.listenClickTap = false;
      }

      // always call preventDefault for desktop events because some browsers
      // try to drag and drop the canvas element
      if (evt.preventDefault) {
        evt.preventDefault();
      }
    },
    _contextmenu: function(evt) {
      this._fire(CONTENT_CONTEXTMENU, { evt: evt });
    },
    _touchstart: function(evt) {
      this._setPointerPosition(evt);
      var shape = this.getIntersection(this.getPointerPosition());

      Konva.listenClickTap = true;

      if (shape && shape.isListening()) {
        this.tapStartShape = shape;
        shape._fireAndBubble(TOUCHSTART, { evt: evt });

        // only call preventDefault if the shape is listening for events
        if (
          shape.isListening() &&
          shape.preventDefault() &&
          evt.preventDefault
        ) {
          evt.preventDefault();
        }
      }
      // content event
      this._fire(CONTENT_TOUCHSTART, { evt: evt });
    },
    _touchend: function(evt) {
      this._setPointerPosition(evt);
      var shape = this.getIntersection(this.getPointerPosition()),
        fireDblClick = false;

      if (Konva.inDblClickWindow) {
        fireDblClick = true;
        Konva.inDblClickWindow = false;
      } else {
        Konva.inDblClickWindow = true;
      }

      setTimeout(function() {
        Konva.inDblClickWindow = false;
      }, Konva.dblClickWindow);

      if (shape && shape.isListening()) {
        shape._fireAndBubble(TOUCHEND, { evt: evt });

        // detect if tap or double tap occurred
        if (
          Konva.listenClickTap &&
          this.tapStartShape &&
          shape._id === this.tapStartShape._id
        ) {
          shape._fireAndBubble(TAP, { evt: evt });

          if (fireDblClick) {
            shape._fireAndBubble(DBL_TAP, { evt: evt });
          }
        }
        // only call preventDefault if the shape is listening for events
        if (
          shape.isListening() &&
          shape.preventDefault() &&
          evt.preventDefault
        ) {
          evt.preventDefault();
        }
      }
      // content events
      this._fire(CONTENT_TOUCHEND, { evt: evt });
      if (Konva.listenClickTap) {
        this._fire(CONTENT_TAP, { evt: evt });
        if (fireDblClick) {
          this._fire(CONTENT_DBL_TAP, { evt: evt });
        }
      }

      Konva.listenClickTap = false;
    },
    _touchmove: function(evt) {
      this._setPointerPosition(evt);
      var dd = Konva.DD,
        shape;
      if (!Konva.isDragging()) {
        shape = this.getIntersection(this.getPointerPosition());
        if (shape && shape.isListening()) {
          shape._fireAndBubble(TOUCHMOVE, { evt: evt });
          // only call preventDefault if the shape is listening for events
          if (
            shape.isListening() &&
            shape.preventDefault() &&
            evt.preventDefault
          ) {
            evt.preventDefault();
          }
        }
        this._fire(CONTENT_TOUCHMOVE, { evt: evt });
      }
      if (dd) {
        if (Konva.isDragging() && Konva.DD.node.preventDefault()) {
          evt.preventDefault();
        }
      }
    },
    _wheel: function(evt) {
      this._setPointerPosition(evt);
      var shape = this.getIntersection(this.getPointerPosition());

      if (shape && shape.isListening()) {
        shape._fireAndBubble(WHEEL, { evt: evt });
      }
      this._fire(CONTENT_WHEEL, { evt: evt });
    },
    _setPointerPosition: function(evt) {
      var contentPosition = this._getContentPosition(),
        x = null,
        y = null;
      evt = evt ? evt : window.event;

      // touch events
      if (evt.touches !== undefined) {
        // currently, only handle one finger
        if (evt.touches.length > 0) {
          var touch = evt.touches[0];
          // get the information for finger #1
          x = touch.clientX - contentPosition.left;
          y = touch.clientY - contentPosition.top;
        }
      } else {
        // mouse events
        x = evt.clientX - contentPosition.left;
        y = evt.clientY - contentPosition.top;
      }
      if (x !== null && y !== null) {
        this.pointerPos = {
          x: x,
          y: y
        };
      }
    },
    _getContentPosition: function() {
      var rect = this.content.getBoundingClientRect
        ? this.content.getBoundingClientRect()
        : { top: 0, left: 0 };
      return {
        top: rect.top,
        left: rect.left
      };
    },
    _buildDOM: function() {
      // the buffer canvas pixel ratio must be 1 because it is used as an
      // intermediate canvas before copying the result onto a scene canvas.
      // not setting it to 1 will result in an over compensation
      this.bufferCanvas = new Konva.SceneCanvas();
      this.bufferHitCanvas = new Konva.HitCanvas({ pixelRatio: 1 });

      if (!Konva.isBrowser) {
        return;
      }
      var container = this.getContainer();
      if (!container) {
        throw 'Stage has no container. A container is required.';
      }
      // clear content inside container
      container.innerHTML = EMPTY_STRING;

      // content
      this.content = Konva.document.createElement(DIV);
      this.content.style.position = RELATIVE;
      this.content.className = KONVA_CONTENT;
      this.content.setAttribute('role', 'presentation');

      container.appendChild(this.content);

      this._resizeDOM();
    },
    _onContent: function(typesStr, handler) {
      var types = typesStr.split(SPACE),
        len = types.length,
        n,
        baseEvent;

      for (n = 0; n < len; n++) {
        baseEvent = types[n];
        this.content.addEventListener(baseEvent, handler, false);
      }
    },
    // currently cache function is now working for stage, because stage has no its own canvas element
    // TODO: may be it is better to cache all children layers?
    cache: function() {
      Konva.Util.warn(
        'Cache function is not allowed for stage. You may use cache only for layers, groups and shapes.'
      );
    },
    clearCache: function() {}
  });
  Konva.Util.extend(Konva.Stage, Konva.Container);

  // add getters and setters
  Konva.Factory.addGetter(Konva.Stage, 'container');
  Konva.Factory.addOverloadedGetterSetter(Konva.Stage, 'container');

  /**
     * get container DOM element
     * @name container
     * @method
     * @memberof Konva.Stage.prototype
     * @returns {DomElement} container
     * @example
     * // get container
     * var container = stage.container();
     * // set container
     * var container = document.createElement('div');
     * body.appendChild(container);
     * stage.container(container);
     */
})();

(function(Konva) {
  'use strict';
  /**
     * BaseLayer constructor.
     * @constructor
     * @memberof Konva
     * @augments Konva.Container
     * @param {Object} config
     * @param {Boolean} [config.clearBeforeDraw] set this property to false if you don't want
     * to clear the canvas before each layer draw.  The default value is true.
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * * @param {Object} [config.clip] set clip
     * @param {Number} [config.clipX] set clip x
     * @param {Number} [config.clipY] set clip y
     * @param {Number} [config.clipWidth] set clip width
     * @param {Number} [config.clipHeight] set clip height
     * @param {Function} [config.clipFunc] set clip func

     */
  Konva.BaseLayer = function(config) {
    this.___init(config);
  };

  Konva.Util.addMethods(Konva.BaseLayer, {
    ___init: function(config) {
      this.nodeType = 'Layer';
      Konva.Container.call(this, config);
    },
    createPNGStream: function() {
      return this.canvas._canvas.createPNGStream();
    },
    /**
     * get layer canvas
     * @method
     * @memberof Konva.BaseLayer.prototype
     */
    getCanvas: function() {
      return this.canvas;
    },
    /**
     * get layer hit canvas
     * @method
     * @memberof Konva.BaseLayer.prototype
     */
    getHitCanvas: function() {
      return this.hitCanvas;
    },
    /**
     * get layer canvas context
     * @method
     * @memberof Konva.BaseLayer.prototype
     */
    getContext: function() {
      return this.getCanvas().getContext();
    },
    /**
     * clear scene and hit canvas contexts tied to the layer
     * @method
     * @memberof Konva.BaseLayer.prototype
     * @param {Object} [bounds]
     * @param {Number} [bounds.x]
     * @param {Number} [bounds.y]
     * @param {Number} [bounds.width]
     * @param {Number} [bounds.height]
     * @example
     * layer.clear();
     * layer.clear({
     *   x : 0,
     *   y : 0,
     *   width : 100,
     *   height : 100
     * });
     */
    clear: function(bounds) {
      this.getContext().clear(bounds);
      return this;
    },
    clearHitCache: function() {
      this._hitImageData = undefined;
    },
    // extend Node.prototype.setZIndex
    setZIndex: function(index) {
      Konva.Node.prototype.setZIndex.call(this, index);
      var stage = this.getStage();
      if (stage) {
        stage.content.removeChild(this.getCanvas()._canvas);

        if (index < stage.getChildren().length - 1) {
          stage.content.insertBefore(
            this.getCanvas()._canvas,
            stage.getChildren()[index + 1].getCanvas()._canvas
          );
        } else {
          stage.content.appendChild(this.getCanvas()._canvas);
        }
      }
      return this;
    },
    // extend Node.prototype.moveToTop
    moveToTop: function() {
      Konva.Node.prototype.moveToTop.call(this);
      var stage = this.getStage();
      if (stage) {
        stage.content.removeChild(this.getCanvas()._canvas);
        stage.content.appendChild(this.getCanvas()._canvas);
      }
      return this;
    },
    // extend Node.prototype.moveUp
    moveUp: function() {
      var moved = Konva.Node.prototype.moveUp.call(this);
      if (!moved) {
        return this;
      }
      var stage = this.getStage();
      if (!stage) {
        return this;
      }
      stage.content.removeChild(this.getCanvas()._canvas);

      if (this.index < stage.getChildren().length - 1) {
        stage.content.insertBefore(
          this.getCanvas()._canvas,
          stage.getChildren()[this.index + 1].getCanvas()._canvas
        );
      } else {
        stage.content.appendChild(this.getCanvas()._canvas);
      }
      return this;
    },
    // extend Node.prototype.moveDown
    moveDown: function() {
      if (Konva.Node.prototype.moveDown.call(this)) {
        var stage = this.getStage();
        if (stage) {
          var children = stage.getChildren();
          stage.content.removeChild(this.getCanvas()._canvas);
          stage.content.insertBefore(
            this.getCanvas()._canvas,
            children[this.index + 1].getCanvas()._canvas
          );
        }
      }
      return this;
    },
    // extend Node.prototype.moveToBottom
    moveToBottom: function() {
      if (Konva.Node.prototype.moveToBottom.call(this)) {
        var stage = this.getStage();
        if (stage) {
          var children = stage.getChildren();
          stage.content.removeChild(this.getCanvas()._canvas);
          stage.content.insertBefore(
            this.getCanvas()._canvas,
            children[1].getCanvas()._canvas
          );
        }
      }
      return this;
    },
    getLayer: function() {
      return this;
    },
    remove: function() {
      var _canvas = this.getCanvas()._canvas;

      Konva.Node.prototype.remove.call(this);

      if (_canvas && _canvas.parentNode && Konva.Util._isInDocument(_canvas)) {
        _canvas.parentNode.removeChild(_canvas);
      }
      return this;
    },
    getStage: function() {
      return this.parent;
    },
    setSize: function(width, height) {
      this.canvas.setSize(width, height);
      return this;
    },
    /**
     * get/set width of layer.getter return width of stage. setter doing nothing.
     * if you want change width use `stage.width(value);`
     * @name width
     * @method
     * @memberof Konva.BaseLayer.prototype
     * @returns {Number}
     * @example
     * var width = layer.width();
     */
    getWidth: function() {
      if (this.parent) {
        return this.parent.getWidth();
      }
    },
    setWidth: function() {
      Konva.Util.warn(
        'Can not change width of layer. Use "stage.width(value)" function instead.'
      );
    },
    /**
     * get/set height of layer.getter return height of stage. setter doing nothing.
     * if you want change height use `stage.height(value);`
     * @name height
     * @method
     * @memberof Konva.BaseLayer.prototype
     * @returns {Number}
     * @example
     * var height = layer.height();
     */
    getHeight: function() {
      if (this.parent) {
        return this.parent.getHeight();
      }
    },
    setHeight: function() {
      Konva.Util.warn(
        'Can not change height of layer. Use "stage.height(value)" function instead.'
      );
    },
    // the apply transform method is handled by the Layer and FastLayer class
    // because it is up to the layer to decide if an absolute or relative transform
    // should be used
    _applyTransform: function(shape, context, top) {
      var m = shape.getAbsoluteTransform(top).getMatrix();
      context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
    }
  });
  Konva.Util.extend(Konva.BaseLayer, Konva.Container);

  // add getters and setters
  Konva.Factory.addGetterSetter(Konva.BaseLayer, 'clearBeforeDraw', true);
  /**
   * get/set clearBeforeDraw flag which determines if the layer is cleared or not
   *  before drawing
   * @name clearBeforeDraw
   * @method
   * @memberof Konva.BaseLayer.prototype
   * @param {Boolean} clearBeforeDraw
   * @returns {Boolean}
   * @example
   * // get clearBeforeDraw flag
   * var clearBeforeDraw = layer.clearBeforeDraw();
   *
   * // disable clear before draw
   * layer.clearBeforeDraw(false);
   *
   * // enable clear before draw
   * layer.clearBeforeDraw(true);
   */

  Konva.Collection.mapMethods(Konva.BaseLayer);
})(Konva);

(function() {
  'use strict';
  // constants
  var HASH = '#',
    BEFORE_DRAW = 'beforeDraw',
    DRAW = 'draw',
    /*
         * 2 - 3 - 4
         * |       |
         * 1 - 0   5
         *         |
         * 8 - 7 - 6
         */
    INTERSECTION_OFFSETS = [
      { x: 0, y: 0 }, // 0
      { x: -1, y: 0 }, // 1
      { x: -1, y: -1 }, // 2
      { x: 0, y: -1 }, // 3
      { x: 1, y: -1 }, // 4
      { x: 1, y: 0 }, // 5
      { x: 1, y: 1 }, // 6
      { x: 0, y: 1 }, // 7
      { x: -1, y: 1 } // 8
    ],
    INTERSECTION_OFFSETS_LEN = INTERSECTION_OFFSETS.length;

  /**
     * Layer constructor.  Layers are tied to their own canvas element and are used
     * to contain groups or shapes.
     * @constructor
     * @memberof Konva
     * @augments Konva.BaseLayer
     * @param {Object} config
     * @param {Boolean} [config.clearBeforeDraw] set this property to false if you don't want
     * to clear the canvas before each layer draw.  The default value is true.
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * * @param {Object} [config.clip] set clip
     * @param {Number} [config.clipX] set clip x
     * @param {Number} [config.clipY] set clip y
     * @param {Number} [config.clipWidth] set clip width
     * @param {Number} [config.clipHeight] set clip height
     * @param {Function} [config.clipFunc] set clip func

     * @example
     * var layer = new Konva.Layer();
     */
  Konva.Layer = function(config) {
    this.____init(config);
  };

  Konva.Util.addMethods(Konva.Layer, {
    ____init: function(config) {
      this.nodeType = 'Layer';
      this.canvas = new Konva.SceneCanvas();
      this.hitCanvas = new Konva.HitCanvas({
        pixelRatio: 1
      });
      // call super constructor
      Konva.BaseLayer.call(this, config);
    },
    _setCanvasSize: function(width, height) {
      this.canvas.setSize(width, height);
      this.hitCanvas.setSize(width, height);
    },
    _validateAdd: function(child) {
      var type = child.getType();
      if (type !== 'Group' && type !== 'Shape') {
        Konva.Util.throw('You may only add groups and shapes to a layer.');
      }
    },
    /**
         * get visible intersection shape. This is the preferred
         * method for determining if a point intersects a shape or not
         * also you may pass optional selector parametr to return ancestor of intersected shape
         * @method
         * @memberof Konva.Layer.prototype
         * @param {Object} pos
         * @param {Number} pos.x
         * @param {Number} pos.y
         * @param {String} [selector]
         * @returns {Konva.Node}
         * @example
         * var shape = layer.getIntersection({x: 50, y: 50});
         * // or if you interested in shape parent:
         * var group = layer.getIntersection({x: 50, y: 50}, 'Group');
         */
    getIntersection: function(pos, selector) {
      var obj, i, intersectionOffset, shape;

      if (!this.hitGraphEnabled() || !this.isVisible()) {
        return null;
      }
      // in some cases antialiased area may be bigger than 1px
      // it is possible if we will cache node, then scale it a lot
      // TODO: check { 0; 0 } point before loop, and remove it from INTERSECTION_OFFSETS.
      var spiralSearchDistance = 1;
      var continueSearch = false;
      while (true) {
        for (i = 0; i < INTERSECTION_OFFSETS_LEN; i++) {
          intersectionOffset = INTERSECTION_OFFSETS[i];
          obj = this._getIntersection({
            x: pos.x + intersectionOffset.x * spiralSearchDistance,
            y: pos.y + intersectionOffset.y * spiralSearchDistance
          });
          shape = obj.shape;
          if (shape && selector) {
            return shape.findAncestor(selector, true);
          } else if (shape) {
            return shape;
          }
          // we should continue search if we found antialiased pixel
          // that means our node somewhere very close
          continueSearch = !!obj.antialiased;
          // stop search if found empty pixel
          if (!obj.antialiased) {
            break;
          }
        }
        // if no shape, and no antialiased pixel, we should end searching
        if (continueSearch) {
          spiralSearchDistance += 1;
        } else {
          return null;
        }
      }
    },
    _getImageData: function(x, y) {
      var width = this.hitCanvas.width || 1,
        height = this.hitCanvas.height || 1,
        index = Math.round(y) * width + Math.round(x);

      if (!this._hitImageData) {
        this._hitImageData = this.hitCanvas.context.getImageData(
          0,
          0,
          width,
          height
        );
      }

      return [
        this._hitImageData.data[4 * index + 0], // Red
        this._hitImageData.data[4 * index + 1], // Green
        this._hitImageData.data[4 * index + 2], // Blue
        this._hitImageData.data[4 * index + 3] // Alpha
      ];
    },
    _getIntersection: function(pos) {
      var ratio = this.hitCanvas.pixelRatio;
      var p = this.hitCanvas.context.getImageData(
        Math.round(pos.x * ratio),
        Math.round(pos.y * ratio),
        1,
        1
      ).data,
        p3 = p[3],
        colorKey,
        shape;
      // fully opaque pixel
      if (p3 === 255) {
        colorKey = Konva.Util._rgbToHex(p[0], p[1], p[2]);
        shape = Konva.shapes[HASH + colorKey];
        if (shape) {
          return {
            shape: shape
          };
        }
        return {
          antialiased: true
        };
      } else if (p3 > 0) {
        // antialiased pixel
        return {
          antialiased: true
        };
      }
      // empty pixel
      return {};
    },
    drawScene: function(can, top) {
      var layer = this.getLayer(), canvas = can || (layer && layer.getCanvas());

      this._fire(BEFORE_DRAW, {
        node: this
      });

      if (this.getClearBeforeDraw()) {
        canvas.getContext().clear();
      }

      Konva.Container.prototype.drawScene.call(this, canvas, top);

      this._fire(DRAW, {
        node: this
      });

      return this;
    },
    drawHit: function(can, top) {
      var layer = this.getLayer(), canvas = can || (layer && layer.hitCanvas);

      if (layer && layer.getClearBeforeDraw()) {
        layer.getHitCanvas().getContext().clear();
      }

      Konva.Container.prototype.drawHit.call(this, canvas, top);
      this.imageData = null; // Clear imageData cache
      return this;
    },
    clear: function(bounds) {
      Konva.BaseLayer.prototype.clear.call(this, bounds);
      this.getHitCanvas().getContext().clear(bounds);
      this.imageData = null; // Clear getImageData cache
      return this;
    },
    // extend Node.prototype.setVisible
    setVisible: function(visible) {
      Konva.Node.prototype.setVisible.call(this, visible);
      if (visible) {
        this.getCanvas()._canvas.style.display = 'block';
        this.hitCanvas._canvas.style.display = 'block';
      } else {
        this.getCanvas()._canvas.style.display = 'none';
        this.hitCanvas._canvas.style.display = 'none';
      }
      return this;
    },
    /**
         * enable hit graph
         * @name enableHitGraph
         * @method
         * @memberof Konva.Layer.prototype
         * @returns {Layer}
         */
    enableHitGraph: function() {
      this.setHitGraphEnabled(true);
      return this;
    },
    /**
         * disable hit graph
         * @name disableHitGraph
         * @method
         * @memberof Konva.Layer.prototype
         * @returns {Layer}
         */
    disableHitGraph: function() {
      this.setHitGraphEnabled(false);
      return this;
    },
    setSize: function(width, height) {
      Konva.BaseLayer.prototype.setSize.call(this, width, height);
      this.hitCanvas.setSize(width, height);
      return this;
    }
  });
  Konva.Util.extend(Konva.Layer, Konva.BaseLayer);

  Konva.Factory.addGetterSetter(Konva.Layer, 'hitGraphEnabled', true);
  /**
     * get/set hitGraphEnabled flag.  Disabling the hit graph will greatly increase
     *  draw performance because the hit graph will not be redrawn each time the layer is
     *  drawn.  This, however, also disables mouse/touch event detection
     * @name hitGraphEnabled
     * @method
     * @memberof Konva.Layer.prototype
     * @param {Boolean} enabled
     * @returns {Boolean}
     * @example
     * // get hitGraphEnabled flag
     * var hitGraphEnabled = layer.hitGraphEnabled();
     *
     * // disable hit graph
     * layer.hitGraphEnabled(false);
     *
     * // enable hit graph
     * layer.hitGraphEnabled(true);
     */
  Konva.Collection.mapMethods(Konva.Layer);
})();

(function() {
  'use strict';
  /**
     * FastLayer constructor. Layers are tied to their own canvas element and are used
     * to contain shapes only.  If you don't need node nesting, mouse and touch interactions,
     * or event pub/sub, you should use FastLayer instead of Layer to create your layers.
     * It renders about 2x faster than normal layers.
     * @constructor
     * @memberof Konva
     * @augments Konva.BaseLayer
     * @param {Object} config
     * @param {Boolean} [config.clearBeforeDraw] set this property to false if you don't want
     * to clear the canvas before each layer draw.  The default value is true.
     * @param {Boolean} [config.visible]
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * * @param {Object} [config.clip] set clip
     * @param {Number} [config.clipX] set clip x
     * @param {Number} [config.clipY] set clip y
     * @param {Number} [config.clipWidth] set clip width
     * @param {Number} [config.clipHeight] set clip height
     * @param {Function} [config.clipFunc] set clip func

     * @example
     * var layer = new Konva.FastLayer();
     */
  Konva.FastLayer = function(config) {
    this.____init(config);
  };

  Konva.Util.addMethods(Konva.FastLayer, {
    ____init: function(config) {
      this.nodeType = 'Layer';
      this.canvas = new Konva.SceneCanvas();
      // call super constructor
      Konva.BaseLayer.call(this, config);
    },
    _validateAdd: function(child) {
      var type = child.getType();
      if (type !== 'Shape') {
        Konva.Util.throw('You may only add shapes to a fast layer.');
      }
    },
    _setCanvasSize: function(width, height) {
      this.canvas.setSize(width, height);
    },
    hitGraphEnabled: function() {
      return false;
    },
    getIntersection: function() {
      return null;
    },
    drawScene: function(can) {
      var layer = this.getLayer(), canvas = can || (layer && layer.getCanvas());

      if (this.getClearBeforeDraw()) {
        canvas.getContext().clear();
      }

      Konva.Container.prototype.drawScene.call(this, canvas);

      return this;
    },
    draw: function() {
      this.drawScene();
      return this;
    },
    // extend Node.prototype.setVisible
    setVisible: function(visible) {
      Konva.Node.prototype.setVisible.call(this, visible);
      if (visible) {
        this.getCanvas()._canvas.style.display = 'block';
      } else {
        this.getCanvas()._canvas.style.display = 'none';
      }
      return this;
    }
  });
  Konva.Util.extend(Konva.FastLayer, Konva.BaseLayer);

  Konva.Collection.mapMethods(Konva.FastLayer);
})();

(function() {
  'use strict';
  /**
     * Group constructor.  Groups are used to contain shapes or other groups.
     * @constructor
     * @memberof Konva
     * @augments Konva.Container
     * @param {Object} config
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * * @param {Object} [config.clip] set clip
     * @param {Number} [config.clipX] set clip x
     * @param {Number} [config.clipY] set clip y
     * @param {Number} [config.clipWidth] set clip width
     * @param {Number} [config.clipHeight] set clip height
     * @param {Function} [config.clipFunc] set clip func

     * @example
     * var group = new Konva.Group();
     */
  Konva.Group = function(config) {
    this.___init(config);
  };

  Konva.Util.addMethods(Konva.Group, {
    ___init: function(config) {
      this.nodeType = 'Group';
      // call super constructor
      Konva.Container.call(this, config);
    },
    _validateAdd: function(child) {
      var type = child.getType();
      if (type !== 'Group' && type !== 'Shape') {
        Konva.Util.throw('You may only add groups and shapes to groups.');
      }
    }
  });
  Konva.Util.extend(Konva.Group, Konva.Container);

  Konva.Collection.mapMethods(Konva.Group);
})();

(function(Konva) {
  'use strict';
  var now = (function() {
    if (Konva.global.performance && Konva.global.performance.now) {
      return function() {
        return Konva.global.performance.now();
      };
    }

    return function() {
      return new Date().getTime();
    };
  })();

  function FRAF(callback) {
    setTimeout(callback, 1000 / 60);
  }

  var RAF = (function() {
    return (
      Konva.global.requestAnimationFrame ||
      Konva.global.webkitRequestAnimationFrame ||
      Konva.global.mozRequestAnimationFrame ||
      Konva.global.oRequestAnimationFrame ||
      Konva.global.msRequestAnimationFrame ||
      FRAF
    );
  })();

  function requestAnimFrame() {
    return RAF.apply(Konva.global, arguments);
  }

  /**
     * Animation constructor.  A stage is used to contain multiple layers and handle
     * @constructor
     * @memberof Konva
     * @param {Function} func function executed on each animation frame.  The function is passed a frame object, which contains
     *  timeDiff, lastTime, time, and frameRate properties.  The timeDiff property is the number of milliseconds that have passed
     *  since the last animation frame.  The lastTime property is time in milliseconds that elapsed from the moment the animation started
     *  to the last animation frame.  The time property is the time in milliseconds that ellapsed from the moment the animation started
     *  to the current animation frame.  The frameRate property is the current frame rate in frames / second. Return false from function,
     *  if you don't need to redraw layer/layers on some frames.
     * @param {Konva.Layer|Array} [layers] layer(s) to be redrawn on each animation frame. Can be a layer, an array of layers, or null.
     *  Not specifying a node will result in no redraw.
     * @example
     * // move a node to the right at 50 pixels / second
     * var velocity = 50;
     *
     * var anim = new Konva.Animation(function(frame) {
     *   var dist = velocity * (frame.timeDiff / 1000);
     *   node.move(dist, 0);
     * }, layer);
     *
     * anim.start();
     */
  Konva.Animation = function(func, layers) {
    var Anim = Konva.Animation;
    this.func = func;
    this.setLayers(layers);
    this.id = Anim.animIdCounter++;
    this.frame = {
      time: 0,
      timeDiff: 0,
      lastTime: now()
    };
  };
  /*
     * Animation methods
     */
  Konva.Animation.prototype = {
    /**
         * set layers to be redrawn on each animation frame
         * @method
         * @memberof Konva.Animation.prototype
         * @param {Konva.Layer|Array} [layers] layer(s) to be redrawn.&nbsp; Can be a layer, an array of layers, or null.  Not specifying a node will result in no redraw.
         * @return {Konva.Animation} this
         */
    setLayers: function(layers) {
      var lays = [];
      // if passing in no layers
      if (!layers) {
        lays = [];
      } else if (layers.length > 0) {
        // if passing in an array of Layers
        // NOTE: layers could be an array or Konva.Collection.  for simplicity, I'm just inspecting
        // the length property to check for both cases
        lays = layers;
      } else {
        // if passing in a Layer
        lays = [layers];
      }

      this.layers = lays;
      return this;
    },
    /**
         * get layers
         * @method
         * @memberof Konva.Animation.prototype
         * @return {Array} Array of Konva.Layer
         */
    getLayers: function() {
      return this.layers;
    },
    /**
         * add layer.  Returns true if the layer was added, and false if it was not
         * @method
         * @memberof Konva.Animation.prototype
         * @param {Konva.Layer} layer to add
         * @return {Bool} true if layer is added to animation, otherwise false
         */
    addLayer: function(layer) {
      var layers = this.layers, len = layers.length, n;

      // don't add the layer if it already exists
      for (n = 0; n < len; n++) {
        if (layers[n]._id === layer._id) {
          return false;
        }
      }

      this.layers.push(layer);
      return true;
    },
    /**
         * determine if animation is running or not.  returns true or false
         * @method
         * @memberof Konva.Animation.prototype
         * @return {Bool} is animation running?
         */
    isRunning: function() {
      var a = Konva.Animation,
        animations = a.animations,
        len = animations.length,
        n;

      for (n = 0; n < len; n++) {
        if (animations[n].id === this.id) {
          return true;
        }
      }
      return false;
    },
    /**
         * start animation
         * @method
         * @memberof Konva.Animation.prototype
         * @return {Konva.Animation} this
         */
    start: function() {
      var Anim = Konva.Animation;
      this.stop();
      this.frame.timeDiff = 0;
      this.frame.lastTime = now();
      Anim._addAnimation(this);
      return this;
    },
    /**
         * stop animation
         * @method
         * @memberof Konva.Animation.prototype
         * @return {Konva.Animation} this
         */
    stop: function() {
      Konva.Animation._removeAnimation(this);
      return this;
    },
    _updateFrameObject: function(time) {
      this.frame.timeDiff = time - this.frame.lastTime;
      this.frame.lastTime = time;
      this.frame.time += this.frame.timeDiff;
      this.frame.frameRate = 1000 / this.frame.timeDiff;
    }
  };
  Konva.Animation.animations = [];
  Konva.Animation.animIdCounter = 0;
  Konva.Animation.animRunning = false;

  Konva.Animation._addAnimation = function(anim) {
    this.animations.push(anim);
    this._handleAnimation();
  };
  Konva.Animation._removeAnimation = function(anim) {
    var id = anim.id, animations = this.animations, len = animations.length, n;

    for (n = 0; n < len; n++) {
      if (animations[n].id === id) {
        this.animations.splice(n, 1);
        break;
      }
    }
  };

  Konva.Animation._runFrames = function() {
    var layerHash = {},
      animations = this.animations,
      anim,
      layers,
      func,
      n,
      i,
      layersLen,
      layer,
      key,
      needRedraw;
    /*
         * loop through all animations and execute animation
         *  function.  if the animation object has specified node,
         *  we can add the node to the nodes hash to eliminate
         *  drawing the same node multiple times.  The node property
         *  can be the stage itself or a layer
         */
    /*
         * WARNING: don't cache animations.length because it could change while
         * the for loop is running, causing a JS error
         */

    for (n = 0; n < animations.length; n++) {
      anim = animations[n];
      layers = anim.layers;
      func = anim.func;

      anim._updateFrameObject(now());
      layersLen = layers.length;

      // if animation object has a function, execute it
      if (func) {
        // allow anim bypassing drawing
        needRedraw = func.call(anim, anim.frame) !== false;
      } else {
        needRedraw = true;
      }
      if (!needRedraw) {
        continue;
      }
      for (i = 0; i < layersLen; i++) {
        layer = layers[i];

        if (layer._id !== undefined) {
          layerHash[layer._id] = layer;
        }
      }
    }

    for (key in layerHash) {
      if (!layerHash.hasOwnProperty(key)) {
        continue;
      }
      layerHash[key].draw();
    }
  };
  Konva.Animation._animationLoop = function() {
    var Anim = Konva.Animation;
    if (Anim.animations.length) {
      Anim._runFrames();
      requestAnimFrame(Anim._animationLoop);
    } else {
      Anim.animRunning = false;
    }
  };
  Konva.Animation._handleAnimation = function() {
    if (!this.animRunning) {
      this.animRunning = true;
      requestAnimFrame(this._animationLoop);
    }
  };

  /**
     * batch draw. this function will not do immediate draw
     * but it will schedule drawing to next tick (requestAnimFrame)
     * @method
     * @return {Konva.Layer} this
     * @memberof Konva.Base.prototype
     */
  Konva.BaseLayer.prototype.batchDraw = function() {
    var that = this, Anim = Konva.Animation;

    if (!this.batchAnim) {
      this.batchAnim = new Anim(function() {
        // stop animation after first tick
        that.batchAnim.stop();
      }, this);
    }

    if (!this.batchAnim.isRunning()) {
      this.batchAnim.start();
    }
    return this;
  };

  /**
     * batch draw
     * @method
     * @return {Konva.Stage} this
     * @memberof Konva.Stage.prototype
     */
  Konva.Stage.prototype.batchDraw = function() {
    this.getChildren().each(function(layer) {
      layer.batchDraw();
    });
    return this;
  };
})(Konva);

(function() {
  'use strict';
  var blacklist = {
    node: 1,
    duration: 1,
    easing: 1,
    onFinish: 1,
    yoyo: 1
  },
    PAUSED = 1,
    PLAYING = 2,
    REVERSING = 3,
    idCounter = 0,
    colorAttrs = ['fill', 'stroke', 'shadowColor'];

  var Tween = function(prop, propFunc, func, begin, finish, duration, yoyo) {
    this.prop = prop;
    this.propFunc = propFunc;
    this.begin = begin;
    this._pos = begin;
    this.duration = duration;
    this._change = 0;
    this.prevPos = 0;
    this.yoyo = yoyo;
    this._time = 0;
    this._position = 0;
    this._startTime = 0;
    this._finish = 0;
    this.func = func;
    this._change = finish - this.begin;
    this.pause();
  };
  /*
     * Tween methods
     */
  Tween.prototype = {
    fire: function(str) {
      var handler = this[str];
      if (handler) {
        handler();
      }
    },
    setTime: function(t) {
      if (t > this.duration) {
        if (this.yoyo) {
          this._time = this.duration;
          this.reverse();
        } else {
          this.finish();
        }
      } else if (t < 0) {
        if (this.yoyo) {
          this._time = 0;
          this.play();
        } else {
          this.reset();
        }
      } else {
        this._time = t;
        this.update();
      }
    },
    getTime: function() {
      return this._time;
    },
    setPosition: function(p) {
      this.prevPos = this._pos;
      this.propFunc(p);
      this._pos = p;
    },
    getPosition: function(t) {
      if (t === undefined) {
        t = this._time;
      }
      return this.func(t, this.begin, this._change, this.duration);
    },
    play: function() {
      this.state = PLAYING;
      this._startTime = this.getTimer() - this._time;
      this.onEnterFrame();
      this.fire('onPlay');
    },
    reverse: function() {
      this.state = REVERSING;
      this._time = this.duration - this._time;
      this._startTime = this.getTimer() - this._time;
      this.onEnterFrame();
      this.fire('onReverse');
    },
    seek: function(t) {
      this.pause();
      this._time = t;
      this.update();
      this.fire('onSeek');
    },
    reset: function() {
      this.pause();
      this._time = 0;
      this.update();
      this.fire('onReset');
    },
    finish: function() {
      this.pause();
      this._time = this.duration;
      this.update();
      this.fire('onFinish');
    },
    update: function() {
      this.setPosition(this.getPosition(this._time));
    },
    onEnterFrame: function() {
      var t = this.getTimer() - this._startTime;
      if (this.state === PLAYING) {
        this.setTime(t);
      } else if (this.state === REVERSING) {
        this.setTime(this.duration - t);
      }
    },
    pause: function() {
      this.state = PAUSED;
      this.fire('onPause');
    },
    getTimer: function() {
      return new Date().getTime();
    }
  };

  /**
     * Tween constructor.  Tweens enable you to animate a node between the current state and a new state.
     *  You can play, pause, reverse, seek, reset, and finish tweens.  By default, tweens are animated using
     *  a linear easing.  For more tweening options, check out {@link Konva.Easings}
     * @constructor
     * @memberof Konva
     * @example
     * // instantiate new tween which fully rotates a node in 1 second
     * var tween = new Konva.Tween({
     *   node: node,
     *   rotationDeg: 360,
     *   duration: 1,
     *   easing: Konva.Easings.EaseInOut
     * });
     *
     * // play tween
     * tween.play();
     *
     * // pause tween
     * tween.pause();
     */
  Konva.Tween = function(config) {
    var that = this,
      node = config.node,
      nodeId = node._id,
      duration,
      easing = config.easing || Konva.Easings.Linear,
      yoyo = !!config.yoyo,
      key;

    if (typeof config.duration === 'undefined') {
      duration = 1;
    } else if (config.duration === 0) {
      // zero is bad value for duration
      duration = 0.001;
    } else {
      duration = config.duration;
    }
    this.node = node;
    this._id = idCounter++;

    var layers =
      node.getLayer() ||
      (node instanceof Konva.Stage ? node.getLayers() : null);
    if (!layers) {
      Konva.Util.error(
        'Tween constructor have `node` that is not in a layer. Please add node into layer first.'
      );
    }
    this.anim = new Konva.Animation(function() {
      that.tween.onEnterFrame();
    }, layers);

    this.tween = new Tween(
      key,
      function(i) {
        that._tweenFunc(i);
      },
      easing,
      0,
      1,
      duration * 1000,
      yoyo
    );

    this._addListeners();

    // init attrs map
    if (!Konva.Tween.attrs[nodeId]) {
      Konva.Tween.attrs[nodeId] = {};
    }
    if (!Konva.Tween.attrs[nodeId][this._id]) {
      Konva.Tween.attrs[nodeId][this._id] = {};
    }
    // init tweens map
    if (!Konva.Tween.tweens[nodeId]) {
      Konva.Tween.tweens[nodeId] = {};
    }

    for (key in config) {
      if (blacklist[key] === undefined) {
        this._addAttr(key, config[key]);
      }
    }

    this.reset();

    // callbacks
    this.onFinish = config.onFinish;
    this.onReset = config.onReset;
  };

  // start/diff object = attrs.nodeId.tweenId.attr
  Konva.Tween.attrs = {};
  // tweenId = tweens.nodeId.attr
  Konva.Tween.tweens = {};

  Konva.Tween.prototype = {
    _addAttr: function(key, end) {
      var node = this.node,
        nodeId = node._id,
        start,
        diff,
        tweenId,
        n,
        len,
        trueEnd,
        trueStart;

      // remove conflict from tween map if it exists
      tweenId = Konva.Tween.tweens[nodeId][key];

      if (tweenId) {
        delete Konva.Tween.attrs[nodeId][tweenId][key];
      }

      // add to tween map
      start = node.getAttr(key);

      if (Konva.Util._isArray(end)) {
        diff = [];
        len = Math.max(end.length, start.length);

        if (key === 'points' && end.length !== start.length) {
          // before tweening points we need to make sure that start.length === end.length
          // Konva.Util._prepareArrayForTween thinking that end.length > start.length

          if (end.length > start.length) {
            // so in this case we will increase number of starting points
            trueStart = start;
            start = Konva.Util._prepareArrayForTween(start, end, node.closed());
          } else {
            // in this case we will increase number of eding points
            trueEnd = end;
            end = Konva.Util._prepareArrayForTween(end, start, node.closed());
          }
        }

        for (n = 0; n < len; n++) {
          diff.push(end[n] - start[n]);
        }
      } else if (colorAttrs.indexOf(key) !== -1) {
        start = Konva.Util.colorToRGBA(start);
        var endRGBA = Konva.Util.colorToRGBA(end);
        diff = {
          r: endRGBA.r - start.r,
          g: endRGBA.g - start.g,
          b: endRGBA.b - start.b,
          a: endRGBA.a - start.a
        };
      } else {
        diff = end - start;
      }

      Konva.Tween.attrs[nodeId][this._id][key] = {
        start: start,
        diff: diff,
        end: end,
        trueEnd: trueEnd,
        trueStart: trueStart
      };
      Konva.Tween.tweens[nodeId][key] = this._id;
    },
    _tweenFunc: function(i) {
      var node = this.node,
        attrs = Konva.Tween.attrs[node._id][this._id],
        key,
        attr,
        start,
        diff,
        newVal,
        n,
        len,
        end;

      for (key in attrs) {
        attr = attrs[key];
        start = attr.start;
        diff = attr.diff;
        end = attr.end;

        if (Konva.Util._isArray(start)) {
          newVal = [];
          len = Math.max(start.length, end.length);
          for (n = 0; n < len; n++) {
            newVal.push((start[n] || 0) + diff[n] * i);
          }
        } else if (colorAttrs.indexOf(key) !== -1) {
          newVal =
            'rgba(' +
            Math.round(start.r + diff.r * i) +
            ',' +
            Math.round(start.g + diff.g * i) +
            ',' +
            Math.round(start.b + diff.b * i) +
            ',' +
            (start.a + diff.a * i) +
            ')';
        } else {
          newVal = start + diff * i;
        }

        node.setAttr(key, newVal);
      }
    },
    _addListeners: function() {
      var that = this;

      // start listeners
      this.tween.onPlay = function() {
        that.anim.start();
      };
      this.tween.onReverse = function() {
        that.anim.start();
      };

      // stop listeners
      this.tween.onPause = function() {
        that.anim.stop();
      };
      this.tween.onFinish = function() {
        var node = that.node;

        // after tweening  points of line we need to set original end
        var attrs = Konva.Tween.attrs[node._id][that._id];
        if (attrs.points && attrs.points.trueEnd) {
          node.points(attrs.points.trueEnd);
        }

        if (that.onFinish) {
          that.onFinish.call(that);
        }
      };
      this.tween.onReset = function() {
        var node = that.node;
        // after tweening  points of line we need to set original start
        var attrs = Konva.Tween.attrs[node._id][that._id];
        if (attrs.points && attrs.points.trueStart) {
          node.points(attrs.points.trueStart);
        }

        if (that.onReset) {
          that.onReset();
        }
      };
    },
    /**
         * play
         * @method
         * @memberof Konva.Tween.prototype
         * @returns {Tween}
         */
    play: function() {
      this.tween.play();
      return this;
    },
    /**
         * reverse
         * @method
         * @memberof Konva.Tween.prototype
         * @returns {Tween}
         */
    reverse: function() {
      this.tween.reverse();
      return this;
    },
    /**
         * reset
         * @method
         * @memberof Konva.Tween.prototype
         * @returns {Tween}
         */
    reset: function() {
      this.tween.reset();
      return this;
    },
    /**
         * seek
         * @method
         * @memberof Konva.Tween.prototype
         * @param {Integer} t time in seconds between 0 and the duration
         * @returns {Tween}
         */
    seek: function(t) {
      this.tween.seek(t * 1000);
      return this;
    },
    /**
         * pause
         * @method
         * @memberof Konva.Tween.prototype
         * @returns {Tween}
         */
    pause: function() {
      this.tween.pause();
      return this;
    },
    /**
         * finish
         * @method
         * @memberof Konva.Tween.prototype
         * @returns {Tween}
         */
    finish: function() {
      this.tween.finish();
      return this;
    },
    /**
         * destroy
         * @method
         * @memberof Konva.Tween.prototype
         */
    destroy: function() {
      var nodeId = this.node._id,
        thisId = this._id,
        attrs = Konva.Tween.tweens[nodeId],
        key;

      this.pause();

      for (key in attrs) {
        delete Konva.Tween.tweens[nodeId][key];
      }

      delete Konva.Tween.attrs[nodeId][thisId];
    }
  };

  /**
     * Tween node properties. Shorter usage of {@link Konva.Tween} object.
     *
     * @method Konva.Node#to
     * @memberof Konva.Node
     * @param {Object} [params] tween params
     * @example
     *
     * circle.to({
     *  x : 50,
     *  duration : 0.5
     * });
     */
  Konva.Node.prototype.to = function(params) {
    var onFinish = params.onFinish;
    params.node = this;
    params.onFinish = function() {
      this.destroy();
      if (onFinish) {
        onFinish();
      }
    };
    var tween = new Konva.Tween(params);
    tween.play();
  };

  /*
    * These eases were ported from an Adobe Flash tweening library to JavaScript
    * by Xaric
    */

  /**
     * @namespace Easings
     * @memberof Konva
     */
  Konva.Easings = {
    /**
        * back ease in
        * @function
        * @memberof Konva.Easings
        */
    BackEaseIn: function(t, b, c, d) {
      var s = 1.70158;
      return c * (t /= d) * t * ((s + 1) * t - s) + b;
    },
    /**
        * back ease out
        * @function
        * @memberof Konva.Easings
        */
    BackEaseOut: function(t, b, c, d) {
      var s = 1.70158;
      return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
    },
    /**
        * back ease in out
        * @function
        * @memberof Konva.Easings
        */
    BackEaseInOut: function(t, b, c, d) {
      var s = 1.70158;
      if ((t /= d / 2) < 1) {
        return c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b;
      }
      return c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;
    },
    /**
        * elastic ease in
        * @function
        * @memberof Konva.Easings
        */
    ElasticEaseIn: function(t, b, c, d, a, p) {
      // added s = 0
      var s = 0;
      if (t === 0) {
        return b;
      }
      if ((t /= d) === 1) {
        return b + c;
      }
      if (!p) {
        p = d * 0.3;
      }
      if (!a || a < Math.abs(c)) {
        a = c;
        s = p / 4;
      } else {
        s = p / (2 * Math.PI) * Math.asin(c / a);
      }
      return (
        -(a *
          Math.pow(2, 10 * (t -= 1)) *
          Math.sin((t * d - s) * (2 * Math.PI) / p)) + b
      );
    },
    /**
        * elastic ease out
        * @function
        * @memberof Konva.Easings
        */
    ElasticEaseOut: function(t, b, c, d, a, p) {
      // added s = 0
      var s = 0;
      if (t === 0) {
        return b;
      }
      if ((t /= d) === 1) {
        return b + c;
      }
      if (!p) {
        p = d * 0.3;
      }
      if (!a || a < Math.abs(c)) {
        a = c;
        s = p / 4;
      } else {
        s = p / (2 * Math.PI) * Math.asin(c / a);
      }
      return (
        a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) +
        c +
        b
      );
    },
    /**
        * elastic ease in out
        * @function
        * @memberof Konva.Easings
        */
    ElasticEaseInOut: function(t, b, c, d, a, p) {
      // added s = 0
      var s = 0;
      if (t === 0) {
        return b;
      }
      if ((t /= d / 2) === 2) {
        return b + c;
      }
      if (!p) {
        p = d * (0.3 * 1.5);
      }
      if (!a || a < Math.abs(c)) {
        a = c;
        s = p / 4;
      } else {
        s = p / (2 * Math.PI) * Math.asin(c / a);
      }
      if (t < 1) {
        return (
          -0.5 *
            (a *
              Math.pow(2, 10 * (t -= 1)) *
              Math.sin((t * d - s) * (2 * Math.PI) / p)) +
          b
        );
      }
      return (
        a *
          Math.pow(2, -10 * (t -= 1)) *
          Math.sin((t * d - s) * (2 * Math.PI) / p) *
          0.5 +
        c +
        b
      );
    },
    /**
        * bounce ease out
        * @function
        * @memberof Konva.Easings
        */
    BounceEaseOut: function(t, b, c, d) {
      if ((t /= d) < 1 / 2.75) {
        return c * (7.5625 * t * t) + b;
      } else if (t < 2 / 2.75) {
        return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;
      } else if (t < 2.5 / 2.75) {
        return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;
      } else {
        return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;
      }
    },
    /**
        * bounce ease in
        * @function
        * @memberof Konva.Easings
        */
    BounceEaseIn: function(t, b, c, d) {
      return c - Konva.Easings.BounceEaseOut(d - t, 0, c, d) + b;
    },
    /**
        * bounce ease in out
        * @function
        * @memberof Konva.Easings
        */
    BounceEaseInOut: function(t, b, c, d) {
      if (t < d / 2) {
        return Konva.Easings.BounceEaseIn(t * 2, 0, c, d) * 0.5 + b;
      } else {
        return (
          Konva.Easings.BounceEaseOut(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b
        );
      }
    },
    /**
        * ease in
        * @function
        * @memberof Konva.Easings
        */
    EaseIn: function(t, b, c, d) {
      return c * (t /= d) * t + b;
    },
    /**
        * ease out
        * @function
        * @memberof Konva.Easings
        */
    EaseOut: function(t, b, c, d) {
      return -c * (t /= d) * (t - 2) + b;
    },
    /**
        * ease in out
        * @function
        * @memberof Konva.Easings
        */
    EaseInOut: function(t, b, c, d) {
      if ((t /= d / 2) < 1) {
        return c / 2 * t * t + b;
      }
      return -c / 2 * (--t * (t - 2) - 1) + b;
    },
    /**
        * strong ease in
        * @function
        * @memberof Konva.Easings
        */
    StrongEaseIn: function(t, b, c, d) {
      return c * (t /= d) * t * t * t * t + b;
    },
    /**
        * strong ease out
        * @function
        * @memberof Konva.Easings
        */
    StrongEaseOut: function(t, b, c, d) {
      return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
    },
    /**
        * strong ease in out
        * @function
        * @memberof Konva.Easings
        */
    StrongEaseInOut: function(t, b, c, d) {
      if ((t /= d / 2) < 1) {
        return c / 2 * t * t * t * t * t + b;
      }
      return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
    },
    /**
        * linear
        * @function
        * @memberof Konva.Easings
        */
    Linear: function(t, b, c, d) {
      return c * t / d + b;
    }
  };
})();

(function() {
  'use strict';
  Konva.DD = {
    // properties
    anim: new Konva.Animation(function() {
      var b = this.dirty;
      this.dirty = false;
      return b;
    }),
    isDragging: false,
    justDragged: false,
    offset: {
      x: 0,
      y: 0
    },
    node: null,

    // methods
    _drag: function(evt) {
      var dd = Konva.DD,
        node = dd.node;
      if (node) {
        if (!dd.isDragging) {
          var pos = node.getStage().getPointerPosition();
          // it is possible that pos is undefined
          // reattach it
          if (!pos) {
            node.getStage()._setPointerPosition(evt);
            pos = node.getStage().getPointerPosition();
          }
          var dragDistance = node.dragDistance();
          var distance = Math.max(
            Math.abs(pos.x - dd.startPointerPos.x),
            Math.abs(pos.y - dd.startPointerPos.y)
          );
          if (distance < dragDistance) {
            return;
          }
        }

        node.getStage()._setPointerPosition(evt);
        node._setDragPosition(evt);
        if (!dd.isDragging) {
          dd.isDragging = true;
          node.fire(
            'dragstart',
            {
              type: 'dragstart',
              target: node,
              evt: evt
            },
            true
          );
        }

        // execute ondragmove if defined
        node.fire(
          'dragmove',
          {
            type: 'dragmove',
            target: node,
            evt: evt
          },
          true
        );
      }
    },
    _endDragBefore: function(evt) {
      var dd = Konva.DD,
        node = dd.node,
        layer;

      if (node) {
        layer = node.getLayer();
        dd.anim.stop();

        // only fire dragend event if the drag and drop
        // operation actually started.
        if (dd.isDragging) {
          dd.isDragging = false;
          dd.justDragged = true;
          Konva.listenClickTap = false;

          if (evt) {
            evt.dragEndNode = node;
          }
        }

        delete dd.node;

        if (node.getLayer() || layer || node instanceof Konva.Stage) {
          (layer || node).draw();
        }
      }
    },
    _endDragAfter: function(evt) {
      evt = evt || {};
      var dragEndNode = evt.dragEndNode;

      if (evt && dragEndNode) {
        dragEndNode.fire(
          'dragend',
          {
            type: 'dragend',
            target: dragEndNode,
            evt: evt
          },
          true
        );
      }
    }
  };

  // Node extenders

  /**
     * initiate drag and drop
     * @method
     * @memberof Konva.Node.prototype
     */
  Konva.Node.prototype.startDrag = function() {
    var dd = Konva.DD,
      stage = this.getStage(),
      layer = this.getLayer(),
      pos = stage.getPointerPosition(),
      ap = this.getAbsolutePosition();

    if (pos) {
      if (dd.node) {
        dd.node.stopDrag();
      }

      dd.node = this;
      dd.startPointerPos = pos;
      dd.offset.x = pos.x - ap.x;
      dd.offset.y = pos.y - ap.y;
      dd.anim.setLayers(layer || this.getLayers());
      dd.anim.start();

      this._setDragPosition();
    }
  };

  Konva.Node.prototype._setDragPosition = function(evt) {
    var dd = Konva.DD,
      pos = this.getStage().getPointerPosition(),
      dbf = this.getDragBoundFunc();
    if (!pos) {
      return;
    }
    var newNodePos = {
      x: pos.x - dd.offset.x,
      y: pos.y - dd.offset.y
    };

    if (dbf !== undefined) {
      newNodePos = dbf.call(this, newNodePos, evt);
    }
    this.setAbsolutePosition(newNodePos);

    if (
      !this._lastPos ||
      this._lastPos.x !== newNodePos.x ||
      this._lastPos.y !== newNodePos.y
    ) {
      dd.anim.dirty = true;
    }

    this._lastPos = newNodePos;
  };

  /**
     * stop drag and drop
     * @method
     * @memberof Konva.Node.prototype
     */
  Konva.Node.prototype.stopDrag = function() {
    var dd = Konva.DD,
      evt = {};
    dd._endDragBefore(evt);
    dd._endDragAfter(evt);
  };

  Konva.Node.prototype.setDraggable = function(draggable) {
    this._setAttr('draggable', draggable);
    this._dragChange();
  };

  var origRemove = Konva.Node.prototype.remove;

  Konva.Node.prototype.__originalRemove = origRemove;
  Konva.Node.prototype.remove = function() {
    var dd = Konva.DD;

    // stop DD
    if (dd.node && dd.node._id === this._id) {
      this.stopDrag();
    }

    origRemove.call(this);
  };

  /**
     * determine if node is currently in drag and drop mode
     * @method
     * @memberof Konva.Node.prototype
     */
  Konva.Node.prototype.isDragging = function() {
    var dd = Konva.DD;
    return !!(dd.node && dd.node._id === this._id && dd.isDragging);
  };

  Konva.Node.prototype._listenDrag = function() {
    var that = this;

    this._dragCleanup();

    if (this.getClassName() === 'Stage') {
      this.on('contentMousedown.konva contentTouchstart.konva', function(evt) {
        if (!Konva.DD.node) {
          that.startDrag(evt);
        }
      });
    } else {
      this.on('mousedown.konva touchstart.konva', function(evt) {
        // ignore right and middle buttons
        if (evt.evt.button === 1 || evt.evt.button === 2) {
          return;
        }
        if (!Konva.DD.node) {
          that.startDrag(evt);
        }
      });
    }

    // listening is required for drag and drop
    /*
        this._listeningEnabled = true;
        this._clearSelfAndAncestorCache('listeningEnabled');
        */
  };

  Konva.Node.prototype._dragChange = function() {
    if (this.attrs.draggable) {
      this._listenDrag();
    } else {
      // remove event listeners
      this._dragCleanup();

      /*
             * force drag and drop to end
             * if this node is currently in
             * drag and drop mode
             */
      var stage = this.getStage();
      var dd = Konva.DD;
      if (stage && dd.node && dd.node._id === this._id) {
        dd.node.stopDrag();
      }
    }
  };

  Konva.Node.prototype._dragCleanup = function() {
    if (this.getClassName() === 'Stage') {
      this.off('contentMousedown.konva');
      this.off('contentTouchstart.konva');
    } else {
      this.off('mousedown.konva');
      this.off('touchstart.konva');
    }
  };

  Konva.Factory.addGetterSetter(Konva.Node, 'dragBoundFunc');

  /**
     * get/set drag bound function.  This is used to override the default
     *  drag and drop position
     * @name dragBoundFunc
     * @method
     * @memberof Konva.Node.prototype
     * @param {Function} dragBoundFunc
     * @returns {Function}
     * @example
     * // get drag bound function
     * var dragBoundFunc = node.dragBoundFunc();
     *
     * // create vertical drag and drop
     * node.dragBoundFunc(function(pos){
     *   return {
     *     x: this.getAbsolutePosition().x,
     *     y: pos.y
     *   };
     * });
     */

  Konva.Factory.addGetter(Konva.Node, 'draggable', false);
  Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'draggable');

  /**
     * get/set draggable flag
     * @name draggable
     * @method
     * @memberof Konva.Node.prototype
     * @param {Boolean} draggable
     * @returns {Boolean}
     * @example
     * // get draggable flag
     * var draggable = node.draggable();
     *
     * // enable drag and drop
     * node.draggable(true);
     *
     * // disable drag and drop
     * node.draggable(false);
     */

  if (Konva.isBrowser) {
    var html = Konva.document.documentElement;
    html.addEventListener('mouseup', Konva.DD._endDragBefore, true);
    html.addEventListener('touchend', Konva.DD._endDragBefore, true);

    html.addEventListener('mousemove', Konva.DD._drag);
    html.addEventListener('touchmove', Konva.DD._drag);

    html.addEventListener('mouseup', Konva.DD._endDragAfter, false);
    html.addEventListener('touchend', Konva.DD._endDragAfter, false);
  }
})();

(function() {
  'use strict';
  /**
     * Rect constructor
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Number} [config.cornerRadius]
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var rect = new Konva.Rect({
     *   width: 100,
     *   height: 50,
     *   fill: 'red',
     *   stroke: 'black',
     *   strokeWidth: 5
     * });
     */
  Konva.Rect = function(config) {
    this.___init(config);
  };

  Konva.Rect.prototype = {
    ___init: function(config) {
      Konva.Shape.call(this, config);
      this.className = 'Rect';
      this.sceneFunc(this._sceneFunc);
    },
    _sceneFunc: function(context) {
      var cornerRadius = this.getCornerRadius(),
        width = this.getWidth(),
        height = this.getHeight();

      context.beginPath();

      if (!cornerRadius) {
        // simple rect - don't bother doing all that complicated maths stuff.
        context.rect(0, 0, width, height);
      } else {
        // arcTo would be nicer, but browser support is patchy (Opera)
        cornerRadius = Math.min(cornerRadius, width / 2, height / 2);
        context.moveTo(cornerRadius, 0);
        context.lineTo(width - cornerRadius, 0);
        context.arc(
          width - cornerRadius,
          cornerRadius,
          cornerRadius,
          Math.PI * 3 / 2,
          0,
          false
        );
        context.lineTo(width, height - cornerRadius);
        context.arc(
          width - cornerRadius,
          height - cornerRadius,
          cornerRadius,
          0,
          Math.PI / 2,
          false
        );
        context.lineTo(cornerRadius, height);
        context.arc(
          cornerRadius,
          height - cornerRadius,
          cornerRadius,
          Math.PI / 2,
          Math.PI,
          false
        );
        context.lineTo(0, cornerRadius);
        context.arc(
          cornerRadius,
          cornerRadius,
          cornerRadius,
          Math.PI,
          Math.PI * 3 / 2,
          false
        );
      }
      context.closePath();
      context.fillStrokeShape(this);
    }
  };

  Konva.Util.extend(Konva.Rect, Konva.Shape);

  Konva.Factory.addGetterSetter(Konva.Rect, 'cornerRadius', 0);
  /**
     * get/set corner radius
     * @name cornerRadius
     * @method
     * @memberof Konva.Rect.prototype
     * @param {Number} cornerRadius
     * @returns {Number}
     * @example
     * // get corner radius
     * var cornerRadius = rect.cornerRadius();
     *
     * // set corner radius
     * rect.cornerRadius(10);
     */

  Konva.Collection.mapMethods(Konva.Rect);
})();

(function(Konva) {
  'use strict';
  // the 0.0001 offset fixes a bug in Chrome 27
  var PIx2 = Math.PI * 2 - 0.0001, CIRCLE = 'Circle';

  /**
     * Circle constructor
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Number} config.radius
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * // create circle
     * var circle = new Konva.Circle({
     *   radius: 40,
     *   fill: 'red',
     *   stroke: 'black'
     *   strokeWidth: 5
     * });
     */
  Konva.Circle = function(config) {
    this.___init(config);
  };

  Konva.Circle.prototype = {
    _centroid: true,
    ___init: function(config) {
      // call super constructor
      Konva.Shape.call(this, config);
      this.className = CIRCLE;
      this.sceneFunc(this._sceneFunc);
    },
    _sceneFunc: function(context) {
      context.beginPath();
      context.arc(0, 0, this.getRadius(), 0, PIx2, false);
      context.closePath();
      context.fillStrokeShape(this);
    },
    // implements Shape.prototype.getWidth()
    getWidth: function() {
      return this.getRadius() * 2;
    },
    // implements Shape.prototype.getHeight()
    getHeight: function() {
      return this.getRadius() * 2;
    },
    // implements Shape.prototype.setWidth()
    setWidth: function(width) {
      Konva.Node.prototype.setWidth.call(this, width);
      if (this.radius() !== width / 2) {
        this.setRadius(width / 2);
      }
    },
    // implements Shape.prototype.setHeight()
    setHeight: function(height) {
      Konva.Node.prototype.setHeight.call(this, height);
      if (this.radius() !== height / 2) {
        this.setRadius(height / 2);
      }
    }
  };
  Konva.Util.extend(Konva.Circle, Konva.Shape);

  // add getters setters
  Konva.Factory.addGetterSetter(Konva.Circle, 'radius', 0);
  Konva.Factory.addOverloadedGetterSetter(Konva.Circle, 'radius');

  /**
     * get/set radius
     * @name radius
     * @method
     * @memberof Konva.Circle.prototype
     * @param {Number} radius
     * @returns {Number}
     * @example
     * // get radius
     * var radius = circle.radius();
     *
     * // set radius
     * circle.radius(10);
     */

  Konva.Collection.mapMethods(Konva.Circle);
})(Konva);

(function() {
  'use strict';
  // the 0.0001 offset fixes a bug in Chrome 27
  var PIx2 = Math.PI * 2 - 0.0001, ELLIPSE = 'Ellipse';

  /**
     * Ellipse constructor
     * @constructor
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Object} config.radius defines x and y radius
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var ellipse = new Konva.Ellipse({
     *   radius : {
     *     x : 50,
     *     y : 50
     *   },
     *   fill: 'red'
     * });
     */
  Konva.Ellipse = function(config) {
    this.___init(config);
  };

  Konva.Ellipse.prototype = {
    _centroid: true,
    ___init: function(config) {
      // call super constructor
      Konva.Shape.call(this, config);
      this.className = ELLIPSE;
      this.sceneFunc(this._sceneFunc);
    },
    _sceneFunc: function(context) {
      var rx = this.getRadiusX(), ry = this.getRadiusY();

      context.beginPath();
      context.save();
      if (rx !== ry) {
        context.scale(1, ry / rx);
      }
      context.arc(0, 0, rx, 0, PIx2, false);
      context.restore();
      context.closePath();
      context.fillStrokeShape(this);
    },
    // implements Shape.prototype.getWidth()
    getWidth: function() {
      return this.getRadiusX() * 2;
    },
    // implements Shape.prototype.getHeight()
    getHeight: function() {
      return this.getRadiusY() * 2;
    },
    // implements Shape.prototype.setWidth()
    setWidth: function(width) {
      Konva.Node.prototype.setWidth.call(this, width);
      this.setRadius({
        x: width / 2
      });
    },
    // implements Shape.prototype.setHeight()
    setHeight: function(height) {
      Konva.Node.prototype.setHeight.call(this, height);
      this.setRadius({
        y: height / 2
      });
    }
  };
  Konva.Util.extend(Konva.Ellipse, Konva.Shape);

  // add getters setters
  Konva.Factory.addComponentsGetterSetter(Konva.Ellipse, 'radius', ['x', 'y']);

  /**
     * get/set radius
     * @name radius
     * @method
     * @memberof Konva.Ellipse.prototype
     * @param {Object} radius
     * @param {Number} radius.x
     * @param {Number} radius.y
     * @returns {Object}
     * @example
     * // get radius
     * var radius = ellipse.radius();
     *
     * // set radius
     * ellipse.radius({
     *   x: 200,
     *   y: 100
     * });
     */

  Konva.Factory.addGetterSetter(Konva.Ellipse, 'radiusX', 0);
  /**
     * get/set radius x
     * @name radiusX
     * @method
     * @memberof Konva.Ellipse.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get radius x
     * var radiusX = ellipse.radiusX();
     *
     * // set radius x
     * ellipse.radiusX(200);
     */

  Konva.Factory.addGetterSetter(Konva.Ellipse, 'radiusY', 0);
  /**
     * get/set radius y
     * @name radiusY
     * @method
     * @memberof Konva.Ellipse.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get radius y
     * var radiusY = ellipse.radiusY();
     *
     * // set radius y
     * ellipse.radiusY(200);
     */

  Konva.Collection.mapMethods(Konva.Ellipse);
})();

(function() {
  'use strict';
  // the 0.0001 offset fixes a bug in Chrome 27
  var PIx2 = Math.PI * 2 - 0.0001;
  /**
     * Ring constructor
     * @constructor
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Number} config.innerRadius
     * @param {Number} config.outerRadius
     * @param {Boolean} [config.clockwise]
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var ring = new Konva.Ring({
     *   innerRadius: 40,
     *   outerRadius: 80,
     *   fill: 'red',
     *   stroke: 'black',
     *   strokeWidth: 5
     * });
     */
  Konva.Ring = function(config) {
    this.___init(config);
  };

  Konva.Ring.prototype = {
    _centroid: true,
    ___init: function(config) {
      // call super constructor
      Konva.Shape.call(this, config);
      this.className = 'Ring';
      this.sceneFunc(this._sceneFunc);
    },
    _sceneFunc: function(context) {
      context.beginPath();
      context.arc(0, 0, this.getInnerRadius(), 0, PIx2, false);
      context.moveTo(this.getOuterRadius(), 0);
      context.arc(0, 0, this.getOuterRadius(), PIx2, 0, true);
      context.closePath();
      context.fillStrokeShape(this);
    },
    // implements Shape.prototype.getWidth()
    getWidth: function() {
      return this.getOuterRadius() * 2;
    },
    // implements Shape.prototype.getHeight()
    getHeight: function() {
      return this.getOuterRadius() * 2;
    },
    // implements Shape.prototype.setWidth()
    setWidth: function(width) {
      Konva.Node.prototype.setWidth.call(this, width);
      if (this.outerRadius() !== width / 2) {
        this.setOuterRadius(width / 2);
      }
    },
    // implements Shape.prototype.setHeight()
    setHeight: function(height) {
      Konva.Node.prototype.setHeight.call(this, height);
      if (this.outerRadius() !== height / 2) {
        this.setOuterRadius(height / 2);
      }
    },
    setOuterRadius: function(val) {
      this._setAttr('outerRadius', val);
      this.setWidth(val * 2);
      this.setHeight(val * 2);
    }
  };
  Konva.Util.extend(Konva.Ring, Konva.Shape);

  // add getters setters
  Konva.Factory.addGetterSetter(Konva.Ring, 'innerRadius', 0);

  /**
     * get/set innerRadius
     * @name innerRadius
     * @method
     * @memberof Konva.Ring.prototype
     * @param {Number} innerRadius
     * @returns {Number}
     * @example
     * // get inner radius
     * var innerRadius = ring.innerRadius();
     *
     * // set inner radius
     * ring.innerRadius(20);
     */
  Konva.Factory.addGetter(Konva.Ring, 'outerRadius', 0);
  Konva.Factory.addOverloadedGetterSetter(Konva.Ring, 'outerRadius');

  /**
     * get/set outerRadius
     * @name outerRadius
     * @method
     * @memberof Konva.Ring.prototype
     * @param {Number} outerRadius
     * @returns {Number}
     * @example
     * // get outer radius
     * var outerRadius = ring.outerRadius();
     *
     * // set outer radius
     * ring.outerRadius(20);
     */

  Konva.Collection.mapMethods(Konva.Ring);
})();

(function() {
  'use strict';
  /**
     * Wedge constructor
     * @constructor
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Number} config.angle in degrees
     * @param {Number} config.radius
     * @param {Boolean} [config.clockwise]
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * // draw a wedge that's pointing downwards
     * var wedge = new Konva.Wedge({
     *   radius: 40,
     *   fill: 'red',
     *   stroke: 'black'
     *   strokeWidth: 5,
     *   angleDeg: 60,
     *   rotationDeg: -120
     * });
     */
  Konva.Wedge = function(config) {
    this.___init(config);
  };

  Konva.Wedge.prototype = {
    _centroid: true,
    ___init: function(config) {
      // call super constructor
      Konva.Shape.call(this, config);
      this.className = 'Wedge';
      this.sceneFunc(this._sceneFunc);
    },
    _sceneFunc: function(context) {
      context.beginPath();
      context.arc(
        0,
        0,
        this.getRadius(),
        0,
        Konva.getAngle(this.getAngle()),
        this.getClockwise()
      );
      context.lineTo(0, 0);
      context.closePath();
      context.fillStrokeShape(this);
    },
    // implements Shape.prototype.getWidth()
    getWidth: function() {
      return this.getRadius() * 2;
    },
    // implements Shape.prototype.getHeight()
    getHeight: function() {
      return this.getRadius() * 2;
    },
    // implements Shape.prototype.setWidth()
    setWidth: function(width) {
      Konva.Node.prototype.setWidth.call(this, width);
      if (this.radius() !== width / 2) {
        this.setRadius(width / 2);
      }
    },
    // implements Shape.prototype.setHeight()
    setHeight: function(height) {
      Konva.Node.prototype.setHeight.call(this, height);
      if (this.radius() !== height / 2) {
        this.setRadius(height / 2);
      }
    }
  };
  Konva.Util.extend(Konva.Wedge, Konva.Shape);

  // add getters setters
  Konva.Factory.addGetterSetter(Konva.Wedge, 'radius', 0);

  /**
     * get/set radius
     * @name radius
     * @method
     * @memberof Konva.Wedge.prototype
     * @param {Number} radius
     * @returns {Number}
     * @example
     * // get radius
     * var radius = wedge.radius();
     *
     * // set radius
     * wedge.radius(10);
     */

  Konva.Factory.addGetterSetter(Konva.Wedge, 'angle', 0);

  /**
     * get/set angle in degrees
     * @name angle
     * @method
     * @memberof Konva.Wedge.prototype
     * @param {Number} angle
     * @returns {Number}
     * @example
     * // get angle
     * var angle = wedge.angle();
     *
     * // set angle
     * wedge.angle(20);
     */

  Konva.Factory.addGetterSetter(Konva.Wedge, 'clockwise', false);

  /**
     * get/set clockwise flag
     * @name clockwise
     * @method
     * @memberof Konva.Wedge.prototype
     * @param {Number} clockwise
     * @returns {Number}
     * @example
     * // get clockwise flag
     * var clockwise = wedge.clockwise();
     *
     * // draw wedge counter-clockwise
     * wedge.clockwise(false);
     *
     * // draw wedge clockwise
     * wedge.clockwise(true);
     */

  Konva.Factory.backCompat(Konva.Wedge, {
    angleDeg: 'angle',
    getAngleDeg: 'getAngle',
    setAngleDeg: 'setAngle'
  });

  Konva.Collection.mapMethods(Konva.Wedge);
})();

(function(Konva) {
  'use strict';
  /**
     * Arc constructor
     * @constructor
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Number} config.angle in degrees
     * @param {Number} config.innerRadius
     * @param {Number} config.outerRadius
     * @param {Boolean} [config.clockwise]
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * // draw a Arc that's pointing downwards
     * var arc = new Konva.Arc({
     *   innerRadius: 40,
     *   outerRadius: 80,
     *   fill: 'red',
     *   stroke: 'black'
     *   strokeWidth: 5,
     *   angle: 60,
     *   rotationDeg: -120
     * });
     */
  Konva.Arc = function(config) {
    this.___init(config);
  };

  Konva.Arc.prototype = {
    _centroid: true,
    ___init: function(config) {
      // call super constructor
      Konva.Shape.call(this, config);
      this.className = 'Arc';
      this.sceneFunc(this._sceneFunc);
    },
    _sceneFunc: function(context) {
      var angle = Konva.getAngle(this.angle()), clockwise = this.clockwise();

      context.beginPath();
      context.arc(0, 0, this.getOuterRadius(), 0, angle, clockwise);
      context.arc(0, 0, this.getInnerRadius(), angle, 0, !clockwise);
      context.closePath();
      context.fillStrokeShape(this);
    },
    // implements Shape.prototype.getWidth()
    getWidth: function() {
      return this.getOuterRadius() * 2;
    },
    // implements Shape.prototype.getHeight()
    getHeight: function() {
      return this.getOuterRadius() * 2;
    },
    // implements Shape.prototype.setWidth()
    setWidth: function(width) {
      Konva.Node.prototype.setWidth.call(this, width);
      if (this.getOuterRadius() !== width / 2) {
        this.setOuterRadius(width / 2);
      }
    },
    // implements Shape.prototype.setHeight()
    setHeight: function(height) {
      Konva.Node.prototype.setHeight.call(this, height);
      if (this.getOuterRadius() !== height / 2) {
        this.setOuterRadius(height / 2);
      }
    }
  };
  Konva.Util.extend(Konva.Arc, Konva.Shape);

  // add getters setters
  Konva.Factory.addGetterSetter(Konva.Arc, 'innerRadius', 0);

  /**
     * get/set innerRadius
     * @name innerRadius
     * @method
     * @memberof Konva.Arc.prototype
     * @param {Number} innerRadius
     * @returns {Number}
     * @example
     * // get inner radius
     * var innerRadius = arc.innerRadius();
     *
     * // set inner radius
     * arc.innerRadius(20);
     */

  Konva.Factory.addGetterSetter(Konva.Arc, 'outerRadius', 0);

  /**
     * get/set outerRadius
     * @name outerRadius
     * @method
     * @memberof Konva.Arc.prototype
     * @param {Number} outerRadius
     * @returns {Number}
     * @example
     * // get outer radius
     * var outerRadius = arc.outerRadius();
     *
     * // set outer radius
     * arc.outerRadius(20);
     */

  Konva.Factory.addGetterSetter(Konva.Arc, 'angle', 0);

  /**
     * get/set angle in degrees
     * @name angle
     * @method
     * @memberof Konva.Arc.prototype
     * @param {Number} angle
     * @returns {Number}
     * @example
     * // get angle
     * var angle = arc.angle();
     *
     * // set angle
     * arc.angle(20);
     */

  Konva.Factory.addGetterSetter(Konva.Arc, 'clockwise', false);

  /**
     * get/set clockwise flag
     * @name clockwise
     * @method
     * @memberof Konva.Arc.prototype
     * @param {Boolean} clockwise
     * @returns {Boolean}
     * @example
     * // get clockwise flag
     * var clockwise = arc.clockwise();
     *
     * // draw arc counter-clockwise
     * arc.clockwise(false);
     *
     * // draw arc clockwise
     * arc.clockwise(true);
     */

  Konva.Collection.mapMethods(Konva.Arc);
})(Konva);

(function() {
  'use strict';
  // CONSTANTS
  var IMAGE = 'Image';

  /**
     * Image constructor
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Image} config.image
     * @param {Object} [config.crop]
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var imageObj = new Image();
     * imageObj.onload = function() {
     *   var image = new Konva.Image({
     *     x: 200,
     *     y: 50,
     *     image: imageObj,
     *     width: 100,
     *     height: 100
     *   });
     * };
     * imageObj.src = '/path/to/image.jpg'
     */
  Konva.Image = function(config) {
    this.___init(config);
  };

  Konva.Image.prototype = {
    ___init: function(config) {
      // call super constructor
      Konva.Shape.call(this, config);
      this.className = IMAGE;
      this.sceneFunc(this._sceneFunc);
      this.hitFunc(this._hitFunc);
    },
    _useBufferCanvas: function() {
      return (
        (this.hasShadow() || this.getAbsoluteOpacity() !== 1) &&
        this.hasStroke() &&
        this.getStage()
      );
    },
    _sceneFunc: function(context) {
      var width = this.getWidth(),
        height = this.getHeight(),
        image = this.getImage(),
        cropWidth,
        cropHeight,
        params;

      if (image) {
        cropWidth = this.getCropWidth();
        cropHeight = this.getCropHeight();
        if (cropWidth && cropHeight) {
          params = [
            image,
            this.getCropX(),
            this.getCropY(),
            cropWidth,
            cropHeight,
            0,
            0,
            width,
            height
          ];
        } else {
          params = [image, 0, 0, width, height];
        }
      }

      if (this.hasFill() || this.hasStroke()) {
        context.beginPath();
        context.rect(0, 0, width, height);
        context.closePath();
        context.fillStrokeShape(this);
      }

      if (image) {
        context.drawImage.apply(context, params);
      }
    },
    _hitFunc: function(context) {
      var width = this.getWidth(), height = this.getHeight();

      context.beginPath();
      context.rect(0, 0, width, height);
      context.closePath();
      context.fillStrokeShape(this);
    },
    getWidth: function() {
      var image = this.getImage();
      return this.attrs.width || (image ? image.width : 0);
    },
    getHeight: function() {
      var image = this.getImage();
      return this.attrs.height || (image ? image.height : 0);
    }
  };
  Konva.Util.extend(Konva.Image, Konva.Shape);

  // add getters setters
  Konva.Factory.addGetterSetter(Konva.Image, 'image');

  /**
     * set image
     * @name setImage
     * @method
     * @memberof Konva.Image.prototype
     * @param {Image} image
     */

  /**
     * get image
     * @name getImage
     * @method
     * @memberof Konva.Image.prototype
     * @returns {Image}
     */

  Konva.Factory.addComponentsGetterSetter(Konva.Image, 'crop', [
    'x',
    'y',
    'width',
    'height'
  ]);
  /**
     * get/set crop
     * @method
     * @name crop
     * @memberof Konva.Image.prototype
     * @param {Object} crop
     * @param {Number} crop.x
     * @param {Number} crop.y
     * @param {Number} crop.width
     * @param {Number} crop.height
     * @returns {Object}
     * @example
     * // get crop
     * var crop = image.crop();
     *
     * // set crop
     * image.crop({
     *   x: 20,
     *   y: 20,
     *   width: 20,
     *   height: 20
     * });
     */

  Konva.Factory.addGetterSetter(Konva.Image, 'cropX', 0);
  /**
     * get/set crop x
     * @method
     * @name cropX
     * @memberof Konva.Image.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get crop x
     * var cropX = image.cropX();
     *
     * // set crop x
     * image.cropX(20);
     */

  Konva.Factory.addGetterSetter(Konva.Image, 'cropY', 0);
  /**
     * get/set crop y
     * @name cropY
     * @method
     * @memberof Konva.Image.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get crop y
     * var cropY = image.cropY();
     *
     * // set crop y
     * image.cropY(20);
     */

  Konva.Factory.addGetterSetter(Konva.Image, 'cropWidth', 0);
  /**
     * get/set crop width
     * @name cropWidth
     * @method
     * @memberof Konva.Image.prototype
     * @param {Number} width
     * @returns {Number}
     * @example
     * // get crop width
     * var cropWidth = image.cropWidth();
     *
     * // set crop width
     * image.cropWidth(20);
     */

  Konva.Factory.addGetterSetter(Konva.Image, 'cropHeight', 0);
  /**
     * get/set crop height
     * @name cropHeight
     * @method
     * @memberof Konva.Image.prototype
     * @param {Number} height
     * @returns {Number}
     * @example
     * // get crop height
     * var cropHeight = image.cropHeight();
     *
     * // set crop height
     * image.cropHeight(20);
     */

  Konva.Collection.mapMethods(Konva.Image);

  /**
     * load image from given url and create `Konva.Image` instance
     * @method
     * @memberof Konva.Image
     * @param {String} url image source
     * @param {Function} callback with Konva.Image instance as first argument
     * @example
     *  Konva.Image.fromURL(imageURL, function(image){
     *    // image is Konva.Image instance
     *    layer.add(image);
     *    layer.draw();
     *  });
     */
  Konva.Image.fromURL = function(url, callback) {
    var img = new Image();
    img.onload = function() {
      var image = new Konva.Image({
        image: img
      });
      callback(image);
    };
    img.src = url;
  };
})();

/*eslint-disable max-depth */
(function() {
  'use strict';
  // var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
  // constants
  var AUTO = 'auto',
    //CANVAS = 'canvas',
    CENTER = 'center',
    JUSTIFY = 'justify',
    CHANGE_KONVA = 'Change.konva',
    CONTEXT_2D = '2d',
    DASH = '-',
    EMPTY_STRING = '',
    LEFT = 'left',
    TEXT = 'text',
    TEXT_UPPER = 'Text',
    MIDDLE = 'middle',
    NORMAL = 'normal',
    PX_SPACE = 'px ',
    SPACE = ' ',
    RIGHT = 'right',
    WORD = 'word',
    CHAR = 'char',
    NONE = 'none',
    ATTR_CHANGE_LIST = [
      'fontFamily',
      'fontSize',
      'fontStyle',
      'fontVariant',
      'padding',
      'align',
      'lineHeight',
      'text',
      'width',
      'height',
      'wrap',
      'letterSpacing'
    ],
    // cached variables
    attrChangeListLen = ATTR_CHANGE_LIST.length;
  var dummyContext;
  function getDummyContext() {
    if (dummyContext) {
      return dummyContext;
    }
    dummyContext = Konva.Util.createCanvasElement().getContext(CONTEXT_2D);
    return dummyContext;
  }

  /**
     * Text constructor
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {String} [config.fontFamily] default is Arial
     * @param {Number} [config.fontSize] in pixels.  Default is 12
     * @param {String} [config.fontStyle] can be normal, bold, or italic.  Default is normal
     * @param {String} [config.fontVariant] can be normal or small-caps.  Default is normal
     * @param {String} config.text
     * @param {String} [config.align] can be left, center, or right
     * @param {Number} [config.padding]
     * @param {Number} [config.lineHeight] default is 1
     * @param {String} [config.wrap] can be word, char, or none. Default is word
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var text = new Konva.Text({
     *   x: 10,
     *   y: 15,
     *   text: 'Simple Text',
     *   fontSize: 30,
     *   fontFamily: 'Calibri',
     *   fill: 'green'
     * });
     */
  Konva.Text = function(config) {
    this.___init(config);
  };
  function _fillFunc(context) {
    context.fillText(this.partialText, 0, 0);
  }
  function _strokeFunc(context) {
    context.strokeText(this.partialText, 0, 0);
  }

  Konva.Text.prototype = {
    ___init: function(config) {
      config = config || {};

      // set default color to black
      if (
        !config.fillLinearGradientColorStops &&
        !config.fillRadialGradientColorStops
      ) {
        config.fill = config.fill || 'black';
      }
      //
      // if (config.width === undefined) {
      //     config.width = AUTO;
      // }
      // if (config.height === undefined) {
      //     config.height = AUTO;
      // }

      // call super constructor
      Konva.Shape.call(this, config);

      this._fillFunc = _fillFunc;
      this._strokeFunc = _strokeFunc;
      this.className = TEXT_UPPER;

      // update text data for certain attr changes
      for (var n = 0; n < attrChangeListLen; n++) {
        this.on(ATTR_CHANGE_LIST[n] + CHANGE_KONVA, this._setTextData);
      }

      this._setTextData();
      this.sceneFunc(this._sceneFunc);
      this.hitFunc(this._hitFunc);
    },
    _sceneFunc: function(context) {
      var p = this.getPadding(),
        textHeight = this.getTextHeight(),
        lineHeightPx = this.getLineHeight() * textHeight,
        textArr = this.textArr,
        textArrLen = textArr.length,
        align = this.getAlign(),
        totalWidth = this.getWidth(),
        letterSpacing = this.getLetterSpacing(),
        textDecoration = this.textDecoration(),
        fill = this.fill(),
        fontSize = this.fontSize(),
        n;

      context.setAttr('font', this._getContextFont());

      context.setAttr('textBaseline', MIDDLE);
      context.setAttr('textAlign', LEFT);
      context.save();
      if (p) {
        context.translate(p, 0);
        context.translate(0, p + textHeight / 2);
      } else {
        context.translate(0, textHeight / 2);
      }

      // draw text lines
      for (n = 0; n < textArrLen; n++) {
        var obj = textArr[n],
          text = obj.text,
          width = obj.width;

        // horizontal alignment
        context.save();
        if (align === RIGHT) {
          context.translate(totalWidth - width - p * 2, 0);
        } else if (align === CENTER) {
          context.translate((totalWidth - width - p * 2) / 2, 0);
        }

        if (textDecoration.indexOf('underline') !== -1) {
          context.save();
          context.beginPath();
          context.moveTo(0, Math.round(lineHeightPx / 2));
          context.lineTo(Math.round(width), Math.round(lineHeightPx / 2));
          // TODO: I have no idea what is real ratio
          // just /20 looks good enough
          context.lineWidth = fontSize / 15;
          context.strokeStyle = fill;
          context.stroke();
          context.restore();
        }
        if (textDecoration.indexOf('line-through') !== -1) {
          context.save();
          context.beginPath();
          context.moveTo(0, 0);
          context.lineTo(Math.round(width), 0);
          context.lineWidth = fontSize / 15;
          context.strokeStyle = fill;
          context.stroke();
          context.restore();
        }
        if (letterSpacing !== 0 || align === JUSTIFY) {
          //   var words = text.split(' ');
          var spacesNumber = text.split(' ').length - 1;
          for (var li = 0; li < text.length; li++) {
            var letter = text[li];
            // skip justify for the last line
            if (letter === ' ' && n !== textArrLen - 1 && align === JUSTIFY) {
              context.translate(
                Math.floor((totalWidth - width) / spacesNumber),
                0
              );
            }
            this.partialText = letter;
            context.fillStrokeShape(this);
            context.translate(
              Math.round(this._getTextSize(letter).width) + letterSpacing,
              0
            );
          }
        } else {
          this.partialText = text;

          context.fillStrokeShape(this);
        }
        context.restore();
        context.translate(0, lineHeightPx);
      }
      context.restore();
    },
    _hitFunc: function(context) {
      var width = this.getWidth(),
        height = this.getHeight();

      context.beginPath();
      context.rect(0, 0, width, height);
      context.closePath();
      context.fillStrokeShape(this);
    },
    // _useBufferCanvas: function(caching) {
    //     var useIt = Konva.Shape.prototype._useBufferCanvas.call(this, caching);
    //     if (useIt) {
    //       return true;
    //     }
    //     return false;
    //     // return isFirefox && this.hasFill() && this.hasShadow();
    // },
    setText: function(text) {
      var str = Konva.Util._isString(text) ? text : (text || '').toString();
      this._setAttr(TEXT, str);
      return this;
    },
    /**
         * get width of text area, which includes padding
         * @method
         * @memberof Konva.Text.prototype
         * @returns {Number}
         */
    getWidth: function() {
      var isAuto = this.attrs.width === AUTO || this.attrs.width === undefined;
      return isAuto
        ? this.getTextWidth() + this.getPadding() * 2
        : this.attrs.width;
    },
    /**
         * get the height of the text area, which takes into account multi-line text, line heights, and padding
         * @method
         * @memberof Konva.Text.prototype
         * @returns {Number}
         */
    getHeight: function() {
      var isAuto =
        this.attrs.height === AUTO || this.attrs.height === undefined;
      return isAuto
        ? this.getTextHeight() * this.textArr.length * this.getLineHeight() +
          this.getPadding() * 2
        : this.attrs.height;
    },
    /**
         * get text width
         * @method
         * @memberof Konva.Text.prototype
         * @returns {Number}
         */
    getTextWidth: function() {
      return this.textWidth;
    },
    /**
         * get text height
         * @method
         * @memberof Konva.Text.prototype
         * @returns {Number}
         */
    getTextHeight: function() {
      return this.textHeight;
    },
    _getTextSize: function(text) {
      var _context = getDummyContext(),
        fontSize = this.getFontSize(),
        metrics;

      _context.save();
      _context.font = this._getContextFont();

      metrics = _context.measureText(text);
      _context.restore();
      return {
        width: metrics.width,
        height: parseInt(fontSize, 10)
      };
    },
    _getContextFont: function() {
      // IE don't want to work with usual font style
      // bold was not working
      // removing font variant will solve
      // fix for: https://github.com/konvajs/konva/issues/94
      if (Konva.UA.isIE) {
        return (
          this.getFontStyle() +
          SPACE +
          this.getFontSize() +
          PX_SPACE +
          this.getFontFamily()
        );
      }
      return (
        this.getFontStyle() +
        SPACE +
        this.getFontVariant() +
        SPACE +
        this.getFontSize() +
        PX_SPACE +
        this.getFontFamily()
      );
    },
    _addTextLine: function(line) {
      if (this.align() === JUSTIFY) {
        line = line.trim();
      }
      var width = this._getTextWidth(line);
      return this.textArr.push({ text: line, width: width });
    },
    _getTextWidth: function(text) {
      var latterSpacing = this.getLetterSpacing();
      var length = text.length;
      return (
        getDummyContext().measureText(text).width +
        (length ? latterSpacing * (length - 1) : 0)
      );
    },
    _setTextData: function() {
      var lines = this.getText().split('\n'),
        fontSize = +this.getFontSize(),
        textWidth = 0,
        lineHeightPx = this.getLineHeight() * fontSize,
        width = this.attrs.width,
        height = this.attrs.height,
        fixedWidth = width !== AUTO,
        fixedHeight = height !== AUTO,
        padding = this.getPadding(),
        maxWidth = width - padding * 2,
        maxHeightPx = height - padding * 2,
        currentHeightPx = 0,
        wrap = this.getWrap(),
        shouldWrap = wrap !== NONE,
        wrapAtWord = wrap !== CHAR && shouldWrap;

      this.textArr = [];
      getDummyContext().save();
      getDummyContext().font = this._getContextFont();
      for (var i = 0, max = lines.length; i < max; ++i) {
        var line = lines[i];

        var lineWidth = this._getTextWidth(line);
        if (fixedWidth && lineWidth > maxWidth) {
          /*
                     * if width is fixed and line does not fit entirely
                     * break the line into multiple fitting lines
                     */
          while (line.length > 0) {
            /*
                         * use binary search to find the longest substring that
                         * that would fit in the specified width
                         */
            var low = 0,
              high = line.length,
              match = '',
              matchWidth = 0;
            while (low < high) {
              var mid = (low + high) >>> 1,
                substr = line.slice(0, mid + 1),
                substrWidth = this._getTextWidth(substr);
              if (substrWidth <= maxWidth) {
                low = mid + 1;
                match = substr;
                matchWidth = substrWidth;
              } else {
                high = mid;
              }
            }
            /*
                         * 'low' is now the index of the substring end
                         * 'match' is the substring
                         * 'matchWidth' is the substring width in px
                         */
            if (match) {
              // a fitting substring was found
              if (wrapAtWord) {
                // try to find a space or dash where wrapping could be done
                var wrapIndex =
                  Math.max(match.lastIndexOf(SPACE), match.lastIndexOf(DASH)) +
                  1;
                if (wrapIndex > 0) {
                  // re-cut the substring found at the space/dash position
                  low = wrapIndex;
                  match = match.slice(0, low);
                  matchWidth = this._getTextWidth(match);
                }
              }
              this._addTextLine(match);
              textWidth = Math.max(textWidth, matchWidth);
              currentHeightPx += lineHeightPx;
              if (
                !shouldWrap ||
                (fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx)
              ) {
                /*
                                 * stop wrapping if wrapping is disabled or if adding
                                 * one more line would overflow the fixed height
                                 */
                break;
              }
              line = line.slice(low);
              if (line.length > 0) {
                // Check if the remaining text would fit on one line
                lineWidth = this._getTextWidth(line);
                if (lineWidth <= maxWidth) {
                  // if it does, add the line and break out of the loop
                  this._addTextLine(line);
                  currentHeightPx += lineHeightPx;
                  textWidth = Math.max(textWidth, lineWidth);
                  break;
                }
              }
            } else {
              // not even one character could fit in the element, abort
              break;
            }
          }
        } else {
          // element width is automatically adjusted to max line width
          this._addTextLine(line);
          currentHeightPx += lineHeightPx;
          textWidth = Math.max(textWidth, lineWidth);
        }
        // if element height is fixed, abort if adding one more line would overflow
        if (fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx) {
          break;
        }
      }
      getDummyContext().restore();
      this.textHeight = fontSize;
      // var maxTextWidth = 0;
      // for(var j = 0; j < this.textArr.length; j++) {
      //     maxTextWidth = Math.max(maxTextWidth, this.textArr[j].width);
      // }
      this.textWidth = textWidth;
    }
  };
  Konva.Util.extend(Konva.Text, Konva.Shape);

  // add getters setters
  Konva.Factory.addGetterSetter(Konva.Text, 'fontFamily', 'Arial');

  /**
     * get/set font family
     * @name fontFamily
     * @method
     * @memberof Konva.Text.prototype
     * @param {String} fontFamily
     * @returns {String}
     * @example
     * // get font family
     * var fontFamily = text.fontFamily();
     *
     * // set font family
     * text.fontFamily('Arial');
     */

  Konva.Factory.addGetterSetter(Konva.Text, 'fontSize', 12);

  /**
     * get/set font size in pixels
     * @name fontSize
     * @method
     * @memberof Konva.Text.prototype
     * @param {Number} fontSize
     * @returns {Number}
     * @example
     * // get font size
     * var fontSize = text.fontSize();
     *
     * // set font size to 22px
     * text.fontSize(22);
     */

  Konva.Factory.addGetterSetter(Konva.Text, 'fontStyle', NORMAL);

  /**
     * set font style.  Can be 'normal', 'italic', or 'bold'.  'normal' is the default.
     * @name fontStyle
     * @method
     * @memberof Konva.Text.prototype
     * @param {String} fontStyle
     * @returns {String}
     * @example
     * // get font style
     * var fontStyle = text.fontStyle();
     *
     * // set font style
     * text.fontStyle('bold');
     */

  Konva.Factory.addGetterSetter(Konva.Text, 'fontVariant', NORMAL);

  /**
     * set font variant.  Can be 'normal' or 'small-caps'.  'normal' is the default.
     * @name fontVariant
     * @method
     * @memberof Konva.Text.prototype
     * @param {String} fontVariant
     * @returns {String}
     * @example
     * // get font variant
     * var fontVariant = text.fontVariant();
     *
     * // set font variant
     * text.fontVariant('small-caps');
     */

  Konva.Factory.addGetterSetter(Konva.Text, 'padding', 0);

  /**
     * set padding
     * @name padding
     * @method
     * @memberof Konva.Text.prototype
     * @param {Number} padding
     * @returns {Number}
     * @example
     * // get padding
     * var padding = text.padding();
     *
     * // set padding to 10 pixels
     * text.padding(10);
     */

  Konva.Factory.addGetterSetter(Konva.Text, 'align', LEFT);

  /**
     * get/set horizontal align of text.  Can be 'left', 'center', 'right' or 'justify'
     * @name align
     * @method
     * @memberof Konva.Text.prototype
     * @param {String} align
     * @returns {String}
     * @example
     * // get text align
     * var align = text.align();
     *
     * // center text
     * text.align('center');
     *
     * // align text to right
     * text.align('right');
     */

  Konva.Factory.addGetterSetter(Konva.Text, 'lineHeight', 1);

  /**
     * get/set line height.  The default is 1.
     * @name lineHeight
     * @method
     * @memberof Konva.Text.prototype
     * @param {Number} lineHeight
     * @returns {Number}
     * @example
     * // get line height
     * var lineHeight = text.lineHeight();
     *
     * // set the line height
     * text.lineHeight(2);
     */

  Konva.Factory.addGetterSetter(Konva.Text, 'wrap', WORD);

  /**
     * get/set wrap.  Can be word, char, or none. Default is word.
     * @name wrap
     * @method
     * @memberof Konva.Text.prototype
     * @param {String} wrap
     * @returns {String}
     * @example
     * // get wrap
     * var wrap = text.wrap();
     *
     * // set wrap
     * text.wrap('word');
     */

  Konva.Factory.addGetterSetter(Konva.Text, 'letterSpacing', 0);

  /**
       * set letter spacing property. Default value is 0.
       * @name letterSpacing
       * @method
       * @memberof Konva.TextPath.prototype
       * @param {Number} letterSpacing
       */

  Konva.Factory.addGetter(Konva.Text, 'text', EMPTY_STRING);
  Konva.Factory.addOverloadedGetterSetter(Konva.Text, 'text');

  /**
     * get/set text
     * @name getText
     * @method
     * @memberof Konva.Text.prototype
     * @param {String} text
     * @returns {String}
     * @example
     * // get text
     * var text = text.text();
     *
     * // set text
     * text.text('Hello world!');
     */

  Konva.Factory.addGetterSetter(Konva.Text, 'textDecoration', EMPTY_STRING);

  /**
      * get/set text decoration of a text.  Possible values are 'underline', 'line-through' or combination of these values separated by space
      * @name textDecoration
      * @method
      * @memberof Konva.Text.prototype
      * @param {String} textDecoration
      * @returns {String}
      * @example
      * // get text decoration
      * var textDecoration = text.textDecoration();
      *
      * // underline text
      * text.textDecoration('underline');
      *
      * // strike text
      * text.textDecoration('line-through');
      *
      * // underline and strike text
      * text.textDecoration('underline line-through');
      */

  Konva.Collection.mapMethods(Konva.Text);
})();

(function() {
  'use strict';
  /**
     * Line constructor.&nbsp; Lines are defined by an array of points and
     *  a tension
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Array} config.points
     * @param {Number} [config.tension] Higher values will result in a more curvy line.  A value of 0 will result in no interpolation.
     *   The default is 0
     * @param {Boolean} [config.closed] defines whether or not the line shape is closed, creating a polygon or blob
     * @param {Boolean} [config.bezier] if no tension is provided but bezier=true, we draw the line as a bezier using the passed points
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var line = new Konva.Line({
     *   x: 100,
     *   y: 50,
     *   points: [73, 70, 340, 23, 450, 60, 500, 20],
     *   stroke: 'red',
     *   tension: 1
     * });
     */
  Konva.Line = function(config) {
    this.___init(config);
  };

  Konva.Line.prototype = {
    ___init: function(config) {
      // call super constructor
      Konva.Shape.call(this, config);
      this.className = 'Line';

      this.on(
        'pointsChange.konva tensionChange.konva closedChange.konva bezierChange.konva',
        function() {
          this._clearCache('tensionPoints');
        }
      );

      this.sceneFunc(this._sceneFunc);
    },
    _sceneFunc: function(context) {
      var points = this.getPoints(),
        length = points.length,
        tension = this.getTension(),
        closed = this.getClosed(),
        bezier = this.getBezier(),
        tp,
        len,
        n;

      if (!length) {
        return;
      }

      context.beginPath();
      context.moveTo(points[0], points[1]);

      // tension
      if (tension !== 0 && length > 4) {
        tp = this.getTensionPoints();
        len = tp.length;
        n = closed ? 0 : 4;

        if (!closed) {
          context.quadraticCurveTo(tp[0], tp[1], tp[2], tp[3]);
        }

        while (n < len - 2) {
          context.bezierCurveTo(
            tp[n++],
            tp[n++],
            tp[n++],
            tp[n++],
            tp[n++],
            tp[n++]
          );
        }

        if (!closed) {
          context.quadraticCurveTo(
            tp[len - 2],
            tp[len - 1],
            points[length - 2],
            points[length - 1]
          );
        }
      } else if (bezier) {
        // no tension but bezier
        n = 2;

        while (n < length) {
          context.bezierCurveTo(
            points[n++],
            points[n++],
            points[n++],
            points[n++],
            points[n++],
            points[n++]
          );
        }
      } else {
        // no tension
        for (n = 2; n < length; n += 2) {
          context.lineTo(points[n], points[n + 1]);
        }
      }

      // closed e.g. polygons and blobs
      if (closed) {
        context.closePath();
        context.fillStrokeShape(this);
      } else {
        // open e.g. lines and splines
        context.strokeShape(this);
      }
    },
    getTensionPoints: function() {
      return this._getCache('tensionPoints', this._getTensionPoints);
    },
    _getTensionPoints: function() {
      if (this.getClosed()) {
        return this._getTensionPointsClosed();
      } else {
        return Konva.Util._expandPoints(this.getPoints(), this.getTension());
      }
    },
    _getTensionPointsClosed: function() {
      var p = this.getPoints(),
        len = p.length,
        tension = this.getTension(),
        util = Konva.Util,
        firstControlPoints = util._getControlPoints(
          p[len - 2],
          p[len - 1],
          p[0],
          p[1],
          p[2],
          p[3],
          tension
        ),
        lastControlPoints = util._getControlPoints(
          p[len - 4],
          p[len - 3],
          p[len - 2],
          p[len - 1],
          p[0],
          p[1],
          tension
        ),
        middle = Konva.Util._expandPoints(p, tension),
        tp = [firstControlPoints[2], firstControlPoints[3]]
          .concat(middle)
          .concat([
            lastControlPoints[0],
            lastControlPoints[1],
            p[len - 2],
            p[len - 1],
            lastControlPoints[2],
            lastControlPoints[3],
            firstControlPoints[0],
            firstControlPoints[1],
            p[0],
            p[1]
          ]);

      return tp;
    },
    getWidth: function() {
      return this.getSelfRect().width;
    },
    getHeight: function() {
      return this.getSelfRect().height;
    },
    // overload size detection
    getSelfRect: function() {
      var points;
      if (this.getTension() !== 0) {
        points = this._getTensionPoints();
      } else {
        points = this.getPoints();
      }
      var minX = points[0];
      var maxX = points[0];
      var minY = points[1];
      var maxY = points[1];
      var x, y;
      for (var i = 0; i < points.length / 2; i++) {
        x = points[i * 2];
        y = points[i * 2 + 1];
        minX = Math.min(minX, x);
        maxX = Math.max(maxX, x);
        minY = Math.min(minY, y);
        maxY = Math.max(maxY, y);
      }
      return {
        x: Math.round(minX),
        y: Math.round(minY),
        width: Math.round(maxX - minX),
        height: Math.round(maxY - minY)
      };
    }
  };
  Konva.Util.extend(Konva.Line, Konva.Shape);

  // add getters setters
  Konva.Factory.addGetterSetter(Konva.Line, 'closed', false);

  /**
     * get/set closed flag.  The default is false
     * @name closed
     * @method
     * @memberof Konva.Line.prototype
     * @param {Boolean} closed
     * @returns {Boolean}
     * @example
     * // get closed flag
     * var closed = line.closed();
     *
     * // close the shape
     * line.closed(true);
     *
     * // open the shape
     * line.closed(false);
     */

  Konva.Factory.addGetterSetter(Konva.Line, 'bezier', false);

  /**
    * get/set bezier flag.  The default is false
    * @name bezier
    * @method
    * @memberof Konva.Line.prototype
    * @param {Boolean} bezier
    * @returns {Boolean}
    * @example
    * // get whether the line is a bezier
    * var isBezier = line.bezier();
    *
    * // set whether the line is a bezier
    * line.bezier(true);
    */

  Konva.Factory.addGetterSetter(Konva.Line, 'tension', 0);

  /**
     * get/set tension
     * @name tension
     * @method
     * @memberof Konva.Line.prototype
     * @param {Number} Higher values will result in a more curvy line.  A value of 0 will result in no interpolation.
     *   The default is 0
     * @returns {Number}
     * @example
     * // get tension
     * var tension = line.tension();
     *
     * // set tension
     * line.tension(3);
     */

  Konva.Factory.addGetterSetter(Konva.Line, 'points', []);
  /**
     * get/set points array
     * @name points
     * @method
     * @memberof Konva.Line.prototype
     * @param {Array} points
     * @returns {Array}
     * @example
     * // get points
     * var points = line.points();
     *
     * // set points
     * line.points([10, 20, 30, 40, 50, 60]);
     *
     * // push a new point
     * line.points(line.points().concat([70, 80]));
     */

  Konva.Collection.mapMethods(Konva.Line);
})();

(function() {
  'use strict';
  /**
     * Sprite constructor
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {String} config.animation animation key
     * @param {Object} config.animations animation map
     * @param {Integer} [config.frameIndex] animation frame index
     * @param {Image} config.image image object
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var imageObj = new Image();
     * imageObj.onload = function() {
     *   var sprite = new Konva.Sprite({
     *     x: 200,
     *     y: 100,
     *     image: imageObj,
     *     animation: 'standing',
     *     animations: {
     *       standing: [
     *         // x, y, width, height (6 frames)
     *         0, 0, 49, 109,
     *         52, 0, 49, 109,
     *         105, 0, 49, 109,
     *         158, 0, 49, 109,
     *         210, 0, 49, 109,
     *         262, 0, 49, 109
     *       ],
     *       kicking: [
     *         // x, y, width, height (6 frames)
     *         0, 109, 45, 98,
     *         45, 109, 45, 98,
     *         95, 109, 63, 98,
     *         156, 109, 70, 98,
     *         229, 109, 60, 98,
     *         287, 109, 41, 98
     *       ]
     *     },
     *     frameRate: 7,
     *     frameIndex: 0
     *   });
     * };
     * imageObj.src = '/path/to/image.jpg'
     */
  Konva.Sprite = function(config) {
    this.___init(config);
  };

  Konva.Sprite.prototype = {
    ___init: function(config) {
      // call super constructor
      Konva.Shape.call(this, config);
      this.className = 'Sprite';

      this._updated = true;
      var that = this;
      this.anim = new Konva.Animation(function() {
        // if we don't need to redraw layer we should return false
        var updated = that._updated;
        that._updated = false;
        return updated;
      });
      this.on('animationChange.konva', function() {
        // reset index when animation changes
        this.frameIndex(0);
      });
      this.on('frameIndexChange.konva', function() {
        this._updated = true;
      });
      // smooth change for frameRate
      this.on('frameRateChange.konva', function() {
        if (!this.anim.isRunning()) {
          return;
        }
        clearInterval(this.interval);
        this._setInterval();
      });

      this.sceneFunc(this._sceneFunc);
      this.hitFunc(this._hitFunc);
    },
    _sceneFunc: function(context) {
      var anim = this.getAnimation(),
        index = this.frameIndex(),
        ix4 = index * 4,
        set = this.getAnimations()[anim],
        offsets = this.frameOffsets(),
        x = set[ix4 + 0],
        y = set[ix4 + 1],
        width = set[ix4 + 2],
        height = set[ix4 + 3],
        image = this.getImage();

      if (this.hasFill() || this.hasStroke()) {
        context.beginPath();
        context.rect(0, 0, width, height);
        context.closePath();
        context.fillStrokeShape(this);
      }

      if (image) {
        if (offsets) {
          var offset = offsets[anim], ix2 = index * 2;
          context.drawImage(
            image,
            x,
            y,
            width,
            height,
            offset[ix2 + 0],
            offset[ix2 + 1],
            width,
            height
          );
        } else {
          context.drawImage(image, x, y, width, height, 0, 0, width, height);
        }
      }
    },
    _hitFunc: function(context) {
      var anim = this.getAnimation(),
        index = this.frameIndex(),
        ix4 = index * 4,
        set = this.getAnimations()[anim],
        offsets = this.frameOffsets(),
        width = set[ix4 + 2],
        height = set[ix4 + 3];

      context.beginPath();
      if (offsets) {
        var offset = offsets[anim];
        var ix2 = index * 2;
        context.rect(offset[ix2 + 0], offset[ix2 + 1], width, height);
      } else {
        context.rect(0, 0, width, height);
      }
      context.closePath();
      context.fillShape(this);
    },
    _useBufferCanvas: function() {
      return (
        (this.hasShadow() || this.getAbsoluteOpacity() !== 1) &&
        this.hasStroke()
      );
    },
    _setInterval: function() {
      var that = this;
      this.interval = setInterval(function() {
        that._updateIndex();
      }, 1000 / this.getFrameRate());
    },
    /**
         * start sprite animation
         * @method
         * @memberof Konva.Sprite.prototype
         */
    start: function() {
      var layer = this.getLayer();

      /*
             * animation object has no executable function because
             *  the updates are done with a fixed FPS with the setInterval
             *  below.  The anim object only needs the layer reference for
             *  redraw
             */
      this.anim.setLayers(layer);
      this._setInterval();
      this.anim.start();
    },
    /**
         * stop sprite animation
         * @method
         * @memberof Konva.Sprite.prototype
         */
    stop: function() {
      this.anim.stop();
      clearInterval(this.interval);
    },
    /**
         * determine if animation of sprite is running or not.  returns true or false
         * @method
         * @memberof Konva.Animation.prototype
         * @returns {Boolean}
         */
    isRunning: function() {
      return this.anim.isRunning();
    },
    _updateIndex: function() {
      var index = this.frameIndex(),
        animation = this.getAnimation(),
        animations = this.getAnimations(),
        anim = animations[animation],
        len = anim.length / 4;

      if (index < len - 1) {
        this.frameIndex(index + 1);
      } else {
        this.frameIndex(0);
      }
    }
  };
  Konva.Util.extend(Konva.Sprite, Konva.Shape);

  // add getters setters
  Konva.Factory.addGetterSetter(Konva.Sprite, 'animation');

  /**
     * get/set animation key
     * @name animation
     * @method
     * @memberof Konva.Sprite.prototype
     * @param {String} anim animation key
     * @returns {String}
     * @example
     * // get animation key
     * var animation = sprite.animation();
     *
     * // set animation key
     * sprite.animation('kicking');
     */

  Konva.Factory.addGetterSetter(Konva.Sprite, 'animations');

  /**
     * get/set animations map
     * @name animations
     * @method
     * @memberof Konva.Sprite.prototype
     * @param {Object} animations
     * @returns {Object}
     * @example
     * // get animations map
     * var animations = sprite.animations();
     *
     * // set animations map
     * sprite.animations({
     *   standing: [
     *     // x, y, width, height (6 frames)
     *     0, 0, 49, 109,
     *     52, 0, 49, 109,
     *     105, 0, 49, 109,
     *     158, 0, 49, 109,
     *     210, 0, 49, 109,
     *     262, 0, 49, 109
     *   ],
     *   kicking: [
     *     // x, y, width, height (6 frames)
     *     0, 109, 45, 98,
     *     45, 109, 45, 98,
     *     95, 109, 63, 98,
     *     156, 109, 70, 98,
     *     229, 109, 60, 98,
     *     287, 109, 41, 98
     *   ]
     * });
     */

  Konva.Factory.addGetterSetter(Konva.Sprite, 'frameOffsets');

  /**
    * get/set offsets map
    * @name offsets
    * @method
    * @memberof Konva.Sprite.prototype
    * @param {Object} offsets
    * @returns {Object}
    * @example
    * // get offsets map
    * var offsets = sprite.offsets();
    *
    * // set offsets map
    * sprite.offsets({
    *   standing: [
    *     // x, y (6 frames)
    *     0, 0,
    *     0, 0,
    *     5, 0,
    *     0, 0,
    *     0, 3,
    *     2, 0
    *   ],
    *   kicking: [
    *     // x, y (6 frames)
    *     0, 5,
    *     5, 0,
    *     10, 0,
    *     0, 0,
    *     2, 1,
    *     0, 0
    *   ]
    * });
    */

  Konva.Factory.addGetterSetter(Konva.Sprite, 'image');

  /**
     * get/set image
     * @name image
     * @method
     * @memberof Konva.Sprite.prototype
     * @param {Image} image
     * @returns {Image}
     * @example
     * // get image
     * var image = sprite.image();
     *
     * // set image
     * sprite.image(imageObj);
     */

  Konva.Factory.addGetterSetter(Konva.Sprite, 'frameIndex', 0);

  /**
     * set/set animation frame index
     * @name frameIndex
     * @method
     * @memberof Konva.Sprite.prototype
     * @param {Integer} frameIndex
     * @returns {Integer}
     * @example
     * // get animation frame index
     * var frameIndex = sprite.frameIndex();
     *
     * // set animation frame index
     * sprite.frameIndex(3);
     */

  Konva.Factory.addGetterSetter(Konva.Sprite, 'frameRate', 17);

  /**
     * get/set frame rate in frames per second.  Increase this number to make the sprite
     *  animation run faster, and decrease the number to make the sprite animation run slower
     *  The default is 17 frames per second
     * @name frameRate
     * @method
     * @memberof Konva.Sprite.prototype
     * @param {Integer} frameRate
     * @returns {Integer}
     * @example
     * // get frame rate
     * var frameRate = sprite.frameRate();
     *
     * // set frame rate to 2 frames per second
     * sprite.frameRate(2);
     */

  Konva.Factory.backCompat(Konva.Sprite, {
    index: 'frameIndex',
    getIndex: 'getFrameIndex',
    setIndex: 'setFrameIndex'
  });

  Konva.Collection.mapMethods(Konva.Sprite);
})();

/*eslint-disable  no-shadow, max-len, max-depth */
(function() {
  'use strict';
  /**
     * Path constructor.
     * @author Jason Follas
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {String} config.data SVG data string
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var path = new Konva.Path({
     *   x: 240,
     *   y: 40,
     *   data: 'M12.582,9.551C3.251,16.237,0.921,29.021,7.08,38.564l-2.36,1.689l4.893,2.262l4.893,2.262l-0.568-5.36l-0.567-5.359l-2.365,1.694c-4.657-7.375-2.83-17.185,4.352-22.33c7.451-5.338,17.817-3.625,23.156,3.824c5.337,7.449,3.625,17.813-3.821,23.152l2.857,3.988c9.617-6.893,11.827-20.277,4.935-29.896C35.591,4.87,22.204,2.658,12.582,9.551z',
     *   fill: 'green',
     *   scale: 2
     * });
     */
  Konva.Path = function(config) {
    this.___init(config);
  };

  Konva.Path.prototype = {
    ___init: function(config) {
      this.dataArray = [];
      var that = this;

      // call super constructor
      Konva.Shape.call(this, config);
      this.className = 'Path';

      this.dataArray = Konva.Path.parsePathData(this.getData());
      this.on('dataChange.konva', function() {
        that.dataArray = Konva.Path.parsePathData(this.getData());
      });

      this.sceneFunc(this._sceneFunc);
    },
    _sceneFunc: function(context) {
      var ca = this.dataArray;

      // context position
      context.beginPath();
      for (var n = 0; n < ca.length; n++) {
        var c = ca[n].command;
        var p = ca[n].points;
        switch (c) {
          case 'L':
            context.lineTo(p[0], p[1]);
            break;
          case 'M':
            context.moveTo(p[0], p[1]);
            break;
          case 'C':
            context.bezierCurveTo(p[0], p[1], p[2], p[3], p[4], p[5]);
            break;
          case 'Q':
            context.quadraticCurveTo(p[0], p[1], p[2], p[3]);
            break;
          case 'A':
            var cx = p[0],
              cy = p[1],
              rx = p[2],
              ry = p[3],
              theta = p[4],
              dTheta = p[5],
              psi = p[6],
              fs = p[7];

            var r = rx > ry ? rx : ry;
            var scaleX = rx > ry ? 1 : rx / ry;
            var scaleY = rx > ry ? ry / rx : 1;

            context.translate(cx, cy);
            context.rotate(psi);
            context.scale(scaleX, scaleY);
            context.arc(0, 0, r, theta, theta + dTheta, 1 - fs);
            context.scale(1 / scaleX, 1 / scaleY);
            context.rotate(-psi);
            context.translate(-cx, -cy);

            break;
          case 'z':
            context.closePath();
            break;
        }
      }

      context.fillStrokeShape(this);
    },
    getSelfRect: function() {
      var points = [];
      this.dataArray.forEach(function(data) {
        points = points.concat(data.points);
      });
      var minX = points[0];
      var maxX = points[0];
      var minY = points[1];
      var maxY = points[1];
      var x, y;
      for (var i = 0; i < points.length / 2; i++) {
        x = points[i * 2];
        y = points[i * 2 + 1];
        minX = Math.min(minX, x);
        maxX = Math.max(maxX, x);
        minY = Math.min(minY, y);
        maxY = Math.max(maxY, y);
      }
      return {
        x: Math.round(minX),
        y: Math.round(minY),
        width: Math.round(maxX - minX),
        height: Math.round(maxY - minY)
      };
    }
  };
  Konva.Util.extend(Konva.Path, Konva.Shape);

  Konva.Path.getLineLength = function(x1, y1, x2, y2) {
    return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
  };
  Konva.Path.getPointOnLine = function(dist, P1x, P1y, P2x, P2y, fromX, fromY) {
    if (fromX === undefined) {
      fromX = P1x;
    }
    if (fromY === undefined) {
      fromY = P1y;
    }

    var m = (P2y - P1y) / (P2x - P1x + 0.00000001);
    var run = Math.sqrt(dist * dist / (1 + m * m));
    if (P2x < P1x) {
      run *= -1;
    }
    var rise = m * run;
    var pt;

    if (P2x === P1x) {
      // vertical line
      pt = {
        x: fromX,
        y: fromY + rise
      };
    } else if ((fromY - P1y) / (fromX - P1x + 0.00000001) === m) {
      pt = {
        x: fromX + run,
        y: fromY + rise
      };
    } else {
      var ix, iy;

      var len = this.getLineLength(P1x, P1y, P2x, P2y);
      if (len < 0.00000001) {
        return undefined;
      }
      var u = (fromX - P1x) * (P2x - P1x) + (fromY - P1y) * (P2y - P1y);
      u = u / (len * len);
      ix = P1x + u * (P2x - P1x);
      iy = P1y + u * (P2y - P1y);

      var pRise = this.getLineLength(fromX, fromY, ix, iy);
      var pRun = Math.sqrt(dist * dist - pRise * pRise);
      run = Math.sqrt(pRun * pRun / (1 + m * m));
      if (P2x < P1x) {
        run *= -1;
      }
      rise = m * run;
      pt = {
        x: ix + run,
        y: iy + rise
      };
    }

    return pt;
  };

  Konva.Path.getPointOnCubicBezier = function(
    pct,
    P1x,
    P1y,
    P2x,
    P2y,
    P3x,
    P3y,
    P4x,
    P4y
  ) {
    function CB1(t) {
      return t * t * t;
    }
    function CB2(t) {
      return 3 * t * t * (1 - t);
    }
    function CB3(t) {
      return 3 * t * (1 - t) * (1 - t);
    }
    function CB4(t) {
      return (1 - t) * (1 - t) * (1 - t);
    }
    var x = P4x * CB1(pct) + P3x * CB2(pct) + P2x * CB3(pct) + P1x * CB4(pct);
    var y = P4y * CB1(pct) + P3y * CB2(pct) + P2y * CB3(pct) + P1y * CB4(pct);

    return {
      x: x,
      y: y
    };
  };
  Konva.Path.getPointOnQuadraticBezier = function(
    pct,
    P1x,
    P1y,
    P2x,
    P2y,
    P3x,
    P3y
  ) {
    function QB1(t) {
      return t * t;
    }
    function QB2(t) {
      return 2 * t * (1 - t);
    }
    function QB3(t) {
      return (1 - t) * (1 - t);
    }
    var x = P3x * QB1(pct) + P2x * QB2(pct) + P1x * QB3(pct);
    var y = P3y * QB1(pct) + P2y * QB2(pct) + P1y * QB3(pct);

    return {
      x: x,
      y: y
    };
  };
  Konva.Path.getPointOnEllipticalArc = function(cx, cy, rx, ry, theta, psi) {
    var cosPsi = Math.cos(psi), sinPsi = Math.sin(psi);
    var pt = {
      x: rx * Math.cos(theta),
      y: ry * Math.sin(theta)
    };
    return {
      x: cx + (pt.x * cosPsi - pt.y * sinPsi),
      y: cy + (pt.x * sinPsi + pt.y * cosPsi)
    };
  };
  /*
     * get parsed data array from the data
     *  string.  V, v, H, h, and l data are converted to
     *  L data for the purpose of high performance Path
     *  rendering
     */
  Konva.Path.parsePathData = function(data) {
    // Path Data Segment must begin with a moveTo
    //m (x y)+  Relative moveTo (subsequent points are treated as lineTo)
    //M (x y)+  Absolute moveTo (subsequent points are treated as lineTo)
    //l (x y)+  Relative lineTo
    //L (x y)+  Absolute LineTo
    //h (x)+    Relative horizontal lineTo
    //H (x)+    Absolute horizontal lineTo
    //v (y)+    Relative vertical lineTo
    //V (y)+    Absolute vertical lineTo
    //z (closepath)
    //Z (closepath)
    //c (x1 y1 x2 y2 x y)+ Relative Bezier curve
    //C (x1 y1 x2 y2 x y)+ Absolute Bezier curve
    //q (x1 y1 x y)+       Relative Quadratic Bezier
    //Q (x1 y1 x y)+       Absolute Quadratic Bezier
    //t (x y)+    Shorthand/Smooth Relative Quadratic Bezier
    //T (x y)+    Shorthand/Smooth Absolute Quadratic Bezier
    //s (x2 y2 x y)+       Shorthand/Smooth Relative Bezier curve
    //S (x2 y2 x y)+       Shorthand/Smooth Absolute Bezier curve
    //a (rx ry x-axis-rotation large-arc-flag sweep-flag x y)+     Relative Elliptical Arc
    //A (rx ry x-axis-rotation large-arc-flag sweep-flag x y)+  Absolute Elliptical Arc

    // return early if data is not defined
    if (!data) {
      return [];
    }

    // command string
    var cs = data;

    // command chars
    var cc = [
      'm',
      'M',
      'l',
      'L',
      'v',
      'V',
      'h',
      'H',
      'z',
      'Z',
      'c',
      'C',
      'q',
      'Q',
      't',
      'T',
      's',
      'S',
      'a',
      'A'
    ];
    // convert white spaces to commas
    cs = cs.replace(new RegExp(' ', 'g'), ',');
    // create pipes so that we can split the data
    for (var n = 0; n < cc.length; n++) {
      cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);
    }
    // create array
    var arr = cs.split('|');
    var ca = [];
    // init context point
    var cpx = 0;
    var cpy = 0;
    for (n = 1; n < arr.length; n++) {
      var str = arr[n];
      var c = str.charAt(0);
      str = str.slice(1);
      // remove ,- for consistency
      str = str.replace(new RegExp(',-', 'g'), '-');
      // add commas so that it's easy to split
      str = str.replace(new RegExp('-', 'g'), ',-');
      str = str.replace(new RegExp('e,-', 'g'), 'e-');
      var p = str.split(',');
      if (p.length > 0 && p[0] === '') {
        p.shift();
      }
      // convert strings to floats
      for (var i = 0; i < p.length; i++) {
        p[i] = parseFloat(p[i]);
      }
      while (p.length > 0) {
        if (isNaN(p[0])) {
          // case for a trailing comma before next command
          break;
        }

        var cmd = null;
        var points = [];
        var startX = cpx, startY = cpy;
        // Move var from within the switch to up here (jshint)
        var prevCmd, ctlPtx, ctlPty; // Ss, Tt
        var rx, ry, psi, fa, fs, x1, y1; // Aa

        // convert l, H, h, V, and v to L
        switch (c) {
          // Note: Keep the lineTo's above the moveTo's in this switch
          case 'l':
            cpx += p.shift();
            cpy += p.shift();
            cmd = 'L';
            points.push(cpx, cpy);
            break;
          case 'L':
            cpx = p.shift();
            cpy = p.shift();
            points.push(cpx, cpy);
            break;
          // Note: lineTo handlers need to be above this point
          case 'm':
            var dx = p.shift();
            var dy = p.shift();
            cpx += dx;
            cpy += dy;
            cmd = 'M';
            // After closing the path move the current position
            // to the the first point of the path (if any).
            if (ca.length > 2 && ca[ca.length - 1].command === 'z') {
              for (var idx = ca.length - 2; idx >= 0; idx--) {
                if (ca[idx].command === 'M') {
                  cpx = ca[idx].points[0] + dx;
                  cpy = ca[idx].points[1] + dy;
                  break;
                }
              }
            }
            points.push(cpx, cpy);
            c = 'l';
            // subsequent points are treated as relative lineTo
            break;
          case 'M':
            cpx = p.shift();
            cpy = p.shift();
            cmd = 'M';
            points.push(cpx, cpy);
            c = 'L';
            // subsequent points are treated as absolute lineTo
            break;

          case 'h':
            cpx += p.shift();
            cmd = 'L';
            points.push(cpx, cpy);
            break;
          case 'H':
            cpx = p.shift();
            cmd = 'L';
            points.push(cpx, cpy);
            break;
          case 'v':
            cpy += p.shift();
            cmd = 'L';
            points.push(cpx, cpy);
            break;
          case 'V':
            cpy = p.shift();
            cmd = 'L';
            points.push(cpx, cpy);
            break;
          case 'C':
            points.push(p.shift(), p.shift(), p.shift(), p.shift());
            cpx = p.shift();
            cpy = p.shift();
            points.push(cpx, cpy);
            break;
          case 'c':
            points.push(
              cpx + p.shift(),
              cpy + p.shift(),
              cpx + p.shift(),
              cpy + p.shift()
            );
            cpx += p.shift();
            cpy += p.shift();
            cmd = 'C';
            points.push(cpx, cpy);
            break;
          case 'S':
            ctlPtx = cpx;
            ctlPty = cpy;
            prevCmd = ca[ca.length - 1];
            if (prevCmd.command === 'C') {
              ctlPtx = cpx + (cpx - prevCmd.points[2]);
              ctlPty = cpy + (cpy - prevCmd.points[3]);
            }
            points.push(ctlPtx, ctlPty, p.shift(), p.shift());
            cpx = p.shift();
            cpy = p.shift();
            cmd = 'C';
            points.push(cpx, cpy);
            break;
          case 's':
            ctlPtx = cpx;
            ctlPty = cpy;
            prevCmd = ca[ca.length - 1];
            if (prevCmd.command === 'C') {
              ctlPtx = cpx + (cpx - prevCmd.points[2]);
              ctlPty = cpy + (cpy - prevCmd.points[3]);
            }
            points.push(ctlPtx, ctlPty, cpx + p.shift(), cpy + p.shift());
            cpx += p.shift();
            cpy += p.shift();
            cmd = 'C';
            points.push(cpx, cpy);
            break;
          case 'Q':
            points.push(p.shift(), p.shift());
            cpx = p.shift();
            cpy = p.shift();
            points.push(cpx, cpy);
            break;
          case 'q':
            points.push(cpx + p.shift(), cpy + p.shift());
            cpx += p.shift();
            cpy += p.shift();
            cmd = 'Q';
            points.push(cpx, cpy);
            break;
          case 'T':
            ctlPtx = cpx;
            ctlPty = cpy;
            prevCmd = ca[ca.length - 1];
            if (prevCmd.command === 'Q') {
              ctlPtx = cpx + (cpx - prevCmd.points[0]);
              ctlPty = cpy + (cpy - prevCmd.points[1]);
            }
            cpx = p.shift();
            cpy = p.shift();
            cmd = 'Q';
            points.push(ctlPtx, ctlPty, cpx, cpy);
            break;
          case 't':
            ctlPtx = cpx;
            ctlPty = cpy;
            prevCmd = ca[ca.length - 1];
            if (prevCmd.command === 'Q') {
              ctlPtx = cpx + (cpx - prevCmd.points[0]);
              ctlPty = cpy + (cpy - prevCmd.points[1]);
            }
            cpx += p.shift();
            cpy += p.shift();
            cmd = 'Q';
            points.push(ctlPtx, ctlPty, cpx, cpy);
            break;
          case 'A':
            rx = p.shift();
            ry = p.shift();
            psi = p.shift();
            fa = p.shift();
            fs = p.shift();
            x1 = cpx;
            y1 = cpy;
            cpx = p.shift();
            cpy = p.shift();
            cmd = 'A';
            points = this.convertEndpointToCenterParameterization(
              x1,
              y1,
              cpx,
              cpy,
              fa,
              fs,
              rx,
              ry,
              psi
            );
            break;
          case 'a':
            rx = p.shift();
            ry = p.shift();
            psi = p.shift();
            fa = p.shift();
            fs = p.shift();
            x1 = cpx;
            y1 = cpy;
            cpx += p.shift();
            cpy += p.shift();
            cmd = 'A';
            points = this.convertEndpointToCenterParameterization(
              x1,
              y1,
              cpx,
              cpy,
              fa,
              fs,
              rx,
              ry,
              psi
            );
            break;
        }

        ca.push({
          command: cmd || c,
          points: points,
          start: {
            x: startX,
            y: startY
          },
          pathLength: this.calcLength(startX, startY, cmd || c, points)
        });
      }

      if (c === 'z' || c === 'Z') {
        ca.push({
          command: 'z',
          points: [],
          start: undefined,
          pathLength: 0
        });
      }
    }

    return ca;
  };
  Konva.Path.calcLength = function(x, y, cmd, points) {
    var len, p1, p2, t;
    var path = Konva.Path;

    switch (cmd) {
      case 'L':
        return path.getLineLength(x, y, points[0], points[1]);
      case 'C':
        // Approximates by breaking curve into 100 line segments
        len = 0.0;
        p1 = path.getPointOnCubicBezier(
          0,
          x,
          y,
          points[0],
          points[1],
          points[2],
          points[3],
          points[4],
          points[5]
        );
        for (t = 0.01; t <= 1; t += 0.01) {
          p2 = path.getPointOnCubicBezier(
            t,
            x,
            y,
            points[0],
            points[1],
            points[2],
            points[3],
            points[4],
            points[5]
          );
          len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
          p1 = p2;
        }
        return len;
      case 'Q':
        // Approximates by breaking curve into 100 line segments
        len = 0.0;
        p1 = path.getPointOnQuadraticBezier(
          0,
          x,
          y,
          points[0],
          points[1],
          points[2],
          points[3]
        );
        for (t = 0.01; t <= 1; t += 0.01) {
          p2 = path.getPointOnQuadraticBezier(
            t,
            x,
            y,
            points[0],
            points[1],
            points[2],
            points[3]
          );
          len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
          p1 = p2;
        }
        return len;
      case 'A':
        // Approximates by breaking curve into line segments
        len = 0.0;
        var start = points[4];
        // 4 = theta
        var dTheta = points[5];
        // 5 = dTheta
        var end = points[4] + dTheta;
        var inc = Math.PI / 180.0;
        // 1 degree resolution
        if (Math.abs(start - end) < inc) {
          inc = Math.abs(start - end);
        }
        // Note: for purpose of calculating arc length, not going to worry about rotating X-axis by angle psi
        p1 = path.getPointOnEllipticalArc(
          points[0],
          points[1],
          points[2],
          points[3],
          start,
          0
        );
        if (dTheta < 0) {
          // clockwise
          for (t = start - inc; t > end; t -= inc) {
            p2 = path.getPointOnEllipticalArc(
              points[0],
              points[1],
              points[2],
              points[3],
              t,
              0
            );
            len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
            p1 = p2;
          }
        } else {
          // counter-clockwise
          for (t = start + inc; t < end; t += inc) {
            p2 = path.getPointOnEllipticalArc(
              points[0],
              points[1],
              points[2],
              points[3],
              t,
              0
            );
            len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
            p1 = p2;
          }
        }
        p2 = path.getPointOnEllipticalArc(
          points[0],
          points[1],
          points[2],
          points[3],
          end,
          0
        );
        len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);

        return len;
    }

    return 0;
  };
  Konva.Path.convertEndpointToCenterParameterization = function(
    x1,
    y1,
    x2,
    y2,
    fa,
    fs,
    rx,
    ry,
    psiDeg
  ) {
    // Derived from: http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes
    var psi = psiDeg * (Math.PI / 180.0);
    var xp = Math.cos(psi) * (x1 - x2) / 2.0 + Math.sin(psi) * (y1 - y2) / 2.0;
    var yp =
      -1 * Math.sin(psi) * (x1 - x2) / 2.0 + Math.cos(psi) * (y1 - y2) / 2.0;

    var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);

    if (lambda > 1) {
      rx *= Math.sqrt(lambda);
      ry *= Math.sqrt(lambda);
    }

    var f = Math.sqrt(
      (rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) /
        (rx * rx * (yp * yp) + ry * ry * (xp * xp))
    );

    if (fa === fs) {
      f *= -1;
    }
    if (isNaN(f)) {
      f = 0;
    }

    var cxp = f * rx * yp / ry;
    var cyp = f * -ry * xp / rx;

    var cx = (x1 + x2) / 2.0 + Math.cos(psi) * cxp - Math.sin(psi) * cyp;
    var cy = (y1 + y2) / 2.0 + Math.sin(psi) * cxp + Math.cos(psi) * cyp;

    var vMag = function(v) {
      return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
    };
    var vRatio = function(u, v) {
      return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
    };
    var vAngle = function(u, v) {
      return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
    };
    var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
    var u = [(xp - cxp) / rx, (yp - cyp) / ry];
    var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
    var dTheta = vAngle(u, v);

    if (vRatio(u, v) <= -1) {
      dTheta = Math.PI;
    }
    if (vRatio(u, v) >= 1) {
      dTheta = 0;
    }
    if (fs === 0 && dTheta > 0) {
      dTheta = dTheta - 2 * Math.PI;
    }
    if (fs === 1 && dTheta < 0) {
      dTheta = dTheta + 2 * Math.PI;
    }
    return [cx, cy, rx, ry, theta, dTheta, psi, fs];
  };
  // add getters setters
  Konva.Factory.addGetterSetter(Konva.Path, 'data');

  /**
     * set SVG path data string.  This method
     *  also automatically parses the data string
     *  into a data array.  Currently supported SVG data:
     *  M, m, L, l, H, h, V, v, Q, q, T, t, C, c, S, s, A, a, Z, z
     * @name setData
     * @method
     * @memberof Konva.Path.prototype
     * @param {String} SVG path command string
     */

  /**
     * get SVG path data string
     * @name getData
     * @method
     * @memberof Konva.Path.prototype
     */

  Konva.Collection.mapMethods(Konva.Path);
})();

(function() {
  'use strict';
  var EMPTY_STRING = '',
    //CALIBRI = 'Calibri',
    NORMAL = 'normal';

  /**
     * Path constructor.
     * @author Jason Follas
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {String} [config.fontFamily] default is Calibri
     * @param {Number} [config.fontSize] default is 12
     * @param {String} [config.fontStyle] can be normal, bold, or italic.  Default is normal
     * @param {String} [config.fontVariant] can be normal or small-caps.  Default is normal
     * @param {String} config.text
     * @param {String} config.data SVG data string
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var textpath = new Konva.TextPath({
     *   x: 100,
     *   y: 50,
     *   fill: '#333',
     *   fontSize: '24',
     *   fontFamily: 'Arial',
     *   text: 'All the world\'s a stage, and all the men and women merely players.',
     *   data: 'M10,10 C0,0 10,150 100,100 S300,150 400,50'
     * });
     */
  Konva.TextPath = function(config) {
    this.___init(config);
  };

  function _fillFunc(context) {
    context.fillText(this.partialText, 0, 0);
  }
  function _strokeFunc(context) {
    context.strokeText(this.partialText, 0, 0);
  }

  Konva.TextPath.prototype = {
    ___init: function(config) {
      var that = this;
      this.dummyCanvas = Konva.Util.createCanvasElement();
      this.dataArray = [];

      // call super constructor
      Konva.Shape.call(this, config);

      // overrides
      // TODO: shouldn't this be on the prototype?
      this._fillFunc = _fillFunc;
      this._strokeFunc = _strokeFunc;
      this._fillFuncHit = _fillFunc;
      this._strokeFuncHit = _strokeFunc;

      this.className = 'TextPath';

      this.dataArray = Konva.Path.parsePathData(this.attrs.data);
      this.on('dataChange.konva', function() {
        that.dataArray = Konva.Path.parsePathData(this.attrs.data);
        that._setTextData();
      });

      // update text data for certain attr changes
      this.on(
        'textChange.konva alignChange.konva letterSpacingChange.konva',
        that._setTextData
      );
      that._setTextData();
      this.sceneFunc(this._sceneFunc);
      this.hitFunc(this._hitFunc);
    },
    _sceneFunc: function(context) {
      context.setAttr('font', this._getContextFont());
      context.setAttr('textBaseline', this.getTextBaseline());
      context.setAttr('textAlign', 'left');
      context.save();

      var textDecoration = this.textDecoration();
      var fill = this.fill();
      var fontSize = this.fontSize();

      var glyphInfo = this.glyphInfo;
      if (textDecoration === 'underline') {
        context.beginPath();
      }
      for (var i = 0; i < glyphInfo.length; i++) {
        context.save();

        var p0 = glyphInfo[i].p0;

        context.translate(p0.x, p0.y);
        context.rotate(glyphInfo[i].rotation);
        this.partialText = glyphInfo[i].text;

        context.fillStrokeShape(this);
        if (textDecoration === 'underline') {
          if (i === 0) {
            context.moveTo(0, fontSize / 2 + 1);
          }

          context.lineTo(fontSize, fontSize / 2 + 1);
        }
        context.restore();

        //// To assist with debugging visually, uncomment following
        //
        // if (i % 2)
        // context.strokeStyle = 'cyan';
        // else
        // context.strokeStyle = 'green';
        // var p1 = glyphInfo[i].p1;
        // context.moveTo(p0.x, p0.y);
        // context.lineTo(p1.x, p1.y);
        // context.stroke();
      }
      if (textDecoration === 'underline') {
        context.strokeStyle = fill;
        context.lineWidth = fontSize / 20;
        context.stroke();
      }

      context.restore();
    },
    _hitFunc: function(context) {
      context.beginPath();

      var glyphInfo = this.glyphInfo;
      if (glyphInfo.length >= 1) {
        var p0 = glyphInfo[0].p0;
        context.moveTo(p0.x, p0.y);
      }
      for (var i = 0; i < glyphInfo.length; i++) {
        var p1 = glyphInfo[i].p1;
        context.lineTo(p1.x, p1.y);
      }
      context.setAttr('lineWidth', this.getFontSize());
      context.setAttr('strokeStyle', this.colorKey);
      context.stroke();
    },
    /**
         * get text width in pixels
         * @method
         * @memberof Konva.TextPath.prototype
         */
    getTextWidth: function() {
      return this.textWidth;
    },
    /**
         * get text height in pixels
         * @method
         * @memberof Konva.TextPath.prototype
         */
    getTextHeight: function() {
      return this.textHeight;
    },
    /**
         * set text
         * @method
         * @memberof Konva.TextPath.prototype
         * @param {String} text
         */
    setText: function(text) {
      Konva.Text.prototype.setText.call(this, text);
    },
    _getTextSize: function(text) {
      var dummyCanvas = this.dummyCanvas;
      var _context = dummyCanvas.getContext('2d');

      _context.save();

      _context.font = this._getContextFont();
      var metrics = _context.measureText(text);

      _context.restore();

      return {
        width: metrics.width,
        height: parseInt(this.attrs.fontSize, 10)
      };
    },
    _setTextData: function() {
      var that = this;
      var size = this._getTextSize(this.attrs.text);
      var letterSpacing = this.getLetterSpacing();
      var align = this.align();

      this.textWidth = size.width;
      this.textHeight = size.height;

      var textFullWidth = Math.max(
        this.textWidth + ((this.attrs.text || '').length - 1) * letterSpacing,
        0
      );

      this.glyphInfo = [];

      var fullPathWidth = 0;
      for (var l = 0; l < that.dataArray.length; l++) {
        if (that.dataArray[l].pathLength > 0) {
          fullPathWidth += that.dataArray[l].pathLength;
        }
      }

      var offset = 0;
      if (align === 'center') {
        offset = Math.max(0, fullPathWidth / 2 - textFullWidth / 2);
      }
      if (align === 'right') {
        offset = Math.max(0, fullPathWidth - textFullWidth);
      }

      var charArr = this.getText().split('');
      var spacesNumber = this.getText().split(' ').length - 1;

      var p0, p1, pathCmd;

      var pIndex = -1;
      var currentT = 0;
      // var sumLength = 0;
      // for(var j = 0; j < that.dataArray.length; j++) {
      //   if(that.dataArray[j].pathLength > 0) {
      //
      //     if (sumLength + that.dataArray[j].pathLength > offset) {}
      //       fullPathWidth += that.dataArray[j].pathLength;
      //   }
      // }

      var getNextPathSegment = function() {
        currentT = 0;
        var pathData = that.dataArray;

        for (var j = pIndex + 1; j < pathData.length; j++) {
          if (pathData[j].pathLength > 0) {
            pIndex = j;

            return pathData[j];
          } else if (pathData[j].command === 'M') {
            p0 = {
              x: pathData[j].points[0],
              y: pathData[j].points[1]
            };
          }
        }

        return {};
      };

      var findSegmentToFitCharacter = function(c) {
        var glyphWidth = that._getTextSize(c).width + letterSpacing;

        if (c === ' ' && align === 'justify') {
          glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;
        }

        var currLen = 0;
        var attempts = 0;

        p1 = undefined;
        while (
          Math.abs(glyphWidth - currLen) / glyphWidth > 0.01 &&
          attempts < 25
        ) {
          attempts++;
          var cumulativePathLength = currLen;
          while (pathCmd === undefined) {
            pathCmd = getNextPathSegment();

            if (
              pathCmd &&
              cumulativePathLength + pathCmd.pathLength < glyphWidth
            ) {
              cumulativePathLength += pathCmd.pathLength;
              pathCmd = undefined;
            }
          }

          if (pathCmd === {} || p0 === undefined) {
            return undefined;
          }

          var needNewSegment = false;

          switch (pathCmd.command) {
            case 'L':
              if (
                Konva.Path.getLineLength(
                  p0.x,
                  p0.y,
                  pathCmd.points[0],
                  pathCmd.points[1]
                ) > glyphWidth
              ) {
                p1 = Konva.Path.getPointOnLine(
                  glyphWidth,
                  p0.x,
                  p0.y,
                  pathCmd.points[0],
                  pathCmd.points[1],
                  p0.x,
                  p0.y
                );
              } else {
                pathCmd = undefined;
              }
              break;
            case 'A':
              var start = pathCmd.points[4];
              // 4 = theta
              var dTheta = pathCmd.points[5];
              // 5 = dTheta
              var end = pathCmd.points[4] + dTheta;

              if (currentT === 0) {
                currentT = start + 0.00000001;
              } else if (glyphWidth > currLen) {
                // Just in case start is 0
                currentT += Math.PI / 180.0 * dTheta / Math.abs(dTheta);
              } else {
                currentT -= Math.PI / 360.0 * dTheta / Math.abs(dTheta);
              }

              // Credit for bug fix: @therth https://github.com/ericdrowell/KonvaJS/issues/249
              // Old code failed to render text along arc of this path: "M 50 50 a 150 50 0 0 1 250 50 l 50 0"
              if (
                (dTheta < 0 && currentT < end) ||
                (dTheta >= 0 && currentT > end)
              ) {
                currentT = end;
                needNewSegment = true;
              }
              p1 = Konva.Path.getPointOnEllipticalArc(
                pathCmd.points[0],
                pathCmd.points[1],
                pathCmd.points[2],
                pathCmd.points[3],
                currentT,
                pathCmd.points[6]
              );
              break;
            case 'C':
              if (currentT === 0) {
                if (glyphWidth > pathCmd.pathLength) {
                  currentT = 0.00000001;
                } else {
                  currentT = glyphWidth / pathCmd.pathLength;
                }
              } else if (glyphWidth > currLen) {
                currentT += (glyphWidth - currLen) / pathCmd.pathLength;
              } else {
                currentT -= (currLen - glyphWidth) / pathCmd.pathLength;
              }

              if (currentT > 1.0) {
                currentT = 1.0;
                needNewSegment = true;
              }
              p1 = Konva.Path.getPointOnCubicBezier(
                currentT,
                pathCmd.start.x,
                pathCmd.start.y,
                pathCmd.points[0],
                pathCmd.points[1],
                pathCmd.points[2],
                pathCmd.points[3],
                pathCmd.points[4],
                pathCmd.points[5]
              );
              break;
            case 'Q':
              if (currentT === 0) {
                currentT = glyphWidth / pathCmd.pathLength;
              } else if (glyphWidth > currLen) {
                currentT += (glyphWidth - currLen) / pathCmd.pathLength;
              } else {
                currentT -= (currLen - glyphWidth) / pathCmd.pathLength;
              }

              if (currentT > 1.0) {
                currentT = 1.0;
                needNewSegment = true;
              }
              p1 = Konva.Path.getPointOnQuadraticBezier(
                currentT,
                pathCmd.start.x,
                pathCmd.start.y,
                pathCmd.points[0],
                pathCmd.points[1],
                pathCmd.points[2],
                pathCmd.points[3]
              );
              break;
          }

          if (p1 !== undefined) {
            currLen = Konva.Path.getLineLength(p0.x, p0.y, p1.x, p1.y);
          }

          if (needNewSegment) {
            needNewSegment = false;
            pathCmd = undefined;
          }
        }
      };

      // fake search for offset, this is very bad approach
      // TODO: find other way to add offset from start (for align)
      var testChar = 'C';
      var glyphWidth = that._getTextSize(testChar).width + letterSpacing;
      for (var k = 0; k < offset / glyphWidth; k++) {
        findSegmentToFitCharacter(testChar);
        if (p0 === undefined || p1 === undefined) {
          break;
        }
        p0 = p1;
      }

      for (var i = 0; i < charArr.length; i++) {
        // Find p1 such that line segment between p0 and p1 is approx. width of glyph
        findSegmentToFitCharacter(charArr[i]);

        if (p0 === undefined || p1 === undefined) {
          break;
        }

        var width = Konva.Path.getLineLength(p0.x, p0.y, p1.x, p1.y);

        // Note: Since glyphs are rendered one at a time, any kerning pair data built into the font will not be used.
        // Can foresee having a rough pair table built in that the developer can override as needed.

        var kern = 0;
        // placeholder for future implementation

        var midpoint = Konva.Path.getPointOnLine(
          kern + width / 2.0,
          p0.x,
          p0.y,
          p1.x,
          p1.y
        );

        var rotation = Math.atan2(p1.y - p0.y, p1.x - p0.x);
        this.glyphInfo.push({
          transposeX: midpoint.x,
          transposeY: midpoint.y,
          text: charArr[i],
          rotation: rotation,
          p0: p0,
          p1: p1
        });
        p0 = p1;
      }
    },
    getSelfRect: function() {
      var points = [];

      this.glyphInfo.forEach(function(info) {
        points.push(info.p0.x);
        points.push(info.p0.y);
        points.push(info.p1.x);
        points.push(info.p1.y);
      });
      var minX = points[0];
      var maxX = points[0];
      var minY = points[0];
      var maxY = points[0];
      var x, y;
      for (var i = 0; i < points.length / 2; i++) {
        x = points[i * 2];
        y = points[i * 2 + 1];
        minX = Math.min(minX, x);
        maxX = Math.max(maxX, x);
        minY = Math.min(minY, y);
        maxY = Math.max(maxY, y);
      }
      var fontSize = this.fontSize();
      return {
        x: Math.round(minX) - fontSize / 2,
        y: Math.round(minY) - fontSize / 2,
        width: Math.round(maxX - minX) + fontSize,
        height: Math.round(maxY - minY) + fontSize
      };
    }
  };

  // map TextPath methods to Text
  Konva.TextPath.prototype._getContextFont =
    Konva.Text.prototype._getContextFont;

  Konva.Util.extend(Konva.TextPath, Konva.Shape);

  // add setters and getters
  Konva.Factory.addGetterSetter(Konva.TextPath, 'fontFamily', 'Arial');

  /**
     * set font family
     * @name setFontFamily
     * @method
     * @memberof Konva.TextPath.prototype
     * @param {String} fontFamily
     */

  /**
     * get font family
     * @name getFontFamily
     * @method
     * @memberof Konva.TextPath.prototype
     */

  Konva.Factory.addGetterSetter(Konva.TextPath, 'fontSize', 12);

  /**
     * set font size
     * @name setFontSize
     * @method
     * @memberof Konva.TextPath.prototype
     * @param {int} fontSize
     */

  /**
     * get font size
     * @name getFontSize
     * @method
     * @memberof Konva.TextPath.prototype
     */

  Konva.Factory.addGetterSetter(Konva.TextPath, 'fontStyle', NORMAL);

  /**
     * set font style.  Can be 'normal', 'italic', or 'bold'.  'normal' is the default.
     * @name setFontStyle
     * @method
     * @memberof Konva.TextPath.prototype
     * @param {String} fontStyle
     */
  Konva.Factory.addGetterSetter(Konva.TextPath, 'align', 'left');

  /**
      * get/set horizontal align of text.  Can be 'left', 'center', 'right' or 'justify'
      * @name align
      * @method
      * @memberof Konva.Text.prototype
      * @param {String} align
      * @returns {String}
      * @example
      * // get text align
      * var align = text.align();
      *
      * // center text
      * text.align('center');
      *
      * // align text to right
      * text.align('right');
      */

  Konva.Factory.addGetterSetter(Konva.TextPath, 'letterSpacing', 0);

  /**
      * set letter spacing property. Default value is 0.
      * @name letterSpacing
      * @method
      * @memberof Konva.TextPath.prototype
      * @param {Number} letterSpacing
      */

  Konva.Factory.addGetterSetter(Konva.TextPath, 'textBaseline', 'middle');

  /**
      * set textBaseline property. Default value is 'middle'.
      * Can be 'top', 'bottom', 'middle', 'alphabetic', 'hanging'
      * @name textBaseline
      * @method
      * @memberof Konva.TextPath.prototype
      * @param {Number} textBaseline
      */

  /**
     * get font style
     * @name getFontStyle
     * @method
     * @memberof Konva.TextPath.prototype
     */

  Konva.Factory.addGetterSetter(Konva.TextPath, 'fontVariant', NORMAL);

  /**
     * set font variant.  Can be 'normal' or 'small-caps'.  'normal' is the default.
     * @name setFontVariant
     * @method
     * @memberof Konva.TextPath.prototype
     * @param {String} fontVariant
     */

  /**
     * @get font variant
     * @name getFontVariant
     * @method
     * @memberof Konva.TextPath.prototype
     */

  Konva.Factory.addGetter(Konva.TextPath, 'text', EMPTY_STRING);

  /**
     * get text
     * @name getText
     * @method
     * @memberof Konva.TextPath.prototype
     */

  Konva.Factory.addGetterSetter(Konva.TextPath, 'textDecoration', null);

  /**
      * get/set text decoration of a text.  Can be '' or 'underline'
      * @name textDecoration
      * @method
      * @memberof Konva.Text.prototype
      * @param {String} textDecoration
      * @returns {String}
      * @example
      * // get text decoration
      * var textDecoration = text.textDecoration();
      *
      * // center text
      * text.textDecoration('underline');
      */

  Konva.Collection.mapMethods(Konva.TextPath);
})();

(function() {
  'use strict';
  /**
     * RegularPolygon constructor.&nbsp; Examples include triangles, squares, pentagons, hexagons, etc.
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Number} config.sides
     * @param {Number} config.radius
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var hexagon = new Konva.RegularPolygon({
     *   x: 100,
     *   y: 200,
     *   sides: 6,
     *   radius: 70,
     *   fill: 'red',
     *   stroke: 'black',
     *   strokeWidth: 4
     * });
     */
  Konva.RegularPolygon = function(config) {
    this.___init(config);
  };

  Konva.RegularPolygon.prototype = {
    _centroid: true,
    ___init: function(config) {
      // call super constructor
      Konva.Shape.call(this, config);
      this.className = 'RegularPolygon';
      this.sceneFunc(this._sceneFunc);
    },
    _sceneFunc: function(context) {
      var sides = this.attrs.sides, radius = this.attrs.radius, n, x, y;

      context.beginPath();
      context.moveTo(0, 0 - radius);

      for (n = 1; n < sides; n++) {
        x = radius * Math.sin(n * 2 * Math.PI / sides);
        y = -1 * radius * Math.cos(n * 2 * Math.PI / sides);
        context.lineTo(x, y);
      }
      context.closePath();
      context.fillStrokeShape(this);
    },
    getWidth: function() {
      return this.getRadius() * 2;
    },
    // implements Shape.prototype.getHeight()
    getHeight: function() {
      return this.getRadius() * 2;
    },
    // implements Shape.prototype.setWidth()
    setWidth: function(width) {
      Konva.Node.prototype.setWidth.call(this, width);
      if (this.radius() !== width / 2) {
        this.setRadius(width / 2);
      }
    },
    // implements Shape.prototype.setHeight()
    setHeight: function(height) {
      Konva.Node.prototype.setHeight.call(this, height);
      if (this.radius() !== height / 2) {
        this.setRadius(height / 2);
      }
    }
  };
  Konva.Util.extend(Konva.RegularPolygon, Konva.Shape);

  // add getters setters
  Konva.Factory.addGetterSetter(Konva.RegularPolygon, 'radius', 0);

  /**
     * set radius
     * @name setRadius
     * @method
     * @memberof Konva.RegularPolygon.prototype
     * @param {Number} radius
     */

  /**
     * get radius
     * @name getRadius
     * @method
     * @memberof Konva.RegularPolygon.prototype
     */

  Konva.Factory.addGetterSetter(Konva.RegularPolygon, 'sides', 0);

  /**
     * set number of sides
     * @name setSides
     * @method
     * @memberof Konva.RegularPolygon.prototype
     * @param {int} sides
     */

  /**
     * get number of sides
     * @name getSides
     * @method
     * @memberof Konva.RegularPolygon.prototype
     */

  Konva.Collection.mapMethods(Konva.RegularPolygon);
})();

(function() {
  'use strict';
  /**
     * Star constructor
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Integer} config.numPoints
     * @param {Number} config.innerRadius
     * @param {Number} config.outerRadius
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var star = new Konva.Star({
     *   x: 100,
     *   y: 200,
     *   numPoints: 5,
     *   innerRadius: 70,
     *   outerRadius: 70,
     *   fill: 'red',
     *   stroke: 'black',
     *   strokeWidth: 4
     * });
     */
  Konva.Star = function(config) {
    this.___init(config);
  };

  Konva.Star.prototype = {
    _centroid: true,
    ___init: function(config) {
      // call super constructor
      Konva.Shape.call(this, config);
      this.className = 'Star';
      this.sceneFunc(this._sceneFunc);
    },
    _sceneFunc: function(context) {
      var innerRadius = this.innerRadius(),
        outerRadius = this.outerRadius(),
        numPoints = this.numPoints();

      context.beginPath();
      context.moveTo(0, 0 - outerRadius);

      for (var n = 1; n < numPoints * 2; n++) {
        var radius = n % 2 === 0 ? outerRadius : innerRadius;
        var x = radius * Math.sin(n * Math.PI / numPoints);
        var y = -1 * radius * Math.cos(n * Math.PI / numPoints);
        context.lineTo(x, y);
      }
      context.closePath();

      context.fillStrokeShape(this);
    },
    // implements Shape.prototype.getWidth()
    getWidth: function() {
      return this.getOuterRadius() * 2;
    },
    // implements Shape.prototype.getHeight()
    getHeight: function() {
      return this.getOuterRadius() * 2;
    },
    // implements Shape.prototype.setWidth()
    setWidth: function(width) {
      Konva.Node.prototype.setWidth.call(this, width);
      if (this.outerRadius() !== width / 2) {
        this.setOuterRadius(width / 2);
      }
    },
    // implements Shape.prototype.setHeight()
    setHeight: function(height) {
      Konva.Node.prototype.setHeight.call(this, height);
      if (this.outerRadius() !== height / 2) {
        this.setOuterRadius(height / 2);
      }
    }
  };
  Konva.Util.extend(Konva.Star, Konva.Shape);

  // add getters setters
  Konva.Factory.addGetterSetter(Konva.Star, 'numPoints', 5);

  /**
     * set number of points
     * @name setNumPoints
     * @method
     * @memberof Konva.Star.prototype
     * @param {Integer} points
     */

  /**
     * get number of points
     * @name getNumPoints
     * @method
     * @memberof Konva.Star.prototype
     */

  Konva.Factory.addGetterSetter(Konva.Star, 'innerRadius', 0);

  /**
     * set inner radius
     * @name setInnerRadius
     * @method
     * @memberof Konva.Star.prototype
     * @param {Number} radius
     */

  /**
     * get inner radius
     * @name getInnerRadius
     * @method
     * @memberof Konva.Star.prototype
     */

  Konva.Factory.addGetterSetter(Konva.Star, 'outerRadius', 0);

  /**
     * set outer radius
     * @name setOuterRadius
     * @method
     * @memberof Konva.Star.prototype
     * @param {Number} radius
     */

  /**
     * get outer radius
     * @name getOuterRadius
     * @method
     * @memberof Konva.Star.prototype
     */

  Konva.Collection.mapMethods(Konva.Star);
})();

(function() {
  'use strict';
  // constants
  var ATTR_CHANGE_LIST = [
    'fontFamily',
    'fontSize',
    'fontStyle',
    'padding',
    'lineHeight',
    'text',
    'width'
  ],
    CHANGE_KONVA = 'Change.konva',
    NONE = 'none',
    UP = 'up',
    RIGHT = 'right',
    DOWN = 'down',
    LEFT = 'left',
    LABEL = 'Label',
    // cached variables
    attrChangeListLen = ATTR_CHANGE_LIST.length;

  /**
     * Label constructor.&nbsp; Labels are groups that contain a Text and Tag shape
     * @constructor
     * @memberof Konva
     * @param {Object} config
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * // create label
     * var label = new Konva.Label({
     *   x: 100,
     *   y: 100,
     *   draggable: true
     * });
     *
     * // add a tag to the label
     * label.add(new Konva.Tag({
     *   fill: '#bbb',
     *   stroke: '#333',
     *   shadowColor: 'black',
     *   shadowBlur: 10,
     *   shadowOffset: [10, 10],
     *   shadowOpacity: 0.2,
     *   lineJoin: 'round',
     *   pointerDirection: 'up',
     *   pointerWidth: 20,
     *   pointerHeight: 20,
     *   cornerRadius: 5
     * }));
     *
     * // add text to the label
     * label.add(new Konva.Text({
     *   text: 'Hello World!',
     *   fontSize: 50,
     *   lineHeight: 1.2,
     *   padding: 10,
     *   fill: 'green'
     *  }));
     */
  Konva.Label = function(config) {
    this.____init(config);
  };

  Konva.Label.prototype = {
    ____init: function(config) {
      var that = this;

      Konva.Group.call(this, config);
      this.className = LABEL;

      this.on('add.konva', function(evt) {
        that._addListeners(evt.child);
        that._sync();
      });
    },
    /**
         * get Text shape for the label.  You need to access the Text shape in order to update
         * the text properties
         * @name getText
         * @method
         * @memberof Konva.Label.prototype
         */
    getText: function() {
      return this.find('Text')[0];
    },
    /**
         * get Tag shape for the label.  You need to access the Tag shape in order to update
         * the pointer properties and the corner radius
         * @name getTag
         * @method
         * @memberof Konva.Label.prototype
         */
    getTag: function() {
      return this.find('Tag')[0];
    },
    _addListeners: function(text) {
      var that = this, n;
      var func = function() {
        that._sync();
      };

      // update text data for certain attr changes
      for (n = 0; n < attrChangeListLen; n++) {
        text.on(ATTR_CHANGE_LIST[n] + CHANGE_KONVA, func);
      }
    },
    getWidth: function() {
      return this.getText().getWidth();
    },
    getHeight: function() {
      return this.getText().getHeight();
    },
    _sync: function() {
      var text = this.getText(),
        tag = this.getTag(),
        width,
        height,
        pointerDirection,
        pointerWidth,
        x,
        y,
        pointerHeight;

      if (text && tag) {
        width = text.getWidth();
        height = text.getHeight();
        pointerDirection = tag.getPointerDirection();
        pointerWidth = tag.getPointerWidth();
        pointerHeight = tag.getPointerHeight();
        x = 0;
        y = 0;

        switch (pointerDirection) {
          case UP:
            x = width / 2;
            y = -1 * pointerHeight;
            break;
          case RIGHT:
            x = width + pointerWidth;
            y = height / 2;
            break;
          case DOWN:
            x = width / 2;
            y = height + pointerHeight;
            break;
          case LEFT:
            x = -1 * pointerWidth;
            y = height / 2;
            break;
        }

        tag.setAttrs({
          x: -1 * x,
          y: -1 * y,
          width: width,
          height: height
        });

        text.setAttrs({
          x: -1 * x,
          y: -1 * y
        });
      }
    }
  };

  Konva.Util.extend(Konva.Label, Konva.Group);

  Konva.Collection.mapMethods(Konva.Label);

  /**
     * Tag constructor.&nbsp; A Tag can be configured
     *  to have a pointer element that points up, right, down, or left
     * @constructor
     * @memberof Konva
     * @param {Object} config
     * @param {String} [config.pointerDirection] can be up, right, down, left, or none; the default
     *  is none.  When a pointer is present, the positioning of the label is relative to the tip of the pointer.
     * @param {Number} [config.pointerWidth]
     * @param {Number} [config.pointerHeight]
     * @param {Number} [config.cornerRadius]
     */
  Konva.Tag = function(config) {
    this.___init(config);
  };

  Konva.Tag.prototype = {
    ___init: function(config) {
      Konva.Shape.call(this, config);
      this.className = 'Tag';
      this.sceneFunc(this._sceneFunc);
    },
    _sceneFunc: function(context) {
      var width = this.getWidth(),
        height = this.getHeight(),
        pointerDirection = this.getPointerDirection(),
        pointerWidth = this.getPointerWidth(),
        pointerHeight = this.getPointerHeight(),
        cornerRadius = Math.min(this.getCornerRadius(), width / 2, height / 2);

      context.beginPath();
      if (!cornerRadius) {
        context.moveTo(0, 0);
      } else {
        context.moveTo(cornerRadius, 0);
      }

      if (pointerDirection === UP) {
        context.lineTo((width - pointerWidth) / 2, 0);
        context.lineTo(width / 2, -1 * pointerHeight);
        context.lineTo((width + pointerWidth) / 2, 0);
      }

      if (!cornerRadius) {
        context.lineTo(width, 0);
      } else {
        context.lineTo(width - cornerRadius, 0);
        context.arc(
          width - cornerRadius,
          cornerRadius,
          cornerRadius,
          Math.PI * 3 / 2,
          0,
          false
        );
      }

      if (pointerDirection === RIGHT) {
        context.lineTo(width, (height - pointerHeight) / 2);
        context.lineTo(width + pointerWidth, height / 2);
        context.lineTo(width, (height + pointerHeight) / 2);
      }

      if (!cornerRadius) {
        context.lineTo(width, height);
      } else {
        context.lineTo(width, height - cornerRadius);
        context.arc(
          width - cornerRadius,
          height - cornerRadius,
          cornerRadius,
          0,
          Math.PI / 2,
          false
        );
      }

      if (pointerDirection === DOWN) {
        context.lineTo((width + pointerWidth) / 2, height);
        context.lineTo(width / 2, height + pointerHeight);
        context.lineTo((width - pointerWidth) / 2, height);
      }

      if (!cornerRadius) {
        context.lineTo(0, height);
      } else {
        context.lineTo(cornerRadius, height);
        context.arc(
          cornerRadius,
          height - cornerRadius,
          cornerRadius,
          Math.PI / 2,
          Math.PI,
          false
        );
      }

      if (pointerDirection === LEFT) {
        context.lineTo(0, (height + pointerHeight) / 2);
        context.lineTo(-1 * pointerWidth, height / 2);
        context.lineTo(0, (height - pointerHeight) / 2);
      }

      if (cornerRadius) {
        context.lineTo(0, cornerRadius);
        context.arc(
          cornerRadius,
          cornerRadius,
          cornerRadius,
          Math.PI,
          Math.PI * 3 / 2,
          false
        );
      }

      context.closePath();
      context.fillStrokeShape(this);
    },
    getSelfRect: function() {
      var x = 0,
        y = 0,
        pointerWidth = this.getPointerWidth(),
        pointerHeight = this.getPointerHeight(),
        direction = this.pointerDirection(),
        width = this.getWidth(),
        height = this.getHeight();

      if (direction === UP) {
        y -= pointerHeight;
        height += pointerHeight;
      } else if (direction === DOWN) {
        height += pointerHeight;
      } else if (direction === LEFT) {
        // ARGH!!! I have no idea why should I used magic 1.5!!!!!!!!!
        x -= pointerWidth * 1.5;
        width += pointerWidth;
      } else if (direction === RIGHT) {
        width += pointerWidth * 1.5;
      }
      return {
        x: x,
        y: y,
        width: width,
        height: height
      };
    }
  };

  Konva.Util.extend(Konva.Tag, Konva.Shape);
  Konva.Factory.addGetterSetter(Konva.Tag, 'pointerDirection', NONE);

  /**
     * set pointer Direction
     * @name setPointerDirection
     * @method
     * @memberof Konva.Tag.prototype
     * @param {String} pointerDirection can be up, right, down, left, or none.  The
     *  default is none
     */

  /**
     * get pointer Direction
     * @name getPointerDirection
     * @method
     * @memberof Konva.Tag.prototype
     */

  Konva.Factory.addGetterSetter(Konva.Tag, 'pointerWidth', 0);

  /**
     * set pointer width
     * @name setPointerWidth
     * @method
     * @memberof Konva.Tag.prototype
     * @param {Number} pointerWidth
     */

  /**
     * get pointer width
     * @name getPointerWidth
     * @method
     * @memberof Konva.Tag.prototype
     */

  Konva.Factory.addGetterSetter(Konva.Tag, 'pointerHeight', 0);

  /**
     * set pointer height
     * @name setPointerHeight
     * @method
     * @memberof Konva.Tag.prototype
     * @param {Number} pointerHeight
     */

  /**
     * get pointer height
     * @name getPointerHeight
     * @method
     * @memberof Konva.Tag.prototype
     */

  Konva.Factory.addGetterSetter(Konva.Tag, 'cornerRadius', 0);

  /**
     * set corner radius
     * @name setCornerRadius
     * @method
     * @memberof Konva.Tag.prototype
     * @param {Number} corner radius
     */

  /**
     * get corner radius
     * @name getCornerRadius
     * @method
     * @memberof Konva.Tag.prototype
     */

  Konva.Collection.mapMethods(Konva.Tag);
})();

(function(Konva) {
  'use strict';
  /**
     * Arrow constructor
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Array} config.points
     * @param {Number} [config.tension] Higher values will result in a more curvy line.  A value of 0 will result in no interpolation.
     *   The default is 0
     * @param {Number} config.pointerLength
     * @param {Number} config.pointerWidth
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var line = new Konva.Line({
     *   points: [73, 70, 340, 23, 450, 60, 500, 20],
     *   stroke: 'red',
     *   tension: 1,
     *   pointerLength : 10,
     *   pointerWidth : 12
     * });
     */
  Konva.Arrow = function(config) {
    this.____init(config);
  };

  Konva.Arrow.prototype = {
    ____init: function(config) {
      // call super constructor
      Konva.Line.call(this, config);
      this.className = 'Arrow';
    },
    _sceneFunc: function(ctx) {
      Konva.Line.prototype._sceneFunc.apply(this, arguments);
      var PI2 = Math.PI * 2;
      var points = this.points();
      var n = points.length;
      var dx = points[n - 2] - points[n - 4];
      var dy = points[n - 1] - points[n - 3];
      var radians = (Math.atan2(dy, dx) + PI2) % PI2;
      var length = this.pointerLength();
      var width = this.pointerWidth();

      ctx.save();
      ctx.beginPath();
      ctx.translate(points[n - 2], points[n - 1]);
      ctx.rotate(radians);
      ctx.moveTo(0, 0);
      ctx.lineTo(-length, width / 2);
      ctx.lineTo(-length, -width / 2);
      ctx.closePath();
      ctx.restore();

      if (this.pointerAtBeginning()) {
        ctx.save();
        ctx.translate(points[0], points[1]);
        dx = points[2] - points[0];
        dy = points[3] - points[1];
        ctx.rotate((Math.atan2(-dy, -dx) + PI2) % PI2);
        ctx.moveTo(0, 0);
        ctx.lineTo(-length, width / 2);
        ctx.lineTo(-length, -width / 2);
        ctx.closePath();
        ctx.restore();
      }
      ctx.fillStrokeShape(this);
    }
  };

  Konva.Util.extend(Konva.Arrow, Konva.Line);
  /**
     * get/set pointerLength
     * @name pointerLength
     * @method
     * @memberof Konva.Arrow.prototype
     * @param {Number} Length of pointer of arrow.
     *   The default is 10.
     * @returns {Number}
     * @example
     * // get tension
     * var pointerLength = line.pointerLength();
     *
     * // set tension
     * line.pointerLength(15);
     */

  Konva.Factory.addGetterSetter(Konva.Arrow, 'pointerLength', 10);
  /**
     * get/set pointerWidth
     * @name pointerWidth
     * @method
     * @memberof Konva.Arrow.prototype
     * @param {Number} Width of pointer of arrow.
     *   The default is 10.
     * @returns {Number}
     * @example
     * // get tension
     * var pointerWidth = line.pointerWidth();
     *
     * // set tension
     * line.pointerWidth(15);
     */

  Konva.Factory.addGetterSetter(Konva.Arrow, 'pointerWidth', 10);
  /**
     * get/set pointerAtBeginning
     * @name pointerAtBeginning
     * @method
     * @memberof Konva.Arrow.prototype
     * @param {Number} Should pointer displayed at beginning of arrow.
     *   The default is false.
     * @returns {Boolean}
     * @example
     * // get tension
     * var pointerAtBeginning = line.pointerAtBeginning();
     *
     * // set tension
     * line.pointerAtBeginning(true);
     */

  Konva.Factory.addGetterSetter(Konva.Arrow, 'pointerAtBeginning', false);
  Konva.Collection.mapMethods(Konva.Arrow);
})(Konva);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(65)))

/***/ }),

/***/ 912:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

if (process.env.NODE_ENV !== 'production') {
  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
    Symbol.for &&
    Symbol.for('react.element')) ||
    0xeac7;

  var isValidElement = function(object) {
    return typeof object === 'object' &&
      object !== null &&
      object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(913)(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(915)();
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),

/***/ 913:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var emptyFunction = __webpack_require__(906);
var invariant = __webpack_require__(907);
var warning = __webpack_require__(909);

var ReactPropTypesSecret = __webpack_require__(908);
var checkPropTypes = __webpack_require__(914);

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (process.env.NODE_ENV !== 'production') {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          invariant(
            false,
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            warning(
              false,
              'You are manually calling a React.PropTypes validation ' +
              'function for the `%s` prop on `%s`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.',
              propFullName,
              componentName
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunction.thatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues);
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        warning(
          false,
          'Invalid argument supplid to oneOfType. Expected an array of check functions, but ' +
          'received %s at index %s.',
          getPostfixForTypeWarning(checker),
          i
        );
        return emptyFunction.thatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),

/***/ 914:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



if (process.env.NODE_ENV !== 'production') {
  var invariant = __webpack_require__(907);
  var warning = __webpack_require__(909);
  var ReactPropTypesSecret = __webpack_require__(908);
  var loggedTypeFailures = {};
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (process.env.NODE_ENV !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', location, typeSpecName);
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
        }
      }
    }
  }
}

module.exports = checkPropTypes;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),

/***/ 915:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var emptyFunction = __webpack_require__(906);
var invariant = __webpack_require__(907);
var ReactPropTypesSecret = __webpack_require__(908);

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    invariant(
      false,
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ 916:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyObject = {};

if (process.env.NODE_ENV !== 'production') {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),

/***/ 917:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var React = __webpack_require__(1);
var onElementResize = __webpack_require__(918);

var defaultContainerStyle = {
  width: '100%',
  height: '100%',
  padding: 0,
  border: 0
};

function defaultGetWidth(element) {
  return element.clientWidth;
}

function defaultGetHeight(element) {
  return element.clientHeight;
}

/**
 * Wraps a react component and adds properties `containerHeight` and
 * `containerWidth`. Useful for responsive design. Properties update on
 * window resize. **Note** that the parent element must have either a
 * height or a width, or nothing will be rendered
 *
 * Can be used as a
 * [higher-order component](http://babeljs.io/blog/2015/06/07/react-on-es6-plus/#property-initializers)
 * or as an [ES7 class decorator](https://github.com/wycats/javascript-decorators)
 * (see examples)
 *
 * @param {object} [options]
 * @param {function} [options.getHeight] A function that is passed an element and returns element
 * height, where element is the wrapper div. Defaults to `(element) => element.clientHeight`
 * @param {function} [options.getWidth]  A function that is passed an element and returns element
 * width, where element is the wrapper div. Defaults to `(element) => element.clientWidth`
 * @param {object} [options.containerStyle] A style object for the `<div>` that will wrap your component.
 * The dimensions of this `div` are what are passed as props to your component. The default style is
 * `{ width: '100%', height: '100%', padding: 0, border: 0 }` which will cause the `div` to fill its
 * parent in most cases. If you are using a flexbox layout you will want to change this default style.
 * @param {string} [options.className] Control the class name set on the wrapper `<div>`
 * @param {boolean} [options.elementResize=false] Set true to watch the wrapper `div` for changes in
 * size which are not a result of window resizing - e.g. changes to the flexbox and other layout.
 * @return {function}                   A higher-order component that can be
 * used to enhance a react component `Dimensions()(MyComponent)`
 *
 * @example
 * // ES2015
 * import React from 'react'
 * import Dimensions from 'react-dimensions'
 *
 * class MyComponent extends React.Component {
 *   render() (
 *     <div
 *       containerWidth={this.props.containerWidth}
 *       containerHeight={this.props.containerHeight}
 *     >
 *     </div>
 *   )
 * }
 *
 * export default Dimensions()(MyComponent) // Enhanced component
 *
 * @example
 * // ES5
 * var React = require('react')
 * var Dimensions = require('react-dimensions')
 *
 * var MyComponent = React.createClass({
 *   render: function() {(
 *     <div
 *       containerWidth={this.props.containerWidth}
 *       containerHeight={this.props.containerHeight}
 *     >
 *     </div>
 *   )}
 * }
 *
 * module.exports = Dimensions()(MyComponent) // Enhanced component
 *
 */
module.exports = function Dimensions() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$getHeight = _ref.getHeight,
      getHeight = _ref$getHeight === undefined ? defaultGetHeight : _ref$getHeight,
      _ref$getWidth = _ref.getWidth,
      getWidth = _ref$getWidth === undefined ? defaultGetWidth : _ref$getWidth,
      _ref$containerStyle = _ref.containerStyle,
      containerStyle = _ref$containerStyle === undefined ? defaultContainerStyle : _ref$containerStyle,
      _ref$className = _ref.className,
      className = _ref$className === undefined ? null : _ref$className,
      _ref$elementResize = _ref.elementResize,
      elementResize = _ref$elementResize === undefined ? false : _ref$elementResize;

  return function (ComposedComponent) {
    return function (_React$Component) {
      _inherits(DimensionsHOC, _React$Component);

      function DimensionsHOC() {
        var _ref2;

        var _temp, _this, _ret;

        _classCallCheck(this, DimensionsHOC);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref2 = DimensionsHOC.__proto__ || Object.getPrototypeOf(DimensionsHOC)).call.apply(_ref2, [this].concat(args))), _this), _this.state = {}, _this.updateDimensions = function () {
          var container = _this.refs.container;
          var containerWidth = getWidth(container);
          var containerHeight = getHeight(container);

          if (containerWidth !== _this.state.containerWidth || containerHeight !== _this.state.containerHeight) {
            _this.setState({ containerWidth: containerWidth, containerHeight: containerHeight });
          }
        }, _this.onResize = function () {
          if (_this.rqf) return;
          _this.rqf = _this.getWindow().requestAnimationFrame(function () {
            _this.rqf = null;
            _this.updateDimensions();
          });
        }, _temp), _possibleConstructorReturn(_this, _ret);
      }
      // ES7 Class properties
      // http://babeljs.io/blog/2015/06/07/react-on-es6-plus/#property-initializers


      // Using arrow functions and ES7 Class properties to autobind
      // http://babeljs.io/blog/2015/06/07/react-on-es6-plus/#arrow-functions


      _createClass(DimensionsHOC, [{
        key: 'getWindow',


        // If the component is mounted in a different window to the javascript
        // context, as with https://github.com/JakeGinnivan/react-popout
        // then the `window` global will be different from the `window` that
        // contains the component.
        // Depends on `defaultView` which is not supported <IE9
        value: function getWindow() {
          return this.refs.container ? this.refs.container.ownerDocument.defaultView || window : window;
        }
      }, {
        key: 'componentDidMount',
        value: function componentDidMount() {
          if (!this.refs.container) {
            throw new Error('Cannot find container div');
          }
          this.updateDimensions();
          if (elementResize) {
            // Experimental: `element-resize-event` fires when an element resizes.
            // It attaches its own window resize listener and also uses
            // requestAnimationFrame, so we can just call `this.updateDimensions`.
            onElementResize(this.refs.container, this.updateDimensions);
          } else {
            this.getWindow().addEventListener('resize', this.onResize, false);
          }
        }
      }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
          this.getWindow().removeEventListener('resize', this.onResize);
        }

        /**
         * Returns the underlying wrapped component instance.
         * Useful if you need to access a method or property of the component
         * passed to react-dimensions.
         *
         * @return {object} The rendered React component
         **/

      }, {
        key: 'getWrappedInstance',
        value: function getWrappedInstance() {
          this.refs.wrappedInstance;
        }
      }, {
        key: 'render',
        value: function render() {
          var _state = this.state,
              containerWidth = _state.containerWidth,
              containerHeight = _state.containerHeight;

          if (!containerWidth && !containerHeight) {
            console.warn('Wrapper div has no height or width, try overriding style with `containerStyle` option');
          }
          return React.createElement(
            'div',
            { className: className, style: containerStyle, ref: 'container' },
            (containerWidth || containerHeight) && React.createElement(ComposedComponent, _extends({}, this.state, this.props, {
              updateDimensions: this.updateDimensions,
              ref: 'wrappedInstance'
            }))
          );
        }
      }]);

      return DimensionsHOC;
    }(React.Component);
  };
};


/***/ }),

/***/ 918:
/***/ (function(module, exports) {

var requestFrame = (function () {
  var window = this
  var raf = window.requestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    function fallbackRAF(func) {
      return window.setTimeout(func, 20)
    }
  return function requestFrameFunction(func) {
    return raf(func)
  }
})()

var cancelFrame = (function () {
  var window = this
  var cancel = window.cancelAnimationFrame ||
    window.mozCancelAnimationFrame ||
    window.webkitCancelAnimationFrame ||
    window.clearTimeout
  return function cancelFrameFunction(id) {
    return cancel(id)
  }
})()

function resizeListener(e) {
  var win = e.target || e.srcElement
  if (win.__resizeRAF__) {
    cancelFrame(win.__resizeRAF__)
  }
  win.__resizeRAF__ = requestFrame(function () {
    var trigger = win.__resizeTrigger__
    trigger.__resizeListeners__.forEach(function (fn) {
      fn.call(trigger, e)
    })
  })
}

var exports = function exports(element, fn) {
  var window = this
  var document = window.document
  var isIE

  var attachEvent = document.attachEvent
  if (typeof navigator !== 'undefined') {
    isIE = navigator.userAgent.match(/Trident/) ||
      navigator.userAgent.match(/Edge/)
  }

  function objectLoad() {
    this.contentDocument.defaultView.__resizeTrigger__ = this.__resizeElement__
    this.contentDocument.defaultView.addEventListener('resize', resizeListener)
  }

  if (!element.__resizeListeners__) {
    element.__resizeListeners__ = []
    if (attachEvent) {
      element.__resizeTrigger__ = element
      element.attachEvent('onresize', resizeListener)
    } else {
      if (getComputedStyle(element).position === 'static') {
        element.style.position = 'relative'
      }
      var obj = (element.__resizeTrigger__ = document.createElement('object'))
      obj.setAttribute(
        'style',
        'display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; pointer-events: none; z-index: -1; opacity: 0;'
      )
      obj.setAttribute('class', 'resize-sensor')
      obj.__resizeElement__ = element
      obj.onload = objectLoad
      obj.type = 'text/html'
      if (isIE) {
        element.appendChild(obj)
      }
      obj.data = 'about:blank'
      if (!isIE) {
        element.appendChild(obj)
      }
    }
  }
  element.__resizeListeners__.push(fn)
}

module.exports = typeof window === 'undefined' ? exports : exports.bind(window)

module.exports.unbind = function (element, fn) {
  var attachEvent = document.attachEvent
  if (fn) {
    element.__resizeListeners__.splice(
      element.__resizeListeners__.indexOf(fn),
      1
    )
  } else {
    element.__resizeListeners__ = []
  }
  if (!element.__resizeListeners__.length) {
    if (attachEvent) {
      element.detachEvent('onresize', resizeListener)
    } else {
      element.__resizeTrigger__.contentDocument.defaultView.removeEventListener(
        'resize',
        resizeListener
      )
      delete element.__resizeTrigger__.contentDocument.defaultView.__resizeTrigger__
      element.__resizeTrigger__ = !element.removeChild(
        element.__resizeTrigger__
      )
    }
    delete element.__resizeListeners__
  }
}


/***/ })

})
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9jYW52YXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWtvbnZhL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1rb252YS9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9ub2RlX21vZHVsZXMvZmJqcy9saWIvaW52YXJpYW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1rb252YS9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWtvbnZhL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL25vZGVfbW9kdWxlcy9mYmpzL2xpYi93YXJuaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1rb252YS9zcmMvcmVhY3Qta29udmEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2tvbnZhL2tvbnZhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1rb252YS9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qta29udmEvbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWtvbnZhL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1rb252YS9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWtvbnZhL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZGltZW5zaW9ucy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC1yZXNpemUtZXZlbnQvaW5kZXguanMiXSwibmFtZXMiOlsicHJvcHMiLCJzdGF0ZSIsImNvbG9yIiwic2hhcGVzIiwiaWQiLCJtYXRjaCIsInBhcmFtcyIsIm1hcElkIiwiYWRkU2hhcGUiLCJiaW5kIiwib25EcmFnU3RhcnQiLCJvbkRyYWdNb3ZlIiwib25Nb3VzZU92ZXIiLCJvbk1vdXNlT3V0Iiwib25EYmxDbGljayIsIm9uRGJsVGFwIiwic2F2ZSIsImUiLCJjb25zb2xlIiwibG9nIiwiZG9jdW1lbnQiLCJib2R5Iiwic3R5bGUiLCJjdXJzb3IiLCJzZXRTdGF0ZSIsInB1c2giLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJoYW5kbGVDbGljayIsIndpbmRvdyIsIktvbnZhIiwiVXRpbCIsImdldFJhbmRvbUNvbG9yIiwiYWxlcnQiLCJtYXAiLCJzaGFwZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7OztBQUNBOztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7OztrQkFFZTtBQUFBOztBQUVYLG9CQUFZQSxLQUFaLEVBQW1CO0FBQUE7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFYZSxvSEFDVEEsS0FEUzs7QUFZZixjQUFLQyxLQUFMLEdBQWE7QUFDVEMsbUJBQU8sT0FERTtBQUVUQyxvQkFBUSxFQUZDO0FBR1RDLGdCQUFJLE1BQUtKLEtBQUwsQ0FBV0ssS0FBWCxDQUFpQkMsTUFBakIsQ0FBd0JDO0FBSG5CLFNBQWI7QUFLQSxjQUFLQyxRQUFMLEdBQWdCLE1BQUtBLFFBQUwsQ0FBY0MsSUFBZCxPQUFoQjtBQUNBLGNBQUtDLFdBQUwsR0FBaUIsTUFBS0EsV0FBTCxDQUFpQkQsSUFBakIsT0FBakI7QUFDQSxjQUFLRSxVQUFMLEdBQWdCLE1BQUtBLFVBQUwsQ0FBZ0JGLElBQWhCLE9BQWhCO0FBQ0EsY0FBS0csV0FBTCxHQUFpQixNQUFLQSxXQUFMLENBQWlCSCxJQUFqQixPQUFqQjtBQUNBLGNBQUtJLFVBQUwsR0FBZ0IsTUFBS0EsVUFBTCxDQUFnQkosSUFBaEIsT0FBaEI7QUFDQSxjQUFLSyxVQUFMLEdBQWdCLE1BQUtBLFVBQUwsQ0FBZ0JMLElBQWhCLE9BQWhCO0FBQ0EsY0FBS00sUUFBTCxHQUFjLE1BQUtBLFFBQUwsQ0FBY04sSUFBZCxPQUFkO0FBQ0EsY0FBS08sSUFBTCxHQUFZLE1BQUtBLElBQUwsQ0FBVVAsSUFBVixPQUFaO0FBeEJlO0FBeUJsQjs7QUEzQlU7QUFBQTtBQUFBLGlDQTZCRFEsQ0E3QkMsRUE2QkU7QUFBRUMsb0JBQVFDLEdBQVIsQ0FBWSxXQUFaLEVBQXlCRixDQUF6QjtBQUE2QjtBQTdCakM7QUFBQTtBQUFBLG9DQThCQ0EsQ0E5QkQsRUE4Qkk7QUFBRUMsb0JBQVFDLEdBQVIsQ0FBWSxhQUFaLEVBQTJCRixDQUEzQjtBQUFnQztBQTlCdEM7QUFBQTtBQUFBLG1DQStCQUEsQ0EvQkEsRUErQkc7QUFBRUMsb0JBQVFDLEdBQVIsQ0FBWSxZQUFaLEVBQTBCRixDQUExQjtBQUE4QjtBQS9CbkM7QUFBQTtBQUFBLG9DQWdDQ0EsQ0FoQ0QsRUFnQ0k7QUFDWEMsb0JBQVFDLEdBQVIsQ0FBWSxhQUFaLEVBQTJCRixDQUEzQjtBQUNBRyxxQkFBU0MsSUFBVCxDQUFjQyxLQUFkLENBQW9CQyxNQUFwQixHQUE2QixTQUE3QjtBQUNIO0FBbkNVO0FBQUE7QUFBQSxtQ0FvQ0FOLENBcENBLEVBb0NHO0FBQ1ZDLG9CQUFRQyxHQUFSLENBQVksWUFBWixFQUEwQkYsQ0FBMUI7QUFDQUcscUJBQVNDLElBQVQsQ0FBY0MsS0FBZCxDQUFvQkMsTUFBcEIsR0FBNkIsU0FBN0I7QUFDSDtBQXZDVTtBQUFBO0FBQUEsbUNBd0NBTixDQXhDQSxFQXdDRztBQUFFQyxvQkFBUUMsR0FBUixDQUFZLFlBQVosRUFBMEJGLENBQTFCO0FBQThCO0FBeENuQztBQUFBO0FBQUEsaUNBeUNGQSxDQXpDRSxFQXlDQztBQUFFQyxvQkFBUUMsR0FBUixDQUFZLFVBQVosRUFBd0JGLENBQXhCO0FBQTRCO0FBekMvQjtBQUFBO0FBQUEsNENBMkNTO0FBQ2hCLGlCQUFLTyxRQUFMLENBQWMsRUFBRXRCLE9BQU8sT0FBVCxFQUFkO0FBQ0g7QUE3Q1U7QUFBQTtBQUFBLG1DQStDQTtBQUNQLGdCQUFJQyxTQUFTLEtBQUtGLEtBQUwsQ0FBV0UsTUFBeEI7QUFDQUEsbUJBQU9zQixJQUFQLENBQVk7QUFDUixtQkFBR0MsS0FBS0MsS0FBTCxDQUFXRCxLQUFLRSxNQUFMLEtBQWdCLElBQWhCLEdBQXVCLENBQWxDLENBREs7QUFFUixtQkFBR0YsS0FBS0MsS0FBTCxDQUFXRCxLQUFLRSxNQUFMLEtBQWdCLEdBQWhCLEdBQXNCLENBQWpDLENBRks7QUFHUix1QkFBTyxHQUhDO0FBSVIsd0JBQVEsR0FKQTtBQUtSLHNCQUFNLEtBQUszQixLQUFMLENBQVdDLEtBTFQ7QUFNUiw0QkFBWSxDQU5KO0FBT1IsK0JBUFE7QUFRUix5QkFBUyxLQUFLMkIsV0FSTjtBQVNSLDZCQUFhLEtBQUtuQixXQVRWO0FBVVIsNEJBQVksS0FBS0MsVUFWVDtBQVdSLDZCQUFhLEtBQUtDLFdBWFY7QUFZUiw0QkFBWSxLQUFLQyxVQVpUO0FBYVIsNEJBQVksS0FBS0MsVUFiVDtBQWNSLDBCQUFVLEtBQUtBO0FBZFAsY0FBWjtBQWdCQSxpQkFBS1UsUUFBTCxDQUFjO0FBQ1Z0Qix1QkFBTzRCLE9BQU9DLEtBQVAsQ0FBYUMsSUFBYixDQUFrQkMsY0FBbEIsRUFERztBQUVWOUI7QUFGVSxhQUFkO0FBSUg7QUFyRVU7QUFBQTtBQUFBLCtCQXVFSjtBQUNIK0Isa0JBQU0sV0FBVSxLQUFLakMsS0FBTCxDQUFXRyxFQUEzQjtBQUNIO0FBekVVO0FBQUE7QUFBQSxpQ0EyRUY7QUFDTCxtQkFDSTtBQUFBO0FBQUE7QUFDQSxxRUFEQTtBQUVJO0FBQUE7QUFBQSxzQkFBUSxTQUFTLEtBQUtJLFFBQXRCO0FBQUE7QUFBQSxpQkFGSjtBQUdJO0FBQUE7QUFBQSxzQkFBUSxTQUFTLEtBQUtRLElBQXRCO0FBQUE7QUFBQSxpQkFISjtBQUlBO0FBQUE7QUFBQSxzQkFBTyxPQUFPLElBQWQsRUFBb0IsUUFBUSxHQUE1QjtBQUNJO0FBQUE7QUFBQTtBQUNLLDZCQUFLZixLQUFMLENBQVdFLE1BQVgsQ0FBa0JnQyxHQUFsQixDQUFzQjtBQUFBLG1DQUFTQyxLQUFUO0FBQUEseUJBQXRCO0FBREw7QUFESjtBQUpBLGFBREo7QUFZSDtBQXhGVTs7QUFBQTtBQUFBLG9COzs7Ozs7OztBQ1BmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0I7Ozs7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBOztBQUVBLDJCOzs7Ozs7Ozs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7Ozs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esc0ZBQXNGLGFBQWE7QUFDbkc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBLDRGQUE0RixlQUFlO0FBQzNHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUI7Ozs7Ozs7O0FDL0RBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7Ozs7Ozs7QUNwWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsYUFBYTtBQUNiLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQyxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDBCQUEwQixJQUFJLE1BQU0sSUFBSSxNQUFNLElBQUk7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZUFBZTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QixtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQixxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLFFBQVE7QUFDMUI7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvQ0FBb0Msb0JBQW9CO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixPQUFPO0FBQzFCLHFCQUFxQixPQUFPLFlBQVksb0JBQW9CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSwrQkFBK0IscUJBQXFCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxTQUFTLHVCQUF1QjtBQUNoQyxTQUFTLG9DQUFvQztBQUM3QyxTQUFTLGtEQUFrRDtBQUMzRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsU0FBUztBQUM1QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IscUJBQXFCO0FBQzdDOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsYUFBYTtBQUNyQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsV0FBVztBQUM5QixxQkFBcUIsTUFBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixXQUFXO0FBQzlCLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixNQUFNO0FBQ3pCLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixTQUFTO0FBQzVCLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUI7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0IscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsU0FBUztBQUM1QixtQkFBbUIsT0FBTztBQUMxQjtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0Isb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLEVBQUU7QUFDckIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0Y7QUFDcEYsc0VBQXNFLDZCQUE2QjtBQUNuRztBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsZ0JBQWdCO0FBQ2hCO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsZUFBZSxZQUFZO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsV0FBVztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLFdBQVc7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpQkFBaUIsYUFBYTtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyx5QkFBeUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixnQ0FBZ0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGdDQUFnQztBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0Esd0JBQXdCLFdBQVc7QUFDbkMsMEJBQTBCLFdBQVc7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0Esd0JBQXdCLFdBQVc7QUFDbkMsMEJBQTBCLFdBQVc7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQSx3QkFBd0IsV0FBVztBQUNuQywwQkFBMEIsV0FBVztBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyx1Q0FBdUM7QUFDdkMsc0NBQXNDO0FBQ3RDLGdDQUFnQztBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSwwQ0FBMEMsd0JBQXdCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDRDQUE0Qyx3QkFBd0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHdCQUF3QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsYUFBYTtBQUM1Qjs7QUFFQSwyQ0FBMkM7QUFDM0MscURBQXFEO0FBQ3JELG9EQUFvRDtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSwwQ0FBMEMseUJBQXlCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDRDQUE0Qyx5QkFBeUI7QUFDckU7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHlCQUF5QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSw2Q0FBNkMseUJBQXlCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixpQkFBaUI7QUFDakI7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsd0JBQXdCLEtBQUssd0JBQXdCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx3QkFBd0IsS0FBSyx3QkFBd0I7QUFDN0Y7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHdCQUF3QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsZ0JBQWdCO0FBQ2hCO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx3QkFBd0IsS0FBSyx3QkFBd0I7QUFDakc7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHdCQUF3QixLQUFLLHdCQUF3QjtBQUM3RjtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsd0JBQXdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsMkJBQTJCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QywyQkFBMkI7QUFDdkU7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDJCQUEyQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywyQkFBMkI7QUFDakU7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsVUFBVSxFQUFFO0FBQ25DLHVCQUF1QixVQUFVO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsNEJBQTRCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQixnQkFBZ0I7QUFDaEI7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0VBQW9FLDhCQUE4QjtBQUNsRztBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsZ0JBQWdCO0FBQ2hCO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSwwQkFBMEI7QUFDbEc7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGdCQUFnQjtBQUNoQjtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsZUFBZTtBQUNqQyxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixhQUFhO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsYUFBYTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDZCQUE2QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLDhCQUE4QixLQUFLLHlCQUF5QjtBQUNqSTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsZ0JBQWdCO0FBQ2hCO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZUFBZSxXQUFXO0FBQzFCLGlCQUFpQixXQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBLGlCQUFpQixXQUFXO0FBQzVCLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QyxtQkFBbUI7QUFDMUQ7O0FBRUE7QUFDQSw0Q0FBNEMsaUNBQWlDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxpQ0FBaUM7QUFDN0U7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLE9BQU87QUFDeEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUzs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFCQUFxQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakMscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsVUFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFdBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxrQ0FBa0M7QUFDL0Y7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIscUJBQXFCLE1BQU07QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG1CQUFtQjs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsa0NBQWtDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTyxZQUFZLG9CQUFvQjtBQUM1RDtBQUNBO0FBQ0EsOEJBQThCLGFBQWE7QUFDM0MsZ0NBQWdDLGFBQWE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLGVBQWU7QUFDOUIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLFNBQVM7QUFDNUIsbUJBQW1CLE9BQU87QUFDMUI7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsU0FBUztBQUM1QixtQkFBbUIsT0FBTztBQUMxQjtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLHFCQUFxQjtBQUNyQjtBQUNBLDhDQUE4QyxhQUFhO0FBQzNEO0FBQ0EsOENBQThDLGFBQWE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRCxXQUFXO0FBQzNELGtEQUFrRCxXQUFXO0FBQzdEO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0MsV0FBVztBQUNqRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFdBQVc7QUFDcEUsMkRBQTJELFdBQVc7QUFDdEU7QUFDQSw2Q0FBNkMsV0FBVztBQUN4RCw4Q0FBOEMsV0FBVztBQUN6RDtBQUNBLFdBQVc7QUFDWCw2Q0FBNkMsV0FBVztBQUN4RDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFdBQVc7QUFDbEUseURBQXlELFdBQVc7QUFDcEU7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDLFdBQVc7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDs7QUFFQTtBQUNBLHVDQUF1QyxXQUFXO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLHlDQUF5QyxXQUFXOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsV0FBVzs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxXQUFXO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFdBQVc7QUFDaEQ7QUFDQSxxQ0FBcUMsV0FBVztBQUNoRDtBQUNBLDJDQUEyQyxXQUFXO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUNBQXVDLFdBQVc7QUFDbEQsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLFdBQVc7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFdBQVc7QUFDakQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0Esd0NBQXdDLFdBQVc7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxXQUFXOztBQUVoRDtBQUNBLDJDQUEyQyxXQUFXO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxXQUFXO0FBQy9DO0FBQ0EsaUNBQWlDLFdBQVc7QUFDNUM7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFdBQVc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyxXQUFXO0FBQ2hEO0FBQ0EsaUNBQWlDLFdBQVc7QUFDNUMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGdCQUFnQjs7QUFFbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFdBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLE9BQU87QUFDeEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUzs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxhQUFhO0FBQ3BCLE9BQU8sY0FBYztBQUNyQixPQUFPLGVBQWU7QUFDdEIsT0FBTyxjQUFjO0FBQ3JCLE9BQU8sY0FBYztBQUNyQixPQUFPLGFBQWE7QUFDcEIsT0FBTyxhQUFhO0FBQ3BCLE9BQU8sYUFBYTtBQUNwQixPQUFPLGNBQWM7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLE9BQU87QUFDeEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUzs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLHFCQUFxQjtBQUNyQjtBQUNBLDhDQUE4QyxhQUFhO0FBQzNEO0FBQ0EsOENBQThDLGFBQWE7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsR0FBRyxJQUFJO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4QkFBOEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixPQUFPO0FBQ3hCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLE9BQU87QUFDeEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUzs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQix1Q0FBdUM7QUFDNUUsb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQixvQkFBb0IsS0FBSztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLEtBQUs7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLHVCQUF1QjtBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0Qsa0JBQWtCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsTUFBTTtBQUNyQixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsTUFBTTtBQUNyQixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLE1BQU07QUFDckIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsTUFBTTtBQUNyQixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsTUFBTTtBQUNyQixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLE1BQU07QUFDckIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsTUFBTTtBQUNyQixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsTUFBTTtBQUNyQixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsTUFBTTtBQUNyQixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsTUFBTTtBQUNyQixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsTUFBTTtBQUNyQixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsTUFBTTtBQUNyQixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtCQUFrQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywyQkFBMkI7QUFDM0QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5QkFBeUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsTUFBTTtBQUNyQixlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsTUFBTTtBQUNyQixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsTUFBTTtBQUNyQixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLE1BQU07QUFDckIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsTUFBTTtBQUNyQixlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsTUFBTTtBQUNyQixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsTUFBTTtBQUNyQixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxVQUFVO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLCtCQUErQixTQUFTO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDJCQUEyQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyxxQkFBcUI7QUFDckQ7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix5QkFBeUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsSUFBSTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsTUFBTTtBQUNyQixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsTUFBTTtBQUNyQixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLE1BQU07QUFDckIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLFdBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxJQUFJO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsTUFBTTtBQUNyQixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsTUFBTTtBQUNyQixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPLGlFQUFpRTtBQUN2RjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsTUFBTTtBQUNyQixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsTUFBTTtBQUNyQixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7QUMzeWpCRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDZCQUE2QjtBQUM3QixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsS0FBSztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDRCQUE0QjtBQUM1QixPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsZ0NBQWdDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixnQ0FBZ0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7QUMvZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7OztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkI7Ozs7Ozs7OztBQ2hCQTs7QUFFQSxtREFBbUQsZ0JBQWdCLHNCQUFzQixPQUFPLDJCQUEyQiwwQkFBMEIseURBQXlELDJCQUEyQixFQUFFLEVBQUUsRUFBRSxlQUFlOztBQUU5UCxnQ0FBZ0MsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUUsRUFBRSx5REFBeUQscUVBQXFFLDZEQUE2RCxvQkFBb0IsR0FBRyxFQUFFOztBQUVqakIsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdkosaURBQWlELGFBQWEsdUZBQXVGLEVBQUUsdUZBQXVGOztBQUU5TywwQ0FBMEMsK0RBQStELHFHQUFxRyxFQUFFLHlFQUF5RSxlQUFlLHlFQUF5RSxFQUFFLEVBQUUsdUhBQXVIOztBQUU1ZTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsS0FBSyx1REFBdUQ7QUFDNUQ7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHlCQUF5QjtBQUN6QiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHVFQUF1RSxhQUFhO0FBQ3BGO0FBQ0E7O0FBRUEsb05BQW9OO0FBQ3BOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixtRUFBbUU7QUFDL0Y7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7O0FBRUEsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0VBQWdFO0FBQzdFLHFHQUFxRztBQUNyRztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7Ozs7Ozs7O0FDdE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQixRQUFRLFNBQVMsY0FBYyxhQUFhLGtCQUFrQixzQkFBc0IsYUFBYSxZQUFZO0FBQ3pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjAuOTNkYmUxMDRkNmU5YjBiNDY1ZTEuaG90LXVwZGF0ZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwge0NvbXBvbmVudH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBMYXllciwgUmVjdCwgU3RhZ2UsIEdyb3VwIH0gZnJvbSAncmVhY3Qta29udmEnXG5pbXBvcnQgeyBCdXR0b24gfSBmcm9tICdzZW1hbnRpYy11aS1yZWFjdCdcbmltcG9ydCBEaW1lbnNpb25zIGZyb20gJ3JlYWN0LWRpbWVuc2lvbnMnXG5pbXBvcnQgTmF2QmFyIGZyb20gJy4vbmF2YmFyJ1xuaW1wb3J0IHt3aXRoUm91dGVyfSBmcm9tICdyZWFjdC1yb3V0ZXItZG9tJ1xuXG5leHBvcnQgZGVmYXVsdCB3aXRoUm91dGVyKGNsYXNzIE15UmVjdCBleHRlbmRzIENvbXBvbmVudCB7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcylcbiAgICAgICAgLy8gbGV0IHNoYXBlcyA9IFtdXG4gICAgICAgIC8vIHNoYXBlcy5wdXNoKDxSZWN0XG4gICAgICAgIC8vICAgICB4PXtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxNjAwICsgMSl9XG4gICAgICAgIC8vICAgICB5PXtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA5MDAgKyAxKX1cbiAgICAgICAgLy8gICAgIHdpZHRoPXsxMDB9XG4gICAgICAgIC8vICAgICBoZWlnaHQ9ezEwMH1cbiAgICAgICAgLy8gICAgIGZpbGw9e3RoaXMuc3RhdGUuY29sb3J9XG4gICAgICAgIC8vICAgICBzaGFkb3dCbHVyPXs1fVxuICAgICAgICAvLyAgICAgb25DbGljaz17dGhpcy5oYW5kbGVDbGlja31cbiAgICAgICAgLy8gLz4pXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBjb2xvcjogJ2dyZWVuJyxcbiAgICAgICAgICAgIHNoYXBlczogW10sXG4gICAgICAgICAgICBpZDogdGhpcy5wcm9wcy5tYXRjaC5wYXJhbXMubWFwSWRcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZFNoYXBlID0gdGhpcy5hZGRTaGFwZS5iaW5kKHRoaXMpXG4gICAgICAgIHRoaXMub25EcmFnU3RhcnQ9dGhpcy5vbkRyYWdTdGFydC5iaW5kKHRoaXMpXG4gICAgICAgIHRoaXMub25EcmFnTW92ZT10aGlzLm9uRHJhZ01vdmUuYmluZCh0aGlzKVxuICAgICAgICB0aGlzLm9uTW91c2VPdmVyPXRoaXMub25Nb3VzZU92ZXIuYmluZCh0aGlzKVxuICAgICAgICB0aGlzLm9uTW91c2VPdXQ9dGhpcy5vbk1vdXNlT3V0LmJpbmQodGhpcylcbiAgICAgICAgdGhpcy5vbkRibENsaWNrPXRoaXMub25EYmxDbGljay5iaW5kKHRoaXMpXG4gICAgICAgIHRoaXMub25EYmxUYXA9dGhpcy5vbkRibFRhcC5iaW5kKHRoaXMpXG4gICAgICAgIHRoaXMuc2F2ZSA9IHRoaXMuc2F2ZS5iaW5kKHRoaXMpXG4gICAgfVxuXG4gICAgYWRkU2hhcGUgKGUpIHsgY29uc29sZS5sb2coJ2FkZFNoYXBlICcsIGUpIH1cbiAgICBvbkRyYWdTdGFydChlKSB7IGNvbnNvbGUubG9nKCdvbkRyYWdTdGFydCcsIGUgKSB9XG4gICAgb25EcmFnTW92ZShlKSB7IGNvbnNvbGUubG9nKCdvbkRyYWdNb3ZlJywgZSkgfVxuICAgIG9uTW91c2VPdmVyKGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ29uTW91c2VPdmVyJywgZSlcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcidcbiAgICB9XG4gICAgb25Nb3VzZU91dChlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdvbk1vdXNlT3V0JywgZSlcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCdcbiAgICB9XG4gICAgb25EYmxDbGljayhlKSB7IGNvbnNvbGUubG9nKCdvbkRibENsaWNrJywgZSkgfVxuICAgIG9uRGJsVGFwKGUpIHsgY29uc29sZS5sb2coJ29uRGJsVGFwJywgZSkgfVxuXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBjb2xvcjogJ2dyZWVuJyB9KVxuICAgIH1cblxuICAgIGFkZFNoYXBlKCkge1xuICAgICAgICBsZXQgc2hhcGVzID0gdGhpcy5zdGF0ZS5zaGFwZXNcbiAgICAgICAgc2hhcGVzLnB1c2goPFJlY3RcbiAgICAgICAgICAgIHg9e01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDE2MDAgKyAxKX1cbiAgICAgICAgICAgIHk9e01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDkwMCArIDEpfVxuICAgICAgICAgICAgd2lkdGg9ezEwMH1cbiAgICAgICAgICAgIGhlaWdodD17MTAwfVxuICAgICAgICAgICAgZmlsbD17dGhpcy5zdGF0ZS5jb2xvcn1cbiAgICAgICAgICAgIHNoYWRvd0JsdXI9ezV9XG4gICAgICAgICAgICBkcmFnZ2FibGVcbiAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuaGFuZGxlQ2xpY2t9XG4gICAgICAgICAgICBvbkRyYWdTdGFydD17dGhpcy5vbkRyYWdTdGFydH1cbiAgICAgICAgICAgIG9uRHJhZ01vdmU9e3RoaXMub25EcmFnTW92ZX1cbiAgICAgICAgICAgIG9uTW91c2VPdmVyPXt0aGlzLm9uTW91c2VPdmVyfVxuICAgICAgICAgICAgb25Nb3VzZU91dD17dGhpcy5vbk1vdXNlT3V0fVxuICAgICAgICAgICAgb25EYmxDbGljaz17dGhpcy5vbkRibENsaWNrfVxuICAgICAgICAgICAgb25EYmxUYXA9e3RoaXMub25EYmxDbGlja31cbiAgICAgICAgLz4pXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgY29sb3I6IHdpbmRvdy5Lb252YS5VdGlsLmdldFJhbmRvbUNvbG9yKCksXG4gICAgICAgICAgICBzaGFwZXNcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBzYXZlKCkge1xuICAgICAgICBhbGVydCgnbWFwSWQ6JysgdGhpcy5zdGF0ZS5pZClcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgPE5hdkJhci8+XG4gICAgICAgICAgICAgICAgPEJ1dHRvbiBvbkNsaWNrPXt0aGlzLmFkZFNoYXBlfT5BZGQ8L0J1dHRvbj5cbiAgICAgICAgICAgICAgICA8QnV0dG9uIG9uQ2xpY2s9e3RoaXMuc2F2ZX0+U2F2ZTwvQnV0dG9uPlxuICAgICAgICAgICAgPFN0YWdlIHdpZHRoPXsxNjAwfSBoZWlnaHQ9ezkwMH0+XG4gICAgICAgICAgICAgICAgPExheWVyPlxuICAgICAgICAgICAgICAgICAgICB7dGhpcy5zdGF0ZS5zaGFwZXMubWFwKHNoYXBlID0+IHNoYXBlKX1cbiAgICAgICAgICAgICAgICA8L0xheWVyPlxuICAgICAgICAgICAgPC9TdGFnZT5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApXG4gICAgfVxufSlcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29tcG9uZW50cy9jYW52YXMuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbmZ1bmN0aW9uIG1ha2VFbXB0eUZ1bmN0aW9uKGFyZykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhcmc7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGFuZCBkaXNjYXJkcyBpbnB1dHM7IGl0IGhhcyBubyBzaWRlIGVmZmVjdHMuIFRoaXMgaXNcbiAqIHByaW1hcmlseSB1c2VmdWwgaWRpb21hdGljYWxseSBmb3Igb3ZlcnJpZGFibGUgZnVuY3Rpb24gZW5kcG9pbnRzIHdoaWNoXG4gKiBhbHdheXMgbmVlZCB0byBiZSBjYWxsYWJsZSwgc2luY2UgSlMgbGFja3MgYSBudWxsLWNhbGwgaWRpb20gYWxhIENvY29hLlxuICovXG52YXIgZW1wdHlGdW5jdGlvbiA9IGZ1bmN0aW9uIGVtcHR5RnVuY3Rpb24oKSB7fTtcblxuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyA9IG1ha2VFbXB0eUZ1bmN0aW9uO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlID0gbWFrZUVtcHR5RnVuY3Rpb24oZmFsc2UpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWUgPSBtYWtlRW1wdHlGdW5jdGlvbih0cnVlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsID0gbWFrZUVtcHR5RnVuY3Rpb24obnVsbCk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVGhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50ID0gZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gYXJnO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eUZ1bmN0aW9uO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWtvbnZhL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA5MDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgdmFsaWRhdGVGb3JtYXQoZm9ybWF0KTtcblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKCdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICsgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSkpO1xuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qta29udmEvbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbm9kZV9tb2R1bGVzL2ZianMvbGliL2ludmFyaWFudC5qc1xuLy8gbW9kdWxlIGlkID0gOTA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWtvbnZhL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qc1xuLy8gbW9kdWxlIGlkID0gOTA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9lbXB0eUZ1bmN0aW9uJyk7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZW1wdHlGdW5jdGlvbjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIHByaW50V2FybmluZyhmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuXG4gIHdhcm5pbmcgPSBmdW5jdGlvbiB3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQuaW5kZXhPZignRmFpbGVkIENvbXBvc2l0ZSBwcm9wVHlwZTogJykgPT09IDApIHtcbiAgICAgIHJldHVybjsgLy8gSWdub3JlIENvbXBvc2l0ZUNvbXBvbmVudCBwcm9wdHlwZSBjaGVjay5cbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWtvbnZhL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL25vZGVfbW9kdWxlcy9mYmpzL2xpYi93YXJuaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSA5MDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gQWRhcHRlZCBmcm9tIFJlYWN0QVJUOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmVhY3QtYXJ0XG5cbnZhciBLb252YSA9IHJlcXVpcmUoJ2tvbnZhJyk7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3QnKTtcblxudmFyIFByb3BUeXBlcyA9IHJlcXVpcmUoJ3Byb3AtdHlwZXMnKTtcbnZhciBjcmVhdGVDbGFzcyA9IHJlcXVpcmUoJ2NyZWF0ZS1yZWFjdC1jbGFzcycpO1xuXG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJ3JlYWN0LWRvbS9saWIvUmVhY3RJbnN0YW5jZU1hcCcpO1xudmFyIFJlYWN0TXVsdGlDaGlsZCA9IHJlcXVpcmUoJ3JlYWN0LWRvbS9saWIvUmVhY3RNdWx0aUNoaWxkJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgncmVhY3QtZG9tL2xpYi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG5cbi8vIHNvbWUgcGF0Y2hpbmcgdG8gbWFrZSBLb252YS5Ob2RlIGxvb2tzIGxpa2UgRE9NIG5vZGVzXG52YXIgb2xkQWRkID0gS29udmEuQ29udGFpbmVyLnByb3RvdHlwZS5hZGQ7XG5Lb252YS5Db250YWluZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGNoaWxkKSB7XG4gIGNoaWxkLnBhcmVudE5vZGUgPSB0aGlzO1xuICBvbGRBZGQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbktvbnZhLkNvbnRhaW5lci5wcm90b3R5cGUucmVwbGFjZUNoaWxkID0gZnVuY3Rpb24obmV3Q2hpbGQsIG9sZENoaWxkKSB7XG4gIHZhciBpbmRleCA9IG9sZENoaWxkLmluZGV4O1xuICB2YXIgcGFyZW50ID0gb2xkQ2hpbGQucGFyZW50O1xuICBvbGRDaGlsZC5kZXN0cm95KCk7XG4gIG9sZENoaWxkLnBhcmVudE5vZGUgPSBudWxsO1xuICBwYXJlbnQuYWRkKG5ld0NoaWxkKTtcbiAgaWYgKG5ld0NoaWxkLmluZGV4ICE9PSBpbmRleCkge1xuICAgIG5ld0NoaWxkLnNldFpJbmRleChpbmRleCk7XG4gIH1cbiAgcGFyZW50LmdldExheWVyKCkuYmF0Y2hEcmF3KCk7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnQobmFtZSkge1xuICB2YXIgUmVhY3RLb252YUNvbXBvbmVudCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICB0aGlzLm5vZGUgPSBudWxsO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IG51bGw7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSBudWxsO1xuICAgIHRoaXMuX21vdW50SW1hZ2UgPSBudWxsO1xuICAgIHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW4gPSBudWxsO1xuICAgIHRoaXMuX21vc3RSZWNlbnRseVBsYWNlZENoaWxkID0gbnVsbDtcbiAgICB0aGlzLl9uYXRpdmVDb250YWluZXJJbmZvID0gbnVsbDtcbiAgICB0aGlzLl9pbml0aWFsUHJvcHMgPSBlbGVtZW50LnByb3BzO1xuICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gZWxlbWVudDtcbiAgfTtcblxuICBSZWFjdEtvbnZhQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gbmFtZTtcblxuICBmb3IgKHZhciBpID0gMSwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBhc3NpZ24oUmVhY3RLb252YUNvbXBvbmVudC5wcm90b3R5cGUsIGFyZ3VtZW50c1tpXSk7XG4gIH1cblxuICByZXR1cm4gUmVhY3RLb252YUNvbXBvbmVudDtcbn1cblxudmFyIENvbnRhaW5lck1peGluID0gYXNzaWduKHt9LCBSZWFjdE11bHRpQ2hpbGQuTWl4aW4sIHtcbiAgbW92ZUNoaWxkOiBmdW5jdGlvbihwcmV2Q2hpbGQsIGxhc3RQbGFjZWROb2RlLCBuZXh0SW5kZXgsIGxhc3RJbmRleCkge1xuICAgIHZhciBjaGlsZE5vZGUgPSBwcmV2Q2hpbGQuX21vdW50SW1hZ2Uubm9kZTtcbiAgICBpZiAoY2hpbGROb2RlLmluZGV4ICE9PSBuZXh0SW5kZXgpIHtcbiAgICAgIGNoaWxkTm9kZS5zZXRaSW5kZXgobmV4dEluZGV4KTtcbiAgICAgIHZhciBsYXllciA9IGNoaWxkTm9kZS5nZXRMYXllcigpO1xuICAgICAgbGF5ZXIgJiYgbGF5ZXIuYmF0Y2hEcmF3KCk7XG4gICAgfVxuICB9LFxuICBjcmVhdGVDaGlsZDogZnVuY3Rpb24oY2hpbGQsIGFmdGVyTm9kZSwgbW91bnRJbWFnZSkge1xuICAgIGNoaWxkLl9tb3VudEltYWdlID0gbW91bnRJbWFnZTtcbiAgICB2YXIgY2hpbGROb2RlID0gbW91bnRJbWFnZS5ub2RlO1xuICAgIGNoaWxkTm9kZS5tb3ZlVG8odGhpcy5ub2RlKTtcbiAgICBjaGlsZE5vZGUucGFyZW50Tm9kZSA9IHRoaXMubm9kZTtcbiAgICBpZiAoY2hpbGQuX21vdW50SW5kZXggIT09IGNoaWxkTm9kZS5pbmRleCkge1xuICAgICAgY2hpbGROb2RlLnNldFpJbmRleChjaGlsZC5fbW91bnRJbmRleCk7XG4gICAgfVxuICAgIHRoaXMuX21vc3RSZWNlbnRseVBsYWNlZENoaWxkID0gY2hpbGROb2RlO1xuICAgIHZhciBsYXllciA9IGNoaWxkTm9kZS5nZXRMYXllcigpO1xuICAgIGxheWVyICYmIGxheWVyLmJhdGNoRHJhdygpO1xuICB9LFxuICByZW1vdmVDaGlsZDogZnVuY3Rpb24oY2hpbGQsIG5vZGUpIHtcbiAgICB2YXIgbGF5ZXIgPSBjaGlsZC5fbW91bnRJbWFnZS5ub2RlLmdldExheWVyKCk7XG4gICAgY2hpbGQuX21vdW50SW1hZ2Uubm9kZS5kZXN0cm95KCk7XG4gICAgY2hpbGQuX21vdW50SW1hZ2Uubm9kZS5wYXJlbnROb2RlID0gbnVsbDtcbiAgICBsYXllciAmJiBsYXllci5iYXRjaERyYXcoKTtcbiAgICBjaGlsZC5fbW91bnRJbWFnZSA9IG51bGw7XG4gIH0sXG4gIHVwZGF0ZUNoaWxkcmVuQXRSb290OiBmdW5jdGlvbihuZXh0Q2hpbGRyZW4sIHRyYW5zYWN0aW9uKSB7XG4gICAgdGhpcy51cGRhdGVDaGlsZHJlbihuZXh0Q2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBlbXB0eU9iamVjdCk7XG4gIH0sXG4gIG1vdW50QW5kSW5qZWN0Q2hpbGRyZW5BdFJvb3Q6IGZ1bmN0aW9uKGNoaWxkcmVuLCB0cmFuc2FjdGlvbikge1xuICAgIHRoaXMubW91bnRBbmRJbmplY3RDaGlsZHJlbihjaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGVtcHR5T2JqZWN0KTtcbiAgfSxcbiAgdXBkYXRlQ2hpbGRyZW46IGZ1bmN0aW9uKG5leHRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB0aGlzLl9tb3N0UmVjZW50bHlQbGFjZWRDaGlsZCA9IG51bGw7XG4gICAgdGhpcy5fdXBkYXRlQ2hpbGRyZW4obmV4dENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gIH0sXG4gIG1vdW50QW5kSW5qZWN0Q2hpbGRyZW46IGZ1bmN0aW9uKGNoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBtb3VudGVkSW1hZ2VzID0gdGhpcy5tb3VudENoaWxkcmVuKGNoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgLy8gRWFjaCBtb3VudCBpbWFnZSBjb3JyZXNwb25kcyB0byBvbmUgb2YgdGhlIGZsYXR0ZW5lZCBjaGlsZHJlblxuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbikge1xuICAgICAgaWYgKHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW4uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLl9yZW5kZXJlZENoaWxkcmVuW2tleV07XG4gICAgICAgIGNoaWxkLl9tb3VudEltYWdlID0gbW91bnRlZEltYWdlc1tpXTtcbiAgICAgICAgLy8gcnVudGltZSBjaGVjayBmb3IgbW92ZVRvIG1ldGhvZFxuICAgICAgICAvLyBpdCBpcyBwb3NzaWJsZSB0aGF0IGNoaWxkIGNvbXBvbmVudCB3aXRoIGJlIG5vdCBLb252YS5Ob2RlIGluc3RhbmNlXG4gICAgICAgIC8vIGZvciBpbnN0YW5jZSA8bm9zY3JpcHQ+IGZvciBudWxsIGVsZW1lbnRcbiAgICAgICAgdmFyIG5vZGUgPSBtb3VudGVkSW1hZ2VzW2ldLm5vZGU7XG4gICAgICAgIGlmICghbm9kZSBpbnN0YW5jZW9mIEtvbnZhLk5vZGUpIHtcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9ICdMb29rcyBsaWtlIG9uZSBvZiBjaGlsZCBlbGVtZW50IGlzIG5vdCBLb252YS5Ob2RlLicgK1xuICAgICAgICAgICAgJ3JlYWN0LWtvbnZhIGRvIG5vdCBzdXBwb3J0IGluIGZvciBub3cuJztcbiAgICAgICAgICAoJ2lmIHlvdSBoYXZlIGVtcHR5KG51bGwpIGNoaWxkLCByZXBsYWNlIGl0IHdpdGggPEdyb3VwLz4nKTtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UsIHRoaXMpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnBhcmVudCAhPT0gdGhpcy5ub2RlKSB7XG4gICAgICAgICAgbm9kZS5tb3ZlVG8odGhpcy5ub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtb3VudEFuZEFkZENoaWxkcmVuOiBmdW5jdGlvbigpIHtcbiAgICBjb25zb2xlLmxvZygnbW91bnRBbmRBZGRDaGlsZHJlbicpO1xuICB9XG59KTtcblxudmFyIHByb3BzVG9Ta2lwID0geyBjaGlsZHJlbjogdHJ1ZSwgcmVmOiB0cnVlLCBrZXk6IHRydWUsIHN0eWxlOiB0cnVlIH07XG5cbnZhciBOb2RlTWl4aW4gPSB7XG4gIGNvbnN0cnVjdDogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gZWxlbWVudDtcbiAgfSxcbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24obmV4dENvbXBvbmVudCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgcHJvcHMgPSBuZXh0Q29tcG9uZW50LnByb3BzO1xuICAgIHZhciBvbGRQcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzIHx8IHRoaXMuX2luaXRpYWxQcm9wcztcbiAgICB0aGlzLmFwcGx5Tm9kZVByb3BzKG9sZFByb3BzLCBwcm9wcyk7XG4gICAgdGhpcy51cGRhdGVDaGlsZHJlbihwcm9wcy5jaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbmV4dENvbXBvbmVudDtcbiAgfSxcbiAgZ2V0UHVibGljSW5zdGFuY2U6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGU7XG4gIH0sXG4gIHB1dEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgLy8gTk9QRS4uLlxuICB9LFxuICBoYW5kbGVFdmVudDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAvLyBOT1BFLi4uXG4gIH0sXG4gIGdldE5hdGl2ZU5vZGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGU7XG4gIH0sXG4gIGFwcGx5Tm9kZVByb3BzOiBmdW5jdGlvbihvbGRQcm9wcywgcHJvcHMpIHtcbiAgICB2YXIgdXBkYXRlZFByb3BzID0ge307XG4gICAgdmFyIGhhc1VwZGF0ZXMgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1RvU2tpcFtrZXldKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGlzRXZlbnQgPSBrZXkuc2xpY2UoMCwgMikgPT09ICdvbic7XG4gICAgICB2YXIgcHJvcENoYW5nZWQgPSBvbGRQcm9wc1trZXldICE9PSBwcm9wc1trZXldO1xuICAgICAgaWYgKGlzRXZlbnQgJiYgcHJvcENoYW5nZWQpIHtcbiAgICAgICAgdmFyIGV2ZW50TmFtZSA9IGtleS5zdWJzdHIoMikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKGV2ZW50TmFtZS5zdWJzdHIoMCwgNykgPT09ICdjb250ZW50Jykge1xuICAgICAgICAgIGV2ZW50TmFtZSA9ICdjb250ZW50JyArXG4gICAgICAgICAgICBldmVudE5hbWUuc3Vic3RyKDcsIDEpLnRvVXBwZXJDYXNlKCkgK1xuICAgICAgICAgICAgZXZlbnROYW1lLnN1YnN0cig4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vZGUub2ZmKGV2ZW50TmFtZSwgb2xkUHJvcHNba2V5XSk7XG4gICAgICB9XG4gICAgICB2YXIgdG9SZW1vdmUgPSAhcHJvcHMuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgICAgIGlmICh0b1JlbW92ZSkge1xuICAgICAgICB0aGlzLm5vZGUuc2V0QXR0cihrZXksIHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgaWYgKHByb3BzVG9Ta2lwW2tleV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgaXNFdmVudCA9IGtleS5zbGljZSgwLCAyKSA9PT0gJ29uJztcbiAgICAgIHZhciB0b0FkZCA9IG9sZFByb3BzW2tleV0gIT09IHByb3BzW2tleV07XG4gICAgICBpZiAoaXNFdmVudCAmJiB0b0FkZCkge1xuICAgICAgICB2YXIgZXZlbnROYW1lID0ga2V5LnN1YnN0cigyKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoZXZlbnROYW1lLnN1YnN0cigwLCA3KSA9PT0gJ2NvbnRlbnQnKSB7XG4gICAgICAgICAgZXZlbnROYW1lID0gJ2NvbnRlbnQnICtcbiAgICAgICAgICAgIGV2ZW50TmFtZS5zdWJzdHIoNywgMSkudG9VcHBlckNhc2UoKSArXG4gICAgICAgICAgICBldmVudE5hbWUuc3Vic3RyKDgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm9kZS5vbihldmVudE5hbWUsIHByb3BzW2tleV0pO1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICAhaXNFdmVudCAmJlxuICAgICAgICAocHJvcHNba2V5XSAhPT0gb2xkUHJvcHNba2V5XSB8fCBwcm9wc1trZXldICE9PSB0aGlzLm5vZGUuZ2V0QXR0cihrZXkpKVxuICAgICAgKSB7XG4gICAgICAgIGhhc1VwZGF0ZXMgPSB0cnVlO1xuICAgICAgICB1cGRhdGVkUHJvcHNba2V5XSA9IHByb3BzW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhc1VwZGF0ZXMpIHtcbiAgICAgIHRoaXMubm9kZS5zZXRBdHRycyh1cGRhdGVkUHJvcHMpO1xuICAgICAgdmFyIGRyYXdpbmdOb2RlID0gdGhpcy5ub2RlLmdldExheWVyKCkgfHwgdGhpcy5ub2RlLmdldFN0YWdlKCk7XG4gICAgICBkcmF3aW5nTm9kZSAmJiBkcmF3aW5nTm9kZS5iYXRjaERyYXcoKTtcbiAgICAgIHZhciB2YWwsIHByb3A7XG4gICAgICBmb3IgKHByb3AgaW4gdXBkYXRlZFByb3BzKSB7XG4gICAgICAgIHZhbCA9IHVwZGF0ZWRQcm9wc1twcm9wXTtcbiAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIHdpbmRvdy5JbWFnZSAmJiAhdmFsLmNvbXBsZXRlKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGU7XG4gICAgICAgICAgdmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBsYXllciA9IG5vZGUuZ2V0TGF5ZXIoKTtcbiAgICAgICAgICAgIGxheWVyICYmIGxheWVyLmJhdGNoRHJhdygpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbigpIHt9LFxuICBtb3VudENvbXBvbmVudEludG9Ob2RlOiBmdW5jdGlvbihyb290SUQsIGNvbnRhaW5lcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdZb3UgY2Fubm90IHJlbmRlciBhbiBBUlQgY29tcG9uZW50IHN0YW5kYWxvbmUuICcgK1xuICAgICAgICAnWW91IG5lZWQgdG8gd3JhcCBpdCBpbiBhIFN0YWdlLidcbiAgICApO1xuICB9XG59O1xuXG52YXIgU3RhZ2UgPSBjcmVhdGVDbGFzcyh7XG4gIHByb3BUeXBlczoge1xuICAgIHdpZHRoOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcbiAgICAgIFByb3BUeXBlcy5udW1iZXIsXG4gICAgICBQcm9wVHlwZXMuc3RyaW5nXG4gICAgXSksXG4gICAgaGVpZ2h0OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcbiAgICAgIFByb3BUeXBlcy5udW1iZXIsXG4gICAgICBQcm9wVHlwZXMuc3RyaW5nXG4gICAgXSlcbiAgfSxcbiAgZGlzcGxheU5hbWU6ICdTdGFnZScsXG4gIG1peGluczogW0NvbnRhaW5lck1peGluXSxcbiAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubm9kZSA9IG5ldyBLb252YS5TdGFnZSh7XG4gICAgICBjb250YWluZXI6IHRoaXMuZG9tTm9kZSxcbiAgICAgIHdpZHRoOiB0aGlzLnByb3BzLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLnByb3BzLmhlaWdodFxuICAgIH0pO1xuICAgIHRoaXMuYXBwbHlOb2RlUHJvcHMoZW1wdHlPYmplY3QsIHRoaXMucHJvcHMpO1xuICAgIHRoaXMuX2RlYnVnSUQgPSB0aGlzLl9yZWFjdEludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQ7XG4gICAgdmFyIHRyYW5zYWN0aW9uID0gUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24uZ2V0UG9vbGVkKCk7XG5cbiAgICB0cmFuc2FjdGlvbi5wZXJmb3JtKFxuICAgICAgdGhpcy5tb3VudEFuZEluamVjdENoaWxkcmVuLFxuICAgICAgdGhpcyxcbiAgICAgIHRoaXMucHJvcHMuY2hpbGRyZW4sXG4gICAgICB0cmFuc2FjdGlvbixcbiAgICAgIFJlYWN0SW5zdGFuY2VNYXAuZ2V0KHRoaXMpLl9jb250ZXh0XG4gICAgKTtcbiAgICBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5yZWxlYXNlKHRyYW5zYWN0aW9uKTtcblxuICAgIHRoaXMubm9kZS5kcmF3KCk7XG4gIH0sXG4gIGdldFN0YWdlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlO1xuICB9LFxuICBjb21wb25lbnREaWRVcGRhdGU6IGZ1bmN0aW9uKG9sZFByb3BzKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLm5vZGU7XG5cbiAgICB0aGlzLmFwcGx5Tm9kZVByb3BzKG9sZFByb3BzLCB0aGlzLnByb3BzKTtcblxuICAgIHZhciB0cmFuc2FjdGlvbiA9IFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLmdldFBvb2xlZCgpO1xuICAgIHRyYW5zYWN0aW9uLnBlcmZvcm0oXG4gICAgICB0aGlzLnVwZGF0ZUNoaWxkcmVuLFxuICAgICAgdGhpcyxcbiAgICAgIHRoaXMucHJvcHMuY2hpbGRyZW4sXG4gICAgICB0cmFuc2FjdGlvbixcbiAgICAgIFJlYWN0SW5zdGFuY2VNYXAuZ2V0KHRoaXMpLl9jb250ZXh0XG4gICAgKTtcbiAgICBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5yZWxlYXNlKHRyYW5zYWN0aW9uKTtcbiAgfSxcbiAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudW5tb3VudENoaWxkcmVuKCk7XG4gICAgdGhpcy5ub2RlLmRlc3Ryb3koKTtcbiAgICB0aGlzLm5vZGUucGFyZW50Tm9kZSA9IG51bGw7XG4gIH0sXG4gIGFwcGx5Tm9kZVByb3BzOiBOb2RlTWl4aW4uYXBwbHlOb2RlUHJvcHMsXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICByZWY6IChmdW5jdGlvbihjKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5kb21Ob2RlID0gYyk7XG4gICAgICB9KS5iaW5kKHRoaXMpLFxuICAgICAgY2xhc3NOYW1lOiBwcm9wcy5jbGFzc05hbWUsXG4gICAgICByb2xlOiBwcm9wcy5yb2xlLFxuICAgICAgc3R5bGU6IHByb3BzLnN0eWxlLFxuICAgICAgdGFiSW5kZXg6IHByb3BzLnRhYkluZGV4LFxuICAgICAgdGl0bGU6IHByb3BzLnRpdGxlXG4gICAgfSk7XG4gIH1cbn0pO1xuXG52YXIgR3JvdXBNaXhpbiA9IHtcbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uKFxuICAgIHRyYW5zYWN0aW9uLFxuICAgIG5hdGl2ZVBhcmVudCxcbiAgICBuYXRpdmVDb250YWluZXJJbmZvLFxuICAgIGNvbnRleHRcbiAgKSB7XG4gICAgdGhpcy5fbmF0aXZlQ29udGFpbmVySW5mbyA9IG5hdGl2ZUNvbnRhaW5lckluZm87XG4gICAgdGhpcy5ub2RlID0gbmV3IEtvbnZhW3RoaXMuY29uc3RydWN0b3IuZGlzcGxheU5hbWVdKCk7XG4gICAgbmF0aXZlUGFyZW50Lm5vZGUuYWRkKHRoaXMubm9kZSk7XG4gICAgdmFyIHByb3BzID0gdGhpcy5faW5pdGlhbFByb3BzO1xuICAgIHRoaXMuYXBwbHlOb2RlUHJvcHMoZW1wdHlPYmplY3QsIHByb3BzKTtcbiAgICB0aGlzLm1vdW50QW5kSW5qZWN0Q2hpbGRyZW4ocHJvcHMuY2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICByZXR1cm4geyBjaGlsZHJlbjogW10sIG5vZGU6IHRoaXMubm9kZSwgaHRtbDogbnVsbCwgdGV4dDogbnVsbCB9O1xuICB9LFxuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnVubW91bnRDaGlsZHJlbigpO1xuICB9XG59O1xuXG52YXIgU2hhcGVNaXhpbiA9IHtcbiAgY29uc3RydWN0OiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuX29sZFBhdGggPSBudWxsO1xuICB9LFxuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24oXG4gICAgdHJhbnNhY3Rpb24sXG4gICAgbmF0aXZlUGFyZW50LFxuICAgIG5hdGl2ZUNvbnRhaW5lckluZm8sXG4gICAgY29udGV4dFxuICApIHtcbiAgICB0aGlzLl9uYXRpdmVDb250YWluZXJJbmZvID0gbmF0aXZlQ29udGFpbmVySW5mbztcbiAgICB0aGlzLm5vZGUgPSBuZXcgS29udmFbdGhpcy5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZV0oKTtcbiAgICBpZiAobmF0aXZlUGFyZW50KSB7XG4gICAgICBuYXRpdmVQYXJlbnQubm9kZS5hZGQodGhpcy5ub2RlKTtcbiAgICB9XG4gICAgdGhpcy5hcHBseU5vZGVQcm9wcyhlbXB0eU9iamVjdCwgdGhpcy5faW5pdGlhbFByb3BzKTtcbiAgICByZXR1cm4geyBjaGlsZHJlbjogW10sIG5vZGU6IHRoaXMubm9kZSwgaHRtbDogbnVsbCwgdGV4dDogbnVsbCB9O1xuICB9LFxuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbihuZXh0Q29tcG9uZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBwcm9wcyA9IG5leHRDb21wb25lbnQucHJvcHM7XG4gICAgdmFyIG9sZFByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHMgfHwgdGhpcy5faW5pdGlhbFByb3BzO1xuICAgIHRoaXMuYXBwbHlOb2RlUHJvcHMob2xkUHJvcHMsIHByb3BzKTtcbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG5leHRDb21wb25lbnQ7XG4gIH1cbn07XG5cbnZhciBHcm91cCA9IGNyZWF0ZUNvbXBvbmVudCgnR3JvdXAnLCBOb2RlTWl4aW4sIENvbnRhaW5lck1peGluLCBHcm91cE1peGluKTtcbnZhciBMYXllciA9IGNyZWF0ZUNvbXBvbmVudCgnTGF5ZXInLCBOb2RlTWl4aW4sIENvbnRhaW5lck1peGluLCBHcm91cE1peGluKTtcbnZhciBGYXN0TGF5ZXIgPSBjcmVhdGVDb21wb25lbnQoXG4gICdGYXN0TGF5ZXInLFxuICBOb2RlTWl4aW4sXG4gIENvbnRhaW5lck1peGluLFxuICBHcm91cE1peGluXG4pO1xuXG52YXIgTGFiZWwgPSBjcmVhdGVDb21wb25lbnQoJ0xhYmVsJywgTm9kZU1peGluLCBDb250YWluZXJNaXhpbiwgR3JvdXBNaXhpbik7XG5cbnZhciBSZWFjdEtvbnZhID0ge1xuICBTdGFnZTogU3RhZ2UsXG4gIEdyb3VwOiBHcm91cCxcbiAgTGF5ZXI6IExheWVyLFxuICBGYXN0TGF5ZXI6IEZhc3RMYXllcixcbiAgTGFiZWw6IExhYmVsXG59O1xuXG52YXIgc2hhcGVzID0gW1xuICAnUmVjdCcsXG4gICdDaXJjbGUnLFxuICAnRWxsaXBzZScsXG4gICdXZWRnZScsXG4gICdMaW5lJyxcbiAgJ1Nwcml0ZScsXG4gICdJbWFnZScsXG4gICdUZXh0JyxcbiAgJ1RleHRQYXRoJyxcbiAgJ1N0YXInLFxuICAnUmluZycsXG4gICdBcmMnLFxuICAnVGFnJyxcbiAgJ1BhdGgnLFxuICAnUmVndWxhclBvbHlnb24nLFxuICAnQXJyb3cnLFxuICAnU2hhcGUnXG5dO1xuXG5zaGFwZXMuZm9yRWFjaChmdW5jdGlvbihzaGFwZU5hbWUpIHtcbiAgUmVhY3RLb252YVtzaGFwZU5hbWVdID0gY3JlYXRlQ29tcG9uZW50KHNoYXBlTmFtZSwgTm9kZU1peGluLCBTaGFwZU1peGluKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0S29udmE7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1rb252YS9zcmMvcmVhY3Qta29udmEuanNcbi8vIG1vZHVsZSBpZCA9IDkxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICogS29udmEgSmF2YVNjcmlwdCBGcmFtZXdvcmsgdjEuNy42XG4gKiBodHRwOi8va29udmFqcy5naXRodWIuaW8vXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIG9yIEdQTCBWZXJzaW9uIDIgbGljZW5zZXMuXG4gKiBEYXRlOiBXZWQgTm92IDAxIDIwMTdcbiAqXG4gKiBPcmlnaW5hbCB3b3JrIENvcHlyaWdodCAoQykgMjAxMSAtIDIwMTMgYnkgRXJpYyBSb3dlbGwgKEtpbmV0aWNKUylcbiAqIE1vZGlmaWVkIHdvcmsgQ29weXJpZ2h0IChDKSAyMDE0IC0gMjAxNyBieSBBbnRvbiBMYXZyZW5vdiAoS29udmEpXG4gKlxuICogQGxpY2Vuc2VcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLy8gcnVudGltZSBjaGVjayBmb3IgYWxyZWFkeSBpbmNsdWRlZCBLb252YVxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIC8qKlxuICAgICAqIEBuYW1lc3BhY2UgS29udmFcbiAgICAgKi9cblxuICB2YXIgUElfT1ZFUl8xODAgPSBNYXRoLlBJIC8gMTgwO1xuXG4gIHZhciBLb252YSA9IHtcbiAgICAvLyBwdWJsaWNcbiAgICB2ZXJzaW9uOiAnMS43LjYnLFxuXG4gICAgLy8gcHJpdmF0ZVxuICAgIHN0YWdlczogW10sXG4gICAgaWRDb3VudGVyOiAwLFxuICAgIGlkczoge30sXG4gICAgbmFtZXM6IHt9LFxuICAgIHNoYXBlczoge30sXG4gICAgbGlzdGVuQ2xpY2tUYXA6IGZhbHNlLFxuICAgIGluRGJsQ2xpY2tXaW5kb3c6IGZhbHNlLFxuXG4gICAgaXNCcm93c2VyOlxuICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIC8vIGJyb3dzZXIgY2FzZVxuICAgICAgKHt9LnRvU3RyaW5nLmNhbGwod2luZG93KSA9PT0gJ1tvYmplY3QgV2luZG93XScgfHxcbiAgICAgICAgLy8gZWxlY3Ryb24gY2FzZVxuICAgICAgICB7fS50b1N0cmluZy5jYWxsKHdpbmRvdykgPT09ICdbb2JqZWN0IGdsb2JhbF0nKSxcblxuICAgIC8vIGNvbmZpZ3VyYXRpb25zXG4gICAgZW5hYmxlVHJhY2U6IGZhbHNlLFxuICAgIHRyYWNlQXJyTWF4OiAxMDAsXG4gICAgZGJsQ2xpY2tXaW5kb3c6IDQwMCxcbiAgICAvKipcbiAgICAgICAgICogR2xvYmFsIHBpeGVsIHJhdGlvIGNvbmZpZ3VyYXRpb24uIEtvbnZhSlMgYXV0b21hdGljYWxseSBkZXRlY3QgcGl4ZWwgcmF0aW8gb2YgY3VycmVudCBkZXZpY2UuXG4gICAgICAgICAqIEJ1dCB5b3UgbWF5IG92ZXJyaWRlIHN1Y2ggcHJvcGVydHksIGlmIHlvdSB3YW50IHRvIHVzZSB5b3VyIHZhbHVlLlxuICAgICAgICAgKiBAcHJvcGVydHkgcGl4ZWxSYXRpb1xuICAgICAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIEtvbnZhLnBpeGVsUmF0aW8gPSAxO1xuICAgICAgICAgKi9cbiAgICBwaXhlbFJhdGlvOiB1bmRlZmluZWQsXG4gICAgLyoqXG4gICAgICAgICAqIERyYWcgZGlzdGFuY2UgcHJvcGVydHkuIElmIHlvdSBzdGFydCB0byBkcmFnIGEgbm9kZSB5b3UgbWF5IHdhbnQgdG8gd2FpdCB1bnRpbCBwb2ludGVyIGlzIG1vdmVkIHRvIHNvbWUgZGlzdGFuY2UgZnJvbSBzdGFydCBwb2ludCxcbiAgICAgICAgICogb25seSB0aGVuIHN0YXJ0IGRyYWdnaW5nLiBEZWZhdWx0IGlzIDNweC5cbiAgICAgICAgICogQHByb3BlcnR5IGRyYWdEaXN0YW5jZVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBLb252YS5kcmFnRGlzdGFuY2UgPSAxMDtcbiAgICAgICAgICovXG4gICAgZHJhZ0Rpc3RhbmNlOiAzLFxuICAgIC8qKlxuICAgICAgICAgKiBVc2UgZGVncmVlIHZhbHVlcyBmb3IgYW5nbGUgcHJvcGVydGllcy4gWW91IG1heSBzZXQgdGhpcyBwcm9wZXJ0eSB0byBmYWxzZSBpZiB5b3Ugd2FudCB0byB1c2UgcmFkaWFudCB2YWx1ZXMuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBhbmdsZURlZ1xuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBub2RlLnJvdGF0aW9uKDQ1KTsgLy8gNDUgZGVncmVlc1xuICAgICAgICAgKiBLb252YS5hbmdsZURlZyA9IGZhbHNlO1xuICAgICAgICAgKiBub2RlLnJvdGF0aW9uKE1hdGguUEkgLyAyKTsgLy8gUEkvMiByYWRpYW5cbiAgICAgICAgICovXG4gICAgYW5nbGVEZWc6IHRydWUsXG4gICAgLyoqXG4gICAgICAgICAqIFNob3cgZGlmZmVyZW50IHdhcm5pbmdzIGFib3V0IGVycm9ycyBvciB3cm9uZyBBUEkgdXNhZ2VcbiAgICAgICAgICogQHByb3BlcnR5IHNob3dXYXJuaW5nc1xuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBLb252YS5zaG93V2FybmluZ3MgPSBmYWxzZTtcbiAgICAgICAgICovXG4gICAgc2hvd1dhcm5pbmdzOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICAgICAqIEBuYW1lc3BhY2UgRmlsdGVyc1xuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgICAgICovXG4gICAgRmlsdGVyczoge30sXG5cbiAgICAvKipcbiAgICAgICAgICogcmV0dXJucyB3aGV0aGVyIG9yIG5vdCBkcmFnIGFuZCBkcm9wIGlzIGN1cnJlbnRseSBhY3RpdmVcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgICAgICovXG4gICAgaXNEcmFnZ2luZzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGQgPSBLb252YS5ERDtcblxuICAgICAgLy8gaWYgREQgaXMgbm90IGluY2x1ZGVkIHdpdGggdGhlIGJ1aWxkLCB0aGVuXG4gICAgICAvLyBkcmFnIGFuZCBkcm9wIGlzIG5vdCBldmVuIHBvc3NpYmxlXG4gICAgICBpZiAoZGQpIHtcbiAgICAgICAgcmV0dXJuIGRkLmlzRHJhZ2dpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgKiByZXR1cm5zIHdoZXRoZXIgb3Igbm90IGEgZHJhZyBhbmQgZHJvcCBvcGVyYXRpb24gaXMgcmVhZHksIGJ1dCBtYXlcbiAgICAgICAgKiAgbm90IG5lY2Vzc2FyaWx5IGhhdmUgc3RhcnRlZFxuICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgICAgKi9cbiAgICBpc0RyYWdSZWFkeTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGQgPSBLb252YS5ERDtcblxuICAgICAgLy8gaWYgREQgaXMgbm90IGluY2x1ZGVkIHdpdGggdGhlIGJ1aWxkLCB0aGVuXG4gICAgICAvLyBkcmFnIGFuZCBkcm9wIGlzIG5vdCBldmVuIHBvc3NpYmxlXG4gICAgICBpZiAoZGQpIHtcbiAgICAgICAgcmV0dXJuICEhZGQubm9kZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIF9hZGRJZDogZnVuY3Rpb24obm9kZSwgaWQpIHtcbiAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuaWRzW2lkXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfSxcbiAgICBfcmVtb3ZlSWQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWxldGUgdGhpcy5pZHNbaWRdO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2FkZE5hbWU6IGZ1bmN0aW9uKG5vZGUsIG5hbWUpIHtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5uYW1lc1tuYW1lXSkge1xuICAgICAgICAgIHRoaXMubmFtZXNbbmFtZV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5hbWVzW25hbWVdLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfcmVtb3ZlTmFtZTogZnVuY3Rpb24obmFtZSwgX2lkKSB7XG4gICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG5vZGVzID0gdGhpcy5uYW1lc1tuYW1lXTtcbiAgICAgIGlmICghbm9kZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBub2Rlcy5sZW5ndGg7IG4rKykge1xuICAgICAgICB2YXIgbm8gPSBub2Rlc1tuXTtcbiAgICAgICAgaWYgKG5vLl9pZCA9PT0gX2lkKSB7XG4gICAgICAgICAgbm9kZXMuc3BsaWNlKG4sIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm5hbWVzW25hbWVdO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0QW5nbGU6IGZ1bmN0aW9uKGFuZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5hbmdsZURlZyA/IGFuZ2xlICogUElfT1ZFUl8xODAgOiBhbmdsZTtcbiAgICB9LFxuICAgIF9kZXRlY3RJRTogZnVuY3Rpb24odWEpIHtcbiAgICAgIHZhciBtc2llID0gdWEuaW5kZXhPZignbXNpZSAnKTtcbiAgICAgIGlmIChtc2llID4gMCkge1xuICAgICAgICAvLyBJRSAxMCBvciBvbGRlciA9PiByZXR1cm4gdmVyc2lvbiBudW1iZXJcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHVhLnN1YnN0cmluZyhtc2llICsgNSwgdWEuaW5kZXhPZignLicsIG1zaWUpKSwgMTApO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHJpZGVudCA9IHVhLmluZGV4T2YoJ3RyaWRlbnQvJyk7XG4gICAgICBpZiAodHJpZGVudCA+IDApIHtcbiAgICAgICAgLy8gSUUgMTEgPT4gcmV0dXJuIHZlcnNpb24gbnVtYmVyXG4gICAgICAgIHZhciBydiA9IHVhLmluZGV4T2YoJ3J2OicpO1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQodWEuc3Vic3RyaW5nKHJ2ICsgMywgdWEuaW5kZXhPZignLicsIHJ2KSksIDEwKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVkZ2UgPSB1YS5pbmRleE9mKCdlZGdlLycpO1xuICAgICAgaWYgKGVkZ2UgPiAwKSB7XG4gICAgICAgIC8vIEVkZ2UgKElFIDEyKykgPT4gcmV0dXJuIHZlcnNpb24gbnVtYmVyXG4gICAgICAgIHJldHVybiBwYXJzZUludCh1YS5zdWJzdHJpbmcoZWRnZSArIDUsIHVhLmluZGV4T2YoJy4nLCBlZGdlKSksIDEwKTtcbiAgICAgIH1cblxuICAgICAgLy8gb3RoZXIgYnJvd3NlclxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgX3BhcnNlVUE6IGZ1bmN0aW9uKHVzZXJBZ2VudCkge1xuICAgICAgdmFyIHVhID0gdXNlckFnZW50LnRvTG93ZXJDYXNlKCksXG4gICAgICAgIC8vIGpRdWVyeSBVQSByZWdleFxuICAgICAgICBtYXRjaCA9XG4gICAgICAgICAgLyhjaHJvbWUpWyAvXShbXFx3Ll0rKS8uZXhlYyh1YSkgfHxcbiAgICAgICAgICAvKHdlYmtpdClbIC9dKFtcXHcuXSspLy5leGVjKHVhKSB8fFxuICAgICAgICAgIC8ob3BlcmEpKD86Lip2ZXJzaW9ufClbIC9dKFtcXHcuXSspLy5leGVjKHVhKSB8fFxuICAgICAgICAgIC8obXNpZSkgKFtcXHcuXSspLy5leGVjKHVhKSB8fFxuICAgICAgICAgICh1YS5pbmRleE9mKCdjb21wYXRpYmxlJykgPCAwICYmXG4gICAgICAgICAgICAvKG1vemlsbGEpKD86Lio/IHJ2OihbXFx3Ll0rKXwpLy5leGVjKHVhKSkgfHxcbiAgICAgICAgICBbXSxcbiAgICAgICAgLy8gYWRkaW5nIG1vYmlsZSBmbGFnIGFzIHdlbGxcbiAgICAgICAgbW9iaWxlID0gISF1c2VyQWdlbnQubWF0Y2goXG4gICAgICAgICAgL0FuZHJvaWR8QmxhY2tCZXJyeXxpUGhvbmV8aVBhZHxpUG9kfE9wZXJhIE1pbml8SUVNb2JpbGUvaVxuICAgICAgICApLFxuICAgICAgICBpZU1vYmlsZSA9ICEhdXNlckFnZW50Lm1hdGNoKC9JRU1vYmlsZS9pKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYnJvd3NlcjogbWF0Y2hbMV0gfHwgJycsXG4gICAgICAgIHZlcnNpb246IG1hdGNoWzJdIHx8ICcwJyxcbiAgICAgICAgaXNJRTogS29udmEuX2RldGVjdElFKHVhKSxcbiAgICAgICAgLy8gYWRkaW5nIG1vYmlsZSBmbGFiXG4gICAgICAgIG1vYmlsZTogbW9iaWxlLFxuICAgICAgICBpZU1vYmlsZTogaWVNb2JpbGUgLy8gSWYgdGhpcyBpcyB0cnVlIChpLmUuLCBXUDgpLCB0aGVuIEtvbnZhIHRvdWNoIGV2ZW50cyBhcmUgZXhlY3V0ZWQgaW5zdGVhZCBvZiBlcXVpdmFsZW50IEtvbnZhIG1vdXNlIGV2ZW50c1xuICAgICAgfTtcbiAgICB9LFxuICAgIC8vIHVzZXIgYWdlbnRcbiAgICBVQTogdW5kZWZpbmVkXG4gIH07XG5cbiAgdmFyIGdsb2IgPVxuICAgIHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnXG4gICAgICA/IGdsb2JhbFxuICAgICAgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IHdpbmRvd1xuICAgICAgICA6IHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbiAgS29udmEuVUEgPSBLb252YS5fcGFyc2VVQSgoZ2xvYi5uYXZpZ2F0b3IgJiYgZ2xvYi5uYXZpZ2F0b3IudXNlckFnZW50KSB8fCAnJyk7XG5cbiAgaWYgKGdsb2IuS29udmEpIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgJ0tvbnZhIGluc3RhbmNlIGlzIGFscmVhZHkgZXhpc3QgaW4gY3VycmVudCBldmlyb21lbnQuICcgK1xuICAgICAgICAnUGxlYXNlIHVzZSBvbmx5IG9uZSBpbnN0YW5jZS4nXG4gICAgKTtcbiAgfVxuICBnbG9iLktvbnZhID0gS29udmE7XG4gIEtvbnZhLmdsb2JhbCA9IGdsb2I7XG4gIEtvbnZhLndpbmRvdyA9IGdsb2I7XG4gIEtvbnZhLmRvY3VtZW50ID0gZ2xvYi5kb2N1bWVudDtcblxuICBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBLb252YTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEtvbnZhO1xuICAgIH0pO1xuICB9XG59KSgpO1xuXG4vKmVzbGludC1kaXNhYmxlICBlcWVxZXEsIG5vLWNvbmQtYXNzaWduLCBuby1lbXB0eSovXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLyoqXG4gICAgICogQ29sbGVjdGlvbiBjb25zdHJ1Y3Rvci4gIENvbGxlY3Rpb24gZXh0ZW5kc1xuICAgICAqICBBcnJheS4gIFRoaXMgY2xhc3MgaXMgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHtAbGluayBLb252YS5Db250YWluZXIjZ2V0fVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqL1xuICBLb252YS5Db2xsZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgICBsZW5ndGggPSBhcmdzLmxlbmd0aCxcbiAgICAgIGkgPSAwO1xuXG4gICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IGFyZ3NbaV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBLb252YS5Db2xsZWN0aW9uLnByb3RvdHlwZSA9IFtdO1xuICAvKipcbiAgICAgKiBpdGVyYXRlIHRocm91Z2ggbm9kZSBhcnJheSBhbmQgcnVuIGEgZnVuY3Rpb24gZm9yIGVhY2ggbm9kZS5cbiAgICAgKiAgVGhlIG5vZGUgYW5kIGluZGV4IGlzIHBhc3NlZCBpbnRvIHRoZSBmdW5jdGlvblxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29sbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgYWxsIG5vZGVzIHdpdGggbmFtZSBmb28gaW5zaWRlIGxheWVyLCBhbmQgc2V0IHggdG8gMTAgZm9yIGVhY2hcbiAgICAgKiBsYXllci5nZXQoJy5mb28nKS5lYWNoKGZ1bmN0aW9uKHNoYXBlLCBuKSB7XG4gICAgICogICBzaGFwZS5zZXRYKDEwKTtcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgS29udmEuQ29sbGVjdGlvbi5wcm90b3R5cGUuZWFjaCA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICBmb3IgKHZhciBuID0gMDsgbiA8IHRoaXMubGVuZ3RoOyBuKyspIHtcbiAgICAgIGZ1bmModGhpc1tuXSwgbik7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICAgKiBjb252ZXJ0IGNvbGxlY3Rpb24gaW50byBhbiBhcnJheVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29sbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgS29udmEuQ29sbGVjdGlvbi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcnIgPSBbXSxcbiAgICAgIGxlbiA9IHRoaXMubGVuZ3RoLFxuICAgICAgbjtcblxuICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgYXJyLnB1c2godGhpc1tuXSk7XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG4gIH07XG4gIC8qKlxuICAgICAqIGNvbnZlcnQgYXJyYXkgaW50byBhIGNvbGxlY3Rpb25cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAgICAgKi9cbiAgS29udmEuQ29sbGVjdGlvbi50b0NvbGxlY3Rpb24gPSBmdW5jdGlvbihhcnIpIHtcbiAgICB2YXIgY29sbGVjdGlvbiA9IG5ldyBLb252YS5Db2xsZWN0aW9uKCksXG4gICAgICBsZW4gPSBhcnIubGVuZ3RoLFxuICAgICAgbjtcblxuICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgY29sbGVjdGlvbi5wdXNoKGFycltuXSk7XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICB9O1xuXG4gIC8vIG1hcCBvbmUgbWV0aG9kIGJ5IGl0J3MgbmFtZVxuICBLb252YS5Db2xsZWN0aW9uLl9tYXBNZXRob2QgPSBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgS29udmEuQ29sbGVjdGlvbi5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcbiAgICAgICAgaTtcblxuICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdGhpc1tpXVttZXRob2ROYW1lXS5hcHBseSh0aGlzW2ldLCBhcmdzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgfTtcblxuICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMgPSBmdW5jdGlvbihjb25zdHJ1Y3Rvcikge1xuICAgIHZhciBwcm90ID0gY29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgIGZvciAodmFyIG1ldGhvZE5hbWUgaW4gcHJvdCkge1xuICAgICAgS29udmEuQ29sbGVjdGlvbi5fbWFwTWV0aG9kKG1ldGhvZE5hbWUpO1xuICAgIH1cbiAgfTtcblxuICAvKlxuICAgICogTGFzdCB1cGRhdGVkIE5vdmVtYmVyIDIwMTFcbiAgICAqIEJ5IFNpbW9uIFNhcnJpc1xuICAgICogd3d3LnNpbW9uc2FycmlzLmNvbVxuICAgICogc2FycmlzQGFjbS5vcmdcbiAgICAqXG4gICAgKiBGcmVlIHRvIHVzZSBhbmQgZGlzdHJpYnV0ZSBhdCB3aWxsXG4gICAgKiBTbyBsb25nIGFzIHlvdSBhcmUgbmljZSB0byBwZW9wbGUsIGV0Y1xuICAgICovXG5cbiAgLypcbiAgICAqIFRoZSB1c2FnZSBvZiB0aGlzIGNsYXNzIHdhcyBpbnNwaXJlZCBieSBzb21lIG9mIHRoZSB3b3JrIGRvbmUgYnkgYSBmb3JrZWRcbiAgICAqIHByb2plY3QsIEtpbmV0aWNKUy1FeHQgYnkgV2FwcHdvcmtzLCB3aGljaCBpcyBiYXNlZCBvbiBTaW1vbidzIFRyYW5zZm9ybVxuICAgICogY2xhc3MuICBNb2RpZmllZCBieSBFcmljIFJvd2VsbFxuICAgICovXG5cbiAgLyoqXG4gICAgICogVHJhbnNmb3JtIGNvbnN0cnVjdG9yXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW21dIE9wdGlvbmFsIHNpeC1lbGVtZW50IG1hdHJpeFxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqL1xuICBLb252YS5UcmFuc2Zvcm0gPSBmdW5jdGlvbihtKSB7XG4gICAgdGhpcy5tID0gKG0gJiYgbS5zbGljZSgpKSB8fCBbMSwgMCwgMCwgMSwgMCwgMF07XG4gIH07XG5cbiAgS29udmEuVHJhbnNmb3JtLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgICAgICogQ29weSBLb252YS5UcmFuc2Zvcm0gb2JqZWN0XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlRyYW5zZm9ybS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLlRyYW5zZm9ybX1cbiAgICAgICAgICovXG4gICAgY29weTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IEtvbnZhLlRyYW5zZm9ybSh0aGlzLm0pO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIFRyYW5zZm9ybSBwb2ludFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5UcmFuc2Zvcm0ucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludCAyRCBwb2ludCh4LCB5KVxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSAyRCBwb2ludCh4LCB5KVxuICAgICAgICAgKi9cbiAgICBwb2ludDogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgIHZhciBtID0gdGhpcy5tO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogbVswXSAqIHBvaW50LnggKyBtWzJdICogcG9pbnQueSArIG1bNF0sXG4gICAgICAgIHk6IG1bMV0gKiBwb2ludC54ICsgbVszXSAqIHBvaW50LnkgKyBtWzVdXG4gICAgICB9O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIEFwcGx5IHRyYW5zbGF0aW9uXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlRyYW5zZm9ybS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLlRyYW5zZm9ybX1cbiAgICAgICAgICovXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB0aGlzLm1bNF0gKz0gdGhpcy5tWzBdICogeCArIHRoaXMubVsyXSAqIHk7XG4gICAgICB0aGlzLm1bNV0gKz0gdGhpcy5tWzFdICogeCArIHRoaXMubVszXSAqIHk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiBBcHBseSBzY2FsZVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5UcmFuc2Zvcm0ucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzeFxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gc3lcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLlRyYW5zZm9ybX1cbiAgICAgICAgICovXG4gICAgc2NhbGU6IGZ1bmN0aW9uKHN4LCBzeSkge1xuICAgICAgdGhpcy5tWzBdICo9IHN4O1xuICAgICAgdGhpcy5tWzFdICo9IHN4O1xuICAgICAgdGhpcy5tWzJdICo9IHN5O1xuICAgICAgdGhpcy5tWzNdICo9IHN5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogQXBwbHkgcm90YXRpb25cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVHJhbnNmb3JtLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkICBBbmdsZSBpbiByYWRpYW5zXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5UcmFuc2Zvcm19XG4gICAgICAgICAqL1xuICAgIHJvdGF0ZTogZnVuY3Rpb24ocmFkKSB7XG4gICAgICB2YXIgYyA9IE1hdGguY29zKHJhZCk7XG4gICAgICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gICAgICB2YXIgbTExID0gdGhpcy5tWzBdICogYyArIHRoaXMubVsyXSAqIHM7XG4gICAgICB2YXIgbTEyID0gdGhpcy5tWzFdICogYyArIHRoaXMubVszXSAqIHM7XG4gICAgICB2YXIgbTIxID0gdGhpcy5tWzBdICogLXMgKyB0aGlzLm1bMl0gKiBjO1xuICAgICAgdmFyIG0yMiA9IHRoaXMubVsxXSAqIC1zICsgdGhpcy5tWzNdICogYztcbiAgICAgIHRoaXMubVswXSA9IG0xMTtcbiAgICAgIHRoaXMubVsxXSA9IG0xMjtcbiAgICAgIHRoaXMubVsyXSA9IG0yMTtcbiAgICAgIHRoaXMubVszXSA9IG0yMjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHRyYW5zbGF0aW9uXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlRyYW5zZm9ybS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH0gMkQgcG9pbnQoeCwgeSlcbiAgICAgICAgICovXG4gICAgZ2V0VHJhbnNsYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogdGhpcy5tWzRdLFxuICAgICAgICB5OiB0aGlzLm1bNV1cbiAgICAgIH07XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogQXBwbHkgc2tld1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5UcmFuc2Zvcm0ucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzeFxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gc3lcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLlRyYW5zZm9ybX1cbiAgICAgICAgICovXG4gICAgc2tldzogZnVuY3Rpb24oc3gsIHN5KSB7XG4gICAgICB2YXIgbTExID0gdGhpcy5tWzBdICsgdGhpcy5tWzJdICogc3k7XG4gICAgICB2YXIgbTEyID0gdGhpcy5tWzFdICsgdGhpcy5tWzNdICogc3k7XG4gICAgICB2YXIgbTIxID0gdGhpcy5tWzJdICsgdGhpcy5tWzBdICogc3g7XG4gICAgICB2YXIgbTIyID0gdGhpcy5tWzNdICsgdGhpcy5tWzFdICogc3g7XG4gICAgICB0aGlzLm1bMF0gPSBtMTE7XG4gICAgICB0aGlzLm1bMV0gPSBtMTI7XG4gICAgICB0aGlzLm1bMl0gPSBtMjE7XG4gICAgICB0aGlzLm1bM10gPSBtMjI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiBUcmFuc2Zvcm0gbXVsdGlwbGljYXRpb25cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVHJhbnNmb3JtLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge0tvbnZhLlRyYW5zZm9ybX0gbWF0cml4XG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5UcmFuc2Zvcm19XG4gICAgICAgICAqL1xuICAgIG11bHRpcGx5OiBmdW5jdGlvbihtYXRyaXgpIHtcbiAgICAgIHZhciBtMTEgPSB0aGlzLm1bMF0gKiBtYXRyaXgubVswXSArIHRoaXMubVsyXSAqIG1hdHJpeC5tWzFdO1xuICAgICAgdmFyIG0xMiA9IHRoaXMubVsxXSAqIG1hdHJpeC5tWzBdICsgdGhpcy5tWzNdICogbWF0cml4Lm1bMV07XG5cbiAgICAgIHZhciBtMjEgPSB0aGlzLm1bMF0gKiBtYXRyaXgubVsyXSArIHRoaXMubVsyXSAqIG1hdHJpeC5tWzNdO1xuICAgICAgdmFyIG0yMiA9IHRoaXMubVsxXSAqIG1hdHJpeC5tWzJdICsgdGhpcy5tWzNdICogbWF0cml4Lm1bM107XG5cbiAgICAgIHZhciBkeCA9IHRoaXMubVswXSAqIG1hdHJpeC5tWzRdICsgdGhpcy5tWzJdICogbWF0cml4Lm1bNV0gKyB0aGlzLm1bNF07XG4gICAgICB2YXIgZHkgPSB0aGlzLm1bMV0gKiBtYXRyaXgubVs0XSArIHRoaXMubVszXSAqIG1hdHJpeC5tWzVdICsgdGhpcy5tWzVdO1xuXG4gICAgICB0aGlzLm1bMF0gPSBtMTE7XG4gICAgICB0aGlzLm1bMV0gPSBtMTI7XG4gICAgICB0aGlzLm1bMl0gPSBtMjE7XG4gICAgICB0aGlzLm1bM10gPSBtMjI7XG4gICAgICB0aGlzLm1bNF0gPSBkeDtcbiAgICAgIHRoaXMubVs1XSA9IGR5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogSW52ZXJ0IHRoZSBtYXRyaXhcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVHJhbnNmb3JtLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuVHJhbnNmb3JtfVxuICAgICAgICAgKi9cbiAgICBpbnZlcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGQgPSAxIC8gKHRoaXMubVswXSAqIHRoaXMubVszXSAtIHRoaXMubVsxXSAqIHRoaXMubVsyXSk7XG4gICAgICB2YXIgbTAgPSB0aGlzLm1bM10gKiBkO1xuICAgICAgdmFyIG0xID0gLXRoaXMubVsxXSAqIGQ7XG4gICAgICB2YXIgbTIgPSAtdGhpcy5tWzJdICogZDtcbiAgICAgIHZhciBtMyA9IHRoaXMubVswXSAqIGQ7XG4gICAgICB2YXIgbTQgPSBkICogKHRoaXMubVsyXSAqIHRoaXMubVs1XSAtIHRoaXMubVszXSAqIHRoaXMubVs0XSk7XG4gICAgICB2YXIgbTUgPSBkICogKHRoaXMubVsxXSAqIHRoaXMubVs0XSAtIHRoaXMubVswXSAqIHRoaXMubVs1XSk7XG4gICAgICB0aGlzLm1bMF0gPSBtMDtcbiAgICAgIHRoaXMubVsxXSA9IG0xO1xuICAgICAgdGhpcy5tWzJdID0gbTI7XG4gICAgICB0aGlzLm1bM10gPSBtMztcbiAgICAgIHRoaXMubVs0XSA9IG00O1xuICAgICAgdGhpcy5tWzVdID0gbTU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiByZXR1cm4gbWF0cml4XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlRyYW5zZm9ybS5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgZ2V0TWF0cml4OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm07XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogc2V0IHRvIGFic29sdXRlIHBvc2l0aW9uIHZpYSB0cmFuc2xhdGlvblxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5UcmFuc2Zvcm0ucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5UcmFuc2Zvcm19XG4gICAgICAgICAqIEBhdXRob3IgZXJpY2Ryb3dlbGxcbiAgICAgICAgICovXG4gICAgc2V0QWJzb2x1dGVQb3NpdGlvbjogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgdmFyIG0wID0gdGhpcy5tWzBdLFxuICAgICAgICBtMSA9IHRoaXMubVsxXSxcbiAgICAgICAgbTIgPSB0aGlzLm1bMl0sXG4gICAgICAgIG0zID0gdGhpcy5tWzNdLFxuICAgICAgICBtNCA9IHRoaXMubVs0XSxcbiAgICAgICAgbTUgPSB0aGlzLm1bNV0sXG4gICAgICAgIHl0ID0gKG0wICogKHkgLSBtNSkgLSBtMSAqICh4IC0gbTQpKSAvIChtMCAqIG0zIC0gbTEgKiBtMiksXG4gICAgICAgIHh0ID0gKHggLSBtNCAtIG0yICogeXQpIC8gbTA7XG5cbiAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZSh4dCwgeXQpO1xuICAgIH1cbiAgfTtcblxuICAvLyBDT05TVEFOVFNcbiAgdmFyIENPTlRFWFRfMkQgPSAnMmQnLFxuICAgIE9CSkVDVF9BUlJBWSA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgT0JKRUNUX05VTUJFUiA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIE9CSkVDVF9TVFJJTkcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBQSV9PVkVSX0RFRzE4MCA9IE1hdGguUEkgLyAxODAsXG4gICAgREVHMTgwX09WRVJfUEkgPSAxODAgLyBNYXRoLlBJLFxuICAgIEhBU0ggPSAnIycsXG4gICAgRU1QVFlfU1RSSU5HID0gJycsXG4gICAgWkVSTyA9ICcwJyxcbiAgICBLT05WQV9XQVJOSU5HID0gJ0tvbnZhIHdhcm5pbmc6ICcsXG4gICAgS09OVkFfRVJST1IgPSAnS29udmEgZXJyb3I6ICcsXG4gICAgUkdCX1BBUkVOID0gJ3JnYignLFxuICAgIENPTE9SUyA9IHtcbiAgICAgIGFsaWNlYmx1ZTogWzI0MCwgMjQ4LCAyNTVdLFxuICAgICAgYW50aXF1ZXdoaXRlOiBbMjUwLCAyMzUsIDIxNV0sXG4gICAgICBhcXVhOiBbMCwgMjU1LCAyNTVdLFxuICAgICAgYXF1YW1hcmluZTogWzEyNywgMjU1LCAyMTJdLFxuICAgICAgYXp1cmU6IFsyNDAsIDI1NSwgMjU1XSxcbiAgICAgIGJlaWdlOiBbMjQ1LCAyNDUsIDIyMF0sXG4gICAgICBiaXNxdWU6IFsyNTUsIDIyOCwgMTk2XSxcbiAgICAgIGJsYWNrOiBbMCwgMCwgMF0sXG4gICAgICBibGFuY2hlZGFsbW9uZDogWzI1NSwgMjM1LCAyMDVdLFxuICAgICAgYmx1ZTogWzAsIDAsIDI1NV0sXG4gICAgICBibHVldmlvbGV0OiBbMTM4LCA0MywgMjI2XSxcbiAgICAgIGJyb3duOiBbMTY1LCA0MiwgNDJdLFxuICAgICAgYnVybHl3b29kOiBbMjIyLCAxODQsIDEzNV0sXG4gICAgICBjYWRldGJsdWU6IFs5NSwgMTU4LCAxNjBdLFxuICAgICAgY2hhcnRyZXVzZTogWzEyNywgMjU1LCAwXSxcbiAgICAgIGNob2NvbGF0ZTogWzIxMCwgMTA1LCAzMF0sXG4gICAgICBjb3JhbDogWzI1NSwgMTI3LCA4MF0sXG4gICAgICBjb3JuZmxvd2VyYmx1ZTogWzEwMCwgMTQ5LCAyMzddLFxuICAgICAgY29ybnNpbGs6IFsyNTUsIDI0OCwgMjIwXSxcbiAgICAgIGNyaW1zb246IFsyMjAsIDIwLCA2MF0sXG4gICAgICBjeWFuOiBbMCwgMjU1LCAyNTVdLFxuICAgICAgZGFya2JsdWU6IFswLCAwLCAxMzldLFxuICAgICAgZGFya2N5YW46IFswLCAxMzksIDEzOV0sXG4gICAgICBkYXJrZ29sZGVucm9kOiBbMTg0LCAxMzIsIDExXSxcbiAgICAgIGRhcmtncmF5OiBbMTY5LCAxNjksIDE2OV0sXG4gICAgICBkYXJrZ3JlZW46IFswLCAxMDAsIDBdLFxuICAgICAgZGFya2dyZXk6IFsxNjksIDE2OSwgMTY5XSxcbiAgICAgIGRhcmtraGFraTogWzE4OSwgMTgzLCAxMDddLFxuICAgICAgZGFya21hZ2VudGE6IFsxMzksIDAsIDEzOV0sXG4gICAgICBkYXJrb2xpdmVncmVlbjogWzg1LCAxMDcsIDQ3XSxcbiAgICAgIGRhcmtvcmFuZ2U6IFsyNTUsIDE0MCwgMF0sXG4gICAgICBkYXJrb3JjaGlkOiBbMTUzLCA1MCwgMjA0XSxcbiAgICAgIGRhcmtyZWQ6IFsxMzksIDAsIDBdLFxuICAgICAgZGFya3NhbG1vbjogWzIzMywgMTUwLCAxMjJdLFxuICAgICAgZGFya3NlYWdyZWVuOiBbMTQzLCAxODgsIDE0M10sXG4gICAgICBkYXJrc2xhdGVibHVlOiBbNzIsIDYxLCAxMzldLFxuICAgICAgZGFya3NsYXRlZ3JheTogWzQ3LCA3OSwgNzldLFxuICAgICAgZGFya3NsYXRlZ3JleTogWzQ3LCA3OSwgNzldLFxuICAgICAgZGFya3R1cnF1b2lzZTogWzAsIDIwNiwgMjA5XSxcbiAgICAgIGRhcmt2aW9sZXQ6IFsxNDgsIDAsIDIxMV0sXG4gICAgICBkZWVwcGluazogWzI1NSwgMjAsIDE0N10sXG4gICAgICBkZWVwc2t5Ymx1ZTogWzAsIDE5MSwgMjU1XSxcbiAgICAgIGRpbWdyYXk6IFsxMDUsIDEwNSwgMTA1XSxcbiAgICAgIGRpbWdyZXk6IFsxMDUsIDEwNSwgMTA1XSxcbiAgICAgIGRvZGdlcmJsdWU6IFszMCwgMTQ0LCAyNTVdLFxuICAgICAgZmlyZWJyaWNrOiBbMTc4LCAzNCwgMzRdLFxuICAgICAgZmxvcmFsd2hpdGU6IFsyNTUsIDI1NSwgMjQwXSxcbiAgICAgIGZvcmVzdGdyZWVuOiBbMzQsIDEzOSwgMzRdLFxuICAgICAgZnVjaHNpYTogWzI1NSwgMCwgMjU1XSxcbiAgICAgIGdhaW5zYm9ybzogWzIyMCwgMjIwLCAyMjBdLFxuICAgICAgZ2hvc3R3aGl0ZTogWzI0OCwgMjQ4LCAyNTVdLFxuICAgICAgZ29sZDogWzI1NSwgMjE1LCAwXSxcbiAgICAgIGdvbGRlbnJvZDogWzIxOCwgMTY1LCAzMl0sXG4gICAgICBncmF5OiBbMTI4LCAxMjgsIDEyOF0sXG4gICAgICBncmVlbjogWzAsIDEyOCwgMF0sXG4gICAgICBncmVlbnllbGxvdzogWzE3MywgMjU1LCA0N10sXG4gICAgICBncmV5OiBbMTI4LCAxMjgsIDEyOF0sXG4gICAgICBob25leWRldzogWzI0MCwgMjU1LCAyNDBdLFxuICAgICAgaG90cGluazogWzI1NSwgMTA1LCAxODBdLFxuICAgICAgaW5kaWFucmVkOiBbMjA1LCA5MiwgOTJdLFxuICAgICAgaW5kaWdvOiBbNzUsIDAsIDEzMF0sXG4gICAgICBpdm9yeTogWzI1NSwgMjU1LCAyNDBdLFxuICAgICAga2hha2k6IFsyNDAsIDIzMCwgMTQwXSxcbiAgICAgIGxhdmVuZGVyOiBbMjMwLCAyMzAsIDI1MF0sXG4gICAgICBsYXZlbmRlcmJsdXNoOiBbMjU1LCAyNDAsIDI0NV0sXG4gICAgICBsYXduZ3JlZW46IFsxMjQsIDI1MiwgMF0sXG4gICAgICBsZW1vbmNoaWZmb246IFsyNTUsIDI1MCwgMjA1XSxcbiAgICAgIGxpZ2h0Ymx1ZTogWzE3MywgMjE2LCAyMzBdLFxuICAgICAgbGlnaHRjb3JhbDogWzI0MCwgMTI4LCAxMjhdLFxuICAgICAgbGlnaHRjeWFuOiBbMjI0LCAyNTUsIDI1NV0sXG4gICAgICBsaWdodGdvbGRlbnJvZHllbGxvdzogWzI1MCwgMjUwLCAyMTBdLFxuICAgICAgbGlnaHRncmF5OiBbMjExLCAyMTEsIDIxMV0sXG4gICAgICBsaWdodGdyZWVuOiBbMTQ0LCAyMzgsIDE0NF0sXG4gICAgICBsaWdodGdyZXk6IFsyMTEsIDIxMSwgMjExXSxcbiAgICAgIGxpZ2h0cGluazogWzI1NSwgMTgyLCAxOTNdLFxuICAgICAgbGlnaHRzYWxtb246IFsyNTUsIDE2MCwgMTIyXSxcbiAgICAgIGxpZ2h0c2VhZ3JlZW46IFszMiwgMTc4LCAxNzBdLFxuICAgICAgbGlnaHRza3libHVlOiBbMTM1LCAyMDYsIDI1MF0sXG4gICAgICBsaWdodHNsYXRlZ3JheTogWzExOSwgMTM2LCAxNTNdLFxuICAgICAgbGlnaHRzbGF0ZWdyZXk6IFsxMTksIDEzNiwgMTUzXSxcbiAgICAgIGxpZ2h0c3RlZWxibHVlOiBbMTc2LCAxOTYsIDIyMl0sXG4gICAgICBsaWdodHllbGxvdzogWzI1NSwgMjU1LCAyMjRdLFxuICAgICAgbGltZTogWzAsIDI1NSwgMF0sXG4gICAgICBsaW1lZ3JlZW46IFs1MCwgMjA1LCA1MF0sXG4gICAgICBsaW5lbjogWzI1MCwgMjQwLCAyMzBdLFxuICAgICAgbWFnZW50YTogWzI1NSwgMCwgMjU1XSxcbiAgICAgIG1hcm9vbjogWzEyOCwgMCwgMF0sXG4gICAgICBtZWRpdW1hcXVhbWFyaW5lOiBbMTAyLCAyMDUsIDE3MF0sXG4gICAgICBtZWRpdW1ibHVlOiBbMCwgMCwgMjA1XSxcbiAgICAgIG1lZGl1bW9yY2hpZDogWzE4NiwgODUsIDIxMV0sXG4gICAgICBtZWRpdW1wdXJwbGU6IFsxNDcsIDExMiwgMjE5XSxcbiAgICAgIG1lZGl1bXNlYWdyZWVuOiBbNjAsIDE3OSwgMTEzXSxcbiAgICAgIG1lZGl1bXNsYXRlYmx1ZTogWzEyMywgMTA0LCAyMzhdLFxuICAgICAgbWVkaXVtc3ByaW5nZ3JlZW46IFswLCAyNTAsIDE1NF0sXG4gICAgICBtZWRpdW10dXJxdW9pc2U6IFs3MiwgMjA5LCAyMDRdLFxuICAgICAgbWVkaXVtdmlvbGV0cmVkOiBbMTk5LCAyMSwgMTMzXSxcbiAgICAgIG1pZG5pZ2h0Ymx1ZTogWzI1LCAyNSwgMTEyXSxcbiAgICAgIG1pbnRjcmVhbTogWzI0NSwgMjU1LCAyNTBdLFxuICAgICAgbWlzdHlyb3NlOiBbMjU1LCAyMjgsIDIyNV0sXG4gICAgICBtb2NjYXNpbjogWzI1NSwgMjI4LCAxODFdLFxuICAgICAgbmF2YWpvd2hpdGU6IFsyNTUsIDIyMiwgMTczXSxcbiAgICAgIG5hdnk6IFswLCAwLCAxMjhdLFxuICAgICAgb2xkbGFjZTogWzI1MywgMjQ1LCAyMzBdLFxuICAgICAgb2xpdmU6IFsxMjgsIDEyOCwgMF0sXG4gICAgICBvbGl2ZWRyYWI6IFsxMDcsIDE0MiwgMzVdLFxuICAgICAgb3JhbmdlOiBbMjU1LCAxNjUsIDBdLFxuICAgICAgb3JhbmdlcmVkOiBbMjU1LCA2OSwgMF0sXG4gICAgICBvcmNoaWQ6IFsyMTgsIDExMiwgMjE0XSxcbiAgICAgIHBhbGVnb2xkZW5yb2Q6IFsyMzgsIDIzMiwgMTcwXSxcbiAgICAgIHBhbGVncmVlbjogWzE1MiwgMjUxLCAxNTJdLFxuICAgICAgcGFsZXR1cnF1b2lzZTogWzE3NSwgMjM4LCAyMzhdLFxuICAgICAgcGFsZXZpb2xldHJlZDogWzIxOSwgMTEyLCAxNDddLFxuICAgICAgcGFwYXlhd2hpcDogWzI1NSwgMjM5LCAyMTNdLFxuICAgICAgcGVhY2hwdWZmOiBbMjU1LCAyMTgsIDE4NV0sXG4gICAgICBwZXJ1OiBbMjA1LCAxMzMsIDYzXSxcbiAgICAgIHBpbms6IFsyNTUsIDE5MiwgMjAzXSxcbiAgICAgIHBsdW06IFsyMjEsIDE2MCwgMjAzXSxcbiAgICAgIHBvd2RlcmJsdWU6IFsxNzYsIDIyNCwgMjMwXSxcbiAgICAgIHB1cnBsZTogWzEyOCwgMCwgMTI4XSxcbiAgICAgIHJlYmVjY2FwdXJwbGU6IFsxMDIsIDUxLCAxNTNdLFxuICAgICAgcmVkOiBbMjU1LCAwLCAwXSxcbiAgICAgIHJvc3licm93bjogWzE4OCwgMTQzLCAxNDNdLFxuICAgICAgcm95YWxibHVlOiBbNjUsIDEwNSwgMjI1XSxcbiAgICAgIHNhZGRsZWJyb3duOiBbMTM5LCA2OSwgMTldLFxuICAgICAgc2FsbW9uOiBbMjUwLCAxMjgsIDExNF0sXG4gICAgICBzYW5keWJyb3duOiBbMjQ0LCAxNjQsIDk2XSxcbiAgICAgIHNlYWdyZWVuOiBbNDYsIDEzOSwgODddLFxuICAgICAgc2Vhc2hlbGw6IFsyNTUsIDI0NSwgMjM4XSxcbiAgICAgIHNpZW5uYTogWzE2MCwgODIsIDQ1XSxcbiAgICAgIHNpbHZlcjogWzE5MiwgMTkyLCAxOTJdLFxuICAgICAgc2t5Ymx1ZTogWzEzNSwgMjA2LCAyMzVdLFxuICAgICAgc2xhdGVibHVlOiBbMTA2LCA5MCwgMjA1XSxcbiAgICAgIHNsYXRlZ3JheTogWzExOSwgMTI4LCAxNDRdLFxuICAgICAgc2xhdGVncmV5OiBbMTE5LCAxMjgsIDE0NF0sXG4gICAgICBzbm93OiBbMjU1LCAyNTUsIDI1MF0sXG4gICAgICBzcHJpbmdncmVlbjogWzAsIDI1NSwgMTI3XSxcbiAgICAgIHN0ZWVsYmx1ZTogWzcwLCAxMzAsIDE4MF0sXG4gICAgICB0YW46IFsyMTAsIDE4MCwgMTQwXSxcbiAgICAgIHRlYWw6IFswLCAxMjgsIDEyOF0sXG4gICAgICB0aGlzdGxlOiBbMjE2LCAxOTEsIDIxNl0sXG4gICAgICB0cmFuc3BhcmVudDogWzI1NSwgMjU1LCAyNTUsIDBdLFxuICAgICAgdG9tYXRvOiBbMjU1LCA5OSwgNzFdLFxuICAgICAgdHVycXVvaXNlOiBbNjQsIDIyNCwgMjA4XSxcbiAgICAgIHZpb2xldDogWzIzOCwgMTMwLCAyMzhdLFxuICAgICAgd2hlYXQ6IFsyNDUsIDIyMiwgMTc5XSxcbiAgICAgIHdoaXRlOiBbMjU1LCAyNTUsIDI1NV0sXG4gICAgICB3aGl0ZXNtb2tlOiBbMjQ1LCAyNDUsIDI0NV0sXG4gICAgICB5ZWxsb3c6IFsyNTUsIDI1NSwgMF0sXG4gICAgICB5ZWxsb3dncmVlbjogWzE1NCwgMjA1LCA1XVxuICAgIH0sXG4gICAgUkdCX1JFR0VYID0gL3JnYlxcKChcXGR7MSwzfSksKFxcZHsxLDN9KSwoXFxkezEsM30pXFwpLztcblxuICAvKipcbiAgICAgKiBAbmFtZXNwYWNlIFV0aWxcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKi9cbiAgS29udmEuVXRpbCA9IHtcbiAgICAvKlxuICAgICAgICAgKiBjaGVycnktcGlja2VkIHV0aWxpdGllcyBmcm9tIHVuZGVyc2NvcmUuanNcbiAgICAgICAgICovXG4gICAgX2lzRWxlbWVudDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PSAxKTtcbiAgICB9LFxuICAgIF9pc0Z1bmN0aW9uOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiAhIShvYmogJiYgb2JqLmNvbnN0cnVjdG9yICYmIG9iai5jYWxsICYmIG9iai5hcHBseSk7XG4gICAgfSxcbiAgICBfaXNPYmplY3Q6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuICEhb2JqICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xuICAgIH0sXG4gICAgX2lzQXJyYXk6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSBPQkpFQ1RfQVJSQVk7XG4gICAgfSxcbiAgICBfaXNOdW1iZXI6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSBPQkpFQ1RfTlVNQkVSO1xuICAgIH0sXG4gICAgX2lzU3RyaW5nOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gT0JKRUNUX1NUUklORztcbiAgICB9LFxuICAgIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgd2hlbiBpbnZva2VkLCB3aWxsIG9ubHkgYmUgdHJpZ2dlcmVkIGF0IG1vc3Qgb25jZVxuICAgIC8vIGR1cmluZyBhIGdpdmVuIHdpbmRvdyBvZiB0aW1lLiBOb3JtYWxseSwgdGhlIHRocm90dGxlZCBmdW5jdGlvbiB3aWxsIHJ1blxuICAgIC8vIGFzIG11Y2ggYXMgaXQgY2FuLCB3aXRob3V0IGV2ZXIgZ29pbmcgbW9yZSB0aGFuIG9uY2UgcGVyIGB3YWl0YCBkdXJhdGlvbjtcbiAgICAvLyBidXQgaWYgeW91J2QgbGlrZSB0byBkaXNhYmxlIHRoZSBleGVjdXRpb24gb24gdGhlIGxlYWRpbmcgZWRnZSwgcGFzc1xuICAgIC8vIGB7bGVhZGluZzogZmFsc2V9YC4gVG8gZGlzYWJsZSBleGVjdXRpb24gb24gdGhlIHRyYWlsaW5nIGVkZ2UsIGRpdHRvLlxuICAgIF90aHJvdHRsZTogZnVuY3Rpb24oZnVuYywgd2FpdCwgb3B0cykge1xuICAgICAgdmFyIGNvbnRleHQsIGFyZ3MsIHJlc3VsdDtcbiAgICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIHZhciBwcmV2aW91cyA9IDA7XG4gICAgICB2YXIgb3B0aW9ucyA9IG9wdHMgfHwge307XG4gICAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICBpZiAoIXByZXZpb3VzICYmIG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBpZiAocmVtYWluaW5nIDw9IDApIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgcmVtYWluaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9LFxuICAgIC8qXG4gICAgICAgICAqIG90aGVyIHV0aWxzXG4gICAgICAgICAqL1xuICAgIF9oYXNNZXRob2RzOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHZhciBuYW1lcyA9IFtdLFxuICAgICAgICBrZXk7XG5cbiAgICAgIGZvciAoa2V5IGluIG9iaikge1xuICAgICAgICBpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2lzRnVuY3Rpb24ob2JqW2tleV0pKSB7XG4gICAgICAgICAgbmFtZXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmFtZXMubGVuZ3RoID4gMDtcbiAgICB9LFxuICAgIGlzVmFsaWRTZWxlY3RvcjogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBmaXJzdENoYXIgPSBzZWxlY3RvclswXTtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGZpcnN0Q2hhciA9PT0gJyMnIHx8XG4gICAgICAgIGZpcnN0Q2hhciA9PT0gJy4nIHx8XG4gICAgICAgIGZpcnN0Q2hhciA9PT0gZmlyc3RDaGFyLnRvVXBwZXJDYXNlKClcbiAgICAgICk7XG4gICAgfSxcbiAgICBjcmVhdGVDYW52YXNFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjYW52YXMgPSBLb252YS5pc0Jyb3dzZXJcbiAgICAgICAgPyBLb252YS5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICAgICAgICA6IG5ldyBLb252YS5fbm9kZUNhbnZhcygpO1xuICAgICAgLy8gb24gc29tZSBlbnZpcm9ubWVudHMgY2FudmFzLnN0eWxlIGlzIHJlYWRvbmx5XG4gICAgICB0cnkge1xuICAgICAgICBjYW52YXMuc3R5bGUgPSBjYW52YXMuc3R5bGUgfHwge307XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9LFxuICAgIF9pc0luRG9jdW1lbnQ6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICB3aGlsZSAoKGVsID0gZWwucGFyZW50Tm9kZSkpIHtcbiAgICAgICAgaWYgKGVsID09IEtvbnZhLmRvY3VtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIF9zaW1wbGlmeUFycmF5OiBmdW5jdGlvbihhcnIpIHtcbiAgICAgIHZhciByZXRBcnIgPSBbXSxcbiAgICAgICAgbGVuID0gYXJyLmxlbmd0aCxcbiAgICAgICAgdXRpbCA9IEtvbnZhLlV0aWwsXG4gICAgICAgIG4sXG4gICAgICAgIHZhbDtcblxuICAgICAgZm9yIChuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgIHZhbCA9IGFycltuXTtcbiAgICAgICAgaWYgKHV0aWwuX2lzTnVtYmVyKHZhbCkpIHtcbiAgICAgICAgICB2YWwgPSBNYXRoLnJvdW5kKHZhbCAqIDEwMDApIC8gMTAwMDtcbiAgICAgICAgfSBlbHNlIGlmICghdXRpbC5faXNTdHJpbmcodmFsKSkge1xuICAgICAgICAgIHZhbCA9IHZhbC50b1N0cmluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0QXJyLnB1c2godmFsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldEFycjtcbiAgICB9LFxuICAgIC8qXG4gICAgICAgICAqIGFyZyBjYW4gYmUgYW4gaW1hZ2Ugb2JqZWN0IG9yIGltYWdlIGRhdGFcbiAgICAgICAgICovXG4gICAgX2dldEltYWdlOiBmdW5jdGlvbihhcmcsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgaW1hZ2VPYmosIGNhbnZhcztcblxuICAgICAgLy8gaWYgYXJnIGlzIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICBpZiAoIWFyZykge1xuICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5faXNFbGVtZW50KGFyZykpIHtcbiAgICAgICAgLy8gaWYgYXJnIGlzIGFscmVhZHkgYW4gaW1hZ2Ugb2JqZWN0XG4gICAgICAgIGNhbGxiYWNrKGFyZyk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2lzU3RyaW5nKGFyZykpIHtcbiAgICAgICAgLy8gaWYgYXJnIGlzIGEgc3RyaW5nLCB0aGVuIGl0J3MgYSBkYXRhIHVybFxuICAgICAgICBpbWFnZU9iaiA9IG5ldyBLb252YS53aW5kb3cuSW1hZ2UoKTtcbiAgICAgICAgaW1hZ2VPYmoub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY2FsbGJhY2soaW1hZ2VPYmopO1xuICAgICAgICB9O1xuICAgICAgICBpbWFnZU9iai5zcmMgPSBhcmc7XG4gICAgICB9IGVsc2UgaWYgKGFyZy5kYXRhKSB7XG4gICAgICAgIC8vaWYgYXJnIGlzIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBkYXRhIHByb3BlcnR5LCBpdCdzIGFuIGltYWdlIG9iamVjdFxuICAgICAgICBjYW52YXMgPSBLb252YS5VdGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgICAgY2FudmFzLndpZHRoID0gYXJnLndpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gYXJnLmhlaWdodDtcbiAgICAgICAgdmFyIF9jb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoQ09OVEVYVF8yRCk7XG4gICAgICAgIF9jb250ZXh0LnB1dEltYWdlRGF0YShhcmcsIDAsIDApO1xuICAgICAgICB0aGlzLl9nZXRJbWFnZShjYW52YXMudG9EYXRhVVJMKCksIGNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2dldFJHQkFTdHJpbmc6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgdmFyIHJlZCA9IG9iai5yZWQgfHwgMCxcbiAgICAgICAgZ3JlZW4gPSBvYmouZ3JlZW4gfHwgMCxcbiAgICAgICAgYmx1ZSA9IG9iai5ibHVlIHx8IDAsXG4gICAgICAgIGFscGhhID0gb2JqLmFscGhhIHx8IDE7XG5cbiAgICAgIHJldHVybiBbJ3JnYmEoJywgcmVkLCAnLCcsIGdyZWVuLCAnLCcsIGJsdWUsICcsJywgYWxwaGEsICcpJ10uam9pbihcbiAgICAgICAgRU1QVFlfU1RSSU5HXG4gICAgICApO1xuICAgIH0sXG4gICAgX3JnYlRvSGV4OiBmdW5jdGlvbihyLCBnLCBiKSB7XG4gICAgICByZXR1cm4gKCgxIDw8IDI0KSArIChyIDw8IDE2KSArIChnIDw8IDgpICsgYikudG9TdHJpbmcoMTYpLnNsaWNlKDEpO1xuICAgIH0sXG4gICAgX2hleFRvUmdiOiBmdW5jdGlvbihoZXgpIHtcbiAgICAgIGhleCA9IGhleC5yZXBsYWNlKEhBU0gsIEVNUFRZX1NUUklORyk7XG4gICAgICB2YXIgYmlnaW50ID0gcGFyc2VJbnQoaGV4LCAxNik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByOiAoYmlnaW50ID4+IDE2KSAmIDI1NSxcbiAgICAgICAgZzogKGJpZ2ludCA+PiA4KSAmIDI1NSxcbiAgICAgICAgYjogYmlnaW50ICYgMjU1XG4gICAgICB9O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIHJldHVybiByYW5kb20gaGV4IGNvbG9yXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlV0aWwucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgIGdldFJhbmRvbUNvbG9yOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByYW5kQ29sb3IgPSAoKE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZikgPDwgMCkudG9TdHJpbmcoMTYpO1xuICAgICAgd2hpbGUgKHJhbmRDb2xvci5sZW5ndGggPCA2KSB7XG4gICAgICAgIHJhbmRDb2xvciA9IFpFUk8gKyByYW5kQ29sb3I7XG4gICAgICB9XG4gICAgICByZXR1cm4gSEFTSCArIHJhbmRDb2xvcjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiByZXR1cm4gdmFsdWUgd2l0aCBkZWZhdWx0IGZhbGxiYWNrXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlV0aWwucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24odmFsLCBkZWYpIHtcbiAgICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZGVmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiBnZXQgUkdCIGNvbXBvbmVudHMgb2YgYSBjb2xvclxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5VdGlsLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3JcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogLy8gZWFjaCBvZiB0aGUgZm9sbG93aW5nIGV4YW1wbGVzIHJldHVybiB7cjowLCBnOjAsIGI6MjU1fVxuICAgICAgICAgKiB2YXIgcmdiID0gS29udmEuVXRpbC5nZXRSR0IoJ2JsdWUnKTtcbiAgICAgICAgICogdmFyIHJnYiA9IEtvbnZhLlV0aWwuZ2V0UkdCKCcjMDAwMGZmJyk7XG4gICAgICAgICAqIHZhciByZ2IgPSBLb252YS5VdGlsLmdldFJHQigncmdiKDAsMCwyNTUpJyk7XG4gICAgICAgICAqL1xuICAgIGdldFJHQjogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgIHZhciByZ2I7XG4gICAgICAvLyBjb2xvciBzdHJpbmdcbiAgICAgIGlmIChjb2xvciBpbiBDT0xPUlMpIHtcbiAgICAgICAgcmdiID0gQ09MT1JTW2NvbG9yXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByOiByZ2JbMF0sXG4gICAgICAgICAgZzogcmdiWzFdLFxuICAgICAgICAgIGI6IHJnYlsyXVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChjb2xvclswXSA9PT0gSEFTSCkge1xuICAgICAgICAvLyBoZXhcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hleFRvUmdiKGNvbG9yLnN1YnN0cmluZygxKSk7XG4gICAgICB9IGVsc2UgaWYgKGNvbG9yLnN1YnN0cigwLCA0KSA9PT0gUkdCX1BBUkVOKSB7XG4gICAgICAgIC8vIHJnYiBzdHJpbmdcbiAgICAgICAgcmdiID0gUkdCX1JFR0VYLmV4ZWMoY29sb3IucmVwbGFjZSgvIC9nLCAnJykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHI6IHBhcnNlSW50KHJnYlsxXSwgMTApLFxuICAgICAgICAgIGc6IHBhcnNlSW50KHJnYlsyXSwgMTApLFxuICAgICAgICAgIGI6IHBhcnNlSW50KHJnYlszXSwgMTApXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWZhdWx0XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcjogMCxcbiAgICAgICAgICBnOiAwLFxuICAgICAgICAgIGI6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIGNvbnZlcnQgYW55IGNvbG9yIHN0cmluZyB0byBSR0JBIG9iamVjdFxuICAgIC8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2NvbXBvbmVudC9jb2xvci1wYXJzZXJcbiAgICBjb2xvclRvUkdCQTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICBzdHIgPSBzdHIgfHwgJ2JsYWNrJztcbiAgICAgIHJldHVybiAoXG4gICAgICAgIEtvbnZhLlV0aWwuX25hbWVkQ29sb3JUb1JCQShzdHIpIHx8XG4gICAgICAgIEtvbnZhLlV0aWwuX2hleDNDb2xvclRvUkdCQShzdHIpIHx8XG4gICAgICAgIEtvbnZhLlV0aWwuX2hleDZDb2xvclRvUkdCQShzdHIpIHx8XG4gICAgICAgIEtvbnZhLlV0aWwuX3JnYkNvbG9yVG9SR0JBKHN0cikgfHxcbiAgICAgICAgS29udmEuVXRpbC5fcmdiYUNvbG9yVG9SR0JBKHN0cilcbiAgICAgICk7XG4gICAgfSxcbiAgICAvLyBQYXJzZSBuYW1lZCBjc3MgY29sb3IuIExpa2UgXCJncmVlblwiXG4gICAgX25hbWVkQ29sb3JUb1JCQTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICB2YXIgYyA9IENPTE9SU1tzdHIudG9Mb3dlckNhc2UoKV07XG4gICAgICBpZiAoIWMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICByOiBjWzBdLFxuICAgICAgICBnOiBjWzFdLFxuICAgICAgICBiOiBjWzJdLFxuICAgICAgICBhOiAxXG4gICAgICB9O1xuICAgIH0sXG4gICAgLy8gUGFyc2UgcmdiKG4sIG4sIG4pXG4gICAgX3JnYkNvbG9yVG9SR0JBOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIGlmIChzdHIuaW5kZXhPZigncmdiKCcpID09PSAwKSB7XG4gICAgICAgIHN0ciA9IHN0ci5tYXRjaCgvcmdiXFwoKFteKV0rKVxcKS8pWzFdO1xuICAgICAgICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoLyAqLCAqLykubWFwKE51bWJlcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcjogcGFydHNbMF0sXG4gICAgICAgICAgZzogcGFydHNbMV0sXG4gICAgICAgICAgYjogcGFydHNbMl0sXG4gICAgICAgICAgYTogMVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gUGFyc2UgcmdiYShuLCBuLCBuLCBuKVxuICAgIF9yZ2JhQ29sb3JUb1JHQkE6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgaWYgKHN0ci5pbmRleE9mKCdyZ2JhKCcpID09PSAwKSB7XG4gICAgICAgIHN0ciA9IHN0ci5tYXRjaCgvcmdiYVxcKChbXildKylcXCkvKVsxXTtcbiAgICAgICAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KC8gKiwgKi8pLm1hcChOdW1iZXIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHI6IHBhcnRzWzBdLFxuICAgICAgICAgIGc6IHBhcnRzWzFdLFxuICAgICAgICAgIGI6IHBhcnRzWzJdLFxuICAgICAgICAgIGE6IHBhcnRzWzNdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBQYXJzZSAjbm5ubm5uXG4gICAgX2hleDZDb2xvclRvUkdCQTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICBpZiAoc3RyWzBdID09PSAnIycgJiYgc3RyLmxlbmd0aCA9PT0gNykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHI6IHBhcnNlSW50KHN0ci5zbGljZSgxLCAzKSwgMTYpLFxuICAgICAgICAgIGc6IHBhcnNlSW50KHN0ci5zbGljZSgzLCA1KSwgMTYpLFxuICAgICAgICAgIGI6IHBhcnNlSW50KHN0ci5zbGljZSg1LCA3KSwgMTYpLFxuICAgICAgICAgIGE6IDFcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIFBhcnNlICNubm5cbiAgICBfaGV4M0NvbG9yVG9SR0JBOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIGlmIChzdHJbMF0gPT09ICcjJyAmJiBzdHIubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcjogcGFyc2VJbnQoc3RyWzFdICsgc3RyWzFdLCAxNiksXG4gICAgICAgICAgZzogcGFyc2VJbnQoc3RyWzJdICsgc3RyWzJdLCAxNiksXG4gICAgICAgICAgYjogcGFyc2VJbnQoc3RyWzNdICsgc3RyWzNdLCAxNiksXG4gICAgICAgICAgYTogMVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gbzEgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIG8yXG4gICAgX21lcmdlOiBmdW5jdGlvbihvMSwgbzIpIHtcbiAgICAgIHZhciByZXRPYmogPSB0aGlzLl9jbG9uZShvMik7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gbzEpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzT2JqZWN0KG8xW2tleV0pKSB7XG4gICAgICAgICAgcmV0T2JqW2tleV0gPSB0aGlzLl9tZXJnZShvMVtrZXldLCByZXRPYmpba2V5XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0T2JqW2tleV0gPSBvMVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0T2JqO1xuICAgIH0sXG4gICAgY2xvbmVPYmplY3Q6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgdmFyIHJldE9iaiA9IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAodGhpcy5faXNPYmplY3Qob2JqW2tleV0pKSB7XG4gICAgICAgICAgcmV0T2JqW2tleV0gPSB0aGlzLmNsb25lT2JqZWN0KG9ialtrZXldKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9pc0FycmF5KG9ialtrZXldKSkge1xuICAgICAgICAgIHJldE9ialtrZXldID0gdGhpcy5jbG9uZUFycmF5KG9ialtrZXldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXRPYmpba2V5XSA9IG9ialtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0T2JqO1xuICAgIH0sXG4gICAgY2xvbmVBcnJheTogZnVuY3Rpb24oYXJyKSB7XG4gICAgICByZXR1cm4gYXJyLnNsaWNlKDApO1xuICAgIH0sXG4gICAgX2RlZ1RvUmFkOiBmdW5jdGlvbihkZWcpIHtcbiAgICAgIHJldHVybiBkZWcgKiBQSV9PVkVSX0RFRzE4MDtcbiAgICB9LFxuICAgIF9yYWRUb0RlZzogZnVuY3Rpb24ocmFkKSB7XG4gICAgICByZXR1cm4gcmFkICogREVHMTgwX09WRVJfUEk7XG4gICAgfSxcbiAgICBfY2FwaXRhbGl6ZTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xuICAgIH0sXG4gICAgdGhyb3c6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKEtPTlZBX0VSUk9SICsgc3RyKTtcbiAgICB9LFxuICAgIGVycm9yOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoS09OVkFfRVJST1IgKyBzdHIpO1xuICAgIH0sXG4gICAgd2FybjogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAvKlxuICAgICAgICAgICAgICogSUU5IG9uIFdpbmRvd3M3IDY0Yml0IHdpbGwgdGhyb3cgYSBKUyBlcnJvclxuICAgICAgICAgICAgICogaWYgd2UgZG9uJ3QgdXNlIHdpbmRvdy5jb25zb2xlIGluIHRoZSBjb25kaXRpb25hbFxuICAgICAgICAgICAgICovXG4gICAgICBpZiAoS29udmEuZ2xvYmFsLmNvbnNvbGUgJiYgY29uc29sZS53YXJuICYmIEtvbnZhLnNob3dXYXJuaW5ncykge1xuICAgICAgICBjb25zb2xlLndhcm4oS09OVkFfV0FSTklORyArIHN0cik7XG4gICAgICB9XG4gICAgfSxcbiAgICBleHRlbmQ6IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHtcbiAgICAgIGZ1bmN0aW9uIEN0b3IoKSB7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDtcbiAgICAgIH1cbiAgICAgIEN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTtcbiAgICAgIHZhciBvbGRQcm90byA9IGNoaWxkLnByb3RvdHlwZTtcbiAgICAgIGNoaWxkLnByb3RvdHlwZSA9IG5ldyBDdG9yKCk7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2xkUHJvdG8pIHtcbiAgICAgICAgaWYgKG9sZFByb3RvLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICBjaGlsZC5wcm90b3R5cGVba2V5XSA9IG9sZFByb3RvW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7XG4gICAgICAvLyBjcmVhdGUgcmVmZXJlbmNlIHRvIHBhcmVudFxuICAgICAgY2hpbGQuc3VwZXIgPSBwYXJlbnQ7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogYWRkcyBtZXRob2RzIHRvIGEgY29uc3RydWN0b3IgcHJvdG90eXBlXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlV0aWwucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtZXRob2RzXG4gICAgICAgICAqL1xuICAgIGFkZE1ldGhvZHM6IGZ1bmN0aW9uKGNvbnN0cnVjdG9yLCBtZXRob2RzKSB7XG4gICAgICB2YXIga2V5O1xuXG4gICAgICBmb3IgKGtleSBpbiBtZXRob2RzKSB7XG4gICAgICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZVtrZXldID0gbWV0aG9kc1trZXldO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2dldENvbnRyb2xQb2ludHM6IGZ1bmN0aW9uKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHQpIHtcbiAgICAgIHZhciBkMDEgPSBNYXRoLnNxcnQoTWF0aC5wb3coeDEgLSB4MCwgMikgKyBNYXRoLnBvdyh5MSAtIHkwLCAyKSksXG4gICAgICAgIGQxMiA9IE1hdGguc3FydChNYXRoLnBvdyh4MiAtIHgxLCAyKSArIE1hdGgucG93KHkyIC0geTEsIDIpKSxcbiAgICAgICAgZmEgPSB0ICogZDAxIC8gKGQwMSArIGQxMiksXG4gICAgICAgIGZiID0gdCAqIGQxMiAvIChkMDEgKyBkMTIpLFxuICAgICAgICBwMXggPSB4MSAtIGZhICogKHgyIC0geDApLFxuICAgICAgICBwMXkgPSB5MSAtIGZhICogKHkyIC0geTApLFxuICAgICAgICBwMnggPSB4MSArIGZiICogKHgyIC0geDApLFxuICAgICAgICBwMnkgPSB5MSArIGZiICogKHkyIC0geTApO1xuXG4gICAgICByZXR1cm4gW3AxeCwgcDF5LCBwMngsIHAyeV07XG4gICAgfSxcbiAgICBfZXhwYW5kUG9pbnRzOiBmdW5jdGlvbihwLCB0ZW5zaW9uKSB7XG4gICAgICB2YXIgbGVuID0gcC5sZW5ndGgsXG4gICAgICAgIGFsbFBvaW50cyA9IFtdLFxuICAgICAgICBuLFxuICAgICAgICBjcDtcblxuICAgICAgZm9yIChuID0gMjsgbiA8IGxlbiAtIDI7IG4gKz0gMikge1xuICAgICAgICBjcCA9IEtvbnZhLlV0aWwuX2dldENvbnRyb2xQb2ludHMoXG4gICAgICAgICAgcFtuIC0gMl0sXG4gICAgICAgICAgcFtuIC0gMV0sXG4gICAgICAgICAgcFtuXSxcbiAgICAgICAgICBwW24gKyAxXSxcbiAgICAgICAgICBwW24gKyAyXSxcbiAgICAgICAgICBwW24gKyAzXSxcbiAgICAgICAgICB0ZW5zaW9uXG4gICAgICAgICk7XG4gICAgICAgIGFsbFBvaW50cy5wdXNoKGNwWzBdKTtcbiAgICAgICAgYWxsUG9pbnRzLnB1c2goY3BbMV0pO1xuICAgICAgICBhbGxQb2ludHMucHVzaChwW25dKTtcbiAgICAgICAgYWxsUG9pbnRzLnB1c2gocFtuICsgMV0pO1xuICAgICAgICBhbGxQb2ludHMucHVzaChjcFsyXSk7XG4gICAgICAgIGFsbFBvaW50cy5wdXNoKGNwWzNdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFsbFBvaW50cztcbiAgICB9LFxuICAgIF9yZW1vdmVMYXN0TGV0dGVyOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSAxKTtcbiAgICB9LFxuICAgIGVhY2g6IGZ1bmN0aW9uKG9iaiwgZnVuYykge1xuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBmdW5jKGtleSwgb2JqW2tleV0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2dldFByb2plY3Rpb25Ub1NlZ21lbnQ6IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICAgIHZhciB4LCB5LCBkaXN0O1xuXG4gICAgICB2YXIgcGQyID0gKHgxIC0geDIpICogKHgxIC0geDIpICsgKHkxIC0geTIpICogKHkxIC0geTIpO1xuICAgICAgaWYgKHBkMiA9PSAwKSB7XG4gICAgICAgIHggPSB4MTtcbiAgICAgICAgeSA9IHkxO1xuICAgICAgICBkaXN0ID0gKHgzIC0geDIpICogKHgzIC0geDIpICsgKHkzIC0geTIpICogKHkzIC0geTIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHUgPSAoKHgzIC0geDEpICogKHgyIC0geDEpICsgKHkzIC0geTEpICogKHkyIC0geTEpKSAvIHBkMjtcbiAgICAgICAgaWYgKHUgPCAwKSB7XG4gICAgICAgICAgeCA9IHgxO1xuICAgICAgICAgIHkgPSB5MTtcbiAgICAgICAgICBkaXN0ID0gKHgxIC0geDMpICogKHgxIC0geDMpICsgKHkxIC0geTMpICogKHkxIC0geTMpO1xuICAgICAgICB9IGVsc2UgaWYgKHUgPiAxLjApIHtcbiAgICAgICAgICB4ID0geDI7XG4gICAgICAgICAgeSA9IHkyO1xuICAgICAgICAgIGRpc3QgPSAoeDIgLSB4MykgKiAoeDIgLSB4MykgKyAoeTIgLSB5MykgKiAoeTIgLSB5Myk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeCA9IHgxICsgdSAqICh4MiAtIHgxKTtcbiAgICAgICAgICB5ID0geTEgKyB1ICogKHkyIC0geTEpO1xuICAgICAgICAgIGRpc3QgPSAoeCAtIHgzKSAqICh4IC0geDMpICsgKHkgLSB5MykgKiAoeSAtIHkzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFt4LCB5LCBkaXN0XTtcbiAgICB9LFxuICAgIC8vIGxpbmUgYXMgYXJyYXkgb2YgcG9pbnRzLlxuICAgIC8vIGxpbmUgbWlnaHQgYmUgY2xvc2VkXG4gICAgX2dldFByb2plY3Rpb25Ub0xpbmU6IGZ1bmN0aW9uKHB0LCBsaW5lLCBpc0Nsb3NlZCkge1xuICAgICAgdmFyIHBjID0gS29udmEuVXRpbC5jbG9uZU9iamVjdChwdCk7XG4gICAgICB2YXIgZGlzdCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICBsaW5lLmZvckVhY2goZnVuY3Rpb24ocDEsIGkpIHtcbiAgICAgICAgaWYgKCFpc0Nsb3NlZCAmJiBpID09PSBsaW5lLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHAyID0gbGluZVsoaSArIDEpICUgbGluZS5sZW5ndGhdO1xuICAgICAgICB2YXIgcHJvaiA9IEtvbnZhLlV0aWwuX2dldFByb2plY3Rpb25Ub1NlZ21lbnQoXG4gICAgICAgICAgcDEueCxcbiAgICAgICAgICBwMS55LFxuICAgICAgICAgIHAyLngsXG4gICAgICAgICAgcDIueSxcbiAgICAgICAgICBwdC54LFxuICAgICAgICAgIHB0LnlcbiAgICAgICAgKTtcbiAgICAgICAgdmFyIHB4ID0gcHJvalswXSxcbiAgICAgICAgICBweSA9IHByb2pbMV0sXG4gICAgICAgICAgcGRpc3QgPSBwcm9qWzJdO1xuICAgICAgICBpZiAocGRpc3QgPCBkaXN0KSB7XG4gICAgICAgICAgcGMueCA9IHB4O1xuICAgICAgICAgIHBjLnkgPSBweTtcbiAgICAgICAgICBkaXN0ID0gcGRpc3Q7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHBjO1xuICAgIH0sXG4gICAgX3ByZXBhcmVBcnJheUZvclR3ZWVuOiBmdW5jdGlvbihzdGFydEFycmF5LCBlbmRBcnJheSwgaXNDbG9zZWQpIHtcbiAgICAgIHZhciBuLFxuICAgICAgICBzdGFydCA9IFtdLFxuICAgICAgICBlbmQgPSBbXTtcbiAgICAgIGlmIChzdGFydEFycmF5Lmxlbmd0aCA+IGVuZEFycmF5Lmxlbmd0aCkge1xuICAgICAgICB2YXIgdGVtcCA9IGVuZEFycmF5O1xuICAgICAgICBlbmRBcnJheSA9IHN0YXJ0QXJyYXk7XG4gICAgICAgIHN0YXJ0QXJyYXkgPSB0ZW1wO1xuICAgICAgfVxuICAgICAgZm9yIChuID0gMDsgbiA8IHN0YXJ0QXJyYXkubGVuZ3RoOyBuICs9IDIpIHtcbiAgICAgICAgc3RhcnQucHVzaCh7XG4gICAgICAgICAgeDogc3RhcnRBcnJheVtuXSxcbiAgICAgICAgICB5OiBzdGFydEFycmF5W24gKyAxXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGZvciAobiA9IDA7IG4gPCBlbmRBcnJheS5sZW5ndGg7IG4gKz0gMikge1xuICAgICAgICBlbmQucHVzaCh7XG4gICAgICAgICAgeDogZW5kQXJyYXlbbl0sXG4gICAgICAgICAgeTogZW5kQXJyYXlbbiArIDFdXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3U3RhcnQgPSBbXTtcbiAgICAgIGVuZC5mb3JFYWNoKGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHZhciBwciA9IEtvbnZhLlV0aWwuX2dldFByb2plY3Rpb25Ub0xpbmUocG9pbnQsIHN0YXJ0LCBpc0Nsb3NlZCk7XG4gICAgICAgIG5ld1N0YXJ0LnB1c2gocHIueCk7XG4gICAgICAgIG5ld1N0YXJ0LnB1c2gocHIueSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXdTdGFydDtcbiAgICB9LFxuICAgIF9wcmVwYXJlVG9TdHJpbmdpZnk6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgdmFyIGRlc2M7XG5cbiAgICAgIG9iai52aXNpdGVkQnlDaXJjdWxhclJlZmVyZW5jZVJlbW92YWwgPSB0cnVlO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIG9ialtrZXldICYmIHR5cGVvZiBvYmpba2V5XSA9PSAnb2JqZWN0JylcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgb2JqW2tleV0udmlzaXRlZEJ5Q2lyY3VsYXJSZWZlcmVuY2VSZW1vdmFsIHx8XG4gICAgICAgICAgS29udmEuVXRpbC5faXNFbGVtZW50KG9ialtrZXldKVxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAoZGVzYy5jb25maWd1cmFibGUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKEtvbnZhLlV0aWwuX3ByZXBhcmVUb1N0cmluZ2lmeShvYmpba2V5XSkgPT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoZGVzYy5jb25maWd1cmFibGUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSBvYmoudmlzaXRlZEJ5Q2lyY3VsYXJSZWZlcmVuY2VSZW1vdmFsO1xuXG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgfTtcbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvLyBjYWxjdWxhdGUgcGl4ZWwgcmF0aW9cblxuICB2YXIgX3BpeGVsUmF0aW87XG4gIGZ1bmN0aW9uIGdldERldmljZVBpeGVsUmF0aW8oKSB7XG4gICAgaWYgKF9waXhlbFJhdGlvKSB7XG4gICAgICByZXR1cm4gX3BpeGVsUmF0aW87XG4gICAgfVxuICAgIHZhciBjYW52YXMgPSBLb252YS5VdGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIF9waXhlbFJhdGlvID0gKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRldmljZVBpeGVsUmF0aW8gPSBLb252YS53aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxLFxuICAgICAgICBiYWNraW5nU3RvcmVSYXRpbyA9XG4gICAgICAgICAgY29udGV4dC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgY29udGV4dC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgY29udGV4dC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICBjb250ZXh0Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgY29udGV4dC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgMTtcbiAgICAgIHJldHVybiBkZXZpY2VQaXhlbFJhdGlvIC8gYmFja2luZ1N0b3JlUmF0aW87XG4gICAgfSkoKTtcbiAgICByZXR1cm4gX3BpeGVsUmF0aW87XG4gIH1cblxuICAvKipcbiAgICAgKiBDYW52YXMgUmVuZGVyZXIgY29uc3RydWN0b3JcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy53aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcuaGVpZ2h0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5waXhlbFJhdGlvIEtvbnZhSlMgYXV0b21hdGljYWxseSBoYW5kbGVzIHBpeGVsIHJhdGlvIGFkanVzdG1lbnRzIGluIG9yZGVyIHRvIHJlbmRlciBjcmlzcCBkcmF3aW5nc1xuICAgICAqICBvbiBhbGwgZGV2aWNlcy4gTW9zdCBkZXNrdG9wcywgbG93IGVuZCB0YWJsZXRzLCBhbmQgbG93IGVuZCBwaG9uZXMsIGhhdmUgZGV2aWNlIHBpeGVsIHJhdGlvc1xuICAgICAqICBvZiAxLiAgU29tZSBoaWdoIGVuZCB0YWJsZXRzIGFuZCBwaG9uZXMsIGxpa2UgaVBob25lcyBhbmQgaVBhZHMgKG5vdCB0aGUgbWluaSkgaGF2ZSBhIGRldmljZSBwaXhlbCByYXRpb1xuICAgICAqICBvZiAyLiAgU29tZSBNYWNib29rIFByb3MsIGFuZCBpTWFjcyBhbHNvIGhhdmUgYSBkZXZpY2UgcGl4ZWwgcmF0aW8gb2YgMi4gIFNvbWUgaGlnaCBlbmQgQW5kcm9pZCBkZXZpY2VzIGhhdmUgcGl4ZWxcbiAgICAgKiAgcmF0aW9zIG9mIDIgb3IgMy4gIFNvbWUgYnJvd3NlcnMgbGlrZSBGaXJlZm94IGFsbG93IHlvdSB0byBjb25maWd1cmUgdGhlIHBpeGVsIHJhdGlvIG9mIHRoZSB2aWV3cG9ydC4gIFVubGVzcyBvdGhlcndpc2VcbiAgICAgKiAgc3BlY2lmaWVkLCB0aGUgcGl4ZWwgcmF0aW8gd2lsbCBiZSBkZWZhdWx0ZWQgdG8gdGhlIGFjdHVhbCBkZXZpY2UgcGl4ZWwgcmF0aW8uICBZb3UgY2FuIG92ZXJyaWRlIHRoZSBkZXZpY2UgcGl4ZWxcbiAgICAgKiAgcmF0aW8gZm9yIHNwZWNpYWwgc2l0dWF0aW9ucywgb3IsIGlmIHlvdSBkb24ndCB3YW50IHRoZSBwaXhlbCByYXRpbyB0byBiZSB0YWtlbiBpbnRvIGFjY291bnQsIHlvdSBjYW4gc2V0IGl0IHRvIDEuXG4gICAgICovXG4gIEtvbnZhLkNhbnZhcyA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHRoaXMuaW5pdChjb25maWcpO1xuICB9O1xuXG4gIEtvbnZhLkNhbnZhcy5wcm90b3R5cGUgPSB7XG4gICAgaW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICB2YXIgY29uZiA9IGNvbmZpZyB8fCB7fTtcblxuICAgICAgdmFyIHBpeGVsUmF0aW8gPVxuICAgICAgICBjb25mLnBpeGVsUmF0aW8gfHwgS29udmEucGl4ZWxSYXRpbyB8fCBnZXREZXZpY2VQaXhlbFJhdGlvKCk7XG5cbiAgICAgIHRoaXMucGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG4gICAgICB0aGlzLl9jYW52YXMgPSBLb252YS5VdGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcblxuICAgICAgLy8gc2V0IGlubGluZSBzdHlsZXNcbiAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5wYWRkaW5nID0gMDtcbiAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5tYXJnaW4gPSAwO1xuICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLmJvcmRlciA9IDA7XG4gICAgICB0aGlzLl9jYW52YXMuc3R5bGUuYmFja2dyb3VuZCA9ICd0cmFuc3BhcmVudCc7XG4gICAgICB0aGlzLl9jYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLnRvcCA9IDA7XG4gICAgICB0aGlzLl9jYW52YXMuc3R5bGUubGVmdCA9IDA7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogZ2V0IGNhbnZhcyBjb250ZXh0XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNhbnZhcy5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0NhbnZhc0NvbnRleHR9IGNvbnRleHRcbiAgICAgICAgICovXG4gICAgZ2V0Q29udGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZXh0O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIGdldCBwaXhlbCByYXRpb1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5DYW52YXMucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IHBpeGVsIHJhdGlvXG4gICAgICAgICAqL1xuICAgIGdldFBpeGVsUmF0aW86IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGl4ZWxSYXRpbztcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiBnZXQgcGl4ZWwgcmF0aW9cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQ2FudmFzLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gcGl4ZWxSYXRpbyBLb252YUpTIGF1dG9tYXRpY2FsbHkgaGFuZGxlcyBwaXhlbCByYXRpbyBhZHVzdG1lbnRzIGluIG9yZGVyIHRvIHJlbmRlciBjcmlzcCBkcmF3aW5nc1xuICAgICAgICAgKiAgb24gYWxsIGRldmljZXMuIE1vc3QgZGVza3RvcHMsIGxvdyBlbmQgdGFibGV0cywgYW5kIGxvdyBlbmQgcGhvbmVzLCBoYXZlIGRldmljZSBwaXhlbCByYXRpb3NcbiAgICAgICAgICogIG9mIDEuICBTb21lIGhpZ2ggZW5kIHRhYmxldHMgYW5kIHBob25lcywgbGlrZSBpUGhvbmVzIGFuZCBpUGFkcyBoYXZlIGEgZGV2aWNlIHBpeGVsIHJhdGlvXG4gICAgICAgICAqICBvZiAyLiAgU29tZSBNYWNib29rIFByb3MsIGFuZCBpTWFjcyBhbHNvIGhhdmUgYSBkZXZpY2UgcGl4ZWwgcmF0aW8gb2YgMi4gIFNvbWUgaGlnaCBlbmQgQW5kcm9pZCBkZXZpY2VzIGhhdmUgcGl4ZWxcbiAgICAgICAgICogIHJhdGlvcyBvZiAyIG9yIDMuICBTb21lIGJyb3dzZXJzIGxpa2UgRmlyZWZveCBhbGxvdyB5b3UgdG8gY29uZmlndXJlIHRoZSBwaXhlbCByYXRpbyBvZiB0aGUgdmlld3BvcnQuICBVbmxlc3Mgb3RoZXJ3aXNlXG4gICAgICAgICAqICBzcGVjaWZpY2VkLCB0aGUgcGl4ZWwgcmF0aW8gd2lsbCBiZSBkZWZhdWx0ZWQgdG8gdGhlIGFjdHVhbCBkZXZpY2UgcGl4ZWwgcmF0aW8uICBZb3UgY2FuIG92ZXJyaWRlIHRoZSBkZXZpY2UgcGl4ZWxcbiAgICAgICAgICogIHJhdGlvIGZvciBzcGVjaWFsIHNpdHVhdGlvbnMsIG9yLCBpZiB5b3UgZG9uJ3Qgd2FudCB0aGUgcGl4ZWwgcmF0aW8gdG8gYmUgdGFrZW4gaW50byBhY2NvdW50LCB5b3UgY2FuIHNldCBpdCB0byAxLlxuICAgICAgICAgKi9cbiAgICBzZXRQaXhlbFJhdGlvOiBmdW5jdGlvbihwaXhlbFJhdGlvKSB7XG4gICAgICB2YXIgcHJldmlvdXNSYXRpbyA9IHRoaXMucGl4ZWxSYXRpbztcbiAgICAgIHRoaXMucGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG4gICAgICB0aGlzLnNldFNpemUoXG4gICAgICAgIHRoaXMuZ2V0V2lkdGgoKSAvIHByZXZpb3VzUmF0aW8sXG4gICAgICAgIHRoaXMuZ2V0SGVpZ2h0KCkgLyBwcmV2aW91c1JhdGlvXG4gICAgICApO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIHNldCB3aWR0aFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5DYW52YXMucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAgICAgKi9cbiAgICBzZXRXaWR0aDogZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgIC8vIHRha2UgaW50byBhY2NvdW50IHBpeGVsIHJhdGlvXG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5fY2FudmFzLndpZHRoID0gd2lkdGggKiB0aGlzLnBpeGVsUmF0aW87XG4gICAgICB0aGlzLl9jYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG5cbiAgICAgIHZhciBwaXhlbFJhdGlvID0gdGhpcy5waXhlbFJhdGlvLFxuICAgICAgICBfY29udGV4dCA9IHRoaXMuZ2V0Q29udGV4dCgpLl9jb250ZXh0O1xuICAgICAgX2NvbnRleHQuc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogc2V0IGhlaWdodFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5DYW52YXMucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgICAgICovXG4gICAgc2V0SGVpZ2h0OiBmdW5jdGlvbihoZWlnaHQpIHtcbiAgICAgIC8vIHRha2UgaW50byBhY2NvdW50IHBpeGVsIHJhdGlvXG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuX2NhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW87XG4gICAgICB0aGlzLl9jYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICAgIHZhciBwaXhlbFJhdGlvID0gdGhpcy5waXhlbFJhdGlvLFxuICAgICAgICBfY29udGV4dCA9IHRoaXMuZ2V0Q29udGV4dCgpLl9jb250ZXh0O1xuICAgICAgX2NvbnRleHQuc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogZ2V0IHdpZHRoXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNhbnZhcy5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge051bWJlcn0gd2lkdGhcbiAgICAgICAgICovXG4gICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMud2lkdGg7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogZ2V0IGhlaWdodFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5DYW52YXMucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IGhlaWdodFxuICAgICAgICAgKi9cbiAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIHNldCBzaXplXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNhbnZhcy5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgICAgICovXG4gICAgc2V0U2l6ZTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgdGhpcy5zZXRXaWR0aCh3aWR0aCk7XG4gICAgICB0aGlzLnNldEhlaWdodChoZWlnaHQpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIHRvIGRhdGEgdXJsXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNhbnZhcy5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG1pbWVUeXBlXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBxdWFsaXR5IGJldHdlZW4gMCBhbmQgMSBmb3IganBnIG1pbWUgdHlwZXNcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ30gZGF0YSB1cmwgc3RyaW5nXG4gICAgICAgICAqL1xuICAgIHRvRGF0YVVSTDogZnVuY3Rpb24obWltZVR5cGUsIHF1YWxpdHkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIElmIHRoaXMgY2FsbCBmYWlscyAoZHVlIHRvIGJyb3dzZXIgYnVnLCBsaWtlIGluIEZpcmVmb3ggMy42KSxcbiAgICAgICAgLy8gdGhlbiByZXZlcnQgdG8gcHJldmlvdXMgbm8tcGFyYW1ldGVyIGltYWdlL3BuZyBiZWhhdmlvclxuICAgICAgICByZXR1cm4gdGhpcy5fY2FudmFzLnRvRGF0YVVSTChtaW1lVHlwZSwgcXVhbGl0eSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbnZhcy50b0RhdGFVUkwoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgS29udmEuVXRpbC53YXJuKCdVbmFibGUgdG8gZ2V0IGRhdGEgVVJMLiAnICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBLb252YS5TY2VuZUNhbnZhcyA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHZhciBjb25mID0gY29uZmlnIHx8IHt9O1xuICAgIHZhciB3aWR0aCA9IGNvbmYud2lkdGggfHwgMCxcbiAgICAgIGhlaWdodCA9IGNvbmYuaGVpZ2h0IHx8IDA7XG5cbiAgICBLb252YS5DYW52YXMuY2FsbCh0aGlzLCBjb25mKTtcbiAgICB0aGlzLmNvbnRleHQgPSBuZXcgS29udmEuU2NlbmVDb250ZXh0KHRoaXMpO1xuICAgIHRoaXMuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgfTtcblxuICBLb252YS5VdGlsLmV4dGVuZChLb252YS5TY2VuZUNhbnZhcywgS29udmEuQ2FudmFzKTtcblxuICBLb252YS5IaXRDYW52YXMgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICB2YXIgY29uZiA9IGNvbmZpZyB8fCB7fTtcbiAgICB2YXIgd2lkdGggPSBjb25mLndpZHRoIHx8IDAsXG4gICAgICBoZWlnaHQgPSBjb25mLmhlaWdodCB8fCAwO1xuXG4gICAgS29udmEuQ2FudmFzLmNhbGwodGhpcywgY29uZik7XG4gICAgdGhpcy5jb250ZXh0ID0gbmV3IEtvbnZhLkhpdENvbnRleHQodGhpcyk7XG4gICAgdGhpcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuaGl0Q2FudmFzID0gdHJ1ZTtcbiAgfTtcbiAgS29udmEuVXRpbC5leHRlbmQoS29udmEuSGl0Q2FudmFzLCBLb252YS5DYW52YXMpO1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIHZhciBDT01NQSA9ICcsJyxcbiAgICBPUEVOX1BBUkVOID0gJygnLFxuICAgIENMT1NFX1BBUkVOID0gJyknLFxuICAgIE9QRU5fUEFSRU5fQlJBQ0tFVCA9ICcoWycsXG4gICAgQ0xPU0VfQlJBQ0tFVF9QQVJFTiA9ICddKScsXG4gICAgU0VNSUNPTE9OID0gJzsnLFxuICAgIERPVUJMRV9QQVJFTiA9ICcoKScsXG4gICAgLy8gRU1QVFlfU1RSSU5HID0gJycsXG4gICAgRVFVQUxTID0gJz0nLFxuICAgIC8vIFNFVCA9ICdzZXQnLFxuICAgIENPTlRFWFRfTUVUSE9EUyA9IFtcbiAgICAgICdhcmMnLFxuICAgICAgJ2FyY1RvJyxcbiAgICAgICdiZWdpblBhdGgnLFxuICAgICAgJ2JlemllckN1cnZlVG8nLFxuICAgICAgJ2NsZWFyUmVjdCcsXG4gICAgICAnY2xpcCcsXG4gICAgICAnY2xvc2VQYXRoJyxcbiAgICAgICdjcmVhdGVMaW5lYXJHcmFkaWVudCcsXG4gICAgICAnY3JlYXRlUGF0dGVybicsXG4gICAgICAnY3JlYXRlUmFkaWFsR3JhZGllbnQnLFxuICAgICAgJ2RyYXdJbWFnZScsXG4gICAgICAnZmlsbCcsXG4gICAgICAnZmlsbFRleHQnLFxuICAgICAgJ2dldEltYWdlRGF0YScsXG4gICAgICAnY3JlYXRlSW1hZ2VEYXRhJyxcbiAgICAgICdsaW5lVG8nLFxuICAgICAgJ21vdmVUbycsXG4gICAgICAncHV0SW1hZ2VEYXRhJyxcbiAgICAgICdxdWFkcmF0aWNDdXJ2ZVRvJyxcbiAgICAgICdyZWN0JyxcbiAgICAgICdyZXN0b3JlJyxcbiAgICAgICdyb3RhdGUnLFxuICAgICAgJ3NhdmUnLFxuICAgICAgJ3NjYWxlJyxcbiAgICAgICdzZXRMaW5lRGFzaCcsXG4gICAgICAnc2V0VHJhbnNmb3JtJyxcbiAgICAgICdzdHJva2UnLFxuICAgICAgJ3N0cm9rZVRleHQnLFxuICAgICAgJ3RyYW5zZm9ybScsXG4gICAgICAndHJhbnNsYXRlJ1xuICAgIF07XG5cbiAgdmFyIENPTlRFWFRfUFJPUEVSVElFUyA9IFtcbiAgICAnZmlsbFN0eWxlJyxcbiAgICAnc3Ryb2tlU3R5bGUnLFxuICAgICdzaGFkb3dDb2xvcicsXG4gICAgJ3NoYWRvd0JsdXInLFxuICAgICdzaGFkb3dPZmZzZXRYJyxcbiAgICAnc2hhZG93T2Zmc2V0WScsXG4gICAgJ2xpbmVDYXAnLFxuICAgICdsaW5lRGFzaE9mZnNldCcsXG4gICAgJ2xpbmVKb2luJyxcbiAgICAnbGluZVdpZHRoJyxcbiAgICAnbWl0ZXJMaW1pdCcsXG4gICAgJ2ZvbnQnLFxuICAgICd0ZXh0QWxpZ24nLFxuICAgICd0ZXh0QmFzZWxpbmUnLFxuICAgICdnbG9iYWxBbHBoYScsXG4gICAgJ2dsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbidcbiAgXTtcblxuICAvKipcbiAgICAgKiBDYW52YXMgQ29udGV4dCBjb25zdHJ1Y3RvclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqL1xuICBLb252YS5Db250ZXh0ID0gZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgdGhpcy5pbml0KGNhbnZhcyk7XG4gIH07XG5cbiAgS29udmEuQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgaW5pdDogZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgIHRoaXMuX2NvbnRleHQgPSBjYW52YXMuX2NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICBpZiAoS29udmEuZW5hYmxlVHJhY2UpIHtcbiAgICAgICAgdGhpcy50cmFjZUFyciA9IFtdO1xuICAgICAgICB0aGlzLl9lbmFibGVUcmFjZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIGZpbGwgc2hhcGVcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGV4dC5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtLb252YS5TaGFwZX0gc2hhcGVcbiAgICAgICAgICovXG4gICAgZmlsbFNoYXBlOiBmdW5jdGlvbihzaGFwZSkge1xuICAgICAgaWYgKHNoYXBlLmdldEZpbGxFbmFibGVkKCkpIHtcbiAgICAgICAgdGhpcy5fZmlsbChzaGFwZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogc3Ryb2tlIHNoYXBlXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRleHQucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7S29udmEuU2hhcGV9IHNoYXBlXG4gICAgICAgICAqL1xuICAgIHN0cm9rZVNoYXBlOiBmdW5jdGlvbihzaGFwZSkge1xuICAgICAgaWYgKHNoYXBlLmdldFN0cm9rZUVuYWJsZWQoKSkge1xuICAgICAgICB0aGlzLl9zdHJva2Uoc2hhcGUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIGZpbGwgdGhlbiBzdHJva2VcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGV4dC5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtLb252YS5TaGFwZX0gc2hhcGVcbiAgICAgICAgICovXG4gICAgZmlsbFN0cm9rZVNoYXBlOiBmdW5jdGlvbihzaGFwZSkge1xuICAgICAgdmFyIGZpbGxFbmFibGVkID0gc2hhcGUuZ2V0RmlsbEVuYWJsZWQoKTtcbiAgICAgIGlmIChmaWxsRW5hYmxlZCkge1xuICAgICAgICB0aGlzLl9maWxsKHNoYXBlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzaGFwZS5nZXRTdHJva2VFbmFibGVkKCkpIHtcbiAgICAgICAgdGhpcy5fc3Ryb2tlKHNoYXBlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiBnZXQgY29udGV4dCB0cmFjZSBpZiB0cmFjZSBpcyBlbmFibGVkXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRleHQucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVsYXhlZCBpZiBmYWxzZSwgcmV0dXJuIHN0cmljdCBjb250ZXh0IHRyYWNlLCB3aGljaCBpbmNsdWRlcyBtZXRob2QgbmFtZXMsIG1ldGhvZCBwYXJhbWV0ZXJzXG4gICAgICAgICAqICBwcm9wZXJ0aWVzLCBhbmQgcHJvcGVydHkgdmFsdWVzLiAgSWYgdHJ1ZSwgcmV0dXJuIHJlbGF4ZWQgY29udGV4dCB0cmFjZSwgd2hpY2ggb25seSByZXR1cm5zIG1ldGhvZCBuYW1lcyBhbmRcbiAgICAgICAgICogIHByb3Blcml0ZXMuXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICAgICAqL1xuICAgIGdldFRyYWNlOiBmdW5jdGlvbihyZWxheGVkKSB7XG4gICAgICB2YXIgdHJhY2VBcnIgPSB0aGlzLnRyYWNlQXJyLFxuICAgICAgICBsZW4gPSB0cmFjZUFyci5sZW5ndGgsXG4gICAgICAgIHN0ciA9ICcnLFxuICAgICAgICBuLFxuICAgICAgICB0cmFjZSxcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBhcmdzO1xuXG4gICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgdHJhY2UgPSB0cmFjZUFycltuXTtcbiAgICAgICAgbWV0aG9kID0gdHJhY2UubWV0aG9kO1xuXG4gICAgICAgIC8vIG1ldGhvZHNcbiAgICAgICAgaWYgKG1ldGhvZCkge1xuICAgICAgICAgIGFyZ3MgPSB0cmFjZS5hcmdzO1xuICAgICAgICAgIHN0ciArPSBtZXRob2Q7XG4gICAgICAgICAgaWYgKHJlbGF4ZWQpIHtcbiAgICAgICAgICAgIHN0ciArPSBET1VCTEVfUEFSRU47XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChLb252YS5VdGlsLl9pc0FycmF5KGFyZ3NbMF0pKSB7XG4gICAgICAgICAgICAgIHN0ciArPVxuICAgICAgICAgICAgICAgIE9QRU5fUEFSRU5fQlJBQ0tFVCArIGFyZ3Muam9pbihDT01NQSkgKyBDTE9TRV9CUkFDS0VUX1BBUkVOO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RyICs9IE9QRU5fUEFSRU4gKyBhcmdzLmpvaW4oQ09NTUEpICsgQ0xPU0VfUEFSRU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHByb3BlcnRpZXNcbiAgICAgICAgICBzdHIgKz0gdHJhY2UucHJvcGVydHk7XG4gICAgICAgICAgaWYgKCFyZWxheGVkKSB7XG4gICAgICAgICAgICBzdHIgKz0gRVFVQUxTICsgdHJhY2UudmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN0ciArPSBTRU1JQ09MT047XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogY2xlYXIgdHJhY2UgaWYgdHJhY2UgaXMgZW5hYmxlZFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250ZXh0LnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICBjbGVhclRyYWNlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudHJhY2VBcnIgPSBbXTtcbiAgICB9LFxuICAgIF90cmFjZTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICB2YXIgdHJhY2VBcnIgPSB0aGlzLnRyYWNlQXJyLCBsZW47XG5cbiAgICAgIHRyYWNlQXJyLnB1c2goc3RyKTtcbiAgICAgIGxlbiA9IHRyYWNlQXJyLmxlbmd0aDtcblxuICAgICAgaWYgKGxlbiA+PSBLb252YS50cmFjZUFyck1heCkge1xuICAgICAgICB0cmFjZUFyci5zaGlmdCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIHJlc2V0IGNhbnZhcyBjb250ZXh0IHRyYW5zZm9ybVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250ZXh0LnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcGl4ZWxSYXRpbyA9IHRoaXMuZ2V0Q2FudmFzKCkuZ2V0UGl4ZWxSYXRpbygpO1xuICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0oMSAqIHBpeGVsUmF0aW8sIDAsIDAsIDEgKiBwaXhlbFJhdGlvLCAwLCAwKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiBnZXQgY2FudmFzXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRleHQucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5DYW52YXN9XG4gICAgICAgICAqL1xuICAgIGdldENhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYW52YXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogY2xlYXIgY2FudmFzXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRleHQucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbYm91bmRzXVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2JvdW5kcy54XVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2JvdW5kcy55XVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2JvdW5kcy53aWR0aF1cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtib3VuZHMuaGVpZ2h0XVxuICAgICAgICAgKi9cbiAgICBjbGVhcjogZnVuY3Rpb24oYm91bmRzKSB7XG4gICAgICB2YXIgY2FudmFzID0gdGhpcy5nZXRDYW52YXMoKTtcblxuICAgICAgaWYgKGJvdW5kcykge1xuICAgICAgICB0aGlzLmNsZWFyUmVjdChcbiAgICAgICAgICBib3VuZHMueCB8fCAwLFxuICAgICAgICAgIGJvdW5kcy55IHx8IDAsXG4gICAgICAgICAgYm91bmRzLndpZHRoIHx8IDAsXG4gICAgICAgICAgYm91bmRzLmhlaWdodCB8fCAwXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNsZWFyUmVjdChcbiAgICAgICAgICAwLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgY2FudmFzLmdldFdpZHRoKCkgLyBjYW52YXMucGl4ZWxSYXRpbyxcbiAgICAgICAgICBjYW52YXMuZ2V0SGVpZ2h0KCkgLyBjYW52YXMucGl4ZWxSYXRpb1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2FwcGx5TGluZUNhcDogZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgIHZhciBsaW5lQ2FwID0gc2hhcGUuZ2V0TGluZUNhcCgpO1xuICAgICAgaWYgKGxpbmVDYXApIHtcbiAgICAgICAgdGhpcy5zZXRBdHRyKCdsaW5lQ2FwJywgbGluZUNhcCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfYXBwbHlPcGFjaXR5OiBmdW5jdGlvbihzaGFwZSkge1xuICAgICAgdmFyIGFic09wYWNpdHkgPSBzaGFwZS5nZXRBYnNvbHV0ZU9wYWNpdHkoKTtcbiAgICAgIGlmIChhYnNPcGFjaXR5ICE9PSAxKSB7XG4gICAgICAgIHRoaXMuc2V0QXR0cignZ2xvYmFsQWxwaGEnLCBhYnNPcGFjaXR5KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9hcHBseUxpbmVKb2luOiBmdW5jdGlvbihzaGFwZSkge1xuICAgICAgdmFyIGxpbmVKb2luID0gc2hhcGUuZ2V0TGluZUpvaW4oKTtcbiAgICAgIGlmIChsaW5lSm9pbikge1xuICAgICAgICB0aGlzLnNldEF0dHIoJ2xpbmVKb2luJywgbGluZUpvaW4pO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0QXR0cjogZnVuY3Rpb24oYXR0ciwgdmFsKSB7XG4gICAgICB0aGlzLl9jb250ZXh0W2F0dHJdID0gdmFsO1xuICAgIH0sXG5cbiAgICAvLyBjb250ZXh0IHBhc3MgdGhyb3VnaCBtZXRob2RzXG4gICAgYXJjOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgdGhpcy5fY29udGV4dC5hcmMoYVswXSwgYVsxXSwgYVsyXSwgYVszXSwgYVs0XSwgYVs1XSk7XG4gICAgfSxcbiAgICBiZWdpblBhdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICB9LFxuICAgIGJlemllckN1cnZlVG86IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICB0aGlzLl9jb250ZXh0LmJlemllckN1cnZlVG8oYVswXSwgYVsxXSwgYVsyXSwgYVszXSwgYVs0XSwgYVs1XSk7XG4gICAgfSxcbiAgICBjbGVhclJlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICB0aGlzLl9jb250ZXh0LmNsZWFyUmVjdChhWzBdLCBhWzFdLCBhWzJdLCBhWzNdKTtcbiAgICB9LFxuICAgIGNsaXA6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fY29udGV4dC5jbGlwKCk7XG4gICAgfSxcbiAgICBjbG9zZVBhdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB9LFxuICAgIGNyZWF0ZUltYWdlRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYSA9IGFyZ3VtZW50cztcbiAgICAgIGlmIChhLmxlbmd0aCA9PT0gMikge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5jcmVhdGVJbWFnZURhdGEoYVswXSwgYVsxXSk7XG4gICAgICB9IGVsc2UgaWYgKGEubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmNyZWF0ZUltYWdlRGF0YShhWzBdKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNyZWF0ZUxpbmVhckdyYWRpZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoYVswXSwgYVsxXSwgYVsyXSwgYVszXSk7XG4gICAgfSxcbiAgICBjcmVhdGVQYXR0ZXJuOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuY3JlYXRlUGF0dGVybihhWzBdLCBhWzFdKTtcbiAgICB9LFxuICAgIGNyZWF0ZVJhZGlhbEdyYWRpZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuY3JlYXRlUmFkaWFsR3JhZGllbnQoXG4gICAgICAgIGFbMF0sXG4gICAgICAgIGFbMV0sXG4gICAgICAgIGFbMl0sXG4gICAgICAgIGFbM10sXG4gICAgICAgIGFbNF0sXG4gICAgICAgIGFbNV1cbiAgICAgICk7XG4gICAgfSxcbiAgICBkcmF3SW1hZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGEgPSBhcmd1bWVudHMsIF9jb250ZXh0ID0gdGhpcy5fY29udGV4dDtcblxuICAgICAgaWYgKGEubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIF9jb250ZXh0LmRyYXdJbWFnZShhWzBdLCBhWzFdLCBhWzJdKTtcbiAgICAgIH0gZWxzZSBpZiAoYS5sZW5ndGggPT09IDUpIHtcbiAgICAgICAgX2NvbnRleHQuZHJhd0ltYWdlKGFbMF0sIGFbMV0sIGFbMl0sIGFbM10sIGFbNF0pO1xuICAgICAgfSBlbHNlIGlmIChhLmxlbmd0aCA9PT0gOSkge1xuICAgICAgICBfY29udGV4dC5kcmF3SW1hZ2UoXG4gICAgICAgICAgYVswXSxcbiAgICAgICAgICBhWzFdLFxuICAgICAgICAgIGFbMl0sXG4gICAgICAgICAgYVszXSxcbiAgICAgICAgICBhWzRdLFxuICAgICAgICAgIGFbNV0sXG4gICAgICAgICAgYVs2XSxcbiAgICAgICAgICBhWzddLFxuICAgICAgICAgIGFbOF1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGlzUG9pbnRJblBhdGg6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmlzUG9pbnRJblBhdGgoeCwgeSk7XG4gICAgfSxcbiAgICBmaWxsOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2NvbnRleHQuZmlsbCgpO1xuICAgIH0sXG4gICAgZmlsbFJlY3Q6IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHRoaXMuX2NvbnRleHQuZmlsbFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSxcbiAgICBzdHJva2VSZWN0OiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB0aGlzLl9jb250ZXh0LnN0cm9rZVJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSxcbiAgICBmaWxsVGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYSA9IGFyZ3VtZW50cztcbiAgICAgIHRoaXMuX2NvbnRleHQuZmlsbFRleHQoYVswXSwgYVsxXSwgYVsyXSk7XG4gICAgfSxcbiAgICBtZWFzdXJlVGV4dDogZnVuY3Rpb24odGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQubWVhc3VyZVRleHQodGV4dCk7XG4gICAgfSxcbiAgICBnZXRJbWFnZURhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5nZXRJbWFnZURhdGEoYVswXSwgYVsxXSwgYVsyXSwgYVszXSk7XG4gICAgfSxcbiAgICBsaW5lVG86IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyhhWzBdLCBhWzFdKTtcbiAgICB9LFxuICAgIG1vdmVUbzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYSA9IGFyZ3VtZW50cztcbiAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKGFbMF0sIGFbMV0pO1xuICAgIH0sXG4gICAgcmVjdDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYSA9IGFyZ3VtZW50cztcbiAgICAgIHRoaXMuX2NvbnRleHQucmVjdChhWzBdLCBhWzFdLCBhWzJdLCBhWzNdKTtcbiAgICB9LFxuICAgIHB1dEltYWdlRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYSA9IGFyZ3VtZW50cztcbiAgICAgIHRoaXMuX2NvbnRleHQucHV0SW1hZ2VEYXRhKGFbMF0sIGFbMV0sIGFbMl0pO1xuICAgIH0sXG4gICAgcXVhZHJhdGljQ3VydmVUbzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYSA9IGFyZ3VtZW50cztcbiAgICAgIHRoaXMuX2NvbnRleHQucXVhZHJhdGljQ3VydmVUbyhhWzBdLCBhWzFdLCBhWzJdLCBhWzNdKTtcbiAgICB9LFxuICAgIHJlc3RvcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfSxcbiAgICByb3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICB0aGlzLl9jb250ZXh0LnJvdGF0ZShhWzBdKTtcbiAgICB9LFxuICAgIHNhdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fY29udGV4dC5zYXZlKCk7XG4gICAgfSxcbiAgICBzY2FsZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYSA9IGFyZ3VtZW50cztcbiAgICAgIHRoaXMuX2NvbnRleHQuc2NhbGUoYVswXSwgYVsxXSk7XG4gICAgfSxcbiAgICBzZXRMaW5lRGFzaDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYSA9IGFyZ3VtZW50cywgX2NvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xuXG4gICAgICAvLyB3b3JrcyBmb3IgQ2hyb21lIGFuZCBJRTExXG4gICAgICBpZiAodGhpcy5fY29udGV4dC5zZXRMaW5lRGFzaCkge1xuICAgICAgICBfY29udGV4dC5zZXRMaW5lRGFzaChhWzBdKTtcbiAgICAgIH0gZWxzZSBpZiAoJ21vekRhc2gnIGluIF9jb250ZXh0KSB7XG4gICAgICAgIC8vIHZlcmlmaWVkIHRoYXQgdGhpcyB3b3JrcyBpbiBmaXJlZm94XG4gICAgICAgIF9jb250ZXh0Lm1vekRhc2ggPSBhWzBdO1xuICAgICAgfSBlbHNlIGlmICgnd2Via2l0TGluZURhc2gnIGluIF9jb250ZXh0KSB7XG4gICAgICAgIC8vIGRvZXMgbm90IGN1cnJlbnRseSB3b3JrIGZvciBTYWZhcmlcbiAgICAgICAgX2NvbnRleHQud2Via2l0TGluZURhc2ggPSBhWzBdO1xuICAgICAgfVxuXG4gICAgICAvLyBubyBzdXBwb3J0IGZvciBJRTkgYW5kIElFMTBcbiAgICB9LFxuICAgIGdldExpbmVEYXNoOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmdldExpbmVEYXNoKCk7XG4gICAgfSxcbiAgICBzZXRUcmFuc2Zvcm06IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICB0aGlzLl9jb250ZXh0LnNldFRyYW5zZm9ybShhWzBdLCBhWzFdLCBhWzJdLCBhWzNdLCBhWzRdLCBhWzVdKTtcbiAgICB9LFxuICAgIHN0cm9rZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9jb250ZXh0LnN0cm9rZSgpO1xuICAgIH0sXG4gICAgc3Ryb2tlVGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYSA9IGFyZ3VtZW50cztcbiAgICAgIHRoaXMuX2NvbnRleHQuc3Ryb2tlVGV4dChhWzBdLCBhWzFdLCBhWzJdKTtcbiAgICB9LFxuICAgIHRyYW5zZm9ybTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYSA9IGFyZ3VtZW50cztcbiAgICAgIHRoaXMuX2NvbnRleHQudHJhbnNmb3JtKGFbMF0sIGFbMV0sIGFbMl0sIGFbM10sIGFbNF0sIGFbNV0pO1xuICAgIH0sXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgdGhpcy5fY29udGV4dC50cmFuc2xhdGUoYVswXSwgYVsxXSk7XG4gICAgfSxcbiAgICBfZW5hYmxlVHJhY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICBsZW4gPSBDT05URVhUX01FVEhPRFMubGVuZ3RoLFxuICAgICAgICBfc2ltcGxpZnlBcnJheSA9IEtvbnZhLlV0aWwuX3NpbXBsaWZ5QXJyYXksXG4gICAgICAgIG9yaWdTZXR0ZXIgPSB0aGlzLnNldEF0dHIsXG4gICAgICAgIG4sXG4gICAgICAgIGFyZ3M7XG5cbiAgICAgIC8vIHRvIHByZXZlbnQgY3JlYXRpbmcgc2NvcGUgZnVuY3Rpb24gYXQgZWFjaCBsb29wXG4gICAgICB2YXIgZnVuYyA9IGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIG9yaWdNZXRob2QgPSB0aGF0W21ldGhvZE5hbWVdLCByZXQ7XG5cbiAgICAgICAgdGhhdFttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGFyZ3MgPSBfc2ltcGxpZnlBcnJheShBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcbiAgICAgICAgICByZXQgPSBvcmlnTWV0aG9kLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICB0aGF0Ll90cmFjZSh7XG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZE5hbWUsXG4gICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIC8vIG1ldGhvZHNcbiAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICBmdW5jKENPTlRFWFRfTUVUSE9EU1tuXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGF0dHJzXG4gICAgICB0aGF0LnNldEF0dHIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgb3JpZ1NldHRlci5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICAgICAgICB2YXIgcHJvcCA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgdmFyIHZhbCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHByb3AgPT09ICdzaGFkb3dPZmZzZXRYJyB8fFxuICAgICAgICAgIHByb3AgPT09ICdzaGFkb3dPZmZzZXRZJyB8fFxuICAgICAgICAgIHByb3AgPT09ICdzaGFkb3dCbHVyJ1xuICAgICAgICApIHtcbiAgICAgICAgICB2YWwgPSB2YWwgLyB0aGlzLmNhbnZhcy5nZXRQaXhlbFJhdGlvKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhhdC5fdHJhY2Uoe1xuICAgICAgICAgIHByb3BlcnR5OiBwcm9wLFxuICAgICAgICAgIHZhbDogdmFsXG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgQ09OVEVYVF9QUk9QRVJUSUVTLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShLb252YS5Db250ZXh0LnByb3RvdHlwZSwgcHJvcCwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHRbcHJvcF07XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dFtwcm9wXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgS29udmEuU2NlbmVDb250ZXh0ID0gZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgS29udmEuQ29udGV4dC5jYWxsKHRoaXMsIGNhbnZhcyk7XG4gIH07XG5cbiAgS29udmEuU2NlbmVDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBfZmlsbENvbG9yOiBmdW5jdGlvbihzaGFwZSkge1xuICAgICAgdmFyIGZpbGwgPSBzaGFwZS5maWxsKCk7XG5cbiAgICAgIHRoaXMuc2V0QXR0cignZmlsbFN0eWxlJywgZmlsbCk7XG4gICAgICBzaGFwZS5fZmlsbEZ1bmModGhpcyk7XG4gICAgfSxcbiAgICBfZmlsbFBhdHRlcm46IGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICB2YXIgZmlsbFBhdHRlcm5YID0gc2hhcGUuZ2V0RmlsbFBhdHRlcm5YKCksXG4gICAgICAgIGZpbGxQYXR0ZXJuWSA9IHNoYXBlLmdldEZpbGxQYXR0ZXJuWSgpLFxuICAgICAgICBmaWxsUGF0dGVyblNjYWxlID0gc2hhcGUuZ2V0RmlsbFBhdHRlcm5TY2FsZSgpLFxuICAgICAgICBmaWxsUGF0dGVyblJvdGF0aW9uID0gS29udmEuZ2V0QW5nbGUoc2hhcGUuZ2V0RmlsbFBhdHRlcm5Sb3RhdGlvbigpKSxcbiAgICAgICAgZmlsbFBhdHRlcm5PZmZzZXQgPSBzaGFwZS5nZXRGaWxsUGF0dGVybk9mZnNldCgpO1xuXG4gICAgICBpZiAoZmlsbFBhdHRlcm5YIHx8IGZpbGxQYXR0ZXJuWSkge1xuICAgICAgICB0aGlzLnRyYW5zbGF0ZShmaWxsUGF0dGVyblggfHwgMCwgZmlsbFBhdHRlcm5ZIHx8IDApO1xuICAgICAgfVxuICAgICAgaWYgKGZpbGxQYXR0ZXJuUm90YXRpb24pIHtcbiAgICAgICAgdGhpcy5yb3RhdGUoZmlsbFBhdHRlcm5Sb3RhdGlvbik7XG4gICAgICB9XG4gICAgICBpZiAoZmlsbFBhdHRlcm5TY2FsZSkge1xuICAgICAgICB0aGlzLnNjYWxlKGZpbGxQYXR0ZXJuU2NhbGUueCwgZmlsbFBhdHRlcm5TY2FsZS55KTtcbiAgICAgIH1cbiAgICAgIGlmIChmaWxsUGF0dGVybk9mZnNldCkge1xuICAgICAgICB0aGlzLnRyYW5zbGF0ZSgtMSAqIGZpbGxQYXR0ZXJuT2Zmc2V0LngsIC0xICogZmlsbFBhdHRlcm5PZmZzZXQueSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0QXR0cihcbiAgICAgICAgJ2ZpbGxTdHlsZScsXG4gICAgICAgIHRoaXMuY3JlYXRlUGF0dGVybihcbiAgICAgICAgICBzaGFwZS5nZXRGaWxsUGF0dGVybkltYWdlKCksXG4gICAgICAgICAgc2hhcGUuZ2V0RmlsbFBhdHRlcm5SZXBlYXQoKSB8fCAncmVwZWF0J1xuICAgICAgICApXG4gICAgICApO1xuICAgICAgdGhpcy5maWxsKCk7XG4gICAgfSxcbiAgICBfZmlsbExpbmVhckdyYWRpZW50OiBmdW5jdGlvbihzaGFwZSkge1xuICAgICAgdmFyIHN0YXJ0ID0gc2hhcGUuZ2V0RmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludCgpLFxuICAgICAgICBlbmQgPSBzaGFwZS5nZXRGaWxsTGluZWFyR3JhZGllbnRFbmRQb2ludCgpLFxuICAgICAgICBjb2xvclN0b3BzID0gc2hhcGUuZ2V0RmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wcygpLFxuICAgICAgICBncmQgPSB0aGlzLmNyZWF0ZUxpbmVhckdyYWRpZW50KHN0YXJ0LngsIHN0YXJ0LnksIGVuZC54LCBlbmQueSk7XG5cbiAgICAgIGlmIChjb2xvclN0b3BzKSB7XG4gICAgICAgIC8vIGJ1aWxkIGNvbG9yIHN0b3BzXG4gICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgY29sb3JTdG9wcy5sZW5ndGg7IG4gKz0gMikge1xuICAgICAgICAgIGdyZC5hZGRDb2xvclN0b3AoY29sb3JTdG9wc1tuXSwgY29sb3JTdG9wc1tuICsgMV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0QXR0cignZmlsbFN0eWxlJywgZ3JkKTtcbiAgICAgICAgc2hhcGUuX2ZpbGxGdW5jKHRoaXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2ZpbGxSYWRpYWxHcmFkaWVudDogZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgIHZhciBzdGFydCA9IHNoYXBlLmdldEZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnQoKSxcbiAgICAgICAgZW5kID0gc2hhcGUuZ2V0RmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnQoKSxcbiAgICAgICAgc3RhcnRSYWRpdXMgPSBzaGFwZS5nZXRGaWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1cygpLFxuICAgICAgICBlbmRSYWRpdXMgPSBzaGFwZS5nZXRGaWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXMoKSxcbiAgICAgICAgY29sb3JTdG9wcyA9IHNoYXBlLmdldEZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHMoKSxcbiAgICAgICAgZ3JkID0gdGhpcy5jcmVhdGVSYWRpYWxHcmFkaWVudChcbiAgICAgICAgICBzdGFydC54LFxuICAgICAgICAgIHN0YXJ0LnksXG4gICAgICAgICAgc3RhcnRSYWRpdXMsXG4gICAgICAgICAgZW5kLngsXG4gICAgICAgICAgZW5kLnksXG4gICAgICAgICAgZW5kUmFkaXVzXG4gICAgICAgICk7XG5cbiAgICAgIC8vIGJ1aWxkIGNvbG9yIHN0b3BzXG4gICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGNvbG9yU3RvcHMubGVuZ3RoOyBuICs9IDIpIHtcbiAgICAgICAgZ3JkLmFkZENvbG9yU3RvcChjb2xvclN0b3BzW25dLCBjb2xvclN0b3BzW24gKyAxXSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldEF0dHIoJ2ZpbGxTdHlsZScsIGdyZCk7XG4gICAgICB0aGlzLmZpbGwoKTtcbiAgICB9LFxuICAgIF9maWxsOiBmdW5jdGlvbihzaGFwZSkge1xuICAgICAgdmFyIGhhc0NvbG9yID0gc2hhcGUuZmlsbCgpLFxuICAgICAgICBoYXNQYXR0ZXJuID0gc2hhcGUuZ2V0RmlsbFBhdHRlcm5JbWFnZSgpLFxuICAgICAgICBoYXNMaW5lYXJHcmFkaWVudCA9IHNoYXBlLmdldEZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHMoKSxcbiAgICAgICAgaGFzUmFkaWFsR3JhZGllbnQgPSBzaGFwZS5nZXRGaWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzKCksXG4gICAgICAgIGZpbGxQcmlvcml0eSA9IHNoYXBlLmdldEZpbGxQcmlvcml0eSgpO1xuXG4gICAgICAvLyBwcmlvcml0eSBmaWxsc1xuICAgICAgaWYgKGhhc0NvbG9yICYmIGZpbGxQcmlvcml0eSA9PT0gJ2NvbG9yJykge1xuICAgICAgICB0aGlzLl9maWxsQ29sb3Ioc2hhcGUpO1xuICAgICAgfSBlbHNlIGlmIChoYXNQYXR0ZXJuICYmIGZpbGxQcmlvcml0eSA9PT0gJ3BhdHRlcm4nKSB7XG4gICAgICAgIHRoaXMuX2ZpbGxQYXR0ZXJuKHNoYXBlKTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzTGluZWFyR3JhZGllbnQgJiYgZmlsbFByaW9yaXR5ID09PSAnbGluZWFyLWdyYWRpZW50Jykge1xuICAgICAgICB0aGlzLl9maWxsTGluZWFyR3JhZGllbnQoc2hhcGUpO1xuICAgICAgfSBlbHNlIGlmIChoYXNSYWRpYWxHcmFkaWVudCAmJiBmaWxsUHJpb3JpdHkgPT09ICdyYWRpYWwtZ3JhZGllbnQnKSB7XG4gICAgICAgIHRoaXMuX2ZpbGxSYWRpYWxHcmFkaWVudChzaGFwZSk7XG4gICAgICB9IGVsc2UgaWYgKGhhc0NvbG9yKSB7XG4gICAgICAgIC8vIG5vdyBqdXN0IHRyeSBhbmQgZmlsbCB3aXRoIHdoYXRldmVyIGlzIGF2YWlsYWJsZVxuICAgICAgICB0aGlzLl9maWxsQ29sb3Ioc2hhcGUpO1xuICAgICAgfSBlbHNlIGlmIChoYXNQYXR0ZXJuKSB7XG4gICAgICAgIHRoaXMuX2ZpbGxQYXR0ZXJuKHNoYXBlKTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzTGluZWFyR3JhZGllbnQpIHtcbiAgICAgICAgdGhpcy5fZmlsbExpbmVhckdyYWRpZW50KHNoYXBlKTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzUmFkaWFsR3JhZGllbnQpIHtcbiAgICAgICAgdGhpcy5fZmlsbFJhZGlhbEdyYWRpZW50KHNoYXBlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9zdHJva2U6IGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICB2YXIgZGFzaCA9IHNoYXBlLmRhc2goKSxcbiAgICAgICAgLy8gaWdub3JlIHN0cm9rZVNjYWxlRW5hYmxlZCBmb3IgVGV4dFxuICAgICAgICBzdHJva2VTY2FsZUVuYWJsZWQgPVxuICAgICAgICAgIHNoYXBlLmdldFN0cm9rZVNjYWxlRW5hYmxlZCgpIHx8IHNoYXBlIGluc3RhbmNlb2YgS29udmEuVGV4dDtcblxuICAgICAgaWYgKHNoYXBlLmhhc1N0cm9rZSgpKSB7XG4gICAgICAgIGlmICghc3Ryb2tlU2NhbGVFbmFibGVkKSB7XG4gICAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9hcHBseUxpbmVDYXAoc2hhcGUpO1xuICAgICAgICBpZiAoZGFzaCAmJiBzaGFwZS5kYXNoRW5hYmxlZCgpKSB7XG4gICAgICAgICAgdGhpcy5zZXRMaW5lRGFzaChkYXNoKTtcbiAgICAgICAgICB0aGlzLnNldEF0dHIoJ2xpbmVEYXNoT2Zmc2V0Jywgc2hhcGUuZGFzaE9mZnNldCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0QXR0cignbGluZVdpZHRoJywgc2hhcGUuc3Ryb2tlV2lkdGgoKSk7XG4gICAgICAgIHRoaXMuc2V0QXR0cignc3Ryb2tlU3R5bGUnLCBzaGFwZS5zdHJva2UoKSk7XG5cbiAgICAgICAgaWYgKCFzaGFwZS5nZXRTaGFkb3dGb3JTdHJva2VFbmFibGVkKCkpIHtcbiAgICAgICAgICB0aGlzLnNldEF0dHIoJ3NoYWRvd0NvbG9yJywgJ3JnYmEoMCwwLDAsMCknKTtcbiAgICAgICAgfVxuICAgICAgICBzaGFwZS5fc3Ryb2tlRnVuYyh0aGlzKTtcblxuICAgICAgICBpZiAoIXN0cm9rZVNjYWxlRW5hYmxlZCkge1xuICAgICAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBfYXBwbHlTaGFkb3c6IGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICB2YXIgdXRpbCA9IEtvbnZhLlV0aWwsXG4gICAgICAgIGNvbG9yID0gdXRpbC5nZXQoc2hhcGUuZ2V0U2hhZG93UkdCQSgpLCAnYmxhY2snKSxcbiAgICAgICAgYmx1ciA9IHV0aWwuZ2V0KHNoYXBlLmdldFNoYWRvd0JsdXIoKSwgNSksXG4gICAgICAgIG9mZnNldCA9IHV0aWwuZ2V0KHNoYXBlLmdldFNoYWRvd09mZnNldCgpLCB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH0pLFxuICAgICAgICAvLyBUT0RPOiBnZXQgdGhpcyBpbmZvIGZyb20gdHJhbnNmb3JtPz9cbiAgICAgICAgc2NhbGUgPSBzaGFwZS5nZXRBYnNvbHV0ZVNjYWxlKCksXG4gICAgICAgIHJhdGlvID0gdGhpcy5jYW52YXMuZ2V0UGl4ZWxSYXRpbygpLFxuICAgICAgICBzY2FsZVggPSBzY2FsZS54ICogcmF0aW8sXG4gICAgICAgIHNjYWxlWSA9IHNjYWxlLnkgKiByYXRpbztcblxuICAgICAgdGhpcy5zZXRBdHRyKCdzaGFkb3dDb2xvcicsIGNvbG9yKTtcbiAgICAgIHRoaXMuc2V0QXR0cihcbiAgICAgICAgJ3NoYWRvd0JsdXInLFxuICAgICAgICBibHVyICogcmF0aW8gKiBNYXRoLm1pbihNYXRoLmFicyhzY2FsZVgpLCBNYXRoLmFicyhzY2FsZVkpKVxuICAgICAgKTtcbiAgICAgIHRoaXMuc2V0QXR0cignc2hhZG93T2Zmc2V0WCcsIG9mZnNldC54ICogc2NhbGVYKTtcbiAgICAgIHRoaXMuc2V0QXR0cignc2hhZG93T2Zmc2V0WScsIG9mZnNldC55ICogc2NhbGVZKTtcbiAgICB9LFxuICAgIF9hcHBseUdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjogZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgIHZhciBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBzaGFwZS5nZXRHbG9iYWxDb21wb3NpdGVPcGVyYXRpb24oKTtcbiAgICAgIGlmIChnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gIT09ICdzb3VyY2Utb3ZlcicpIHtcbiAgICAgICAgdGhpcy5zZXRBdHRyKCdnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24nLCBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgS29udmEuVXRpbC5leHRlbmQoS29udmEuU2NlbmVDb250ZXh0LCBLb252YS5Db250ZXh0KTtcblxuICBLb252YS5IaXRDb250ZXh0ID0gZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgS29udmEuQ29udGV4dC5jYWxsKHRoaXMsIGNhbnZhcyk7XG4gIH07XG5cbiAgS29udmEuSGl0Q29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgX2ZpbGw6IGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICB0aGlzLnNhdmUoKTtcbiAgICAgIHRoaXMuc2V0QXR0cignZmlsbFN0eWxlJywgc2hhcGUuY29sb3JLZXkpO1xuICAgICAgc2hhcGUuX2ZpbGxGdW5jSGl0KHRoaXMpO1xuICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgfSxcbiAgICBfc3Ryb2tlOiBmdW5jdGlvbihzaGFwZSkge1xuICAgICAgaWYgKHNoYXBlLmhhc1N0cm9rZSgpICYmIHNoYXBlLnN0cm9rZUhpdEVuYWJsZWQoKSkge1xuICAgICAgICAvLyBpZ25vcmUgc3Ryb2tlU2NhbGVFbmFibGVkIGZvciBUZXh0XG4gICAgICAgIHZhciBzdHJva2VTY2FsZUVuYWJsZWQgPVxuICAgICAgICAgIHNoYXBlLmdldFN0cm9rZVNjYWxlRW5hYmxlZCgpIHx8IHNoYXBlIGluc3RhbmNlb2YgS29udmEuVGV4dDtcbiAgICAgICAgaWYgKCFzdHJva2VTY2FsZUVuYWJsZWQpIHtcbiAgICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICAgICAgICB0aGlzLnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hcHBseUxpbmVDYXAoc2hhcGUpO1xuICAgICAgICB0aGlzLnNldEF0dHIoJ2xpbmVXaWR0aCcsIHNoYXBlLnN0cm9rZVdpZHRoKCkpO1xuICAgICAgICB0aGlzLnNldEF0dHIoJ3N0cm9rZVN0eWxlJywgc2hhcGUuY29sb3JLZXkpO1xuICAgICAgICBzaGFwZS5fc3Ryb2tlRnVuY0hpdCh0aGlzKTtcbiAgICAgICAgaWYgKCFzdHJva2VTY2FsZUVuYWJsZWQpIHtcbiAgICAgICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgS29udmEuVXRpbC5leHRlbmQoS29udmEuSGl0Q29udGV4dCwgS29udmEuQ29udGV4dCk7XG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLy8gQ09OU1RBTlRTXG4gIHZhciBHRVQgPSAnZ2V0JywgU0VUID0gJ3NldCc7XG5cbiAgS29udmEuRmFjdG9yeSA9IHtcbiAgICBhZGRHZXR0ZXJTZXR0ZXI6IGZ1bmN0aW9uKGNvbnN0cnVjdG9yLCBhdHRyLCBkZWYsIHZhbGlkYXRvciwgYWZ0ZXIpIHtcbiAgICAgIHRoaXMuYWRkR2V0dGVyKGNvbnN0cnVjdG9yLCBhdHRyLCBkZWYpO1xuICAgICAgdGhpcy5hZGRTZXR0ZXIoY29uc3RydWN0b3IsIGF0dHIsIHZhbGlkYXRvciwgYWZ0ZXIpO1xuICAgICAgdGhpcy5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKGNvbnN0cnVjdG9yLCBhdHRyKTtcbiAgICB9LFxuICAgIGFkZEdldHRlcjogZnVuY3Rpb24oY29uc3RydWN0b3IsIGF0dHIsIGRlZikge1xuICAgICAgdmFyIG1ldGhvZCA9IEdFVCArIEtvbnZhLlV0aWwuX2NhcGl0YWxpemUoYXR0cik7XG5cbiAgICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmF0dHJzW2F0dHJdO1xuICAgICAgICByZXR1cm4gdmFsID09PSB1bmRlZmluZWQgPyBkZWYgOiB2YWw7XG4gICAgICB9O1xuICAgIH0sXG4gICAgYWRkU2V0dGVyOiBmdW5jdGlvbihjb25zdHJ1Y3RvciwgYXR0ciwgdmFsaWRhdG9yLCBhZnRlcikge1xuICAgICAgdmFyIG1ldGhvZCA9IFNFVCArIEtvbnZhLlV0aWwuX2NhcGl0YWxpemUoYXR0cik7XG5cbiAgICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgICAgICB2YWwgPSB2YWxpZGF0b3IuY2FsbCh0aGlzLCB2YWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2V0QXR0cihhdHRyLCB2YWwpO1xuXG4gICAgICAgIGlmIChhZnRlcikge1xuICAgICAgICAgIGFmdGVyLmNhbGwodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgfSxcbiAgICBhZGRDb21wb25lbnRzR2V0dGVyU2V0dGVyOiBmdW5jdGlvbihcbiAgICAgIGNvbnN0cnVjdG9yLFxuICAgICAgYXR0cixcbiAgICAgIGNvbXBvbmVudHMsXG4gICAgICB2YWxpZGF0b3IsXG4gICAgICBhZnRlclxuICAgICkge1xuICAgICAgdmFyIGxlbiA9IGNvbXBvbmVudHMubGVuZ3RoLFxuICAgICAgICBjYXBpdGFsaXplID0gS29udmEuVXRpbC5fY2FwaXRhbGl6ZSxcbiAgICAgICAgZ2V0dGVyID0gR0VUICsgY2FwaXRhbGl6ZShhdHRyKSxcbiAgICAgICAgc2V0dGVyID0gU0VUICsgY2FwaXRhbGl6ZShhdHRyKSxcbiAgICAgICAgbixcbiAgICAgICAgY29tcG9uZW50O1xuXG4gICAgICAvLyBnZXR0ZXJcbiAgICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZVtnZXR0ZXJdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXQgPSB7fTtcblxuICAgICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICBjb21wb25lbnQgPSBjb21wb25lbnRzW25dO1xuICAgICAgICAgIHJldFtjb21wb25lbnRdID0gdGhpcy5nZXRBdHRyKGF0dHIgKyBjYXBpdGFsaXplKGNvbXBvbmVudCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH07XG5cbiAgICAgIC8vIHNldHRlclxuICAgICAgY29uc3RydWN0b3IucHJvdG90eXBlW3NldHRlcl0gPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdmFyIG9sZFZhbCA9IHRoaXMuYXR0cnNbYXR0cl0sIGtleTtcblxuICAgICAgICBpZiAodmFsaWRhdG9yKSB7XG4gICAgICAgICAgdmFsID0gdmFsaWRhdG9yLmNhbGwodGhpcywgdmFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoa2V5IGluIHZhbCkge1xuICAgICAgICAgIGlmICghdmFsLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9zZXRBdHRyKGF0dHIgKyBjYXBpdGFsaXplKGtleSksIHZhbFtrZXldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2ZpcmVDaGFuZ2VFdmVudChhdHRyLCBvbGRWYWwsIHZhbCk7XG5cbiAgICAgICAgaWYgKGFmdGVyKSB7XG4gICAgICAgICAgYWZ0ZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKGNvbnN0cnVjdG9yLCBhdHRyKTtcbiAgICB9LFxuICAgIGFkZE92ZXJsb2FkZWRHZXR0ZXJTZXR0ZXI6IGZ1bmN0aW9uKGNvbnN0cnVjdG9yLCBhdHRyKSB7XG4gICAgICB2YXIgY2FwaXRhbGl6ZWRBdHRyID0gS29udmEuVXRpbC5fY2FwaXRhbGl6ZShhdHRyKSxcbiAgICAgICAgc2V0dGVyID0gU0VUICsgY2FwaXRhbGl6ZWRBdHRyLFxuICAgICAgICBnZXR0ZXIgPSBHRVQgKyBjYXBpdGFsaXplZEF0dHI7XG5cbiAgICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZVthdHRyXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBzZXR0aW5nXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpc1tzZXR0ZXJdKGFyZ3VtZW50c1swXSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZ2V0dGluZ1xuICAgICAgICByZXR1cm4gdGhpc1tnZXR0ZXJdKCk7XG4gICAgICB9O1xuICAgIH0sXG4gICAgYWRkRGVwcmVjYXRlZEdldHRlclNldHRlcjogZnVuY3Rpb24oY29uc3RydWN0b3IsIGF0dHIsIGRlZiwgdmFsaWRhdG9yKSB7XG4gICAgICB2YXIgbWV0aG9kID0gR0VUICsgS29udmEuVXRpbC5fY2FwaXRhbGl6ZShhdHRyKTtcbiAgICAgIHZhciBtZXNzYWdlID1cbiAgICAgICAgYXR0ciArXG4gICAgICAgICcgcHJvcGVydHkgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIHNvb24uIExvb2sgYXQgS29udmEgY2hhbmdlIGxvZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nO1xuICAgICAgY29uc3RydWN0b3IucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgS29udmEuVXRpbC5lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuYXR0cnNbYXR0cl07XG4gICAgICAgIHJldHVybiB2YWwgPT09IHVuZGVmaW5lZCA/IGRlZiA6IHZhbDtcbiAgICAgIH07XG4gICAgICB0aGlzLmFkZFNldHRlcihjb25zdHJ1Y3RvciwgYXR0ciwgdmFsaWRhdG9yLCBmdW5jdGlvbigpIHtcbiAgICAgICAgS29udmEuVXRpbC5lcnJvcihtZXNzYWdlKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKGNvbnN0cnVjdG9yLCBhdHRyKTtcbiAgICB9LFxuICAgIGJhY2tDb21wYXQ6IGZ1bmN0aW9uKGNvbnN0cnVjdG9yLCBtZXRob2RzKSB7XG4gICAgICBLb252YS5VdGlsLmVhY2gobWV0aG9kcywgZnVuY3Rpb24ob2xkTWV0aG9kTmFtZSwgbmV3TWV0aG9kTmFtZSkge1xuICAgICAgICB2YXIgbWV0aG9kID0gY29uc3RydWN0b3IucHJvdG90eXBlW25ld01ldGhvZE5hbWVdO1xuICAgICAgICBjb25zdHJ1Y3Rvci5wcm90b3R5cGVbb2xkTWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICBLb252YS5VdGlsLmVycm9yKFxuICAgICAgICAgICAgb2xkTWV0aG9kTmFtZSArXG4gICAgICAgICAgICAgICcgbWV0aG9kIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBzb29uLiBVc2UgJyArXG4gICAgICAgICAgICAgIG5ld01ldGhvZE5hbWUgK1xuICAgICAgICAgICAgICAnIGluc3RlYWQnXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgYWZ0ZXJTZXRGaWx0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fZmlsdGVyVXBUb0RhdGUgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgS29udmEuVmFsaWRhdG9ycyA9IHtcbiAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICBSR0JDb21wb25lbnQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgaWYgKHZhbCA+IDI1NSkge1xuICAgICAgICByZXR1cm4gMjU1O1xuICAgICAgfSBlbHNlIGlmICh2YWwgPCAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1hdGgucm91bmQodmFsKTtcbiAgICB9LFxuICAgIGFscGhhQ29tcG9uZW50OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIGlmICh2YWwgPiAxKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIGlmICh2YWwgPCAwLjAwMDEpIHtcbiAgICAgICAgLy8gY2hyb21lIGRvZXMgbm90IGhvbm9yIGFscGhhIHZhbHVlcyBvZiAwXG4gICAgICAgIHJldHVybiAwLjAwMDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICB9O1xufSkoKTtcblxuKGZ1bmN0aW9uKEtvbnZhKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLy8gQ09OU1RBTlRTXG4gIHZhciBBQlNPTFVURV9PUEFDSVRZID0gJ2Fic29sdXRlT3BhY2l0eScsXG4gICAgQUJTT0xVVEVfVFJBTlNGT1JNID0gJ2Fic29sdXRlVHJhbnNmb3JtJyxcbiAgICBBQlNPTFVURV9TQ0FMRSA9ICdhYnNvbHV0ZVNjYWxlJyxcbiAgICBDSEFOR0UgPSAnQ2hhbmdlJyxcbiAgICBDSElMRFJFTiA9ICdjaGlsZHJlbicsXG4gICAgRE9UID0gJy4nLFxuICAgIEVNUFRZX1NUUklORyA9ICcnLFxuICAgIEdFVCA9ICdnZXQnLFxuICAgIElEID0gJ2lkJyxcbiAgICBLT05WQSA9ICdrb252YScsXG4gICAgTElTVEVOSU5HID0gJ2xpc3RlbmluZycsXG4gICAgTU9VU0VFTlRFUiA9ICdtb3VzZWVudGVyJyxcbiAgICBNT1VTRUxFQVZFID0gJ21vdXNlbGVhdmUnLFxuICAgIE5BTUUgPSAnbmFtZScsXG4gICAgU0VUID0gJ3NldCcsXG4gICAgU0hBUEUgPSAnU2hhcGUnLFxuICAgIFNQQUNFID0gJyAnLFxuICAgIFNUQUdFID0gJ3N0YWdlJyxcbiAgICBUUkFOU0ZPUk0gPSAndHJhbnNmb3JtJyxcbiAgICBVUFBFUl9TVEFHRSA9ICdTdGFnZScsXG4gICAgVklTSUJMRSA9ICd2aXNpYmxlJyxcbiAgICBDTE9ORV9CTEFDS19MSVNUID0gWydpZCddLFxuICAgIFRSQU5TRk9STV9DSEFOR0VfU1RSID0gW1xuICAgICAgJ3hDaGFuZ2Uua29udmEnLFxuICAgICAgJ3lDaGFuZ2Uua29udmEnLFxuICAgICAgJ3NjYWxlWENoYW5nZS5rb252YScsXG4gICAgICAnc2NhbGVZQ2hhbmdlLmtvbnZhJyxcbiAgICAgICdza2V3WENoYW5nZS5rb252YScsXG4gICAgICAnc2tld1lDaGFuZ2Uua29udmEnLFxuICAgICAgJ3JvdGF0aW9uQ2hhbmdlLmtvbnZhJyxcbiAgICAgICdvZmZzZXRYQ2hhbmdlLmtvbnZhJyxcbiAgICAgICdvZmZzZXRZQ2hhbmdlLmtvbnZhJyxcbiAgICAgICd0cmFuc2Zvcm1zRW5hYmxlZENoYW5nZS5rb252YSdcbiAgICBdLmpvaW4oU1BBQ0UpLFxuICAgIFNDQUxFX0NIQU5HRV9TVFIgPSBbJ3NjYWxlWENoYW5nZS5rb252YScsICdzY2FsZVlDaGFuZ2Uua29udmEnXS5qb2luKFNQQUNFKTtcblxuICAvKipcbiAgICAgKiBOb2RlIGNvbnN0cnVjdG9yLiBOb2RlcyBhcmUgZW50aXRpZXMgdGhhdCBjYW4gYmUgdHJhbnNmb3JtZWQsIGxheWVyZWQsXG4gICAgICogYW5kIGhhdmUgYm91bmQgZXZlbnRzLiBUaGUgc3RhZ2UsIGxheWVycywgZ3JvdXBzLCBhbmQgc2hhcGVzIGFsbCBleHRlbmQgTm9kZS5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICAgKi9cbiAgS29udmEuTm9kZSA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHRoaXMuX2luaXQoY29uZmlnKTtcbiAgfTtcblxuICBLb252YS5VdGlsLmFkZE1ldGhvZHMoS29udmEuTm9kZSwge1xuICAgIF9pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHRoaXMuX2lkID0gS29udmEuaWRDb3VudGVyKys7XG4gICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzID0ge307XG4gICAgICB0aGlzLmF0dHJzID0ge307XG4gICAgICB0aGlzLl9jYWNoZSA9IHt9O1xuICAgICAgdGhpcy5fZmlsdGVyVXBUb0RhdGUgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2lzVW5kZXJDYWNoZSA9IGZhbHNlO1xuICAgICAgdGhpcy5zZXRBdHRycyhjb25maWcpO1xuXG4gICAgICAvLyBldmVudCBiaW5kaW5ncyBmb3IgY2FjaGUgaGFuZGxpbmdcbiAgICAgIHRoaXMub24oVFJBTlNGT1JNX0NIQU5HRV9TVFIsIGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9jbGVhckNhY2hlKFRSQU5TRk9STSk7XG4gICAgICAgIHRoYXQuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZShBQlNPTFVURV9UUkFOU0ZPUk0pO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMub24oU0NBTEVfQ0hBTkdFX1NUUiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoYXQuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZShBQlNPTFVURV9TQ0FMRSk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5vbigndmlzaWJsZUNoYW5nZS5rb252YScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGF0Ll9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoVklTSUJMRSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMub24oJ2xpc3RlbmluZ0NoYW5nZS5rb252YScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGF0Ll9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoTElTVEVOSU5HKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5vbignb3BhY2l0eUNoYW5nZS5rb252YScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGF0Ll9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoQUJTT0xVVEVfT1BBQ0lUWSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIF9jbGVhckNhY2hlOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICBpZiAoYXR0cikge1xuICAgICAgICBkZWxldGUgdGhpcy5fY2FjaGVbYXR0cl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jYWNoZSA9IHt9O1xuICAgICAgfVxuICAgIH0sXG4gICAgX2dldENhY2hlOiBmdW5jdGlvbihhdHRyLCBwcml2YXRlR2V0dGVyKSB7XG4gICAgICB2YXIgY2FjaGUgPSB0aGlzLl9jYWNoZVthdHRyXTtcblxuICAgICAgLy8gaWYgbm90IGNhY2hlZCwgd2UgbmVlZCB0byBzZXQgaXQgdXNpbmcgdGhlIHByaXZhdGUgZ2V0dGVyIG1ldGhvZC5cbiAgICAgIGlmIChjYWNoZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX2NhY2hlW2F0dHJdID0gcHJpdmF0ZUdldHRlci5jYWxsKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGVbYXR0cl07XG4gICAgfSxcbiAgICAvKlxuICAgICAgICAgKiB3aGVuIHRoZSBsb2dpYyBmb3IgYSBjYWNoZWQgcmVzdWx0IGRlcGVuZHMgb24gYW5jZXN0b3IgcHJvcGFnYXRpb24sIHVzZSB0aGlzXG4gICAgICAgICAqIG1ldGhvZCB0byBjbGVhciBzZWxmIGFuZCBjaGlsZHJlbiBjYWNoZVxuICAgICAgICAgKi9cbiAgICBfY2xlYXJTZWxmQW5kRGVzY2VuZGFudENhY2hlOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICB0aGlzLl9jbGVhckNhY2hlKGF0dHIpO1xuXG4gICAgICBpZiAodGhpcy5jaGlsZHJlbikge1xuICAgICAgICB0aGlzLmdldENoaWxkcmVuKCkuZWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgbm9kZS5fY2xlYXJTZWxmQW5kRGVzY2VuZGFudENhY2hlKGF0dHIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAqIGNsZWFyIGNhY2hlZCBjYW52YXNcbiAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgKiBub2RlLmNsZWFyQ2FjaGUoKTtcbiAgICAgICAgKi9cbiAgICBjbGVhckNhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9jYWNoZS5jYW52YXM7XG4gICAgICB0aGlzLl9maWx0ZXJVcFRvRGF0ZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgKiAgY2FjaGUgbm9kZSB0byBpbXByb3ZlIGRyYXdpbmcgcGVyZm9ybWFuY2UsIGFwcGx5IGZpbHRlcnMsIG9yIGNyZWF0ZSBtb3JlIGFjY3VyYXRlXG4gICAgICAgICogIGhpdCByZWdpb25zLiBGb3IgYWxsIGJhc2ljIHNoYXBlcyBzaXplIG9mIGNhY2hlIGNhbnZhcyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgZGV0ZWN0ZWQuXG4gICAgICAgICogIElmIHlvdSBuZWVkIHRvIGNhY2hlIHlvdXIgY3VzdG9tIGBLb252YS5TaGFwZWAgaW5zdGFuY2UgeW91IGhhdmUgdG8gcGFzcyBzaGFwZSdzIGJvdW5kaW5nIGJveFxuICAgICAgICAqICBwcm9wZXJ0aWVzLiBMb29rIGF0IFtsaW5rIHRvIGRlbW8gcGFnZV0obGluayB0byBkZW1vIHBhZ2UpIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ11cbiAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldF0gIGluY3JlYXNlIGNhbnZhcyBzaXplIGJ5IGBvZmZzZXRgIHBpeGVsIGluIGFsbCBkaXJlY3Rpb25zLlxuICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmF3Qm9yZGVyXSB3aGVuIHNldCB0byB0cnVlLCBhIHJlZCBib3JkZXIgd2lsbCBiZSBkcmF3biBhcm91bmQgdGhlIGNhY2hlZFxuICAgICAgICAqICByZWdpb24gZm9yIGRlYnVnZ2luZyBwdXJwb3Nlc1xuICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnBpeGVsUmF0aW9dIGNoYW5nZSBxdWFsaXR5IChvciBwaXhlbCByYXRpbykgb2YgY2FjaGVkIGltYWdlLiBwaXhlbFJhdGlvID0gMiB3aWxsIHByb2R1Y2UgMnggc2l6ZWQgY2FjaGUuXG4gICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgKiAvLyBjYWNoZSBhIHNoYXBlIHdpdGggdGhlIHgseSBwb3NpdGlvbiBvZiB0aGUgYm91bmRpbmcgYm94IGF0IHRoZSBjZW50ZXIgYW5kXG4gICAgICAgICogLy8gdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIGJvdW5kaW5nIGJveCBlcXVhbCB0byB0aGUgd2lkdGggYW5kIGhlaWdodCBvZlxuICAgICAgICAqIC8vIHRoZSBzaGFwZSBvYnRhaW5lZCBmcm9tIHNoYXBlLndpZHRoKCkgYW5kIHNoYXBlLmhlaWdodCgpXG4gICAgICAgICogaW1hZ2UuY2FjaGUoKTtcbiAgICAgICAgKlxuICAgICAgICAqIC8vIGNhY2hlIGEgbm9kZSBhbmQgZGVmaW5lIHRoZSBib3VuZGluZyBib3ggcG9zaXRpb24gYW5kIHNpemVcbiAgICAgICAgKiBub2RlLmNhY2hlKHtcbiAgICAgICAgKiAgIHg6IC0zMCxcbiAgICAgICAgKiAgIHk6IC0zMCxcbiAgICAgICAgKiAgIHdpZHRoOiAxMDAsXG4gICAgICAgICogICBoZWlnaHQ6IDIwMFxuICAgICAgICAqIH0pO1xuICAgICAgICAqXG4gICAgICAgICogLy8gY2FjaGUgYSBub2RlIGFuZCBkcmF3IGEgcmVkIGJvcmRlciBhcm91bmQgdGhlIGJvdW5kaW5nIGJveFxuICAgICAgICAqIC8vIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXNcbiAgICAgICAgKiBub2RlLmNhY2hlKHtcbiAgICAgICAgKiAgIHg6IC0zMCxcbiAgICAgICAgKiAgIHk6IC0zMCxcbiAgICAgICAgKiAgIHdpZHRoOiAxMDAsXG4gICAgICAgICogICBoZWlnaHQ6IDIwMCxcbiAgICAgICAgKiAgIG9mZnNldCA6IDEwLFxuICAgICAgICAqICAgZHJhd0JvcmRlcjogdHJ1ZVxuICAgICAgICAqIH0pO1xuICAgICAgICAqL1xuICAgIGNhY2hlOiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIHZhciBjb25mID0gY29uZmlnIHx8IHt9LFxuICAgICAgICByZWN0ID0gdGhpcy5nZXRDbGllbnRSZWN0KHtcbiAgICAgICAgICBza2lwVHJhbnNmb3JtOiB0cnVlLFxuICAgICAgICAgIHJlbGF0aXZlVG86IHRoaXMuZ2V0UGFyZW50KClcbiAgICAgICAgfSksXG4gICAgICAgIHdpZHRoID0gY29uZi53aWR0aCB8fCByZWN0LndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBjb25mLmhlaWdodCB8fCByZWN0LmhlaWdodCxcbiAgICAgICAgcGl4ZWxSYXRpbyA9IGNvbmYucGl4ZWxSYXRpbyxcbiAgICAgICAgeCA9IGNvbmYueCB8fCByZWN0LngsXG4gICAgICAgIHkgPSBjb25mLnkgfHwgcmVjdC55LFxuICAgICAgICBvZmZzZXQgPSBjb25mLm9mZnNldCB8fCAwLFxuICAgICAgICBkcmF3Qm9yZGVyID0gY29uZi5kcmF3Qm9yZGVyIHx8IGZhbHNlO1xuXG4gICAgICBpZiAoIXdpZHRoIHx8ICFoZWlnaHQpIHtcbiAgICAgICAgLy8gbWFrZSB0aHJvdyBhc3luYywgYmVjYXVzZSB3ZSBkb24ndCBuZWVkIHRvIHN0b3AgZnVuY2lvblxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIEtvbnZhLlV0aWwudGhyb3coXG4gICAgICAgICAgICAnV2lkdGggb3IgaGVpZ2h0IG9mIGNhY2hpbmcgY29uZmlndXJhdGlvbiBlcXVhbHMgMC4gQ2FjaGluZyBpcyBpZ25vcmVkLidcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB3aWR0aCArPSBvZmZzZXQgKiAyO1xuICAgICAgaGVpZ2h0ICs9IG9mZnNldCAqIDI7XG5cbiAgICAgIHggLT0gb2Zmc2V0O1xuICAgICAgeSAtPSBvZmZzZXQ7XG5cbiAgICAgIHZhciBjYWNoZWRTY2VuZUNhbnZhcyA9IG5ldyBLb252YS5TY2VuZUNhbnZhcyh7XG4gICAgICAgICAgcGl4ZWxSYXRpbzogcGl4ZWxSYXRpbyxcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgfSksXG4gICAgICAgIGNhY2hlZEZpbHRlckNhbnZhcyA9IG5ldyBLb252YS5TY2VuZUNhbnZhcyh7XG4gICAgICAgICAgcGl4ZWxSYXRpbzogcGl4ZWxSYXRpbyxcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgfSksXG4gICAgICAgIGNhY2hlZEhpdENhbnZhcyA9IG5ldyBLb252YS5IaXRDYW52YXMoe1xuICAgICAgICAgIHBpeGVsUmF0aW86IDEsXG4gICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgIH0pLFxuICAgICAgICBzY2VuZUNvbnRleHQgPSBjYWNoZWRTY2VuZUNhbnZhcy5nZXRDb250ZXh0KCksXG4gICAgICAgIGhpdENvbnRleHQgPSBjYWNoZWRIaXRDYW52YXMuZ2V0Q29udGV4dCgpO1xuXG4gICAgICBjYWNoZWRIaXRDYW52YXMuaXNDYWNoZSA9IHRydWU7XG5cbiAgICAgIHRoaXMuY2xlYXJDYWNoZSgpO1xuXG4gICAgICBzY2VuZUNvbnRleHQuc2F2ZSgpO1xuICAgICAgaGl0Q29udGV4dC5zYXZlKCk7XG5cbiAgICAgIHNjZW5lQ29udGV4dC50cmFuc2xhdGUoLXgsIC15KTtcbiAgICAgIGhpdENvbnRleHQudHJhbnNsYXRlKC14LCAteSk7XG5cbiAgICAgIC8vIGV4dHJhIGZsYWcgdG8gc2tpcCBvbiBnZXRBYnNvbHV0ZSBvcGFjaXR5IGNhbGNcbiAgICAgIHRoaXMuX2lzVW5kZXJDYWNoZSA9IHRydWU7XG4gICAgICB0aGlzLl9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoQUJTT0xVVEVfT1BBQ0lUWSk7XG4gICAgICB0aGlzLl9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoQUJTT0xVVEVfU0NBTEUpO1xuXG4gICAgICB0aGlzLmRyYXdTY2VuZShjYWNoZWRTY2VuZUNhbnZhcywgdGhpcywgdHJ1ZSk7XG4gICAgICB0aGlzLmRyYXdIaXQoY2FjaGVkSGl0Q2FudmFzLCB0aGlzLCB0cnVlKTtcbiAgICAgIHRoaXMuX2lzVW5kZXJDYWNoZSA9IGZhbHNlO1xuXG4gICAgICBzY2VuZUNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgaGl0Q29udGV4dC5yZXN0b3JlKCk7XG5cbiAgICAgIC8vIHRoaXMgd2lsbCBkcmF3IGEgcmVkIGJvcmRlciBhcm91bmQgdGhlIGNhY2hlZCBib3ggZm9yXG4gICAgICAvLyBkZWJ1Z2dpbmcgcHVycG9zZXNcbiAgICAgIGlmIChkcmF3Qm9yZGVyKSB7XG4gICAgICAgIHNjZW5lQ29udGV4dC5zYXZlKCk7XG4gICAgICAgIHNjZW5lQ29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgc2NlbmVDb250ZXh0LnJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHNjZW5lQ29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgc2NlbmVDb250ZXh0LnNldEF0dHIoJ3N0cm9rZVN0eWxlJywgJ3JlZCcpO1xuICAgICAgICBzY2VuZUNvbnRleHQuc2V0QXR0cignbGluZVdpZHRoJywgNSk7XG4gICAgICAgIHNjZW5lQ29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgc2NlbmVDb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2FjaGUuY2FudmFzID0ge1xuICAgICAgICBzY2VuZTogY2FjaGVkU2NlbmVDYW52YXMsXG4gICAgICAgIGZpbHRlcjogY2FjaGVkRmlsdGVyQ2FudmFzLFxuICAgICAgICBoaXQ6IGNhY2hlZEhpdENhbnZhcyxcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogUmV0dXJuIGNsaWVudCByZWN0YW5nbGUge3gsIHksIHdpZHRoLCBoZWlnaHR9IG9mIG5vZGUuIFRoaXMgcmVjdGFuZ2xlIGFsc28gaW5jbHVkZSBhbGwgc3R5bGluZyAoc3Ryb2tlcywgc2hhZG93cywgZXRjKS5cbiAgICAgICAgICogVGhlIHJlY3RhbmdsZSBwb3NpdGlvbiBpcyByZWxhdGl2ZSB0byBwYXJlbnQgY29udGFpbmVyLlxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5za2lwVHJhbnNmb3JtXSBzaG91bGQgd2UgYXBwbHkgdHJhbnNmb3JtIHRvIG5vZGUgZm9yIGNhbGN1bGF0aW5nIHJlY3Q/XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnJlbGF0aXZlVG9dIGNhbGN1bGF0ZSBjbGllbnQgcmVjdCByZWxhdGl2ZSB0byBvbmUgb2YgdGhlIHBhcmVudHNcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH0gcmVjdCB3aXRoIHt4LCB5LCB3aWR0aCwgaGVpZ2h0fSBwcm9wZXJ0aWVzXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIHZhciByZWN0ID0gbmV3IEtvbnZhLlJlY3Qoe1xuICAgICAgICAgKiAgICAgIHdpZHRoIDogMTAwLFxuICAgICAgICAgKiAgICAgIGhlaWdodCA6IDEwMCxcbiAgICAgICAgICogICAgICB4IDogNTAsXG4gICAgICAgICAqICAgICAgeSA6IDUwLFxuICAgICAgICAgKiAgICAgIHN0cm9rZVdpZHRoIDogNCxcbiAgICAgICAgICogICAgICBzdHJva2UgOiAnYmxhY2snLFxuICAgICAgICAgKiAgICAgIG9mZnNldFggOiA1MCxcbiAgICAgICAgICogICAgICBzY2FsZVkgOiAyXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBnZXQgY2xpZW50IHJlY3Qgd2l0aG91dCB0aGluayBvZmYgdHJhbnNmb3JtYXRpb25zIChwb3NpdGlvbiwgcm90YXRpb24sIHNjYWxlLCBvZmZzZXQsIGV0YylcbiAgICAgICAgICogcmVjdC5nZXRDbGllbnRSZWN0KHsgc2tpcFRyYW5zZm9ybTogdHJ1ZX0pO1xuICAgICAgICAgKiAvLyByZXR1cm5zIHtcbiAgICAgICAgICogLy8gICAgIHggOiAtMiwgICAvLyB0d28gcGl4ZWxzIGZvciBzdHJva2UgLyAyXG4gICAgICAgICAqIC8vICAgICB5IDogLTIsXG4gICAgICAgICAqIC8vICAgICB3aWR0aCA6IDEwNCwgLy8gaW5jcmVhc2VkIGJ5IDQgZm9yIHN0cm9rZVxuICAgICAgICAgKiAvLyAgICAgaGVpZ2h0IDogMTA0XG4gICAgICAgICAqIC8vfVxuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBnZXQgY2xpZW50IHJlY3Qgd2l0aCB0cmFuc2Zvcm1hdGlvbiBhcHBsaWVkXG4gICAgICAgICAqIHJlY3QuZ2V0Q2xpZW50UmVjdCgpO1xuICAgICAgICAgKiAvLyByZXR1cm5zIE9iamVjdCB7eDogLTIsIHk6IDQ2LCB3aWR0aDogMTA0LCBoZWlnaHQ6IDIwOH1cbiAgICAgICAgICovXG4gICAgZ2V0Q2xpZW50UmVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBhYnN0cmFjdCBtZXRob2RcbiAgICAgIC8vIHJlZGVmaW5lIGluIENvbnRhaW5lciBhbmQgU2hhcGVcbiAgICAgIHRocm93IG5ldyBFcnJvcignYWJzdHJhY3QgXCJnZXRDbGllbnRSZWN0XCIgbWV0aG9kIGNhbGwnKTtcbiAgICB9LFxuICAgIF90cmFuc2Zvcm1lZFJlY3Q6IGZ1bmN0aW9uKHJlY3QsIHRvcCkge1xuICAgICAgdmFyIHBvaW50cyA9IFtcbiAgICAgICAgeyB4OiByZWN0LngsIHk6IHJlY3QueSB9LFxuICAgICAgICB7IHg6IHJlY3QueCArIHJlY3Qud2lkdGgsIHk6IHJlY3QueSB9LFxuICAgICAgICB7IHg6IHJlY3QueCArIHJlY3Qud2lkdGgsIHk6IHJlY3QueSArIHJlY3QuaGVpZ2h0IH0sXG4gICAgICAgIHsgeDogcmVjdC54LCB5OiByZWN0LnkgKyByZWN0LmhlaWdodCB9XG4gICAgICBdO1xuICAgICAgdmFyIG1pblgsIG1pblksIG1heFgsIG1heFk7XG4gICAgICB2YXIgdHJhbnMgPSB0aGlzLmdldEFic29sdXRlVHJhbnNmb3JtKHRvcCk7XG4gICAgICBwb2ludHMuZm9yRWFjaChmdW5jdGlvbihwb2ludCkge1xuICAgICAgICB2YXIgdHJhbnNmb3JtZWQgPSB0cmFucy5wb2ludChwb2ludCk7XG4gICAgICAgIGlmIChtaW5YID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBtaW5YID0gbWF4WCA9IHRyYW5zZm9ybWVkLng7XG4gICAgICAgICAgbWluWSA9IG1heFkgPSB0cmFuc2Zvcm1lZC55O1xuICAgICAgICB9XG4gICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB0cmFuc2Zvcm1lZC54KTtcbiAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIHRyYW5zZm9ybWVkLnkpO1xuICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgdHJhbnNmb3JtZWQueCk7XG4gICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCB0cmFuc2Zvcm1lZC55KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogbWluWCxcbiAgICAgICAgeTogbWluWSxcbiAgICAgICAgd2lkdGg6IG1heFggLSBtaW5YLFxuICAgICAgICBoZWlnaHQ6IG1heFkgLSBtaW5ZXG4gICAgICB9O1xuICAgIH0sXG4gICAgX2RyYXdDYWNoZWRTY2VuZUNhbnZhczogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICBjb250ZXh0Ll9hcHBseU9wYWNpdHkodGhpcyk7XG4gICAgICBjb250ZXh0Ll9hcHBseUdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbih0aGlzKTtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKHRoaXMuX2NhY2hlLmNhbnZhcy54LCB0aGlzLl9jYWNoZS5jYW52YXMueSk7XG5cbiAgICAgIHZhciBjYWNoZUNhbnZhcyA9IHRoaXMuX2dldENhY2hlZFNjZW5lQ2FudmFzKCk7XG4gICAgICB2YXIgcmF0aW8gPSBjYWNoZUNhbnZhcy5waXhlbFJhdGlvO1xuXG4gICAgICBjb250ZXh0LmRyYXdJbWFnZShcbiAgICAgICAgY2FjaGVDYW52YXMuX2NhbnZhcyxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgY2FjaGVDYW52YXMud2lkdGggLyByYXRpbyxcbiAgICAgICAgY2FjaGVDYW52YXMuaGVpZ2h0IC8gcmF0aW9cbiAgICAgICk7XG4gICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9LFxuICAgIF9kcmF3Q2FjaGVkSGl0Q2FudmFzOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICB2YXIgY2FjaGVkQ2FudmFzID0gdGhpcy5fY2FjaGUuY2FudmFzLFxuICAgICAgICBoaXRDYW52YXMgPSBjYWNoZWRDYW52YXMuaGl0O1xuICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZSh0aGlzLl9jYWNoZS5jYW52YXMueCwgdGhpcy5fY2FjaGUuY2FudmFzLnkpO1xuICAgICAgY29udGV4dC5kcmF3SW1hZ2UoaGl0Q2FudmFzLl9jYW52YXMsIDAsIDApO1xuICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfSxcbiAgICBfZ2V0Q2FjaGVkU2NlbmVDYW52YXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGZpbHRlcnMgPSB0aGlzLmZpbHRlcnMoKSxcbiAgICAgICAgY2FjaGVkQ2FudmFzID0gdGhpcy5fY2FjaGUuY2FudmFzLFxuICAgICAgICBzY2VuZUNhbnZhcyA9IGNhY2hlZENhbnZhcy5zY2VuZSxcbiAgICAgICAgZmlsdGVyQ2FudmFzID0gY2FjaGVkQ2FudmFzLmZpbHRlcixcbiAgICAgICAgZmlsdGVyQ29udGV4dCA9IGZpbHRlckNhbnZhcy5nZXRDb250ZXh0KCksXG4gICAgICAgIGxlbixcbiAgICAgICAgaW1hZ2VEYXRhLFxuICAgICAgICBuLFxuICAgICAgICBmaWx0ZXI7XG5cbiAgICAgIGlmIChmaWx0ZXJzKSB7XG4gICAgICAgIGlmICghdGhpcy5fZmlsdGVyVXBUb0RhdGUpIHtcbiAgICAgICAgICB2YXIgcmF0aW8gPSBzY2VuZUNhbnZhcy5waXhlbFJhdGlvO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxlbiA9IGZpbHRlcnMubGVuZ3RoO1xuICAgICAgICAgICAgZmlsdGVyQ29udGV4dC5jbGVhcigpO1xuXG4gICAgICAgICAgICAvLyBjb3B5IGNhY2hlZCBjYW52YXMgb250byBmaWx0ZXIgY29udGV4dFxuICAgICAgICAgICAgZmlsdGVyQ29udGV4dC5kcmF3SW1hZ2UoXG4gICAgICAgICAgICAgIHNjZW5lQ2FudmFzLl9jYW52YXMsXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIHNjZW5lQ2FudmFzLmdldFdpZHRoKCkgLyByYXRpbyxcbiAgICAgICAgICAgICAgc2NlbmVDYW52YXMuZ2V0SGVpZ2h0KCkgLyByYXRpb1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGltYWdlRGF0YSA9IGZpbHRlckNvbnRleHQuZ2V0SW1hZ2VEYXRhKFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICBmaWx0ZXJDYW52YXMuZ2V0V2lkdGgoKSxcbiAgICAgICAgICAgICAgZmlsdGVyQ2FudmFzLmdldEhlaWdodCgpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBhcHBseSBmaWx0ZXJzIHRvIGZpbHRlciBjb250ZXh0XG4gICAgICAgICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICAgICAgZmlsdGVyID0gZmlsdGVyc1tuXTtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWx0ZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBLb252YS5VdGlsLmVycm9yKFxuICAgICAgICAgICAgICAgICAgJ0ZpbHRlciBzaG91bGQgYmUgdHlwZSBvZiBmdW5jdGlvbiwgYnV0IGdvdCAnICtcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGZpbHRlciArXG4gICAgICAgICAgICAgICAgICAgICcgaW5zdGVkLiBQbGVhc2UgY2hlY2sgY29ycmVjdCBmaWx0ZXJzJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZmlsdGVyLmNhbGwodGhpcywgaW1hZ2VEYXRhKTtcbiAgICAgICAgICAgICAgZmlsdGVyQ29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBLb252YS5VdGlsLmVycm9yKCdVbmFibGUgdG8gYXBwbHkgZmlsdGVyLiAnICsgZS5tZXNzYWdlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9maWx0ZXJVcFRvRGF0ZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmlsdGVyQ2FudmFzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjZW5lQ2FudmFzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIGJpbmQgZXZlbnRzIHRvIHRoZSBub2RlLiBLb252YUpTIHN1cHBvcnRzIG1vdXNlb3ZlciwgbW91c2Vtb3ZlLFxuICAgICAgICAgKiAgbW91c2VvdXQsIG1vdXNlZW50ZXIsIG1vdXNlbGVhdmUsIG1vdXNlZG93biwgbW91c2V1cCwgd2hlZWwsIGNsaWNrLCBkYmxjbGljaywgdG91Y2hzdGFydCwgdG91Y2htb3ZlLFxuICAgICAgICAgKiAgdG91Y2hlbmQsIHRhcCwgZGJsdGFwLCBkcmFnc3RhcnQsIGRyYWdtb3ZlLCBhbmQgZHJhZ2VuZCBldmVudHMuIFRoZSBLb252YSBTdGFnZSBzdXBwb3J0c1xuICAgICAgICAgKiAgY29udGVudE1vdXNlb3ZlciwgY29udGVudE1vdXNlbW92ZSwgY29udGVudE1vdXNlb3V0LCBjb250ZW50TW91c2Vkb3duLCBjb250ZW50TW91c2V1cCwgY29udGVudFdoZWVsLCBjb250ZW50Q29udGV4dG1lbnVcbiAgICAgICAgICogIGNvbnRlbnRDbGljaywgY29udGVudERibGNsaWNrLCBjb250ZW50VG91Y2hzdGFydCwgY29udGVudFRvdWNobW92ZSwgY29udGVudFRvdWNoZW5kLCBjb250ZW50VGFwLFxuICAgICAgICAgKiAgYW5kIGNvbnRlbnREYmxUYXAuICBQYXNzIGluIGEgc3RyaW5nIG9mIGV2ZW50cyBkZWxpbW1pdGVkIGJ5IGEgc3BhY2UgdG8gYmluZCBtdWx0aXBsZSBldmVudHMgYXQgb25jZVxuICAgICAgICAgKiAgc3VjaCBhcyAnbW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlJy4gSW5jbHVkZSBhIG5hbWVzcGFjZSB0byBiaW5kIGFuXG4gICAgICAgICAqICBldmVudCBieSBuYW1lIHN1Y2ggYXMgJ2NsaWNrLmZvb2JhcicuXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldnRTdHIgZS5nLiAnY2xpY2snLCAnbW91c2Vkb3duIHRvdWNoc3RhcnQnLCAnbW91c2Vkb3duLmZvbyB0b3VjaHN0YXJ0LmZvbydcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgaGFuZGxlciBmdW5jdGlvbiBpcyBwYXNzZWQgYW4gZXZlbnQgb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAvLyBhZGQgY2xpY2sgbGlzdGVuZXJcbiAgICAgICAgICogbm9kZS5vbignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICogICBjb25zb2xlLmxvZygneW91IGNsaWNrZWQgbWUhJyk7XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBnZXQgdGhlIHRhcmdldCBub2RlXG4gICAgICAgICAqIG5vZGUub24oJ2NsaWNrJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAqICAgY29uc29sZS5sb2coZXZ0LnRhcmdldCk7XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBzdG9wIGV2ZW50IHByb3BhZ2F0aW9uXG4gICAgICAgICAqIG5vZGUub24oJ2NsaWNrJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAqICAgZXZ0LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBiaW5kIG11bHRpcGxlIGxpc3RlbmVyc1xuICAgICAgICAgKiBub2RlLm9uKCdjbGljayB0b3VjaHN0YXJ0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAqICAgY29uc29sZS5sb2coJ3lvdSBjbGlja2VkL3RvdWNoZWQgbWUhJyk7XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBuYW1lc3BhY2UgbGlzdGVuZXJcbiAgICAgICAgICogbm9kZS5vbignY2xpY2suZm9vJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAqICAgY29uc29sZS5sb2coJ3lvdSBjbGlja2VkL3RvdWNoZWQgbWUhJyk7XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBnZXQgdGhlIGV2ZW50IHR5cGVcbiAgICAgICAgICogbm9kZS5vbignY2xpY2sgdGFwJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAqICAgdmFyIGV2ZW50VHlwZSA9IGV2dC50eXBlO1xuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gZ2V0IG5hdGl2ZSBldmVudCBvYmplY3RcbiAgICAgICAgICogbm9kZS5vbignY2xpY2sgdGFwJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAqICAgdmFyIG5hdGl2ZUV2ZW50ID0gZXZ0LmV2dDtcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIGZvciBjaGFuZ2UgZXZlbnRzLCBnZXQgdGhlIG9sZCBhbmQgbmV3IHZhbFxuICAgICAgICAgKiBub2RlLm9uKCd4Q2hhbmdlJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAqICAgdmFyIG9sZFZhbCA9IGV2dC5vbGRWYWw7XG4gICAgICAgICAqICAgdmFyIG5ld1ZhbCA9IGV2dC5uZXdWYWw7XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBnZXQgZXZlbnQgdGFyZ2V0c1xuICAgICAgICAgKiAvLyB3aXRoIGV2ZW50IGRlbGVnYXRpb25zXG4gICAgICAgICAqIGxheWVyLm9uKCdjbGljaycsICdHcm91cCcsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgKiAgIHZhciBzaGFwZSA9IGV2dC50YXJnZXQ7XG4gICAgICAgICAqICAgdmFyIGdyb3VwID0gZXZ0bi5jdXJyZW50VGFyZ2VyO1xuICAgICAgICAgKiB9KTtcbiAgICAgICAgICovXG4gICAgb246IGZ1bmN0aW9uKGV2dFN0ciwgaGFuZGxlcikge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICB2YXIgZXZlbnRzID0gZXZ0U3RyLnNwbGl0KFNQQUNFKSxcbiAgICAgICAgbGVuID0gZXZlbnRzLmxlbmd0aCxcbiAgICAgICAgbixcbiAgICAgICAgZXZlbnQsXG4gICAgICAgIHBhcnRzLFxuICAgICAgICBiYXNlRXZlbnQsXG4gICAgICAgIG5hbWU7XG5cbiAgICAgIC8qXG4gICAgICAgICAgICAgKiBsb29wIHRocm91Z2ggdHlwZXMgYW5kIGF0dGFjaCBldmVudCBsaXN0ZW5lcnMgdG9cbiAgICAgICAgICAgICAqIGVhY2ggb25lLiAgZWcuICdjbGljayBtb3VzZW92ZXIubmFtZXNwYWNlIG1vdXNlb3V0J1xuICAgICAgICAgICAgICogd2lsbCBjcmVhdGUgdGhyZWUgZXZlbnQgYmluZGluZ3NcbiAgICAgICAgICAgICAqL1xuICAgICAgZm9yIChuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgIGV2ZW50ID0gZXZlbnRzW25dO1xuICAgICAgICBwYXJ0cyA9IGV2ZW50LnNwbGl0KERPVCk7XG4gICAgICAgIGJhc2VFdmVudCA9IHBhcnRzWzBdO1xuICAgICAgICBuYW1lID0gcGFydHNbMV0gfHwgRU1QVFlfU1RSSU5HO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBldmVudHMgYXJyYXkgaWYgaXQgZG9lc24ndCBleGlzdFxuICAgICAgICBpZiAoIXRoaXMuZXZlbnRMaXN0ZW5lcnNbYmFzZUV2ZW50XSkge1xuICAgICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnNbYmFzZUV2ZW50XSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ldmVudExpc3RlbmVyc1tiYXNlRXZlbnRdLnB1c2goe1xuICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgaGFuZGxlcjogaGFuZGxlclxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogcmVtb3ZlIGV2ZW50IGJpbmRpbmdzIGZyb20gdGhlIG5vZGUuIFBhc3MgaW4gYSBzdHJpbmcgb2ZcbiAgICAgICAgICogIGV2ZW50IHR5cGVzIGRlbGltbWl0ZWQgYnkgYSBzcGFjZSB0byByZW1vdmUgbXVsdGlwbGUgZXZlbnRcbiAgICAgICAgICogIGJpbmRpbmdzIGF0IG9uY2Ugc3VjaCBhcyAnbW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlJy5cbiAgICAgICAgICogIGluY2x1ZGUgYSBuYW1lc3BhY2UgdG8gcmVtb3ZlIGFuIGV2ZW50IGJpbmRpbmcgYnkgbmFtZVxuICAgICAgICAgKiAgc3VjaCBhcyAnY2xpY2suZm9vYmFyJy4gSWYgeW91IG9ubHkgZ2l2ZSBhIG5hbWUgbGlrZSAnLmZvb2JhcicsXG4gICAgICAgICAqICBhbGwgZXZlbnRzIGluIHRoYXQgbmFtZXNwYWNlIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV2dFN0ciBlLmcuICdjbGljaycsICdtb3VzZWRvd24gdG91Y2hzdGFydCcsICcuZm9vYmFyJ1xuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogLy8gcmVtb3ZlIGxpc3RlbmVyXG4gICAgICAgICAqIG5vZGUub2ZmKCdjbGljaycpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyByZW1vdmUgbXVsdGlwbGUgbGlzdGVuZXJzXG4gICAgICAgICAqIG5vZGUub2ZmKCdjbGljayB0b3VjaHN0YXJ0Jyk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIHJlbW92ZSBsaXN0ZW5lciBieSBuYW1lXG4gICAgICAgICAqIG5vZGUub2ZmKCdjbGljay5mb28nKTtcbiAgICAgICAgICovXG4gICAgb2ZmOiBmdW5jdGlvbihldnRTdHIpIHtcbiAgICAgIHZhciBldmVudHMgPSAoZXZ0U3RyIHx8ICcnKS5zcGxpdChTUEFDRSksXG4gICAgICAgIGxlbiA9IGV2ZW50cy5sZW5ndGgsXG4gICAgICAgIG4sXG4gICAgICAgIHQsXG4gICAgICAgIGV2ZW50LFxuICAgICAgICBwYXJ0cyxcbiAgICAgICAgYmFzZUV2ZW50LFxuICAgICAgICBuYW1lO1xuXG4gICAgICBpZiAoIWV2dFN0cikge1xuICAgICAgICAvLyByZW1vdmUgYWxsIGV2ZW50c1xuICAgICAgICBmb3IgKHQgaW4gdGhpcy5ldmVudExpc3RlbmVycykge1xuICAgICAgICAgIHRoaXMuX29mZih0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgIGV2ZW50ID0gZXZlbnRzW25dO1xuICAgICAgICBwYXJ0cyA9IGV2ZW50LnNwbGl0KERPVCk7XG4gICAgICAgIGJhc2VFdmVudCA9IHBhcnRzWzBdO1xuICAgICAgICBuYW1lID0gcGFydHNbMV07XG5cbiAgICAgICAgaWYgKGJhc2VFdmVudCkge1xuICAgICAgICAgIGlmICh0aGlzLmV2ZW50TGlzdGVuZXJzW2Jhc2VFdmVudF0pIHtcbiAgICAgICAgICAgIHRoaXMuX29mZihiYXNlRXZlbnQsIG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKHQgaW4gdGhpcy5ldmVudExpc3RlbmVycykge1xuICAgICAgICAgICAgdGhpcy5fb2ZmKHQsIG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBzb21lIGV2ZW50IGFsaWFzZXMgZm9yIHRoaXJkIHBhcnR5IGludGVncmF0aW9uIGxpa2UgSGFtbWVySlNcbiAgICBkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciBlID0ge1xuICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICAgIHR5cGU6IGV2dC50eXBlLFxuICAgICAgICBldnQ6IGV2dFxuICAgICAgfTtcbiAgICAgIHRoaXMuZmlyZShldnQudHlwZSwgZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgIC8vIHdlIGhhdmUgdG8gcGFzcyBuYXRpdmUgZXZlbnQgdG8gaGFuZGxlclxuICAgICAgdGhpcy5vbih0eXBlLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGV2dC5ldnQpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHRoaXMub2ZmKHR5cGUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBsaWtlIG5vZGUub25cbiAgICBfZGVsZWdhdGU6IGZ1bmN0aW9uKGV2ZW50LCBzZWxlY3RvciwgaGFuZGxlcikge1xuICAgICAgdmFyIHN0b3BOb2RlID0gdGhpcztcbiAgICAgIHRoaXMub24oZXZlbnQsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICB2YXIgdGFyZ2V0cyA9IGV2dC50YXJnZXQuZmluZEFuY2VzdG9ycyhzZWxlY3RvciwgdHJ1ZSwgc3RvcE5vZGUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBldnQgPSBLb252YS5VdGlsLmNsb25lT2JqZWN0KGV2dCk7XG4gICAgICAgICAgZXZ0LmN1cnJlbnRUYXJnZXQgPSB0YXJnZXRzW2ldO1xuICAgICAgICAgIGhhbmRsZXIuY2FsbCh0YXJnZXRzW2ldLCBldnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiByZW1vdmUgc2VsZiBmcm9tIHBhcmVudCwgYnV0IGRvbid0IGRlc3Ryb3lcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIG5vZGUucmVtb3ZlKCk7XG4gICAgICAgICAqL1xuICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKTtcblxuICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQuY2hpbGRyZW4pIHtcbiAgICAgICAgcGFyZW50LmNoaWxkcmVuLnNwbGljZSh0aGlzLmluZGV4LCAxKTtcbiAgICAgICAgcGFyZW50Ll9zZXRDaGlsZHJlbkluZGljZXMoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMucGFyZW50O1xuICAgICAgfVxuXG4gICAgICAvLyBldmVyeSBjYWNoZWQgYXR0ciB0aGF0IGlzIGNhbGN1bGF0ZWQgdmlhIG5vZGUgdHJlZVxuICAgICAgLy8gdHJhdmVyc2FsIG11c3QgYmUgY2xlYXJlZCB3aGVuIHJlbW92aW5nIGEgbm9kZVxuICAgICAgdGhpcy5fY2xlYXJTZWxmQW5kRGVzY2VuZGFudENhY2hlKFNUQUdFKTtcbiAgICAgIHRoaXMuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZShBQlNPTFVURV9UUkFOU0ZPUk0pO1xuICAgICAgdGhpcy5fY2xlYXJTZWxmQW5kRGVzY2VuZGFudENhY2hlKFZJU0lCTEUpO1xuICAgICAgdGhpcy5fY2xlYXJTZWxmQW5kRGVzY2VuZGFudENhY2hlKExJU1RFTklORyk7XG4gICAgICB0aGlzLl9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoQUJTT0xVVEVfT1BBQ0lUWSk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIHJlbW92ZSBhbmQgZGVzdHJveSBzZWxmXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIG5vZGUuZGVzdHJveSgpO1xuICAgICAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIHJlbW92ZSBmcm9tIGlkcyBhbmQgbmFtZXMgaGFzaGVzXG4gICAgICBLb252YS5fcmVtb3ZlSWQodGhpcy5nZXRJZCgpKTtcblxuICAgICAgLy8gcmVtb3ZlIGFsbCBuYW1lc1xuICAgICAgdmFyIG5hbWVzID0gKHRoaXMuZ2V0TmFtZSgpIHx8ICcnKS5zcGxpdCgvXFxzL2cpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3VibmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICBLb252YS5fcmVtb3ZlTmFtZShzdWJuYW1lLCB0aGlzLl9pZCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiBnZXQgYXR0clxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0clxuICAgICAgICAgKiBAcmV0dXJucyB7SW50ZWdlcnxTdHJpbmd8T2JqZWN0fEFycmF5fVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiB2YXIgeCA9IG5vZGUuZ2V0QXR0cigneCcpO1xuICAgICAgICAgKi9cbiAgICBnZXRBdHRyOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICB2YXIgbWV0aG9kID0gR0VUICsgS29udmEuVXRpbC5fY2FwaXRhbGl6ZShhdHRyKTtcbiAgICAgIGlmIChLb252YS5VdGlsLl9pc0Z1bmN0aW9uKHRoaXNbbWV0aG9kXSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbbWV0aG9kXSgpO1xuICAgICAgfVxuICAgICAgLy8gb3RoZXJ3aXNlIGdldCBkaXJlY3RseVxuICAgICAgcmV0dXJuIHRoaXMuYXR0cnNbYXR0cl07XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgKiBnZXQgYW5jZXN0b3JzXG4gICAgICAgICogQG1ldGhvZFxuICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Db2xsZWN0aW9ufVxuICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICogc2hhcGUuZ2V0QW5jZXN0b3JzKCkuZWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICogICBjb25zb2xlLmxvZyhub2RlLmdldElkKCkpO1xuICAgICAgICAqIH0pXG4gICAgICAgICovXG4gICAgZ2V0QW5jZXN0b3JzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpLFxuICAgICAgICBhbmNlc3RvcnMgPSBuZXcgS29udmEuQ29sbGVjdGlvbigpO1xuXG4gICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgIGFuY2VzdG9ycy5wdXNoKHBhcmVudCk7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFuY2VzdG9ycztcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiBnZXQgYXR0cnMgb2JqZWN0IGxpdGVyYWxcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgICAgICovXG4gICAgZ2V0QXR0cnM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cnMgfHwge307XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogc2V0IG11bHRpcGxlIGF0dHJzIGF0IG9uY2UgdXNpbmcgYW4gb2JqZWN0IGxpdGVyYWxcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBvYmplY3QgY29udGFpbmluZyBrZXkgdmFsdWUgcGFpcnNcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIG5vZGUuc2V0QXR0cnMoe1xuICAgICAgICAgKiAgIHg6IDUsXG4gICAgICAgICAqICAgZmlsbDogJ3JlZCdcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqL1xuICAgIHNldEF0dHJzOiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIHZhciBrZXksIG1ldGhvZDtcblxuICAgICAgaWYgKCFjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBmb3IgKGtleSBpbiBjb25maWcpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gQ0hJTERSRU4pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBtZXRob2QgPSBTRVQgKyBLb252YS5VdGlsLl9jYXBpdGFsaXplKGtleSk7XG4gICAgICAgIC8vIHVzZSBzZXR0ZXIgaWYgYXZhaWxhYmxlXG4gICAgICAgIGlmIChLb252YS5VdGlsLl9pc0Z1bmN0aW9uKHRoaXNbbWV0aG9kXSkpIHtcbiAgICAgICAgICB0aGlzW21ldGhvZF0oY29uZmlnW2tleV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG90aGVyd2lzZSBzZXQgZGlyZWN0bHlcbiAgICAgICAgICB0aGlzLl9zZXRBdHRyKGtleSwgY29uZmlnW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiBkZXRlcm1pbmUgaWYgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50cyBieSB0YWtpbmcgaW50byBhY2NvdW50IGFuY2VzdG9ycy5cbiAgICAgICAgICpcbiAgICAgICAgICogUGFyZW50ICAgIHwgU2VsZiAgICAgIHwgaXNMaXN0ZW5pbmdcbiAgICAgICAgICogbGlzdGVuaW5nIHwgbGlzdGVuaW5nIHxcbiAgICAgICAgICogLS0tLS0tLS0tLSstLS0tLS0tLS0tLSstLS0tLS0tLS0tLS1cbiAgICAgICAgICogVCAgICAgICAgIHwgVCAgICAgICAgIHwgVFxuICAgICAgICAgKiBUICAgICAgICAgfCBGICAgICAgICAgfCBGXG4gICAgICAgICAqIEYgICAgICAgICB8IFQgICAgICAgICB8IFRcbiAgICAgICAgICogRiAgICAgICAgIHwgRiAgICAgICAgIHwgRlxuICAgICAgICAgKiAtLS0tLS0tLS0tKy0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLVxuICAgICAgICAgKiBUICAgICAgICAgfCBJICAgICAgICAgfCBUXG4gICAgICAgICAqIEYgICAgICAgICB8IEkgICAgICAgICB8IEZcbiAgICAgICAgICogSSAgICAgICAgIHwgSSAgICAgICAgIHwgVFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgaXNMaXN0ZW5pbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldENhY2hlKExJU1RFTklORywgdGhpcy5faXNMaXN0ZW5pbmcpO1xuICAgIH0sXG4gICAgX2lzTGlzdGVuaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsaXN0ZW5pbmcgPSB0aGlzLmdldExpc3RlbmluZygpLFxuICAgICAgICBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xuXG4gICAgICAvLyB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIGEgc2ltcGxpZmljYXRpb24gb2YgdGhlIHRydXRoIHRhYmxlIGFib3ZlLlxuICAgICAgLy8gcGxlYXNlIG1vZGlmeSBjYXJlZnVsbHlcbiAgICAgIGlmIChsaXN0ZW5pbmcgPT09ICdpbmhlcml0Jykge1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHBhcmVudC5pc0xpc3RlbmluZygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbGlzdGVuaW5nO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIGRldGVybWluZSBpZiBub2RlIGlzIHZpc2libGUgYnkgdGFraW5nIGludG8gYWNjb3VudCBhbmNlc3RvcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFBhcmVudCAgICB8IFNlbGYgICAgICB8IGlzVmlzaWJsZVxuICAgICAgICAgKiB2aXNpYmxlICAgfCB2aXNpYmxlICAgfFxuICAgICAgICAgKiAtLS0tLS0tLS0tKy0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLVxuICAgICAgICAgKiBUICAgICAgICAgfCBUICAgICAgICAgfCBUXG4gICAgICAgICAqIFQgICAgICAgICB8IEYgICAgICAgICB8IEZcbiAgICAgICAgICogRiAgICAgICAgIHwgVCAgICAgICAgIHwgVFxuICAgICAgICAgKiBGICAgICAgICAgfCBGICAgICAgICAgfCBGXG4gICAgICAgICAqIC0tLS0tLS0tLS0rLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tXG4gICAgICAgICAqIFQgICAgICAgICB8IEkgICAgICAgICB8IFRcbiAgICAgICAgICogRiAgICAgICAgIHwgSSAgICAgICAgIHwgRlxuICAgICAgICAgKiBJICAgICAgICAgfCBJICAgICAgICAgfCBUXG5cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgIGlzVmlzaWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGUoVklTSUJMRSwgdGhpcy5faXNWaXNpYmxlKTtcbiAgICB9LFxuICAgIF9pc1Zpc2libGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHZpc2libGUgPSB0aGlzLmdldFZpc2libGUoKSxcbiAgICAgICAgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKTtcblxuICAgICAgLy8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBhIHNpbXBsaWZpY2F0aW9uIG9mIHRoZSB0cnV0aCB0YWJsZSBhYm92ZS5cbiAgICAgIC8vIHBsZWFzZSBtb2RpZnkgY2FyZWZ1bGx5XG4gICAgICBpZiAodmlzaWJsZSA9PT0gJ2luaGVyaXQnKSB7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICByZXR1cm4gcGFyZW50LmlzVmlzaWJsZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmlzaWJsZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiBkZXRlcm1pbmUgaWYgbGlzdGVuaW5nIGlzIGVuYWJsZWQgYnkgdGFraW5nIGludG8gYWNjb3VudCBkZXNjZW5kYW50cy4gIElmIHNlbGYgb3IgYW55IGNoaWxkcmVuXG4gICAgICAgICAqIGhhdmUgX2lzTGlzdGVuaW5nRW5hYmxlZCBzZXQgdG8gdHJ1ZSwgdGhlbiBzZWxmIGFsc28gaGFzIGxpc3RlbmluZyBlbmFibGVkLlxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgc2hvdWxkRHJhd0hpdDogZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKCk7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAoY2FudmFzICYmIGNhbnZhcy5pc0NhY2hlKSB8fFxuICAgICAgICAobGF5ZXIgJiZcbiAgICAgICAgICBsYXllci5oaXRHcmFwaEVuYWJsZWQoKSAmJlxuICAgICAgICAgIHRoaXMuaXNMaXN0ZW5pbmcoKSAmJlxuICAgICAgICAgIHRoaXMuaXNWaXNpYmxlKCkpXG4gICAgICApO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIHNob3cgbm9kZVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cbiAgICAgICAgICovXG4gICAgc2hvdzogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnNldFZpc2libGUodHJ1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiBoaWRlIG5vZGUuICBIaWRkZW4gbm9kZXMgYXJlIG5vIGxvbmdlciBkZXRlY3RhYmxlXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAgICAgKi9cbiAgICBoaWRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2V0VmlzaWJsZShmYWxzZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiBnZXQgekluZGV4IHJlbGF0aXZlIHRvIHRoZSBub2RlJ3Mgc2libGluZ3Mgd2hvIHNoYXJlIHRoZSBzYW1lIHBhcmVudFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7SW50ZWdlcn1cbiAgICAgICAgICovXG4gICAgZ2V0WkluZGV4OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmluZGV4IHx8IDA7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogZ2V0IGFic29sdXRlIHotaW5kZXggd2hpY2ggdGFrZXMgaW50byBhY2NvdW50IHNpYmxpbmdcbiAgICAgICAgICogIGFuZCBhbmNlc3RvciBpbmRpY2VzXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfVxuICAgICAgICAgKi9cbiAgICBnZXRBYnNvbHV0ZVpJbmRleDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGVwdGggPSB0aGlzLmdldERlcHRoKCksXG4gICAgICAgIHRoYXQgPSB0aGlzLFxuICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgIG5vZGVzLFxuICAgICAgICBsZW4sXG4gICAgICAgIG4sXG4gICAgICAgIGNoaWxkO1xuXG4gICAgICBmdW5jdGlvbiBhZGRDaGlsZHJlbihjaGlsZHJlbikge1xuICAgICAgICBub2RlcyA9IFtdO1xuICAgICAgICBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgIGNoaWxkID0gY2hpbGRyZW5bbl07XG4gICAgICAgICAgaW5kZXgrKztcblxuICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSAhPT0gU0hBUEUpIHtcbiAgICAgICAgICAgIG5vZGVzID0gbm9kZXMuY29uY2F0KGNoaWxkLmdldENoaWxkcmVuKCkudG9BcnJheSgpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY2hpbGQuX2lkID09PSB0aGF0Ll9pZCkge1xuICAgICAgICAgICAgbiA9IGxlbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9kZXMubGVuZ3RoID4gMCAmJiBub2Rlc1swXS5nZXREZXB0aCgpIDw9IGRlcHRoKSB7XG4gICAgICAgICAgYWRkQ2hpbGRyZW4obm9kZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhhdC5ub2RlVHlwZSAhPT0gVVBQRVJfU1RBR0UpIHtcbiAgICAgICAgYWRkQ2hpbGRyZW4odGhhdC5nZXRTdGFnZSgpLmdldENoaWxkcmVuKCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogZ2V0IG5vZGUgZGVwdGggaW4gbm9kZSB0cmVlLiAgUmV0dXJucyBhbiBpbnRlZ2VyLlxuICAgICAgICAgKiAgZS5nLiBTdGFnZSBkZXB0aCB3aWxsIGFsd2F5cyBiZSAwLiAgTGF5ZXJzIHdpbGwgYWx3YXlzIGJlIDEuICBHcm91cHMgYW5kIFNoYXBlcyB3aWxsIGFsd2F5c1xuICAgICAgICAgKiAgYmUgPj0gMlxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7SW50ZWdlcn1cbiAgICAgICAgICovXG4gICAgZ2V0RGVwdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRlcHRoID0gMCxcbiAgICAgICAgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG5cbiAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXB0aDtcbiAgICB9LFxuICAgIHNldFBvc2l0aW9uOiBmdW5jdGlvbihwb3MpIHtcbiAgICAgIHRoaXMuc2V0WChwb3MueCk7XG4gICAgICB0aGlzLnNldFkocG9zLnkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBnZXRQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB0aGlzLmdldFgoKSxcbiAgICAgICAgeTogdGhpcy5nZXRZKClcbiAgICAgIH07XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogZ2V0IGFic29sdXRlIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHN0YWdlIGNvbnRhaW5lciBkaXZcbiAgICAgICAgICogb3IgcmVsYXRpdmUgdG8gcGFzc2VkIG5vZGVcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW3RvcF0gb3B0aW9uYWwgcGFyZW50IG5vZGVcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgIGdldEFic29sdXRlUG9zaXRpb246IGZ1bmN0aW9uKHRvcCkge1xuICAgICAgdmFyIGFic29sdXRlTWF0cml4ID0gdGhpcy5nZXRBYnNvbHV0ZVRyYW5zZm9ybSh0b3ApLmdldE1hdHJpeCgpLFxuICAgICAgICBhYnNvbHV0ZVRyYW5zZm9ybSA9IG5ldyBLb252YS5UcmFuc2Zvcm0oKSxcbiAgICAgICAgb2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcblxuICAgICAgLy8gY2xvbmUgdGhlIG1hdHJpeCBhcnJheVxuICAgICAgYWJzb2x1dGVUcmFuc2Zvcm0ubSA9IGFic29sdXRlTWF0cml4LnNsaWNlKCk7XG4gICAgICBhYnNvbHV0ZVRyYW5zZm9ybS50cmFuc2xhdGUob2Zmc2V0LngsIG9mZnNldC55KTtcblxuICAgICAgcmV0dXJuIGFic29sdXRlVHJhbnNmb3JtLmdldFRyYW5zbGF0aW9uKCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogc2V0IGFic29sdXRlIHBvc2l0aW9uXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb3NcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvcy54XG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb3MueVxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cbiAgICAgICAgICovXG4gICAgc2V0QWJzb2x1dGVQb3NpdGlvbjogZnVuY3Rpb24ocG9zKSB7XG4gICAgICB2YXIgb3JpZ1RyYW5zID0gdGhpcy5fY2xlYXJUcmFuc2Zvcm0oKSxcbiAgICAgICAgaXQ7XG5cbiAgICAgIC8vIGRvbid0IGNsZWFyIHRyYW5zbGF0aW9uXG4gICAgICB0aGlzLmF0dHJzLnggPSBvcmlnVHJhbnMueDtcbiAgICAgIHRoaXMuYXR0cnMueSA9IG9yaWdUcmFucy55O1xuICAgICAgZGVsZXRlIG9yaWdUcmFucy54O1xuICAgICAgZGVsZXRlIG9yaWdUcmFucy55O1xuXG4gICAgICAvLyB1bnJhdmVsIHRyYW5zZm9ybVxuICAgICAgaXQgPSB0aGlzLmdldEFic29sdXRlVHJhbnNmb3JtKCk7XG5cbiAgICAgIGl0LmludmVydCgpO1xuICAgICAgaXQudHJhbnNsYXRlKHBvcy54LCBwb3MueSk7XG4gICAgICBwb3MgPSB7XG4gICAgICAgIHg6IHRoaXMuYXR0cnMueCArIGl0LmdldFRyYW5zbGF0aW9uKCkueCxcbiAgICAgICAgeTogdGhpcy5hdHRycy55ICsgaXQuZ2V0VHJhbnNsYXRpb24oKS55XG4gICAgICB9O1xuXG4gICAgICB0aGlzLnNldFBvc2l0aW9uKHsgeDogcG9zLngsIHk6IHBvcy55IH0pO1xuICAgICAgdGhpcy5fc2V0VHJhbnNmb3JtKG9yaWdUcmFucyk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgX3NldFRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnMpIHtcbiAgICAgIHZhciBrZXk7XG5cbiAgICAgIGZvciAoa2V5IGluIHRyYW5zKSB7XG4gICAgICAgIHRoaXMuYXR0cnNba2V5XSA9IHRyYW5zW2tleV07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NsZWFyQ2FjaGUoVFJBTlNGT1JNKTtcbiAgICAgIHRoaXMuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZShBQlNPTFVURV9UUkFOU0ZPUk0pO1xuICAgIH0sXG4gICAgX2NsZWFyVHJhbnNmb3JtOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0cmFucyA9IHtcbiAgICAgICAgeDogdGhpcy5nZXRYKCksXG4gICAgICAgIHk6IHRoaXMuZ2V0WSgpLFxuICAgICAgICByb3RhdGlvbjogdGhpcy5nZXRSb3RhdGlvbigpLFxuICAgICAgICBzY2FsZVg6IHRoaXMuZ2V0U2NhbGVYKCksXG4gICAgICAgIHNjYWxlWTogdGhpcy5nZXRTY2FsZVkoKSxcbiAgICAgICAgb2Zmc2V0WDogdGhpcy5nZXRPZmZzZXRYKCksXG4gICAgICAgIG9mZnNldFk6IHRoaXMuZ2V0T2Zmc2V0WSgpLFxuICAgICAgICBza2V3WDogdGhpcy5nZXRTa2V3WCgpLFxuICAgICAgICBza2V3WTogdGhpcy5nZXRTa2V3WSgpXG4gICAgICB9O1xuXG4gICAgICB0aGlzLmF0dHJzLnggPSAwO1xuICAgICAgdGhpcy5hdHRycy55ID0gMDtcbiAgICAgIHRoaXMuYXR0cnMucm90YXRpb24gPSAwO1xuICAgICAgdGhpcy5hdHRycy5zY2FsZVggPSAxO1xuICAgICAgdGhpcy5hdHRycy5zY2FsZVkgPSAxO1xuICAgICAgdGhpcy5hdHRycy5vZmZzZXRYID0gMDtcbiAgICAgIHRoaXMuYXR0cnMub2Zmc2V0WSA9IDA7XG4gICAgICB0aGlzLmF0dHJzLnNrZXdYID0gMDtcbiAgICAgIHRoaXMuYXR0cnMuc2tld1kgPSAwO1xuXG4gICAgICB0aGlzLl9jbGVhckNhY2hlKFRSQU5TRk9STSk7XG4gICAgICB0aGlzLl9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoQUJTT0xVVEVfVFJBTlNGT1JNKTtcblxuICAgICAgLy8gcmV0dXJuIG9yaWdpbmFsIHRyYW5zZm9ybVxuICAgICAgcmV0dXJuIHRyYW5zO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIG1vdmUgbm9kZSBieSBhbiBhbW91bnQgcmVsYXRpdmUgdG8gaXRzIGN1cnJlbnQgcG9zaXRpb25cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNoYW5nZVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhbmdlLnhcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYW5nZS55XG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAvLyBtb3ZlIG5vZGUgaW4geCBkaXJlY3Rpb24gYnkgMXB4IGFuZCB5IGRpcmVjdGlvbiBieSAycHhcbiAgICAgICAgICogbm9kZS5tb3ZlKHtcbiAgICAgICAgICogICB4OiAxLFxuICAgICAgICAgKiAgIHk6IDIpXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKi9cbiAgICBtb3ZlOiBmdW5jdGlvbihjaGFuZ2UpIHtcbiAgICAgIHZhciBjaGFuZ2VYID0gY2hhbmdlLngsXG4gICAgICAgIGNoYW5nZVkgPSBjaGFuZ2UueSxcbiAgICAgICAgeCA9IHRoaXMuZ2V0WCgpLFxuICAgICAgICB5ID0gdGhpcy5nZXRZKCk7XG5cbiAgICAgIGlmIChjaGFuZ2VYICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgeCArPSBjaGFuZ2VYO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hhbmdlWSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHkgKz0gY2hhbmdlWTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRQb3NpdGlvbih7IHg6IHgsIHk6IHkgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIF9lYWNoQW5jZXN0b3JSZXZlcnNlOiBmdW5jdGlvbihmdW5jLCB0b3ApIHtcbiAgICAgIHZhciBmYW1pbHkgPSBbXSxcbiAgICAgICAgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKSxcbiAgICAgICAgbGVuLFxuICAgICAgICBuO1xuXG4gICAgICAvLyBpZiB0b3Agbm9kZSBpcyBkZWZpbmVkLCBhbmQgdGhpcyBub2RlIGlzIHRvcCBub2RlLFxuICAgICAgLy8gdGhlcmUncyBubyBuZWVkIHRvIGJ1aWxkIGEgZmFtaWx5IHRyZWUuICBqdXN0IGV4ZWN1dGVcbiAgICAgIC8vIGZ1bmMgd2l0aCB0aGlzIGJlY2F1c2UgaXQgd2lsbCBiZSB0aGUgb25seSBub2RlXG4gICAgICBpZiAodG9wICYmIHRvcC5faWQgPT09IHRoaXMuX2lkKSB7XG4gICAgICAgIGZ1bmModGhpcyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBmYW1pbHkudW5zaGlmdCh0aGlzKTtcblxuICAgICAgd2hpbGUgKHBhcmVudCAmJiAoIXRvcCB8fCBwYXJlbnQuX2lkICE9PSB0b3AuX2lkKSkge1xuICAgICAgICBmYW1pbHkudW5zaGlmdChwYXJlbnQpO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgfVxuXG4gICAgICBsZW4gPSBmYW1pbHkubGVuZ3RoO1xuICAgICAgZm9yIChuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgIGZ1bmMoZmFtaWx5W25dKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiByb3RhdGUgbm9kZSBieSBhbiBhbW91bnQgaW4gZGVncmVlcyByZWxhdGl2ZSB0byBpdHMgY3VycmVudCByb3RhdGlvblxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gdGhldGFcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICAgICAqL1xuICAgIHJvdGF0ZTogZnVuY3Rpb24odGhldGEpIHtcbiAgICAgIHRoaXMuc2V0Um90YXRpb24odGhpcy5nZXRSb3RhdGlvbigpICsgdGhldGEpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogbW92ZSBub2RlIHRvIHRoZSB0b3Agb2YgaXRzIHNpYmxpbmdzXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICBtb3ZlVG9Ub3A6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgICBLb252YS5VdGlsLndhcm4oJ05vZGUgaGFzIG5vIHBhcmVudC4gbW92ZVRvVG9wIGZ1bmN0aW9uIGlzIGlnbm9yZWQuJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICB0aGlzLnBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4ucHVzaCh0aGlzKTtcbiAgICAgIHRoaXMucGFyZW50Ll9zZXRDaGlsZHJlbkluZGljZXMoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIG1vdmUgbm9kZSB1cFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gZmxhZyBpcyBtb3ZlZCBvciBub3RcbiAgICAgICAgICovXG4gICAgbW92ZVVwOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgS29udmEuVXRpbC53YXJuKCdOb2RlIGhhcyBubyBwYXJlbnQuIG1vdmVVcCBmdW5jdGlvbiBpcyBpZ25vcmVkLicpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4LFxuICAgICAgICBsZW4gPSB0aGlzLnBhcmVudC5nZXRDaGlsZHJlbigpLmxlbmd0aDtcbiAgICAgIGlmIChpbmRleCA8IGxlbiAtIDEpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4ICsgMSwgMCwgdGhpcyk7XG4gICAgICAgIHRoaXMucGFyZW50Ll9zZXRDaGlsZHJlbkluZGljZXMoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogbW92ZSBub2RlIGRvd25cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgIG1vdmVEb3duOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgS29udmEuVXRpbC53YXJuKCdOb2RlIGhhcyBubyBwYXJlbnQuIG1vdmVEb3duIGZ1bmN0aW9uIGlzIGlnbm9yZWQuJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgIHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCAtIDEsIDAsIHRoaXMpO1xuICAgICAgICB0aGlzLnBhcmVudC5fc2V0Q2hpbGRyZW5JbmRpY2VzKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIG1vdmUgbm9kZSB0byB0aGUgYm90dG9tIG9mIGl0cyBzaWJsaW5nc1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgbW92ZVRvQm90dG9tOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgS29udmEuVXRpbC53YXJuKFxuICAgICAgICAgICdOb2RlIGhhcyBubyBwYXJlbnQuIG1vdmVUb0JvdHRvbSBmdW5jdGlvbiBpcyBpZ25vcmVkLidcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4udW5zaGlmdCh0aGlzKTtcbiAgICAgICAgdGhpcy5wYXJlbnQuX3NldENoaWxkcmVuSW5kaWNlcygpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiBzZXQgekluZGV4IHJlbGF0aXZlIHRvIHNpYmxpbmdzXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gekluZGV4XG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAgICAgKi9cbiAgICBzZXRaSW5kZXg6IGZ1bmN0aW9uKHpJbmRleCkge1xuICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgICBLb252YS5VdGlsLndhcm4oJ05vZGUgaGFzIG5vIHBhcmVudC4gekluZGV4IHBhcmFtZXRlciBpcyBpZ25vcmVkLicpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZSh6SW5kZXgsIDAsIHRoaXMpO1xuICAgICAgdGhpcy5wYXJlbnQuX3NldENoaWxkcmVuSW5kaWNlcygpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogZ2V0IGFic29sdXRlIG9wYWNpdHlcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgICAgICovXG4gICAgZ2V0QWJzb2x1dGVPcGFjaXR5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRDYWNoZShBQlNPTFVURV9PUEFDSVRZLCB0aGlzLl9nZXRBYnNvbHV0ZU9wYWNpdHkpO1xuICAgIH0sXG4gICAgX2dldEFic29sdXRlT3BhY2l0eTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYWJzT3BhY2l0eSA9IHRoaXMuZ2V0T3BhY2l0eSgpO1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KCk7XG4gICAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzVW5kZXJDYWNoZSkge1xuICAgICAgICBhYnNPcGFjaXR5ICo9IHRoaXMuZ2V0UGFyZW50KCkuZ2V0QWJzb2x1dGVPcGFjaXR5KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWJzT3BhY2l0eTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiBtb3ZlIG5vZGUgdG8gYW5vdGhlciBjb250YWluZXJcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtDb250YWluZXJ9IG5ld0NvbnRhaW5lclxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogLy8gbW92ZSBub2RlIGZyb20gY3VycmVudCBsYXllciBpbnRvIGxheWVyMlxuICAgICAgICAgKiBub2RlLm1vdmVUbyhsYXllcjIpO1xuICAgICAgICAgKi9cbiAgICBtb3ZlVG86IGZ1bmN0aW9uKG5ld0NvbnRhaW5lcikge1xuICAgICAgLy8gZG8gbm90aGluZyBpZiBuZXcgY29udGFpbmVyIGlzIGFscmVhZHkgcGFyZW50XG4gICAgICBpZiAodGhpcy5nZXRQYXJlbnQoKSAhPT0gbmV3Q29udGFpbmVyKSB7XG4gICAgICAgIC8vIHRoaXMucmVtb3ZlIG15IGJlIG92ZXJyaWRlZCBieSBkcmFnIGFuZCBkcm9wXG4gICAgICAgIC8vIGJ1eSB3ZSBuZWVkIG9yaWdpbmFsXG4gICAgICAgICh0aGlzLl9fb3JpZ2luYWxSZW1vdmUgfHwgdGhpcy5yZW1vdmUpLmNhbGwodGhpcyk7XG4gICAgICAgIG5ld0NvbnRhaW5lci5hZGQodGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiBjb252ZXJ0IE5vZGUgaW50byBhbiBvYmplY3QgZm9yIHNlcmlhbGl6YXRpb24uICBSZXR1cm5zIGFuIG9iamVjdC5cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9iaiA9IHt9LFxuICAgICAgICBhdHRycyA9IHRoaXMuZ2V0QXR0cnMoKSxcbiAgICAgICAga2V5LFxuICAgICAgICB2YWwsXG4gICAgICAgIGdldHRlcixcbiAgICAgICAgZGVmYXVsdFZhbHVlO1xuXG4gICAgICBvYmouYXR0cnMgPSB7fTtcblxuICAgICAgZm9yIChrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgdmFsID0gYXR0cnNba2V5XTtcbiAgICAgICAgZ2V0dGVyID0gdGhpc1trZXldO1xuICAgICAgICAvLyByZW1vdmUgYXR0ciB2YWx1ZSBzbyB0aGF0IHdlIGNhbiBleHRyYWN0IHRoZSBkZWZhdWx0IHZhbHVlIGZyb20gdGhlIGdldHRlclxuICAgICAgICBkZWxldGUgYXR0cnNba2V5XTtcbiAgICAgICAgZGVmYXVsdFZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwodGhpcykgOiBudWxsO1xuICAgICAgICAvLyByZXN0b3JlIGF0dHIgdmFsdWVcbiAgICAgICAgYXR0cnNba2V5XSA9IHZhbDtcbiAgICAgICAgaWYgKGRlZmF1bHRWYWx1ZSAhPT0gdmFsKSB7XG4gICAgICAgICAgb2JqLmF0dHJzW2tleV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb2JqLmNsYXNzTmFtZSA9IHRoaXMuZ2V0Q2xhc3NOYW1lKCk7XG4gICAgICByZXR1cm4gS29udmEuVXRpbC5fcHJlcGFyZVRvU3RyaW5naWZ5KG9iaik7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogY29udmVydCBOb2RlIGludG8gYSBKU09OIHN0cmluZy4gIFJldHVybnMgYSBKU09OIHN0cmluZy5cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ319XG4gICAgICAgICAqL1xuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy50b09iamVjdCgpKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiBnZXQgcGFyZW50IGNvbnRhaW5lclxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cbiAgICAgICAgICovXG4gICAgZ2V0UGFyZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiBnZXQgYWxsIGFuY2VzdHJvcyAocGFyZW50IHRoZW4gcGFyZW50IG9mIHRoZSBwYXJlbnQsIGV0Yykgb2YgdGhlIG5vZGVcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFtzZWxlY3Rvcl0gc2VsZWN0b3IgZm9yIHNlYXJjaFxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbmNsdWRlU2VsZl0gc2hvdyB3ZSB0aGluayB0aGF0IG5vZGUgaXMgYW5jZXN0cm8gaXRzZWxmP1xuICAgICAgICAgKiBAcGFyYW0ge0tvbnZhLk5vZGV9IFtzdG9wTm9kZV0gb3B0aW9uYWwgbm9kZSB3aGVyZSB3ZSBuZWVkIHRvIHN0b3Agc2VhcmNoaW5nIChvbmUgb2YgYW5jZXN0b3JzKVxuICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFthbmNlc3RvcnNdXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIGdldCBvbmUgb2YgdGhlIHBhcmVudCBncm91cFxuICAgICAgICAgKiB2YXIgcGFyZW50R3JvdXBzID0gbm9kZS5maW5kQW5jZXN0b3JzKCdHcm91cCcpO1xuICAgICAgICAgKi9cbiAgICBmaW5kQW5jZXN0b3JzOiBmdW5jdGlvbihzZWxlY3RvciwgaW5jbHVkZVNlbGYsIHN0b3BOb2RlKSB7XG4gICAgICB2YXIgcmVzID0gW107XG5cbiAgICAgIGlmIChpbmNsdWRlU2VsZiAmJiB0aGlzLl9pc01hdGNoKHNlbGVjdG9yKSkge1xuICAgICAgICByZXMucHVzaCh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHZhciBhbmNlc3RvciA9IHRoaXMucGFyZW50O1xuICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgIGlmIChhbmNlc3RvciA9PT0gc3RvcE5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbmNlc3Rvci5faXNNYXRjaChzZWxlY3RvcikpIHtcbiAgICAgICAgICByZXMucHVzaChhbmNlc3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIGdldCBhbmNlc3RvciAocGFyZW50IG9yIHBhcmVudCBvZiB0aGUgcGFyZW50LCBldGMpIG9mIHRoZSBub2RlIHRoYXQgbWF0Y2ggcGFzc2VkIHNlbGVjdG9yXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2VsZWN0b3JdIHNlbGVjdG9yIGZvciBzZWFyY2hcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbaW5jbHVkZVNlbGZdIHNob3cgd2UgdGhpbmsgdGhhdCBub2RlIGlzIGFuY2VzdHJvIGl0c2VsZj9cbiAgICAgICAgICogQHBhcmFtIHtLb252YS5Ob2RlfSBbc3RvcE5vZGVdIG9wdGlvbmFsIG5vZGUgd2hlcmUgd2UgbmVlZCB0byBzdG9wIHNlYXJjaGluZyAob25lIG9mIGFuY2VzdG9ycylcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9IGFuY2VzdG9yXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIGdldCBvbmUgb2YgdGhlIHBhcmVudCBncm91cFxuICAgICAgICAgKiB2YXIgZ3JvdXAgPSBub2RlLmZpbmRBbmNlc3RvcnMoJy5teWdyb3VwJyk7XG4gICAgICAgICAqL1xuICAgIGZpbmRBbmNlc3RvcjogZnVuY3Rpb24oc2VsZWN0b3IsIGluY2x1ZGVTZWxmLCBzdG9wTm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmluZEFuY2VzdG9ycyhzZWxlY3RvciwgaW5jbHVkZVNlbGYsIHN0b3BOb2RlKVswXTtcbiAgICB9LFxuICAgIC8vIGlzIGN1cnJlbnQgbm9kZSBtYXRjaCBwYXNzZWQgc2VsZWN0b3I/XG4gICAgX2lzTWF0Y2g6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBzZWxlY3RvckFyciA9IHNlbGVjdG9yLnJlcGxhY2UoLyAvZywgJycpLnNwbGl0KCcsJyksXG4gICAgICAgIGxlbiA9IHNlbGVjdG9yQXJyLmxlbmd0aCxcbiAgICAgICAgbixcbiAgICAgICAgc2VsO1xuXG4gICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgc2VsID0gc2VsZWN0b3JBcnJbbl07XG4gICAgICAgIGlmICghS29udmEuVXRpbC5pc1ZhbGlkU2VsZWN0b3Ioc2VsKSkge1xuICAgICAgICAgIEtvbnZhLlV0aWwud2FybihcbiAgICAgICAgICAgICdTZWxlY3RvciBcIicgK1xuICAgICAgICAgICAgICBzZWwgK1xuICAgICAgICAgICAgICAnXCIgaXMgaW52YWxpZC4gQWxsb3dlZCBzZWxlY3RvcnMgZXhhbXBsZXMgYXJlIFwiI2Zvb1wiLCBcIi5iYXJcIiBvciBcIkdyb3VwXCIuJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgS29udmEuVXRpbC53YXJuKFxuICAgICAgICAgICAgJ0lmIHlvdSBoYXZlIGEgY3VzdG9tIHNoYXBlIHdpdGggc3VjaCBjbGFzc05hbWUsIHBsZWFzZSBjaGFuZ2UgaXQgdG8gc3RhcnQgd2l0aCB1cHBlciBsZXR0ZXIgbGlrZSBcIlRyaWFuZ2xlXCIuJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgS29udmEuVXRpbC53YXJuKCdLb252YSBpcyBhd2Vzb21lLCByaWdodD8nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZCBzZWxlY3RvclxuICAgICAgICBpZiAoc2VsLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaWQoKSA9PT0gc2VsLnNsaWNlKDEpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsLmNoYXJBdCgwKSA9PT0gJy4nKSB7XG4gICAgICAgICAgLy8gbmFtZSBzZWxlY3RvclxuICAgICAgICAgIGlmICh0aGlzLmhhc05hbWUoc2VsLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2dldChzZWwpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogZ2V0IGxheWVyIGFuY2VzdG9yXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5MYXllcn1cbiAgICAgICAgICovXG4gICAgZ2V0TGF5ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KCk7XG4gICAgICByZXR1cm4gcGFyZW50ID8gcGFyZW50LmdldExheWVyKCkgOiBudWxsO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIGdldCBzdGFnZSBhbmNlc3RvclxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuU3RhZ2V9XG4gICAgICAgICAqL1xuICAgIGdldFN0YWdlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRDYWNoZShTVEFHRSwgdGhpcy5fZ2V0U3RhZ2UpO1xuICAgIH0sXG4gICAgX2dldFN0YWdlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICByZXR1cm4gcGFyZW50LmdldFN0YWdlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIGZpcmUgZXZlbnRcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZSBldmVudCB0eXBlLiAgY2FuIGJlIGEgcmVndWxhciBldmVudCwgbGlrZSBjbGljaywgbW91c2VvdmVyLCBvciBtb3VzZW91dCwgb3IgaXQgY2FuIGJlIGEgY3VzdG9tIGV2ZW50LCBsaWtlIG15Q3VzdG9tRXZlbnRcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gW2V2dF0gZXZlbnQgb2JqZWN0XG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2J1YmJsZV0gc2V0dGluZyB0aGUgdmFsdWUgdG8gZmFsc2UsIG9yIGxlYXZpbmcgaXQgdW5kZWZpbmVkLCB3aWxsIHJlc3VsdCBpbiB0aGUgZXZlbnRcbiAgICAgICAgICogIG5vdCBidWJibGluZy4gIFNldHRpbmcgdGhlIHZhbHVlIHRvIHRydWUgd2lsbCByZXN1bHQgaW4gdGhlIGV2ZW50IGJ1YmJsaW5nLlxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogLy8gbWFudWFsbHkgZmlyZSBjbGljayBldmVudFxuICAgICAgICAgKiBub2RlLmZpcmUoJ2NsaWNrJyk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIGZpcmUgY3VzdG9tIGV2ZW50XG4gICAgICAgICAqIG5vZGUuZmlyZSgnZm9vJyk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIGZpcmUgY3VzdG9tIGV2ZW50IHdpdGggY3VzdG9tIGV2ZW50IG9iamVjdFxuICAgICAgICAgKiBub2RlLmZpcmUoJ2ZvbycsIHtcbiAgICAgICAgICogICBiYXI6IDEwXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBmaXJlIGNsaWNrIGV2ZW50IHRoYXQgYnViYmxlc1xuICAgICAgICAgKiBub2RlLmZpcmUoJ2NsaWNrJywgbnVsbCwgdHJ1ZSk7XG4gICAgICAgICAqL1xuICAgIGZpcmU6IGZ1bmN0aW9uKGV2ZW50VHlwZSwgZXZ0LCBidWJibGUpIHtcbiAgICAgIGV2dCA9IGV2dCB8fCB7fTtcbiAgICAgIGV2dC50YXJnZXQgPSBldnQudGFyZ2V0IHx8IHRoaXM7XG4gICAgICAvLyBidWJibGVcbiAgICAgIGlmIChidWJibGUpIHtcbiAgICAgICAgdGhpcy5fZmlyZUFuZEJ1YmJsZShldmVudFR5cGUsIGV2dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBubyBidWJibGVcbiAgICAgICAgdGhpcy5fZmlyZShldmVudFR5cGUsIGV2dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiBnZXQgYWJzb2x1dGUgdHJhbnNmb3JtIG9mIHRoZSBub2RlIHdoaWNoIHRha2VzIGludG9cbiAgICAgICAgICogIGFjY291bnQgaXRzIGFuY2VzdG9yIHRyYW5zZm9ybXNcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLlRyYW5zZm9ybX1cbiAgICAgICAgICovXG4gICAgZ2V0QWJzb2x1dGVUcmFuc2Zvcm06IGZ1bmN0aW9uKHRvcCkge1xuICAgICAgLy8gaWYgdXNpbmcgYW4gYXJndW1lbnQsIHdlIGNhbid0IGNhY2hlIHRoZSByZXN1bHQuXG4gICAgICBpZiAodG9wKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRBYnNvbHV0ZVRyYW5zZm9ybSh0b3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgbm8gYXJndW1lbnQsIHdlIGNhbiBjYWNoZSB0aGUgcmVzdWx0XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRDYWNoZShBQlNPTFVURV9UUkFOU0ZPUk0sIHRoaXMuX2dldEFic29sdXRlVHJhbnNmb3JtKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9nZXRBYnNvbHV0ZVRyYW5zZm9ybTogZnVuY3Rpb24odG9wKSB7XG4gICAgICB2YXIgYXQgPSBuZXcgS29udmEuVHJhbnNmb3JtKCksXG4gICAgICAgIHRyYW5zZm9ybXNFbmFibGVkLFxuICAgICAgICB0cmFucztcblxuICAgICAgLy8gc3RhcnQgd2l0aCBzdGFnZSBhbmQgdHJhdmVyc2UgZG93bndhcmRzIHRvIHNlbGZcbiAgICAgIHRoaXMuX2VhY2hBbmNlc3RvclJldmVyc2UoZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB0cmFuc2Zvcm1zRW5hYmxlZCA9IG5vZGUudHJhbnNmb3Jtc0VuYWJsZWQoKTtcbiAgICAgICAgdHJhbnMgPSBub2RlLmdldFRyYW5zZm9ybSgpO1xuXG4gICAgICAgIGlmICh0cmFuc2Zvcm1zRW5hYmxlZCA9PT0gJ2FsbCcpIHtcbiAgICAgICAgICBhdC5tdWx0aXBseSh0cmFucyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHJhbnNmb3Jtc0VuYWJsZWQgPT09ICdwb3NpdGlvbicpIHtcbiAgICAgICAgICBhdC50cmFuc2xhdGUobm9kZS54KCksIG5vZGUueSgpKTtcbiAgICAgICAgfVxuICAgICAgfSwgdG9wKTtcbiAgICAgIHJldHVybiBhdDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiBnZXQgYWJzb2x1dGUgc2NhbGUgb2YgdGhlIG5vZGUgd2hpY2ggdGFrZXMgaW50b1xuICAgICAgICAgKiAgYWNjb3VudCBpdHMgYW5jZXN0b3Igc2NhbGVzXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5UcmFuc2Zvcm19XG4gICAgICAgICAqL1xuICAgIGdldEFic29sdXRlU2NhbGU6IGZ1bmN0aW9uKHRvcCkge1xuICAgICAgLy8gaWYgdXNpbmcgYW4gYXJndW1lbnQsIHdlIGNhbid0IGNhY2hlIHRoZSByZXN1bHQuXG4gICAgICBpZiAodG9wKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRBYnNvbHV0ZVNjYWxlKHRvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiBubyBhcmd1bWVudCwgd2UgY2FuIGNhY2hlIHRoZSByZXN1bHRcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldENhY2hlKEFCU09MVVRFX1NDQUxFLCB0aGlzLl9nZXRBYnNvbHV0ZVNjYWxlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9nZXRBYnNvbHV0ZVNjYWxlOiBmdW5jdGlvbih0b3ApIHtcbiAgICAgIC8vIHRoaXMgaXMgc3BlY2lhbCBsb2dpYyBmb3IgY2FjaGluZyB3aXRoIHNvbWUgc2hhcGVzIHdpdGggc2hhZG93XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcztcbiAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgaWYgKHBhcmVudC5faXNVbmRlckNhY2hlKSB7XG4gICAgICAgICAgdG9wID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnQoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNjYWxlWCA9IDEsXG4gICAgICAgIHNjYWxlWSA9IDE7XG5cbiAgICAgIC8vIHN0YXJ0IHdpdGggc3RhZ2UgYW5kIHRyYXZlcnNlIGRvd253YXJkcyB0byBzZWxmXG4gICAgICB0aGlzLl9lYWNoQW5jZXN0b3JSZXZlcnNlKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgc2NhbGVYICo9IG5vZGUuc2NhbGVYKCk7XG4gICAgICAgIHNjYWxlWSAqPSBub2RlLnNjYWxlWSgpO1xuICAgICAgfSwgdG9wKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHNjYWxlWCxcbiAgICAgICAgeTogc2NhbGVZXG4gICAgICB9O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIGdldCB0cmFuc2Zvcm0gb2YgdGhlIG5vZGVcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLlRyYW5zZm9ybX1cbiAgICAgICAgICovXG4gICAgZ2V0VHJhbnNmb3JtOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRDYWNoZShUUkFOU0ZPUk0sIHRoaXMuX2dldFRyYW5zZm9ybSk7XG4gICAgfSxcbiAgICBfZ2V0VHJhbnNmb3JtOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtID0gbmV3IEtvbnZhLlRyYW5zZm9ybSgpLFxuICAgICAgICB4ID0gdGhpcy5nZXRYKCksXG4gICAgICAgIHkgPSB0aGlzLmdldFkoKSxcbiAgICAgICAgcm90YXRpb24gPSBLb252YS5nZXRBbmdsZSh0aGlzLmdldFJvdGF0aW9uKCkpLFxuICAgICAgICBzY2FsZVggPSB0aGlzLmdldFNjYWxlWCgpLFxuICAgICAgICBzY2FsZVkgPSB0aGlzLmdldFNjYWxlWSgpLFxuICAgICAgICBza2V3WCA9IHRoaXMuZ2V0U2tld1goKSxcbiAgICAgICAgc2tld1kgPSB0aGlzLmdldFNrZXdZKCksXG4gICAgICAgIG9mZnNldFggPSB0aGlzLmdldE9mZnNldFgoKSxcbiAgICAgICAgb2Zmc2V0WSA9IHRoaXMuZ2V0T2Zmc2V0WSgpO1xuXG4gICAgICBpZiAoeCAhPT0gMCB8fCB5ICE9PSAwKSB7XG4gICAgICAgIG0udHJhbnNsYXRlKHgsIHkpO1xuICAgICAgfVxuICAgICAgaWYgKHJvdGF0aW9uICE9PSAwKSB7XG4gICAgICAgIG0ucm90YXRlKHJvdGF0aW9uKTtcbiAgICAgIH1cbiAgICAgIGlmIChza2V3WCAhPT0gMCB8fCBza2V3WSAhPT0gMCkge1xuICAgICAgICBtLnNrZXcoc2tld1gsIHNrZXdZKTtcbiAgICAgIH1cbiAgICAgIGlmIChzY2FsZVggIT09IDEgfHwgc2NhbGVZICE9PSAxKSB7XG4gICAgICAgIG0uc2NhbGUoc2NhbGVYLCBzY2FsZVkpO1xuICAgICAgfVxuICAgICAgaWYgKG9mZnNldFggIT09IDAgfHwgb2Zmc2V0WSAhPT0gMCkge1xuICAgICAgICBtLnRyYW5zbGF0ZSgtMSAqIG9mZnNldFgsIC0xICogb2Zmc2V0WSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIGNsb25lIG5vZGUuICBSZXR1cm5zIGEgbmV3IE5vZGUgaW5zdGFuY2Ugd2l0aCBpZGVudGljYWwgYXR0cmlidXRlcy4gIFlvdSBjYW4gYWxzbyBvdmVycmlkZVxuICAgICAgICAgKiAgdGhlIG5vZGUgcHJvcGVydGllcyB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLCBlbmFibGluZyB5b3UgdG8gdXNlIGFuIGV4aXN0aW5nIG5vZGUgYXMgYSB0ZW1wbGF0ZVxuICAgICAgICAgKiAgZm9yIGFub3RoZXIgbm9kZVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIG92ZXJyaWRlIGF0dHJzXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAvLyBzaW1wbGUgY2xvbmVcbiAgICAgICAgICogdmFyIGNsb25lID0gbm9kZS5jbG9uZSgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBjbG9uZSBhIG5vZGUgYW5kIG92ZXJyaWRlIHRoZSB4IHBvc2l0aW9uXG4gICAgICAgICAqIHZhciBjbG9uZSA9IHJlY3QuY2xvbmUoe1xuICAgICAgICAgKiAgIHg6IDVcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIC8vIGluc3RhbnRpYXRlIG5ldyBub2RlXG4gICAgICB2YXIgYXR0cnMgPSBLb252YS5VdGlsLmNsb25lT2JqZWN0KHRoaXMuYXR0cnMpLFxuICAgICAgICBrZXksXG4gICAgICAgIGFsbExpc3RlbmVycyxcbiAgICAgICAgbGVuLFxuICAgICAgICBuLFxuICAgICAgICBsaXN0ZW5lcjtcbiAgICAgIC8vIGZpbHRlciBibGFjayBhdHRyc1xuICAgICAgZm9yICh2YXIgaSBpbiBDTE9ORV9CTEFDS19MSVNUKSB7XG4gICAgICAgIHZhciBibG9ja0F0dHIgPSBDTE9ORV9CTEFDS19MSVNUW2ldO1xuICAgICAgICBkZWxldGUgYXR0cnNbYmxvY2tBdHRyXTtcbiAgICAgIH1cbiAgICAgIC8vIGFwcGx5IGF0dHIgb3ZlcnJpZGVzXG4gICAgICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICAgICAgYXR0cnNba2V5XSA9IG9ialtrZXldO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm9kZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKGF0dHJzKTtcbiAgICAgIC8vIGNvcHkgb3ZlciBsaXN0ZW5lcnNcbiAgICAgIGZvciAoa2V5IGluIHRoaXMuZXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgICAgYWxsTGlzdGVuZXJzID0gdGhpcy5ldmVudExpc3RlbmVyc1trZXldO1xuICAgICAgICBsZW4gPSBhbGxMaXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICBsaXN0ZW5lciA9IGFsbExpc3RlbmVyc1tuXTtcbiAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgKiBkb24ndCBpbmNsdWRlIGtvbnZhIG5hbWVzcGFjZWQgbGlzdGVuZXJzIGJlY2F1c2VcbiAgICAgICAgICAgICAgICAgICAgICogIHRoZXNlIGFyZSBnZW5lcmF0ZWQgYnkgdGhlIGNvbnN0cnVjdG9yc1xuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICBpZiAobGlzdGVuZXIubmFtZS5pbmRleE9mKEtPTlZBKSA8IDApIHtcbiAgICAgICAgICAgIC8vIGlmIGxpc3RlbmVycyBhcnJheSBkb2Vzbid0IGV4aXN0LCB0aGVuIGNyZWF0ZSBpdFxuICAgICAgICAgICAgaWYgKCFub2RlLmV2ZW50TGlzdGVuZXJzW2tleV0pIHtcbiAgICAgICAgICAgICAgbm9kZS5ldmVudExpc3RlbmVyc1trZXldID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlLmV2ZW50TGlzdGVuZXJzW2tleV0ucHVzaChsaXN0ZW5lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuICAgIF90b0tvbnZhQ2FudmFzOiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuICAgICAgdmFyIHN0YWdlID0gdGhpcy5nZXRTdGFnZSgpLFxuICAgICAgICB4ID0gY29uZmlnLnggfHwgMCxcbiAgICAgICAgeSA9IGNvbmZpZy55IHx8IDAsXG4gICAgICAgIHBpeGVsUmF0aW8gPSBjb25maWcucGl4ZWxSYXRpbyB8fCAxLFxuICAgICAgICBjYW52YXMgPSBuZXcgS29udmEuU2NlbmVDYW52YXMoe1xuICAgICAgICAgIHdpZHRoOlxuICAgICAgICAgICAgY29uZmlnLndpZHRoIHx8IHRoaXMuZ2V0V2lkdGgoKSB8fCAoc3RhZ2UgPyBzdGFnZS5nZXRXaWR0aCgpIDogMCksXG4gICAgICAgICAgaGVpZ2h0OlxuICAgICAgICAgICAgY29uZmlnLmhlaWdodCB8fFxuICAgICAgICAgICAgdGhpcy5nZXRIZWlnaHQoKSB8fFxuICAgICAgICAgICAgKHN0YWdlID8gc3RhZ2UuZ2V0SGVpZ2h0KCkgOiAwKSxcbiAgICAgICAgICBwaXhlbFJhdGlvOiBwaXhlbFJhdGlvXG4gICAgICAgIH0pLFxuICAgICAgICBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoKTtcblxuICAgICAgY29udGV4dC5zYXZlKCk7XG5cbiAgICAgIGlmICh4IHx8IHkpIHtcbiAgICAgICAgY29udGV4dC50cmFuc2xhdGUoLTEgKiB4LCAtMSAqIHkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRyYXdTY2VuZShjYW52YXMpO1xuICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG5cbiAgICAgIHJldHVybiBjYW52YXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogY29udmVydHMgbm9kZSBpbnRvIGFuIGNhbnZhcyBlbGVtZW50LlxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbmZpZy5jYWxsYmFjayBmdW5jdGlvbiBleGVjdXRlZCB3aGVuIHRoZSBjb21wb3NpdGUgaGFzIGNvbXBsZXRlZFxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XSB4IHBvc2l0aW9uIG9mIGNhbnZhcyBzZWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldIHkgcG9zaXRpb24gb2YgY2FudmFzIHNlY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdIHdpZHRoIG9mIGNhbnZhcyBzZWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF0gaGVpZ2h0IG9mIGNhbnZhcyBzZWN0aW9uXG4gICAgICAgICAqIEBwYXJlbXQge051bWJlcn0gW2NvbmZpZy5waXhlbFJhdGlvXSBwaXhlbFJhdGlvIG9mIG91cHV0IGltYWdlLiAgRGVmYXVsdCBpcyAxLlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiB2YXIgY2FudmFzID0gbm9kZS50b0NhbnZhcygpO1xuICAgICAgICAgKi9cbiAgICB0b0NhbnZhczogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdG9Lb252YUNhbnZhcyhjb25maWcpLl9jYW52YXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIGNvbXBvc2l0ZSBkYXRhIFVSTC4gSWYgTUlNRSB0eXBlIGlzIG5vdFxuICAgICAgICAgKiBzcGVjaWZpZWQsIHRoZW4gXCJpbWFnZS9wbmdcIiB3aWxsIHJlc3VsdC4gRm9yIFwiaW1hZ2UvanBlZ1wiLCBzcGVjaWZ5IGEgcXVhbGl0eVxuICAgICAgICAgKiBsZXZlbCBhcyBxdWFsaXR5IChyYW5nZSAwLjAgLSAxLjApXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubWltZVR5cGVdIGNhbiBiZSBcImltYWdlL3BuZ1wiIG9yIFwiaW1hZ2UvanBlZ1wiLlxuICAgICAgICAgKiAgXCJpbWFnZS9wbmdcIiBpcyB0aGUgZGVmYXVsdFxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XSB4IHBvc2l0aW9uIG9mIGNhbnZhcyBzZWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldIHkgcG9zaXRpb24gb2YgY2FudmFzIHNlY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdIHdpZHRoIG9mIGNhbnZhcyBzZWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF0gaGVpZ2h0IG9mIGNhbnZhcyBzZWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnF1YWxpdHldIGpwZWcgcXVhbGl0eS4gIElmIHVzaW5nIGFuIFwiaW1hZ2UvanBlZ1wiIG1pbWVUeXBlLFxuICAgICAgICAgKiAgeW91IGNhbiBzcGVjaWZ5IHRoZSBxdWFsaXR5IGZyb20gMCB0byAxLCB3aGVyZSAwIGlzIHZlcnkgcG9vciBxdWFsaXR5IGFuZCAxXG4gICAgICAgICAqICBpcyB2ZXJ5IGhpZ2ggcXVhbGl0eVxuICAgICAgICAgKiBAcGFyZW10IHtOdW1iZXJ9IFtjb25maWcucGl4ZWxSYXRpb10gcGl4ZWxSYXRpbyBvZiBvdXB1dCBpbWFnZSB1cmwuIERlZmF1bHQgaXMgMVxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAgICAgKi9cbiAgICB0b0RhdGFVUkw6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgICAgdmFyIG1pbWVUeXBlID0gY29uZmlnLm1pbWVUeXBlIHx8IG51bGwsXG4gICAgICAgIHF1YWxpdHkgPSBjb25maWcucXVhbGl0eSB8fCBudWxsO1xuICAgICAgcmV0dXJuIHRoaXMuX3RvS29udmFDYW52YXMoY29uZmlnKS50b0RhdGFVUkwobWltZVR5cGUsIHF1YWxpdHkpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIGNvbnZlcnRzIG5vZGUgaW50byBhbiBpbWFnZS4gIFNpbmNlIHRoZSB0b0ltYWdlXG4gICAgICAgICAqICBtZXRob2QgaXMgYXN5bmNocm9ub3VzLCBhIGNhbGxiYWNrIGlzIHJlcXVpcmVkLiAgdG9JbWFnZSBpcyBtb3N0IGNvbW1vbmx5IHVzZWRcbiAgICAgICAgICogIHRvIGNhY2hlIGNvbXBsZXggZHJhd2luZ3MgYXMgYW4gaW1hZ2Ugc28gdGhhdCB0aGV5IGRvbid0IGhhdmUgdG8gY29uc3RhbnRseSBiZSByZWRyYXduXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29uZmlnLmNhbGxiYWNrIGZ1bmN0aW9uIGV4ZWN1dGVkIHdoZW4gdGhlIGNvbXBvc2l0ZSBoYXMgY29tcGxldGVkXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm1pbWVUeXBlXSBjYW4gYmUgXCJpbWFnZS9wbmdcIiBvciBcImltYWdlL2pwZWdcIi5cbiAgICAgICAgICogIFwiaW1hZ2UvcG5nXCIgaXMgdGhlIGRlZmF1bHRcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF0geCBwb3NpdGlvbiBvZiBjYW52YXMgc2VjdGlvblxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XSB5IHBvc2l0aW9uIG9mIGNhbnZhcyBzZWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXSB3aWR0aCBvZiBjYW52YXMgc2VjdGlvblxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdIGhlaWdodCBvZiBjYW52YXMgc2VjdGlvblxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5xdWFsaXR5XSBqcGVnIHF1YWxpdHkuICBJZiB1c2luZyBhbiBcImltYWdlL2pwZWdcIiBtaW1lVHlwZSxcbiAgICAgICAgICogIHlvdSBjYW4gc3BlY2lmeSB0aGUgcXVhbGl0eSBmcm9tIDAgdG8gMSwgd2hlcmUgMCBpcyB2ZXJ5IHBvb3IgcXVhbGl0eSBhbmQgMVxuICAgICAgICAgKiAgaXMgdmVyeSBoaWdoIHF1YWxpdHlcbiAgICAgICAgICogQHBhcmVtdCB7TnVtYmVyfSBbY29uZmlnLnBpeGVsUmF0aW9dIHBpeGVsUmF0aW8gb2Ygb3VwdXQgaW1hZ2UuICBEZWZhdWx0IGlzIDEuXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIHZhciBpbWFnZSA9IG5vZGUudG9JbWFnZSh7XG4gICAgICAgICAqICAgY2FsbGJhY2s6IGZ1bmN0aW9uKGltZykge1xuICAgICAgICAgKiAgICAgLy8gZG8gc3R1ZmYgd2l0aCBpbWdcbiAgICAgICAgICogICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKi9cbiAgICB0b0ltYWdlOiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIGlmICghY29uZmlnIHx8ICFjb25maWcuY2FsbGJhY2spIHtcbiAgICAgICAgdGhyb3cgJ2NhbGxiYWNrIHJlcXVpcmVkIGZvciB0b0ltYWdlIG1ldGhvZCBjb25maWcgYXJndW1lbnQnO1xuICAgICAgfVxuICAgICAgS29udmEuVXRpbC5fZ2V0SW1hZ2UodGhpcy50b0RhdGFVUkwoY29uZmlnKSwgZnVuY3Rpb24oaW1nKSB7XG4gICAgICAgIGNvbmZpZy5jYWxsYmFjayhpbWcpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBzZXRTaXplOiBmdW5jdGlvbihzaXplKSB7XG4gICAgICB0aGlzLnNldFdpZHRoKHNpemUud2lkdGgpO1xuICAgICAgdGhpcy5zZXRIZWlnaHQoc2l6ZS5oZWlnaHQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBnZXRTaXplOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiB0aGlzLmdldFdpZHRoKCksXG4gICAgICAgIGhlaWdodDogdGhpcy5nZXRIZWlnaHQoKVxuICAgICAgfTtcbiAgICB9LFxuICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHJzLndpZHRoIHx8IDA7XG4gICAgfSxcbiAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cnMuaGVpZ2h0IHx8IDA7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogZ2V0IGNsYXNzIG5hbWUsIHdoaWNoIG1heSByZXR1cm4gU3RhZ2UsIExheWVyLCBHcm91cCwgb3Igc2hhcGUgY2xhc3MgbmFtZXMgbGlrZSBSZWN0LCBDaXJjbGUsIFRleHQsIGV0Yy5cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgICAgICovXG4gICAgZ2V0Q2xhc3NOYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsYXNzTmFtZSB8fCB0aGlzLm5vZGVUeXBlO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIGdldCB0aGUgbm9kZSB0eXBlLCB3aGljaCBtYXkgcmV0dXJuIFN0YWdlLCBMYXllciwgR3JvdXAsIG9yIE5vZGVcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgICAgICovXG4gICAgZ2V0VHlwZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlVHlwZTtcbiAgICB9LFxuICAgIGdldERyYWdEaXN0YW5jZTogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBjb21wYXJlIHdpdGggdW5kZWZpbmVkIGJlY2F1c2Ugd2UgbmVlZCB0byB0cmFjayAwIHZhbHVlXG4gICAgICBpZiAodGhpcy5hdHRycy5kcmFnRGlzdGFuY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRycy5kcmFnRGlzdGFuY2U7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5nZXREcmFnRGlzdGFuY2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBLb252YS5kcmFnRGlzdGFuY2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBfZ2V0OiBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIHRoaXMuY2xhc3NOYW1lID09PSBzZWxlY3RvciB8fCB0aGlzLm5vZGVUeXBlID09PSBzZWxlY3RvclxuICAgICAgICA/IFt0aGlzXVxuICAgICAgICA6IFtdO1xuICAgIH0sXG4gICAgX29mZjogZnVuY3Rpb24odHlwZSwgbmFtZSkge1xuICAgICAgdmFyIGV2dExpc3RlbmVycyA9IHRoaXMuZXZlbnRMaXN0ZW5lcnNbdHlwZV0sXG4gICAgICAgIGksXG4gICAgICAgIGV2dE5hbWU7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBldnRMaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZXZ0TmFtZSA9IGV2dExpc3RlbmVyc1tpXS5uYW1lO1xuICAgICAgICAvLyB0aGUgZm9sbG93aW5nIHR3byBjb25kaXRpb25zIG11c3QgYmUgdHJ1ZSBpbiBvcmRlciB0byByZW1vdmUgYSBoYW5kbGVyOlxuICAgICAgICAvLyAxKSB0aGUgY3VycmVudCBldmVudCBuYW1lIGNhbm5vdCBiZSBrb252YSB1bmxlc3MgdGhlIGV2ZW50IG5hbWUgaXMga29udmFcbiAgICAgICAgLy8gICAgdGhpcyBlbmFibGVzIGRldmVsb3BlcnMgdG8gZm9yY2UgcmVtb3ZlIGEga29udmEgc3BlY2lmaWMgbGlzdGVuZXIgZm9yIHdoYXRldmVyIHJlYXNvblxuICAgICAgICAvLyAyKSBhbiBldmVudCBuYW1lIGlzIG5vdCBzcGVjaWZpZWQsIG9yIGlmIG9uZSBpcyBzcGVjaWZpZWQsIGl0IG1hdGNoZXMgdGhlIGN1cnJlbnQgZXZlbnQgbmFtZVxuICAgICAgICBpZiAoXG4gICAgICAgICAgKGV2dE5hbWUgIT09ICdrb252YScgfHwgbmFtZSA9PT0gJ2tvbnZhJykgJiZcbiAgICAgICAgICAoIW5hbWUgfHwgZXZ0TmFtZSA9PT0gbmFtZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgZXZ0TGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICBpZiAoZXZ0TGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZXZlbnRMaXN0ZW5lcnNbdHlwZV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBfZmlyZUNoYW5nZUV2ZW50OiBmdW5jdGlvbihhdHRyLCBvbGRWYWwsIG5ld1ZhbCkge1xuICAgICAgdGhpcy5fZmlyZShhdHRyICsgQ0hBTkdFLCB7XG4gICAgICAgIG9sZFZhbDogb2xkVmFsLFxuICAgICAgICBuZXdWYWw6IG5ld1ZhbFxuICAgICAgfSk7XG4gICAgfSxcbiAgICBzZXRJZDogZnVuY3Rpb24oaWQpIHtcbiAgICAgIHZhciBvbGRJZCA9IHRoaXMuZ2V0SWQoKTtcblxuICAgICAgS29udmEuX3JlbW92ZUlkKG9sZElkKTtcbiAgICAgIEtvbnZhLl9hZGRJZCh0aGlzLCBpZCk7XG4gICAgICB0aGlzLl9zZXRBdHRyKElELCBpZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHNldE5hbWU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBvbGROYW1lcyA9ICh0aGlzLmdldE5hbWUoKSB8fCAnJykuc3BsaXQoL1xccy9nKTtcbiAgICAgIHZhciBuZXdOYW1lcyA9IChuYW1lIHx8ICcnKS5zcGxpdCgvXFxzL2cpO1xuICAgICAgdmFyIHN1Ym5hbWUsIGk7XG4gICAgICAvLyByZW1vdmUgYWxsIHN1Ym5hbWVzXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgb2xkTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3VibmFtZSA9IG9sZE5hbWVzW2ldO1xuICAgICAgICBpZiAobmV3TmFtZXMuaW5kZXhPZihzdWJuYW1lKSA9PT0gLTEgJiYgc3VibmFtZSkge1xuICAgICAgICAgIEtvbnZhLl9yZW1vdmVOYW1lKHN1Ym5hbWUsIHRoaXMuX2lkKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBhZGQgbmV3IG5hbWVzXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbmV3TmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3VibmFtZSA9IG5ld05hbWVzW2ldO1xuICAgICAgICBpZiAob2xkTmFtZXMuaW5kZXhPZihzdWJuYW1lKSA9PT0gLTEgJiYgc3VibmFtZSkge1xuICAgICAgICAgIEtvbnZhLl9hZGROYW1lKHRoaXMsIHN1Ym5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3NldEF0dHIoTkFNRSwgbmFtZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIG5hbWluZyBtZXRob2RzXG4gICAgLyoqXG4gICAgICAgICAqIGFkZCBuYW1lIHRvIG5vZGVcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIG5vZGUubmFtZSgncmVkJyk7XG4gICAgICAgICAqIG5vZGUuYWRkTmFtZSgnc2VsZWN0ZWQnKTtcbiAgICAgICAgICogbm9kZS5uYW1lKCk7IC8vIHJldHVybiAncmVkIHNlbGVjdGVkJ1xuICAgICAgICAgKi9cbiAgICBhZGROYW1lOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICBpZiAoIXRoaXMuaGFzTmFtZShuYW1lKSkge1xuICAgICAgICB2YXIgb2xkTmFtZSA9IHRoaXMubmFtZSgpO1xuICAgICAgICB2YXIgbmV3TmFtZSA9IG9sZE5hbWUgPyBvbGROYW1lICsgJyAnICsgbmFtZSA6IG5hbWU7XG4gICAgICAgIHRoaXMuc2V0TmFtZShuZXdOYW1lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIGNoZWNrIGlzIG5vZGUgaGFzIG5hbWVcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIG5vZGUubmFtZSgncmVkJyk7XG4gICAgICAgICAqIG5vZGUuaGFzTmFtZSgncmVkJyk7ICAgLy8gcmV0dXJuIHRydWVcbiAgICAgICAgICogbm9kZS5oYXNOYW1lKCdzZWxlY3RlZCcpOyAvLyByZXR1cm4gZmFsc2VcbiAgICAgICAgICovXG4gICAgaGFzTmFtZTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIG5hbWVzID0gKHRoaXMubmFtZSgpIHx8ICcnKS5zcGxpdCgvXFxzL2cpO1xuICAgICAgcmV0dXJuIG5hbWVzLmluZGV4T2YobmFtZSkgIT09IC0xO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIHJlbW92ZSBuYW1lIGZyb20gbm9kZVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogbm9kZS5uYW1lKCdyZWQgc2VsZWN0ZWQnKTtcbiAgICAgICAgICogbm9kZS5yZW1vdmVOYW1lKCdzZWxlY3RlZCcpO1xuICAgICAgICAgKiBub2RlLmhhc05hbWUoJ3NlbGVjdGVkJyk7IC8vIHJldHVybiBmYWxzZVxuICAgICAgICAgKiBub2RlLm5hbWUoKTsgLy8gcmV0dXJuICdyZWQnXG4gICAgICAgICAqL1xuICAgIHJlbW92ZU5hbWU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBuYW1lcyA9ICh0aGlzLm5hbWUoKSB8fCAnJykuc3BsaXQoL1xccy9nKTtcbiAgICAgIHZhciBpbmRleCA9IG5hbWVzLmluZGV4T2YobmFtZSk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIG5hbWVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIHRoaXMuc2V0TmFtZShuYW1lcy5qb2luKCcgJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogc2V0IGF0dHJcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWxcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIG5vZGUuc2V0QXR0cigneCcsIDUpO1xuICAgICAgICAgKi9cbiAgICBzZXRBdHRyOiBmdW5jdGlvbihhdHRyLCB2YWwpIHtcbiAgICAgIHZhciBtZXRob2QgPSBTRVQgKyBLb252YS5VdGlsLl9jYXBpdGFsaXplKGF0dHIpLFxuICAgICAgICBmdW5jID0gdGhpc1ttZXRob2RdO1xuXG4gICAgICBpZiAoS29udmEuVXRpbC5faXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICBmdW5jLmNhbGwodGhpcywgdmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG90aGVyd2lzZSBzZXQgZGlyZWN0bHlcbiAgICAgICAgdGhpcy5fc2V0QXR0cihhdHRyLCB2YWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBfc2V0QXR0cjogZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAgICAgIHZhciBvbGRWYWw7XG4gICAgICBvbGRWYWwgPSB0aGlzLmF0dHJzW2tleV07XG4gICAgICBpZiAob2xkVmFsID09PSB2YWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkIHx8IHZhbCA9PT0gbnVsbCkge1xuICAgICAgICBkZWxldGUgdGhpcy5hdHRyc1trZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hdHRyc1trZXldID0gdmFsO1xuICAgICAgfVxuICAgICAgdGhpcy5fZmlyZUNoYW5nZUV2ZW50KGtleSwgb2xkVmFsLCB2YWwpO1xuICAgIH0sXG4gICAgX3NldENvbXBvbmVudEF0dHI6IGZ1bmN0aW9uKGtleSwgY29tcG9uZW50LCB2YWwpIHtcbiAgICAgIHZhciBvbGRWYWw7XG4gICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb2xkVmFsID0gdGhpcy5hdHRyc1trZXldO1xuXG4gICAgICAgIGlmICghb2xkVmFsKSB7XG4gICAgICAgICAgLy8gc2V0IHZhbHVlIHRvIGRlZmF1bHQgdmFsdWUgdXNpbmcgZ2V0QXR0clxuICAgICAgICAgIHRoaXMuYXR0cnNba2V5XSA9IHRoaXMuZ2V0QXR0cihrZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hdHRyc1trZXldW2NvbXBvbmVudF0gPSB2YWw7XG4gICAgICAgIHRoaXMuX2ZpcmVDaGFuZ2VFdmVudChrZXksIG9sZFZhbCwgdmFsKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9maXJlQW5kQnViYmxlOiBmdW5jdGlvbihldmVudFR5cGUsIGV2dCwgY29tcGFyZVNoYXBlKSB7XG4gICAgICB2YXIgb2theVRvUnVuID0gdHJ1ZTtcblxuICAgICAgaWYgKGV2dCAmJiB0aGlzLm5vZGVUeXBlID09PSBTSEFQRSkge1xuICAgICAgICBldnQudGFyZ2V0ID0gdGhpcztcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICBldmVudFR5cGUgPT09IE1PVVNFRU5URVIgJiZcbiAgICAgICAgY29tcGFyZVNoYXBlICYmXG4gICAgICAgICh0aGlzLl9pZCA9PT0gY29tcGFyZVNoYXBlLl9pZCB8fFxuICAgICAgICAgICh0aGlzLmlzQW5jZXN0b3JPZiAmJiB0aGlzLmlzQW5jZXN0b3JPZihjb21wYXJlU2hhcGUpKSlcbiAgICAgICkge1xuICAgICAgICBva2F5VG9SdW4gPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGV2ZW50VHlwZSA9PT0gTU9VU0VMRUFWRSAmJlxuICAgICAgICBjb21wYXJlU2hhcGUgJiZcbiAgICAgICAgKHRoaXMuX2lkID09PSBjb21wYXJlU2hhcGUuX2lkIHx8XG4gICAgICAgICAgKHRoaXMuaXNBbmNlc3Rvck9mICYmIHRoaXMuaXNBbmNlc3Rvck9mKGNvbXBhcmVTaGFwZSkpKVxuICAgICAgKSB7XG4gICAgICAgIG9rYXlUb1J1biA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKG9rYXlUb1J1bikge1xuICAgICAgICB0aGlzLl9maXJlKGV2ZW50VHlwZSwgZXZ0KTtcblxuICAgICAgICAvLyBzaW11bGF0ZSBldmVudCBidWJibGluZ1xuICAgICAgICB2YXIgc3RvcEJ1YmJsZSA9XG4gICAgICAgICAgKGV2ZW50VHlwZSA9PT0gTU9VU0VFTlRFUiB8fCBldmVudFR5cGUgPT09IE1PVVNFTEVBVkUpICYmXG4gICAgICAgICAgKGNvbXBhcmVTaGFwZSAmJlxuICAgICAgICAgICAgY29tcGFyZVNoYXBlLmlzQW5jZXN0b3JPZiAmJlxuICAgICAgICAgICAgY29tcGFyZVNoYXBlLmlzQW5jZXN0b3JPZih0aGlzKSAmJlxuICAgICAgICAgICAgIWNvbXBhcmVTaGFwZS5pc0FuY2VzdG9yT2YodGhpcy5wYXJlbnQpKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICgoZXZ0ICYmICFldnQuY2FuY2VsQnViYmxlKSB8fCAhZXZ0KSAmJlxuICAgICAgICAgIHRoaXMucGFyZW50ICYmXG4gICAgICAgICAgdGhpcy5wYXJlbnQuaXNMaXN0ZW5pbmcoKSAmJlxuICAgICAgICAgICFzdG9wQnViYmxlXG4gICAgICAgICkge1xuICAgICAgICAgIGlmIChjb21wYXJlU2hhcGUgJiYgY29tcGFyZVNoYXBlLnBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5fZmlyZUFuZEJ1YmJsZS5jYWxsKFxuICAgICAgICAgICAgICB0aGlzLnBhcmVudCxcbiAgICAgICAgICAgICAgZXZlbnRUeXBlLFxuICAgICAgICAgICAgICBldnQsXG4gICAgICAgICAgICAgIGNvbXBhcmVTaGFwZS5wYXJlbnRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpcmVBbmRCdWJibGUuY2FsbCh0aGlzLnBhcmVudCwgZXZlbnRUeXBlLCBldnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgX2ZpcmU6IGZ1bmN0aW9uKGV2ZW50VHlwZSwgZXZ0KSB7XG4gICAgICB2YXIgZXZlbnRzID0gdGhpcy5ldmVudExpc3RlbmVyc1tldmVudFR5cGVdLFxuICAgICAgICBpO1xuXG4gICAgICBldnQgPSBldnQgfHwge307XG4gICAgICBldnQuY3VycmVudFRhcmdldCA9IHRoaXM7XG4gICAgICBldnQudHlwZSA9IGV2ZW50VHlwZTtcblxuICAgICAgaWYgKGV2ZW50cykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZXZlbnRzW2ldLmhhbmRsZXIuY2FsbCh0aGlzLCBldnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogZHJhdyBib3RoIHNjZW5lIGFuZCBoaXQgZ3JhcGhzLiAgSWYgdGhlIG5vZGUgYmVpbmcgZHJhd24gaXMgdGhlIHN0YWdlLCBhbGwgb2YgdGhlIGxheWVycyB3aWxsIGJlIGNsZWFyZWQgYW5kIHJlZHJhd25cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICAgICAqL1xuICAgIGRyYXc6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kcmF3U2NlbmUoKTtcbiAgICAgIHRoaXMuZHJhd0hpdCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICAgKiBjcmVhdGUgbm9kZSB3aXRoIEpTT04gc3RyaW5nIG9yIGFuIE9iamVjdC4gIERlLXNlcmlhbGl6dGlvbiBkb2VzIG5vdCBnZW5lcmF0ZSBjdXN0b21cbiAgICAgKiAgc2hhcGUgZHJhd2luZyBmdW5jdGlvbnMsIGltYWdlcywgb3IgZXZlbnQgaGFuZGxlcnMgKHRoaXMgd291bGQgbWFrZSB0aGVcbiAgICAgKiAgc2VyaWFsaXplZCBvYmplY3QgaHVnZSkuICBJZiB5b3VyIGFwcCB1c2VzIGN1c3RvbSBzaGFwZXMsIGltYWdlcywgYW5kXG4gICAgICogIGV2ZW50IGhhbmRsZXJzIChpdCBwcm9iYWJseSBkb2VzKSwgdGhlbiB5b3UgbmVlZCB0byBzZWxlY3QgdGhlIGFwcHJvcHJpYXRlXG4gICAgICogIHNoYXBlcyBhZnRlciBsb2FkaW5nIHRoZSBzdGFnZSBhbmQgc2V0IHRoZXNlIHByb3BlcnRpZXMgdmlhIG9uKCksIHNldERyYXdGdW5jKCksXG4gICAgICogIGFuZCBzZXRJbWFnZSgpIG1ldGhvZHNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGpzb24gc3RyaW5nIG9yIG9iamVjdFxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gW2NvbnRhaW5lcl0gb3B0aW9uYWwgY29udGFpbmVyIGRvbSBlbGVtZW50IHVzZWQgb25seSBpZiB5b3UncmVcbiAgICAgKiAgY3JlYXRpbmcgYSBzdGFnZSBub2RlXG4gICAgICovXG4gIEtvbnZhLk5vZGUuY3JlYXRlID0gZnVuY3Rpb24oZGF0YSwgY29udGFpbmVyKSB7XG4gICAgaWYgKEtvbnZhLlV0aWwuX2lzU3RyaW5nKGRhdGEpKSB7XG4gICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZU5vZGUoZGF0YSwgY29udGFpbmVyKTtcbiAgfTtcbiAgS29udmEuTm9kZS5fY3JlYXRlTm9kZSA9IGZ1bmN0aW9uKG9iaiwgY29udGFpbmVyKSB7XG4gICAgdmFyIGNsYXNzTmFtZSA9IEtvbnZhLk5vZGUucHJvdG90eXBlLmdldENsYXNzTmFtZS5jYWxsKG9iaiksXG4gICAgICBjaGlsZHJlbiA9IG9iai5jaGlsZHJlbixcbiAgICAgIG5vLFxuICAgICAgbGVuLFxuICAgICAgbjtcblxuICAgIC8vIGlmIGNvbnRhaW5lciB3YXMgcGFzc2VkIGluLCBhZGQgaXQgdG8gYXR0cnNcbiAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICBvYmouYXR0cnMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIH1cblxuICAgIG5vID0gbmV3IEtvbnZhW2NsYXNzTmFtZV0ob2JqLmF0dHJzKTtcbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICBuby5hZGQodGhpcy5fY3JlYXRlTm9kZShjaGlsZHJlbltuXSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBubztcbiAgfTtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT0gYWRkIGdldHRlcnMgc2V0dGVycyA9PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBLb252YS5GYWN0b3J5LmFkZE92ZXJsb2FkZWRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3Bvc2l0aW9uJyk7XG4gIC8qKlxuICAgICAqIGdldC9zZXQgbm9kZSBwb3NpdGlvbiByZWxhdGl2ZSB0byBwYXJlbnRcbiAgICAgKiBAbmFtZSBwb3NpdGlvblxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvcy54XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvcy55XG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBwb3NpdGlvblxuICAgICAqIHZhciBwb3NpdGlvbiA9IG5vZGUucG9zaXRpb24oKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBwb3NpdGlvblxuICAgICAqIG5vZGUucG9zaXRpb24oe1xuICAgICAqICAgeDogNVxuICAgICAqICAgeTogMTBcbiAgICAgKiB9KTtcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAneCcsIDApO1xuXG4gIC8qKlxuICAgICAqIGdldC9zZXQgeCBwb3NpdGlvblxuICAgICAqIEBuYW1lIHhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHhcbiAgICAgKiB2YXIgeCA9IG5vZGUueCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHhcbiAgICAgKiBub2RlLngoNSk7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3knLCAwKTtcblxuICAvKipcbiAgICAgKiBnZXQvc2V0IHkgcG9zaXRpb25cbiAgICAgKiBAbmFtZSB5XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge0ludGVnZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgeVxuICAgICAqIHZhciB5ID0gbm9kZS55KCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgeVxuICAgICAqIG5vZGUueSg1KTtcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5Ob2RlLFxuICAgICdnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24nLFxuICAgICdzb3VyY2Utb3ZlcidcbiAgKTtcblxuICAvKipcbiAgICAgKiBnZXQvc2V0IGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiBvZiBhIHNoYXBlXG4gICAgICogQG5hbWUgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBibHVyXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBzaGFkb3cgYmx1clxuICAgICAqIHZhciBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBzaGFwZS5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24oKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBzaGFkb3cgYmx1clxuICAgICAqIHNoYXBlLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbignc291cmNlLWluJyk7XG4gICAgICovXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdvcGFjaXR5JywgMSk7XG5cbiAgLyoqXG4gICAgICogZ2V0L3NldCBvcGFjaXR5LiAgT3BhY2l0eSB2YWx1ZXMgcmFuZ2UgZnJvbSAwIHRvIDEuXG4gICAgICogIEEgbm9kZSB3aXRoIGFuIG9wYWNpdHkgb2YgMCBpcyBmdWxseSB0cmFuc3BhcmVudCwgYW5kIGEgbm9kZVxuICAgICAqICB3aXRoIGFuIG9wYWNpdHkgb2YgMSBpcyBmdWxseSBvcGFxdWVcbiAgICAgKiBAbmFtZSBvcGFjaXR5XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcGFjaXR5XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBvcGFjaXR5XG4gICAgICogdmFyIG9wYWNpdHkgPSBub2RlLm9wYWNpdHkoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBvcGFjaXR5XG4gICAgICogbm9kZS5vcGFjaXR5KDAuNSk7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXIoS29udmEuTm9kZSwgJ25hbWUnKTtcbiAgS29udmEuRmFjdG9yeS5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICduYW1lJyk7XG5cbiAgLyoqXG4gICAgICogZ2V0L3NldCBuYW1lXG4gICAgICogQG5hbWUgbmFtZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgbmFtZVxuICAgICAqIHZhciBuYW1lID0gbm9kZS5uYW1lKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgbmFtZVxuICAgICAqIG5vZGUubmFtZSgnZm9vJyk7XG4gICAgICpcbiAgICAgKiAvLyBhbHNvIG5vZGUgbWF5IGhhdmUgbXVsdGlwbGUgbmFtZXMgKGFzIGNzcyBjbGFzc2VzKVxuICAgICAqIG5vZGUubmFtZSgnZm9vIGJhcicpO1xuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyKEtvbnZhLk5vZGUsICdpZCcpO1xuICBLb252YS5GYWN0b3J5LmFkZE92ZXJsb2FkZWRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2lkJyk7XG5cbiAgLyoqXG4gICAgICogZ2V0L3NldCBpZC4gSWQgaXMgZ2xvYmFsIGZvciB3aG9sZSBwYWdlLlxuICAgICAqIEBuYW1lIGlkXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgaWRcbiAgICAgKiB2YXIgbmFtZSA9IG5vZGUuaWQoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBpZFxuICAgICAqIG5vZGUuaWQoJ2ZvbycpO1xuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdyb3RhdGlvbicsIDApO1xuXG4gIC8qKlxuICAgICAqIGdldC9zZXQgcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBuYW1lIHJvdGF0aW9uXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByb3RhdGlvblxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIHZhciByb3RhdGlvbiA9IG5vZGUucm90YXRpb24oKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogbm9kZS5yb3RhdGlvbig0NSk7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRDb21wb25lbnRzR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdzY2FsZScsIFsneCcsICd5J10pO1xuXG4gIC8qKlxuICAgICAqIGdldC9zZXQgc2NhbGVcbiAgICAgKiBAbmFtZSBzY2FsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZS54XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlLnlcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBzY2FsZVxuICAgICAqIHZhciBzY2FsZSA9IG5vZGUuc2NhbGUoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBzY2FsZVxuICAgICAqIHNoYXBlLnNjYWxlKHtcbiAgICAgKiAgIHg6IDJcbiAgICAgKiAgIHk6IDNcbiAgICAgKiB9KTtcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnc2NhbGVYJywgMSk7XG5cbiAgLyoqXG4gICAgICogZ2V0L3NldCBzY2FsZSB4XG4gICAgICogQG5hbWUgc2NhbGVYXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBzY2FsZSB4XG4gICAgICogdmFyIHNjYWxlWCA9IG5vZGUuc2NhbGVYKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgc2NhbGUgeFxuICAgICAqIG5vZGUuc2NhbGVYKDIpO1xuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdzY2FsZVknLCAxKTtcblxuICAvKipcbiAgICAgKiBnZXQvc2V0IHNjYWxlIHlcbiAgICAgKiBAbmFtZSBzY2FsZVlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHNjYWxlIHlcbiAgICAgKiB2YXIgc2NhbGVZID0gbm9kZS5zY2FsZVkoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBzY2FsZSB5XG4gICAgICogbm9kZS5zY2FsZVkoMik7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRDb21wb25lbnRzR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdza2V3JywgWyd4JywgJ3knXSk7XG5cbiAgLyoqXG4gICAgICogZ2V0L3NldCBza2V3XG4gICAgICogQG5hbWUgc2tld1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBza2V3XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNrZXcueFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBza2V3LnlcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBza2V3XG4gICAgICogdmFyIHNrZXcgPSBub2RlLnNrZXcoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBza2V3XG4gICAgICogbm9kZS5za2V3KHtcbiAgICAgKiAgIHg6IDIwXG4gICAgICogICB5OiAxMFxuICAgICAqIH0pO1xuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdza2V3WCcsIDApO1xuXG4gIC8qKlxuICAgICAqIGdldC9zZXQgc2tldyB4XG4gICAgICogQG5hbWUgc2tld1hcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHNrZXcgeFxuICAgICAqIHZhciBza2V3WCA9IG5vZGUuc2tld1goKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBza2V3IHhcbiAgICAgKiBub2RlLnNrZXdYKDMpO1xuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdza2V3WScsIDApO1xuXG4gIC8qKlxuICAgICAqIGdldC9zZXQgc2tldyB5XG4gICAgICogQG5hbWUgc2tld1lcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHNrZXcgeVxuICAgICAqIHZhciBza2V3WSA9IG5vZGUuc2tld1koKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBza2V3IHlcbiAgICAgKiBub2RlLnNrZXdZKDMpO1xuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkQ29tcG9uZW50c0dldHRlclNldHRlcihLb252YS5Ob2RlLCAnb2Zmc2V0JywgWyd4JywgJ3knXSk7XG5cbiAgLyoqXG4gICAgICogZ2V0L3NldCBvZmZzZXQuICBPZmZzZXRzIHRoZSBkZWZhdWx0IHBvc2l0aW9uIGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2Zmc2V0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldC54XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldC55XG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBvZmZzZXRcbiAgICAgKiB2YXIgb2Zmc2V0ID0gbm9kZS5vZmZzZXQoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBvZmZzZXRcbiAgICAgKiBub2RlLm9mZnNldCh7XG4gICAgICogICB4OiAyMFxuICAgICAqICAgeTogMTBcbiAgICAgKiB9KTtcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnb2Zmc2V0WCcsIDApO1xuXG4gIC8qKlxuICAgICAqIGdldC9zZXQgb2Zmc2V0IHhcbiAgICAgKiBAbmFtZSBvZmZzZXRYXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBvZmZzZXQgeFxuICAgICAqIHZhciBvZmZzZXRYID0gbm9kZS5vZmZzZXRYKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgb2Zmc2V0IHhcbiAgICAgKiBub2RlLm9mZnNldFgoMyk7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ29mZnNldFknLCAwKTtcblxuICAvKipcbiAgICAgKiBnZXQvc2V0IG9mZnNldCB5XG4gICAgICogQG5hbWUgb2Zmc2V0WVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgb2Zmc2V0IHlcbiAgICAgKiB2YXIgb2Zmc2V0WSA9IG5vZGUub2Zmc2V0WSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IG9mZnNldCB5XG4gICAgICogbm9kZS5vZmZzZXRZKDMpO1xuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkU2V0dGVyKEtvbnZhLk5vZGUsICdkcmFnRGlzdGFuY2UnKTtcbiAgS29udmEuRmFjdG9yeS5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdkcmFnRGlzdGFuY2UnKTtcblxuICAvKipcbiAgICAgKiBnZXQvc2V0IGRyYWcgZGlzdGFuY2VcbiAgICAgKiBAbmFtZSBkcmFnRGlzdGFuY2VcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRpc3RhbmNlXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBkcmFnIGRpc3RhbmNlXG4gICAgICogdmFyIGRyYWdEaXN0YW5jZSA9IG5vZGUuZHJhZ0Rpc3RhbmNlKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZGlzdGFuY2VcbiAgICAgKiAvLyBub2RlIHN0YXJ0cyBkcmFnZ2luZyBvbmx5IGlmIHBvaW50ZXIgbW92ZWQgbW9yZSB0aGVuIDMgcGl4ZWxzXG4gICAgICogbm9kZS5kcmFnRGlzdGFuY2UoMyk7XG4gICAgICogLy8gb3Igc2V0IGdsb2JhbGx5XG4gICAgICogS29udmEuZHJhZ0Rpc3RhbmNlID0gMztcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZFNldHRlcihLb252YS5Ob2RlLCAnd2lkdGgnLCAwKTtcbiAgS29udmEuRmFjdG9yeS5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICd3aWR0aCcpO1xuICAvKipcbiAgICAgKiBnZXQvc2V0IHdpZHRoXG4gICAgICogQG5hbWUgd2lkdGhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCB3aWR0aFxuICAgICAqIHZhciB3aWR0aCA9IG5vZGUud2lkdGgoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCB3aWR0aFxuICAgICAqIG5vZGUud2lkdGgoMTAwKTtcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZFNldHRlcihLb252YS5Ob2RlLCAnaGVpZ2h0JywgMCk7XG4gIEtvbnZhLkZhY3RvcnkuYWRkT3ZlcmxvYWRlZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnaGVpZ2h0Jyk7XG4gIC8qKlxuICAgICAqIGdldC9zZXQgaGVpZ2h0XG4gICAgICogQG5hbWUgaGVpZ2h0XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGhlaWdodFxuICAgICAqIHZhciBoZWlnaHQgPSBub2RlLmhlaWdodCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGhlaWdodFxuICAgICAqIG5vZGUuaGVpZ2h0KDEwMCk7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2xpc3RlbmluZycsICdpbmhlcml0Jyk7XG4gIC8qKlxuICAgICAqIGdldC9zZXQgbGlzdGVuaWcgYXR0ci4gIElmIHlvdSBuZWVkIHRvIGRldGVybWluZSBpZiBhIG5vZGUgaXMgbGlzdGVuaW5nIG9yIG5vdFxuICAgICAqICAgYnkgdGFraW5nIGludG8gYWNjb3VudCBpdHMgcGFyZW50cywgdXNlIHRoZSBpc0xpc3RlbmluZygpIG1ldGhvZFxuICAgICAqIEBuYW1lIGxpc3RlbmluZ1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBsaXN0ZW5pbmcgQ2FuIGJlIFwiaW5oZXJpdFwiLCB0cnVlLCBvciBmYWxzZS4gIFRoZSBkZWZhdWx0IGlzIFwiaW5oZXJpdFwiLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufFN0cmluZ31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBsaXN0ZW5pbmcgYXR0clxuICAgICAqIHZhciBsaXN0ZW5pbmcgPSBub2RlLmxpc3RlbmluZygpO1xuICAgICAqXG4gICAgICogLy8gc3RvcCBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIG5vZGUubGlzdGVuaW5nKGZhbHNlKTtcbiAgICAgKlxuICAgICAqIC8vIGxpc3RlbiBmb3IgZXZlbnRzXG4gICAgICogbm9kZS5saXN0ZW5pbmcodHJ1ZSk7XG4gICAgICpcbiAgICAgKiAvLyBsaXN0ZW4gdG8gZXZlbnRzIGFjY29yZGluZyB0byB0aGUgcGFyZW50XG4gICAgICogbm9kZS5saXN0ZW5pbmcoJ2luaGVyaXQnKTtcbiAgICAgKi9cblxuICAvKipcbiAgICAgICogZ2V0L3NldCBwcmV2ZW50RGVmYXVsdFxuICAgICAgKiBCeSBkZWZhdWx0IGFsbCBzaGFwZXMgd2lsbCBwcmV2ZW50IGRlZmF1bHQgYmVoYXZpb3VyXG4gICAgICAqIG9mIGEgYnJvd3NlciBvbiBhIHBvaW50ZXIgbW92ZSBvciB0YXAuXG4gICAgICAqIHRoYXQgd2lsbCBwcmV2ZW50IG5hdGl2ZSBzY3JvbGxpbmcgd2hlbiB5b3UgYXJlIHRyeWluZyB0byBkcmFnJmRyb3AgYSBub2RlXG4gICAgICAqIGJ1dCBzb21ldGltZXMgeW91IG1heSBuZWVkIHRvIGVuYWJsZSBkZWZhdWx0IGFjdGlvbnNcbiAgICAgICogaW4gdGhhdCBjYXNlIHlvdSBjYW4gc2V0IHRoZSBwcm9wZXJ0eSB0byBmYWxzZVxuICAgICAgKiBAbmFtZSBwcmV2ZW50RGVmYXVsdFxuICAgICAgKiBAbWV0aG9kXG4gICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgKiBAcGFyYW0ge051bWJlcn0gcHJldmVudERlZmF1bHRcbiAgICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgICogQGV4YW1wbGVcbiAgICAgICogLy8gZ2V0IHByZXZlbnREZWZhdWx0XG4gICAgICAqIHZhciBzaG91bGRQcmV2ZW50ID0gc2hhcGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICpcbiAgICAgICogLy8gc2V0IHByZXZlbnREZWZhdWx0XG4gICAgICAqIHNoYXBlLnByZXZlbnREZWZhdWx0KGZhbHNlKTtcbiAgICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3ByZXZlbnREZWZhdWx0JywgdHJ1ZSk7XG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2ZpbHRlcnMnLCB1bmRlZmluZWQsIGZ1bmN0aW9uKFxuICAgIHZhbFxuICApIHtcbiAgICB0aGlzLl9maWx0ZXJVcFRvRGF0ZSA9IGZhbHNlO1xuICAgIHJldHVybiB2YWw7XG4gIH0pO1xuICAvKipcbiAgICAgKiBnZXQvc2V0IGZpbHRlcnMuICBGaWx0ZXJzIGFyZSBhcHBsaWVkIHRvIGNhY2hlZCBjYW52YXNlc1xuICAgICAqIEBuYW1lIGZpbHRlcnNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtBcnJheX0gZmlsdGVycyBhcnJheSBvZiBmaWx0ZXJzXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZpbHRlcnNcbiAgICAgKiB2YXIgZmlsdGVycyA9IG5vZGUuZmlsdGVycygpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGEgc2luZ2xlIGZpbHRlclxuICAgICAqIG5vZGUuY2FjaGUoKTtcbiAgICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuQmx1cl0pO1xuICAgICAqXG4gICAgICogLy8gc2V0IG11bHRpcGxlIGZpbHRlcnNcbiAgICAgKiBub2RlLmNhY2hlKCk7XG4gICAgICogbm9kZS5maWx0ZXJzKFtcbiAgICAgKiAgIEtvbnZhLkZpbHRlcnMuQmx1cixcbiAgICAgKiAgIEtvbnZhLkZpbHRlcnMuU2VwaWEsXG4gICAgICogICBLb252YS5GaWx0ZXJzLkludmVydFxuICAgICAqIF0pO1xuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICd2aXNpYmxlJywgJ2luaGVyaXQnKTtcbiAgLyoqXG4gICAgICogZ2V0L3NldCB2aXNpYmxlIGF0dHIuICBDYW4gYmUgXCJpbmhlcml0XCIsIHRydWUsIG9yIGZhbHNlLiAgVGhlIGRlZmF1bHQgaXMgXCJpbmhlcml0XCIuXG4gICAgICogICBJZiB5b3UgbmVlZCB0byBkZXRlcm1pbmUgaWYgYSBub2RlIGlzIHZpc2libGUgb3Igbm90XG4gICAgICogICBieSB0YWtpbmcgaW50byBhY2NvdW50IGl0cyBwYXJlbnRzLCB1c2UgdGhlIGlzVmlzaWJsZSgpIG1ldGhvZFxuICAgICAqIEBuYW1lIHZpc2libGVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gdmlzaWJsZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufFN0cmluZ31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCB2aXNpYmxlIGF0dHJcbiAgICAgKiB2YXIgdmlzaWJsZSA9IG5vZGUudmlzaWJsZSgpO1xuICAgICAqXG4gICAgICogLy8gbWFrZSBpbnZpc2libGVcbiAgICAgKiBub2RlLnZpc2libGUoZmFsc2UpO1xuICAgICAqXG4gICAgICogLy8gbWFrZSB2aXNpYmxlXG4gICAgICogbm9kZS52aXNpYmxlKHRydWUpO1xuICAgICAqXG4gICAgICogLy8gbWFrZSB2aXNpYmxlIGFjY29yZGluZyB0byB0aGUgcGFyZW50XG4gICAgICogbm9kZS52aXNpYmxlKCdpbmhlcml0Jyk7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3RyYW5zZm9ybXNFbmFibGVkJywgJ2FsbCcpO1xuXG4gIC8qKlxuICAgICAqIGdldC9zZXQgdHJhbnNmb3JtcyB0aGF0IGFyZSBlbmFibGVkLiAgQ2FuIGJlIFwiYWxsXCIsIFwibm9uZVwiLCBvciBcInBvc2l0aW9uXCIuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBcImFsbFwiXG4gICAgICogQG5hbWUgdHJhbnNmb3Jtc0VuYWJsZWRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGVuYWJsZWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZW5hYmxlIHBvc2l0aW9uIHRyYW5zZm9ybSBvbmx5IHRvIGltcHJvdmUgZHJhdyBwZXJmb3JtYW5jZVxuICAgICAqIG5vZGUudHJhbnNmb3Jtc0VuYWJsZWQoJ3Bvc2l0aW9uJyk7XG4gICAgICpcbiAgICAgKiAvLyBlbmFibGUgYWxsIHRyYW5zZm9ybXNcbiAgICAgKiBub2RlLnRyYW5zZm9ybXNFbmFibGVkKCdhbGwnKTtcbiAgICAgKi9cblxuICAvKipcbiAgICAgKiBnZXQvc2V0IG5vZGUgc2l6ZVxuICAgICAqIEBuYW1lIHNpemVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNpemVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2l6ZS53aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzaXplLmhlaWdodFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgbm9kZSBzaXplXG4gICAgICogdmFyIHNpemUgPSBub2RlLnNpemUoKTtcbiAgICAgKiB2YXIgeCA9IHNpemUueDtcbiAgICAgKiB2YXIgeSA9IHNpemUueTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBzaXplXG4gICAgICogbm9kZS5zaXplKHtcbiAgICAgKiAgIHdpZHRoOiAxMDAsXG4gICAgICogICBoZWlnaHQ6IDIwMFxuICAgICAqIH0pO1xuICAgICAqL1xuICBLb252YS5GYWN0b3J5LmFkZE92ZXJsb2FkZWRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3NpemUnKTtcblxuICBLb252YS5GYWN0b3J5LmJhY2tDb21wYXQoS29udmEuTm9kZSwge1xuICAgIHJvdGF0ZURlZzogJ3JvdGF0ZScsXG4gICAgc2V0Um90YXRpb25EZWc6ICdzZXRSb3RhdGlvbicsXG4gICAgZ2V0Um90YXRpb25EZWc6ICdnZXRSb3RhdGlvbidcbiAgfSk7XG5cbiAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLk5vZGUpO1xufSkoS29udmEpO1xuXG4oZnVuY3Rpb24oKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG4gIC8qKlxyXG4gICAgKiBHcmF5c2NhbGUgRmlsdGVyXHJcbiAgICAqIEBmdW5jdGlvblxyXG4gICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xyXG4gICAgKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VEYXRhXHJcbiAgICAqIEBleGFtcGxlXHJcbiAgICAqIG5vZGUuY2FjaGUoKTtcclxuICAgICogbm9kZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLkdyYXlzY2FsZV0pO1xyXG4gICAgKi9cclxuICBLb252YS5GaWx0ZXJzLkdyYXlzY2FsZSA9IGZ1bmN0aW9uKGltYWdlRGF0YSkge1xyXG4gICAgdmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YSwgbGVuID0gZGF0YS5sZW5ndGgsIGksIGJyaWdodG5lc3M7XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XHJcbiAgICAgIGJyaWdodG5lc3MgPSAwLjM0ICogZGF0YVtpXSArIDAuNSAqIGRhdGFbaSArIDFdICsgMC4xNiAqIGRhdGFbaSArIDJdO1xyXG4gICAgICAvLyByZWRcclxuICAgICAgZGF0YVtpXSA9IGJyaWdodG5lc3M7XHJcbiAgICAgIC8vIGdyZWVuXHJcbiAgICAgIGRhdGFbaSArIDFdID0gYnJpZ2h0bmVzcztcclxuICAgICAgLy8gYmx1ZVxyXG4gICAgICBkYXRhW2kgKyAyXSA9IGJyaWdodG5lc3M7XHJcbiAgICB9XHJcbiAgfTtcclxufSkoKTtcclxuXG4oZnVuY3Rpb24oS29udmEpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvKipcbiAgICAgKiBCcmlnaHRlbiBGaWx0ZXIuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VEYXRhXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBub2RlLmNhY2hlKCk7XG4gICAgICogbm9kZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLkJyaWdodGVuXSk7XG4gICAgICogbm9kZS5icmlnaHRuZXNzKDAuOCk7XG4gICAgICovXG4gIEtvbnZhLkZpbHRlcnMuQnJpZ2h0ZW4gPSBmdW5jdGlvbihpbWFnZURhdGEpIHtcbiAgICB2YXIgYnJpZ2h0bmVzcyA9IHRoaXMuYnJpZ2h0bmVzcygpICogMjU1LFxuICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgbGVuID0gZGF0YS5sZW5ndGgsXG4gICAgICBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAvLyByZWRcbiAgICAgIGRhdGFbaV0gKz0gYnJpZ2h0bmVzcztcbiAgICAgIC8vIGdyZWVuXG4gICAgICBkYXRhW2kgKyAxXSArPSBicmlnaHRuZXNzO1xuICAgICAgLy8gYmx1ZVxuICAgICAgZGF0YVtpICsgMl0gKz0gYnJpZ2h0bmVzcztcbiAgICB9XG4gIH07XG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuTm9kZSxcbiAgICAnYnJpZ2h0bmVzcycsXG4gICAgMCxcbiAgICBudWxsLFxuICAgIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXJcbiAgKTtcbiAgLyoqXG4gICAgKiBnZXQvc2V0IGZpbHRlciBicmlnaHRuZXNzLiAgVGhlIGJyaWdodG5lc3MgaXMgYSBudW1iZXIgYmV0d2VlbiAtMSBhbmQgMS4mbmJzcDsgUG9zaXRpdmUgdmFsdWVzXG4gICAgKiAgYnJpZ2h0ZW4gdGhlIHBpeGVscyBhbmQgbmVnYXRpdmUgdmFsdWVzIGRhcmtlbiB0aGVtLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5CcmlnaHRlbn0gZmlsdGVyLlxuICAgICogQG5hbWUgYnJpZ2h0bmVzc1xuICAgICogQG1ldGhvZFxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgKiBAcGFyYW0ge051bWJlcn0gYnJpZ2h0bmVzcyB2YWx1ZSBiZXR3ZWVuIC0xIGFuZCAxXG4gICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICovXG59KShLb252YSk7XG5cbihmdW5jdGlvbigpIHtcclxuICAndXNlIHN0cmljdCc7XHJcbiAgLyoqXHJcbiAgICAqIEludmVydCBGaWx0ZXJcclxuICAgICogQGZ1bmN0aW9uXHJcbiAgICAqIEBtZW1iZXJvZiBLb252YS5GaWx0ZXJzXHJcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcclxuICAgICogQGV4YW1wbGVcclxuICAgICogbm9kZS5jYWNoZSgpO1xyXG4gICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuSW52ZXJ0XSk7XHJcbiAgICAqL1xyXG4gIEtvbnZhLkZpbHRlcnMuSW52ZXJ0ID0gZnVuY3Rpb24oaW1hZ2VEYXRhKSB7XHJcbiAgICB2YXIgZGF0YSA9IGltYWdlRGF0YS5kYXRhLCBsZW4gPSBkYXRhLmxlbmd0aCwgaTtcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcclxuICAgICAgLy8gcmVkXHJcbiAgICAgIGRhdGFbaV0gPSAyNTUgLSBkYXRhW2ldO1xyXG4gICAgICAvLyBncmVlblxyXG4gICAgICBkYXRhW2kgKyAxXSA9IDI1NSAtIGRhdGFbaSArIDFdO1xyXG4gICAgICAvLyBibHVlXHJcbiAgICAgIGRhdGFbaSArIDJdID0gMjU1IC0gZGF0YVtpICsgMl07XHJcbiAgICB9XHJcbiAgfTtcclxufSkoKTtcclxuXG4vKlxuIHRoZSBHYXVzcyBmaWx0ZXJcbiBtYXN0ZXIgcmVwbzogaHR0cHM6Ly9naXRodWIuY29tL3BhdmVscG93ZXIva2luZXRpY2pzR2F1c3NGaWx0ZXJcbiovXG4oZnVuY3Rpb24oS29udmEpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvKlxuXG4gICAgIFN0YWNrQmx1ciAtIGEgZmFzdCBhbG1vc3QgR2F1c3NpYW4gQmx1ciBGb3IgQ2FudmFzXG5cbiAgICAgVmVyc2lvbjogICAwLjVcbiAgICAgQXV0aG9yOiAgICBNYXJpbyBLbGluZ2VtYW5uXG4gICAgIENvbnRhY3Q6ICAgbWFyaW9AcXVhc2ltb25kby5jb21cbiAgICAgV2Vic2l0ZTogICBodHRwOi8vd3d3LnF1YXNpbW9uZG8uY29tL1N0YWNrQmx1ckZvckNhbnZhc1xuICAgICBUd2l0dGVyOiAgIEBxdWFzaW1vbmRvXG5cbiAgICAgSW4gY2FzZSB5b3UgZmluZCB0aGlzIGNsYXNzIHVzZWZ1bCAtIGVzcGVjaWFsbHkgaW4gY29tbWVyY2lhbCBwcm9qZWN0cyAtXG4gICAgIEkgYW0gbm90IHRvdGFsbHkgdW5oYXBweSBmb3IgYSBzbWFsbCBkb25hdGlvbiB0byBteSBQYXlQYWwgYWNjb3VudFxuICAgICBtYXJpb0BxdWFzaW1vbmRvLmRlXG5cbiAgICAgT3Igc3VwcG9ydCBtZSBvbiBmbGF0dHI6XG4gICAgIGh0dHBzOi8vZmxhdHRyLmNvbS90aGluZy83Mjc5MS9TdGFja0JsdXItYS1mYXN0LWFsbW9zdC1HYXVzc2lhbi1CbHVyLUVmZmVjdC1mb3ItQ2FudmFzSmF2YXNjcmlwdFxuXG4gICAgIENvcHlyaWdodCAoYykgMjAxMCBNYXJpbyBLbGluZ2VtYW5uXG5cbiAgICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgICAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAgICAgZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XG4gICAgIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuICAgICBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICAgICBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAgICAgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiAgICAgY29uZGl0aW9uczpcblxuICAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICAgICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICAgICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiAgICAgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgICAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbiAgICAgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4gICAgIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICAgICBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXG4gICAgIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAgICAgKi9cblxuICBmdW5jdGlvbiBCbHVyU3RhY2soKSB7XG4gICAgdGhpcy5yID0gMDtcbiAgICB0aGlzLmcgPSAwO1xuICAgIHRoaXMuYiA9IDA7XG4gICAgdGhpcy5hID0gMDtcbiAgICB0aGlzLm5leHQgPSBudWxsO1xuICB9XG5cbiAgdmFyIG11bF90YWJsZSA9IFtcbiAgICA1MTIsXG4gICAgNTEyLFxuICAgIDQ1NixcbiAgICA1MTIsXG4gICAgMzI4LFxuICAgIDQ1NixcbiAgICAzMzUsXG4gICAgNTEyLFxuICAgIDQwNSxcbiAgICAzMjgsXG4gICAgMjcxLFxuICAgIDQ1NixcbiAgICAzODgsXG4gICAgMzM1LFxuICAgIDI5MixcbiAgICA1MTIsXG4gICAgNDU0LFxuICAgIDQwNSxcbiAgICAzNjQsXG4gICAgMzI4LFxuICAgIDI5OCxcbiAgICAyNzEsXG4gICAgNDk2LFxuICAgIDQ1NixcbiAgICA0MjAsXG4gICAgMzg4LFxuICAgIDM2MCxcbiAgICAzMzUsXG4gICAgMzEyLFxuICAgIDI5MixcbiAgICAyNzMsXG4gICAgNTEyLFxuICAgIDQ4MixcbiAgICA0NTQsXG4gICAgNDI4LFxuICAgIDQwNSxcbiAgICAzODMsXG4gICAgMzY0LFxuICAgIDM0NSxcbiAgICAzMjgsXG4gICAgMzEyLFxuICAgIDI5OCxcbiAgICAyODQsXG4gICAgMjcxLFxuICAgIDI1OSxcbiAgICA0OTYsXG4gICAgNDc1LFxuICAgIDQ1NixcbiAgICA0MzcsXG4gICAgNDIwLFxuICAgIDQwNCxcbiAgICAzODgsXG4gICAgMzc0LFxuICAgIDM2MCxcbiAgICAzNDcsXG4gICAgMzM1LFxuICAgIDMyMyxcbiAgICAzMTIsXG4gICAgMzAyLFxuICAgIDI5MixcbiAgICAyODIsXG4gICAgMjczLFxuICAgIDI2NSxcbiAgICA1MTIsXG4gICAgNDk3LFxuICAgIDQ4MixcbiAgICA0NjgsXG4gICAgNDU0LFxuICAgIDQ0MSxcbiAgICA0MjgsXG4gICAgNDE3LFxuICAgIDQwNSxcbiAgICAzOTQsXG4gICAgMzgzLFxuICAgIDM3MyxcbiAgICAzNjQsXG4gICAgMzU0LFxuICAgIDM0NSxcbiAgICAzMzcsXG4gICAgMzI4LFxuICAgIDMyMCxcbiAgICAzMTIsXG4gICAgMzA1LFxuICAgIDI5OCxcbiAgICAyOTEsXG4gICAgMjg0LFxuICAgIDI3OCxcbiAgICAyNzEsXG4gICAgMjY1LFxuICAgIDI1OSxcbiAgICA1MDcsXG4gICAgNDk2LFxuICAgIDQ4NSxcbiAgICA0NzUsXG4gICAgNDY1LFxuICAgIDQ1NixcbiAgICA0NDYsXG4gICAgNDM3LFxuICAgIDQyOCxcbiAgICA0MjAsXG4gICAgNDEyLFxuICAgIDQwNCxcbiAgICAzOTYsXG4gICAgMzg4LFxuICAgIDM4MSxcbiAgICAzNzQsXG4gICAgMzY3LFxuICAgIDM2MCxcbiAgICAzNTQsXG4gICAgMzQ3LFxuICAgIDM0MSxcbiAgICAzMzUsXG4gICAgMzI5LFxuICAgIDMyMyxcbiAgICAzMTgsXG4gICAgMzEyLFxuICAgIDMwNyxcbiAgICAzMDIsXG4gICAgMjk3LFxuICAgIDI5MixcbiAgICAyODcsXG4gICAgMjgyLFxuICAgIDI3OCxcbiAgICAyNzMsXG4gICAgMjY5LFxuICAgIDI2NSxcbiAgICAyNjEsXG4gICAgNTEyLFxuICAgIDUwNSxcbiAgICA0OTcsXG4gICAgNDg5LFxuICAgIDQ4MixcbiAgICA0NzUsXG4gICAgNDY4LFxuICAgIDQ2MSxcbiAgICA0NTQsXG4gICAgNDQ3LFxuICAgIDQ0MSxcbiAgICA0MzUsXG4gICAgNDI4LFxuICAgIDQyMixcbiAgICA0MTcsXG4gICAgNDExLFxuICAgIDQwNSxcbiAgICAzOTksXG4gICAgMzk0LFxuICAgIDM4OSxcbiAgICAzODMsXG4gICAgMzc4LFxuICAgIDM3MyxcbiAgICAzNjgsXG4gICAgMzY0LFxuICAgIDM1OSxcbiAgICAzNTQsXG4gICAgMzUwLFxuICAgIDM0NSxcbiAgICAzNDEsXG4gICAgMzM3LFxuICAgIDMzMixcbiAgICAzMjgsXG4gICAgMzI0LFxuICAgIDMyMCxcbiAgICAzMTYsXG4gICAgMzEyLFxuICAgIDMwOSxcbiAgICAzMDUsXG4gICAgMzAxLFxuICAgIDI5OCxcbiAgICAyOTQsXG4gICAgMjkxLFxuICAgIDI4NyxcbiAgICAyODQsXG4gICAgMjgxLFxuICAgIDI3OCxcbiAgICAyNzQsXG4gICAgMjcxLFxuICAgIDI2OCxcbiAgICAyNjUsXG4gICAgMjYyLFxuICAgIDI1OSxcbiAgICAyNTcsXG4gICAgNTA3LFxuICAgIDUwMSxcbiAgICA0OTYsXG4gICAgNDkxLFxuICAgIDQ4NSxcbiAgICA0ODAsXG4gICAgNDc1LFxuICAgIDQ3MCxcbiAgICA0NjUsXG4gICAgNDYwLFxuICAgIDQ1NixcbiAgICA0NTEsXG4gICAgNDQ2LFxuICAgIDQ0MixcbiAgICA0MzcsXG4gICAgNDMzLFxuICAgIDQyOCxcbiAgICA0MjQsXG4gICAgNDIwLFxuICAgIDQxNixcbiAgICA0MTIsXG4gICAgNDA4LFxuICAgIDQwNCxcbiAgICA0MDAsXG4gICAgMzk2LFxuICAgIDM5MixcbiAgICAzODgsXG4gICAgMzg1LFxuICAgIDM4MSxcbiAgICAzNzcsXG4gICAgMzc0LFxuICAgIDM3MCxcbiAgICAzNjcsXG4gICAgMzYzLFxuICAgIDM2MCxcbiAgICAzNTcsXG4gICAgMzU0LFxuICAgIDM1MCxcbiAgICAzNDcsXG4gICAgMzQ0LFxuICAgIDM0MSxcbiAgICAzMzgsXG4gICAgMzM1LFxuICAgIDMzMixcbiAgICAzMjksXG4gICAgMzI2LFxuICAgIDMyMyxcbiAgICAzMjAsXG4gICAgMzE4LFxuICAgIDMxNSxcbiAgICAzMTIsXG4gICAgMzEwLFxuICAgIDMwNyxcbiAgICAzMDQsXG4gICAgMzAyLFxuICAgIDI5OSxcbiAgICAyOTcsXG4gICAgMjk0LFxuICAgIDI5MixcbiAgICAyODksXG4gICAgMjg3LFxuICAgIDI4NSxcbiAgICAyODIsXG4gICAgMjgwLFxuICAgIDI3OCxcbiAgICAyNzUsXG4gICAgMjczLFxuICAgIDI3MSxcbiAgICAyNjksXG4gICAgMjY3LFxuICAgIDI2NSxcbiAgICAyNjMsXG4gICAgMjYxLFxuICAgIDI1OVxuICBdO1xuXG4gIHZhciBzaGdfdGFibGUgPSBbXG4gICAgOSxcbiAgICAxMSxcbiAgICAxMixcbiAgICAxMyxcbiAgICAxMyxcbiAgICAxNCxcbiAgICAxNCxcbiAgICAxNSxcbiAgICAxNSxcbiAgICAxNSxcbiAgICAxNSxcbiAgICAxNixcbiAgICAxNixcbiAgICAxNixcbiAgICAxNixcbiAgICAxNyxcbiAgICAxNyxcbiAgICAxNyxcbiAgICAxNyxcbiAgICAxNyxcbiAgICAxNyxcbiAgICAxNyxcbiAgICAxOCxcbiAgICAxOCxcbiAgICAxOCxcbiAgICAxOCxcbiAgICAxOCxcbiAgICAxOCxcbiAgICAxOCxcbiAgICAxOCxcbiAgICAxOCxcbiAgICAxOSxcbiAgICAxOSxcbiAgICAxOSxcbiAgICAxOSxcbiAgICAxOSxcbiAgICAxOSxcbiAgICAxOSxcbiAgICAxOSxcbiAgICAxOSxcbiAgICAxOSxcbiAgICAxOSxcbiAgICAxOSxcbiAgICAxOSxcbiAgICAxOSxcbiAgICAyMCxcbiAgICAyMCxcbiAgICAyMCxcbiAgICAyMCxcbiAgICAyMCxcbiAgICAyMCxcbiAgICAyMCxcbiAgICAyMCxcbiAgICAyMCxcbiAgICAyMCxcbiAgICAyMCxcbiAgICAyMCxcbiAgICAyMCxcbiAgICAyMCxcbiAgICAyMCxcbiAgICAyMCxcbiAgICAyMCxcbiAgICAyMCxcbiAgICAyMSxcbiAgICAyMSxcbiAgICAyMSxcbiAgICAyMSxcbiAgICAyMSxcbiAgICAyMSxcbiAgICAyMSxcbiAgICAyMSxcbiAgICAyMSxcbiAgICAyMSxcbiAgICAyMSxcbiAgICAyMSxcbiAgICAyMSxcbiAgICAyMSxcbiAgICAyMSxcbiAgICAyMSxcbiAgICAyMSxcbiAgICAyMSxcbiAgICAyMSxcbiAgICAyMSxcbiAgICAyMSxcbiAgICAyMSxcbiAgICAyMSxcbiAgICAyMSxcbiAgICAyMSxcbiAgICAyMSxcbiAgICAyMSxcbiAgICAyMixcbiAgICAyMixcbiAgICAyMixcbiAgICAyMixcbiAgICAyMixcbiAgICAyMixcbiAgICAyMixcbiAgICAyMixcbiAgICAyMixcbiAgICAyMixcbiAgICAyMixcbiAgICAyMixcbiAgICAyMixcbiAgICAyMixcbiAgICAyMixcbiAgICAyMixcbiAgICAyMixcbiAgICAyMixcbiAgICAyMixcbiAgICAyMixcbiAgICAyMixcbiAgICAyMixcbiAgICAyMixcbiAgICAyMixcbiAgICAyMixcbiAgICAyMixcbiAgICAyMixcbiAgICAyMixcbiAgICAyMixcbiAgICAyMixcbiAgICAyMixcbiAgICAyMixcbiAgICAyMixcbiAgICAyMixcbiAgICAyMixcbiAgICAyMixcbiAgICAyMixcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyMyxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNCxcbiAgICAyNFxuICBdO1xuXG4gIGZ1bmN0aW9uIGZpbHRlckdhdXNzQmx1clJHQkEoaW1hZ2VEYXRhLCByYWRpdXMpIHtcbiAgICB2YXIgcGl4ZWxzID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICB3aWR0aCA9IGltYWdlRGF0YS53aWR0aCxcbiAgICAgIGhlaWdodCA9IGltYWdlRGF0YS5oZWlnaHQ7XG5cbiAgICB2YXIgeCxcbiAgICAgIHksXG4gICAgICBpLFxuICAgICAgcCxcbiAgICAgIHlwLFxuICAgICAgeWksXG4gICAgICB5dyxcbiAgICAgIHJfc3VtLFxuICAgICAgZ19zdW0sXG4gICAgICBiX3N1bSxcbiAgICAgIGFfc3VtLFxuICAgICAgcl9vdXRfc3VtLFxuICAgICAgZ19vdXRfc3VtLFxuICAgICAgYl9vdXRfc3VtLFxuICAgICAgYV9vdXRfc3VtLFxuICAgICAgcl9pbl9zdW0sXG4gICAgICBnX2luX3N1bSxcbiAgICAgIGJfaW5fc3VtLFxuICAgICAgYV9pbl9zdW0sXG4gICAgICBwcixcbiAgICAgIHBnLFxuICAgICAgcGIsXG4gICAgICBwYSxcbiAgICAgIHJicztcblxuICAgIHZhciBkaXYgPSByYWRpdXMgKyByYWRpdXMgKyAxLFxuICAgICAgd2lkdGhNaW51czEgPSB3aWR0aCAtIDEsXG4gICAgICBoZWlnaHRNaW51czEgPSBoZWlnaHQgLSAxLFxuICAgICAgcmFkaXVzUGx1czEgPSByYWRpdXMgKyAxLFxuICAgICAgc3VtRmFjdG9yID0gcmFkaXVzUGx1czEgKiAocmFkaXVzUGx1czEgKyAxKSAvIDIsXG4gICAgICBzdGFja1N0YXJ0ID0gbmV3IEJsdXJTdGFjaygpLFxuICAgICAgc3RhY2tFbmQgPSBudWxsLFxuICAgICAgc3RhY2sgPSBzdGFja1N0YXJ0LFxuICAgICAgc3RhY2tJbiA9IG51bGwsXG4gICAgICBzdGFja091dCA9IG51bGwsXG4gICAgICBtdWxfc3VtID0gbXVsX3RhYmxlW3JhZGl1c10sXG4gICAgICBzaGdfc3VtID0gc2hnX3RhYmxlW3JhZGl1c107XG5cbiAgICBmb3IgKGkgPSAxOyBpIDwgZGl2OyBpKyspIHtcbiAgICAgIHN0YWNrID0gc3RhY2submV4dCA9IG5ldyBCbHVyU3RhY2soKTtcbiAgICAgIGlmIChpID09PSByYWRpdXNQbHVzMSkge1xuICAgICAgICBzdGFja0VuZCA9IHN0YWNrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN0YWNrLm5leHQgPSBzdGFja1N0YXJ0O1xuXG4gICAgeXcgPSB5aSA9IDA7XG5cbiAgICBmb3IgKHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgIHJfaW5fc3VtID0gZ19pbl9zdW0gPSBiX2luX3N1bSA9IGFfaW5fc3VtID0gcl9zdW0gPSBnX3N1bSA9IGJfc3VtID0gYV9zdW0gPSAwO1xuXG4gICAgICByX291dF9zdW0gPSByYWRpdXNQbHVzMSAqIChwciA9IHBpeGVsc1t5aV0pO1xuICAgICAgZ19vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAocGcgPSBwaXhlbHNbeWkgKyAxXSk7XG4gICAgICBiX291dF9zdW0gPSByYWRpdXNQbHVzMSAqIChwYiA9IHBpeGVsc1t5aSArIDJdKTtcbiAgICAgIGFfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKHBhID0gcGl4ZWxzW3lpICsgM10pO1xuXG4gICAgICByX3N1bSArPSBzdW1GYWN0b3IgKiBwcjtcbiAgICAgIGdfc3VtICs9IHN1bUZhY3RvciAqIHBnO1xuICAgICAgYl9zdW0gKz0gc3VtRmFjdG9yICogcGI7XG4gICAgICBhX3N1bSArPSBzdW1GYWN0b3IgKiBwYTtcblxuICAgICAgc3RhY2sgPSBzdGFja1N0YXJ0O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcmFkaXVzUGx1czE7IGkrKykge1xuICAgICAgICBzdGFjay5yID0gcHI7XG4gICAgICAgIHN0YWNrLmcgPSBwZztcbiAgICAgICAgc3RhY2suYiA9IHBiO1xuICAgICAgICBzdGFjay5hID0gcGE7XG4gICAgICAgIHN0YWNrID0gc3RhY2submV4dDtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMTsgaSA8IHJhZGl1c1BsdXMxOyBpKyspIHtcbiAgICAgICAgcCA9IHlpICsgKCh3aWR0aE1pbnVzMSA8IGkgPyB3aWR0aE1pbnVzMSA6IGkpIDw8IDIpO1xuICAgICAgICByX3N1bSArPSAoc3RhY2suciA9IHByID0gcGl4ZWxzW3BdKSAqIChyYnMgPSByYWRpdXNQbHVzMSAtIGkpO1xuICAgICAgICBnX3N1bSArPSAoc3RhY2suZyA9IHBnID0gcGl4ZWxzW3AgKyAxXSkgKiByYnM7XG4gICAgICAgIGJfc3VtICs9IChzdGFjay5iID0gcGIgPSBwaXhlbHNbcCArIDJdKSAqIHJicztcbiAgICAgICAgYV9zdW0gKz0gKHN0YWNrLmEgPSBwYSA9IHBpeGVsc1twICsgM10pICogcmJzO1xuXG4gICAgICAgIHJfaW5fc3VtICs9IHByO1xuICAgICAgICBnX2luX3N1bSArPSBwZztcbiAgICAgICAgYl9pbl9zdW0gKz0gcGI7XG4gICAgICAgIGFfaW5fc3VtICs9IHBhO1xuXG4gICAgICAgIHN0YWNrID0gc3RhY2submV4dDtcbiAgICAgIH1cblxuICAgICAgc3RhY2tJbiA9IHN0YWNrU3RhcnQ7XG4gICAgICBzdGFja091dCA9IHN0YWNrRW5kO1xuICAgICAgZm9yICh4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgcGl4ZWxzW3lpICsgM10gPSBwYSA9IChhX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW07XG4gICAgICAgIGlmIChwYSAhPT0gMCkge1xuICAgICAgICAgIHBhID0gMjU1IC8gcGE7XG4gICAgICAgICAgcGl4ZWxzW3lpXSA9ICgocl9zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtKSAqIHBhO1xuICAgICAgICAgIHBpeGVsc1t5aSArIDFdID0gKChnX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW0pICogcGE7XG4gICAgICAgICAgcGl4ZWxzW3lpICsgMl0gPSAoKGJfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bSkgKiBwYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwaXhlbHNbeWldID0gcGl4ZWxzW3lpICsgMV0gPSBwaXhlbHNbeWkgKyAyXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICByX3N1bSAtPSByX291dF9zdW07XG4gICAgICAgIGdfc3VtIC09IGdfb3V0X3N1bTtcbiAgICAgICAgYl9zdW0gLT0gYl9vdXRfc3VtO1xuICAgICAgICBhX3N1bSAtPSBhX291dF9zdW07XG5cbiAgICAgICAgcl9vdXRfc3VtIC09IHN0YWNrSW4ucjtcbiAgICAgICAgZ19vdXRfc3VtIC09IHN0YWNrSW4uZztcbiAgICAgICAgYl9vdXRfc3VtIC09IHN0YWNrSW4uYjtcbiAgICAgICAgYV9vdXRfc3VtIC09IHN0YWNrSW4uYTtcblxuICAgICAgICBwID0gKHl3ICsgKChwID0geCArIHJhZGl1cyArIDEpIDwgd2lkdGhNaW51czEgPyBwIDogd2lkdGhNaW51czEpKSA8PCAyO1xuXG4gICAgICAgIHJfaW5fc3VtICs9IHN0YWNrSW4uciA9IHBpeGVsc1twXTtcbiAgICAgICAgZ19pbl9zdW0gKz0gc3RhY2tJbi5nID0gcGl4ZWxzW3AgKyAxXTtcbiAgICAgICAgYl9pbl9zdW0gKz0gc3RhY2tJbi5iID0gcGl4ZWxzW3AgKyAyXTtcbiAgICAgICAgYV9pbl9zdW0gKz0gc3RhY2tJbi5hID0gcGl4ZWxzW3AgKyAzXTtcblxuICAgICAgICByX3N1bSArPSByX2luX3N1bTtcbiAgICAgICAgZ19zdW0gKz0gZ19pbl9zdW07XG4gICAgICAgIGJfc3VtICs9IGJfaW5fc3VtO1xuICAgICAgICBhX3N1bSArPSBhX2luX3N1bTtcblxuICAgICAgICBzdGFja0luID0gc3RhY2tJbi5uZXh0O1xuXG4gICAgICAgIHJfb3V0X3N1bSArPSBwciA9IHN0YWNrT3V0LnI7XG4gICAgICAgIGdfb3V0X3N1bSArPSBwZyA9IHN0YWNrT3V0Lmc7XG4gICAgICAgIGJfb3V0X3N1bSArPSBwYiA9IHN0YWNrT3V0LmI7XG4gICAgICAgIGFfb3V0X3N1bSArPSBwYSA9IHN0YWNrT3V0LmE7XG5cbiAgICAgICAgcl9pbl9zdW0gLT0gcHI7XG4gICAgICAgIGdfaW5fc3VtIC09IHBnO1xuICAgICAgICBiX2luX3N1bSAtPSBwYjtcbiAgICAgICAgYV9pbl9zdW0gLT0gcGE7XG5cbiAgICAgICAgc3RhY2tPdXQgPSBzdGFja091dC5uZXh0O1xuXG4gICAgICAgIHlpICs9IDQ7XG4gICAgICB9XG4gICAgICB5dyArPSB3aWR0aDtcbiAgICB9XG5cbiAgICBmb3IgKHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgZ19pbl9zdW0gPSBiX2luX3N1bSA9IGFfaW5fc3VtID0gcl9pbl9zdW0gPSBnX3N1bSA9IGJfc3VtID0gYV9zdW0gPSByX3N1bSA9IDA7XG5cbiAgICAgIHlpID0geCA8PCAyO1xuICAgICAgcl9vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAocHIgPSBwaXhlbHNbeWldKTtcbiAgICAgIGdfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKHBnID0gcGl4ZWxzW3lpICsgMV0pO1xuICAgICAgYl9vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAocGIgPSBwaXhlbHNbeWkgKyAyXSk7XG4gICAgICBhX291dF9zdW0gPSByYWRpdXNQbHVzMSAqIChwYSA9IHBpeGVsc1t5aSArIDNdKTtcblxuICAgICAgcl9zdW0gKz0gc3VtRmFjdG9yICogcHI7XG4gICAgICBnX3N1bSArPSBzdW1GYWN0b3IgKiBwZztcbiAgICAgIGJfc3VtICs9IHN1bUZhY3RvciAqIHBiO1xuICAgICAgYV9zdW0gKz0gc3VtRmFjdG9yICogcGE7XG5cbiAgICAgIHN0YWNrID0gc3RhY2tTdGFydDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHJhZGl1c1BsdXMxOyBpKyspIHtcbiAgICAgICAgc3RhY2suciA9IHByO1xuICAgICAgICBzdGFjay5nID0gcGc7XG4gICAgICAgIHN0YWNrLmIgPSBwYjtcbiAgICAgICAgc3RhY2suYSA9IHBhO1xuICAgICAgICBzdGFjayA9IHN0YWNrLm5leHQ7XG4gICAgICB9XG5cbiAgICAgIHlwID0gd2lkdGg7XG5cbiAgICAgIGZvciAoaSA9IDE7IGkgPD0gcmFkaXVzOyBpKyspIHtcbiAgICAgICAgeWkgPSAoeXAgKyB4KSA8PCAyO1xuXG4gICAgICAgIHJfc3VtICs9IChzdGFjay5yID0gcHIgPSBwaXhlbHNbeWldKSAqIChyYnMgPSByYWRpdXNQbHVzMSAtIGkpO1xuICAgICAgICBnX3N1bSArPSAoc3RhY2suZyA9IHBnID0gcGl4ZWxzW3lpICsgMV0pICogcmJzO1xuICAgICAgICBiX3N1bSArPSAoc3RhY2suYiA9IHBiID0gcGl4ZWxzW3lpICsgMl0pICogcmJzO1xuICAgICAgICBhX3N1bSArPSAoc3RhY2suYSA9IHBhID0gcGl4ZWxzW3lpICsgM10pICogcmJzO1xuXG4gICAgICAgIHJfaW5fc3VtICs9IHByO1xuICAgICAgICBnX2luX3N1bSArPSBwZztcbiAgICAgICAgYl9pbl9zdW0gKz0gcGI7XG4gICAgICAgIGFfaW5fc3VtICs9IHBhO1xuXG4gICAgICAgIHN0YWNrID0gc3RhY2submV4dDtcblxuICAgICAgICBpZiAoaSA8IGhlaWdodE1pbnVzMSkge1xuICAgICAgICAgIHlwICs9IHdpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHlpID0geDtcbiAgICAgIHN0YWNrSW4gPSBzdGFja1N0YXJ0O1xuICAgICAgc3RhY2tPdXQgPSBzdGFja0VuZDtcbiAgICAgIGZvciAoeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICBwID0geWkgPDwgMjtcbiAgICAgICAgcGl4ZWxzW3AgKyAzXSA9IHBhID0gKGFfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bTtcbiAgICAgICAgaWYgKHBhID4gMCkge1xuICAgICAgICAgIHBhID0gMjU1IC8gcGE7XG4gICAgICAgICAgcGl4ZWxzW3BdID0gKChyX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW0pICogcGE7XG4gICAgICAgICAgcGl4ZWxzW3AgKyAxXSA9ICgoZ19zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtKSAqIHBhO1xuICAgICAgICAgIHBpeGVsc1twICsgMl0gPSAoKGJfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bSkgKiBwYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwaXhlbHNbcF0gPSBwaXhlbHNbcCArIDFdID0gcGl4ZWxzW3AgKyAyXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICByX3N1bSAtPSByX291dF9zdW07XG4gICAgICAgIGdfc3VtIC09IGdfb3V0X3N1bTtcbiAgICAgICAgYl9zdW0gLT0gYl9vdXRfc3VtO1xuICAgICAgICBhX3N1bSAtPSBhX291dF9zdW07XG5cbiAgICAgICAgcl9vdXRfc3VtIC09IHN0YWNrSW4ucjtcbiAgICAgICAgZ19vdXRfc3VtIC09IHN0YWNrSW4uZztcbiAgICAgICAgYl9vdXRfc3VtIC09IHN0YWNrSW4uYjtcbiAgICAgICAgYV9vdXRfc3VtIC09IHN0YWNrSW4uYTtcblxuICAgICAgICBwID1cbiAgICAgICAgICAoeCArXG4gICAgICAgICAgICAoKHAgPSB5ICsgcmFkaXVzUGx1czEpIDwgaGVpZ2h0TWludXMxID8gcCA6IGhlaWdodE1pbnVzMSkgKlxuICAgICAgICAgICAgICB3aWR0aCkgPDxcbiAgICAgICAgICAyO1xuXG4gICAgICAgIHJfc3VtICs9IHJfaW5fc3VtICs9IHN0YWNrSW4uciA9IHBpeGVsc1twXTtcbiAgICAgICAgZ19zdW0gKz0gZ19pbl9zdW0gKz0gc3RhY2tJbi5nID0gcGl4ZWxzW3AgKyAxXTtcbiAgICAgICAgYl9zdW0gKz0gYl9pbl9zdW0gKz0gc3RhY2tJbi5iID0gcGl4ZWxzW3AgKyAyXTtcbiAgICAgICAgYV9zdW0gKz0gYV9pbl9zdW0gKz0gc3RhY2tJbi5hID0gcGl4ZWxzW3AgKyAzXTtcblxuICAgICAgICBzdGFja0luID0gc3RhY2tJbi5uZXh0O1xuXG4gICAgICAgIHJfb3V0X3N1bSArPSBwciA9IHN0YWNrT3V0LnI7XG4gICAgICAgIGdfb3V0X3N1bSArPSBwZyA9IHN0YWNrT3V0Lmc7XG4gICAgICAgIGJfb3V0X3N1bSArPSBwYiA9IHN0YWNrT3V0LmI7XG4gICAgICAgIGFfb3V0X3N1bSArPSBwYSA9IHN0YWNrT3V0LmE7XG5cbiAgICAgICAgcl9pbl9zdW0gLT0gcHI7XG4gICAgICAgIGdfaW5fc3VtIC09IHBnO1xuICAgICAgICBiX2luX3N1bSAtPSBwYjtcbiAgICAgICAgYV9pbl9zdW0gLT0gcGE7XG5cbiAgICAgICAgc3RhY2tPdXQgPSBzdGFja091dC5uZXh0O1xuXG4gICAgICAgIHlpICs9IHdpZHRoO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgICAqIEJsdXIgRmlsdGVyXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG5hbWUgQmx1clxuICAgICAqIEBtZW1iZXJvZiBLb252YS5GaWx0ZXJzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGltYWdlRGF0YVxuICAgICAqIEBleGFtcGxlXG4gICAgICogbm9kZS5jYWNoZSgpO1xuICAgICAqIG5vZGUuZmlsdGVycyhbS29udmEuRmlsdGVycy5CbHVyXSk7XG4gICAgICogbm9kZS5ibHVyUmFkaXVzKDEwKTtcbiAgICAgKi9cbiAgS29udmEuRmlsdGVycy5CbHVyID0gZnVuY3Rpb24gQmx1cihpbWFnZURhdGEpIHtcbiAgICB2YXIgcmFkaXVzID0gTWF0aC5yb3VuZCh0aGlzLmJsdXJSYWRpdXMoKSk7XG5cbiAgICBpZiAocmFkaXVzID4gMCkge1xuICAgICAgZmlsdGVyR2F1c3NCbHVyUkdCQShpbWFnZURhdGEsIHJhZGl1cyk7XG4gICAgfVxuICB9O1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLk5vZGUsXG4gICAgJ2JsdXJSYWRpdXMnLFxuICAgIDAsXG4gICAgbnVsbCxcbiAgICBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyXG4gICk7XG5cbiAgLyoqXG4gICAgKiBnZXQvc2V0IGJsdXIgcmFkaXVzLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5CbHVyfSBmaWx0ZXJcbiAgICAqIEBuYW1lIGJsdXJSYWRpdXNcbiAgICAqIEBtZXRob2RcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICogQHBhcmFtIHtJbnRlZ2VyfSByYWRpdXNcbiAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfVxuICAgICovXG59KShLb252YSk7XG5cbi8qZXNsaW50LWRpc2FibGUgIG1heC1kZXB0aCAqL1xuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIGZ1bmN0aW9uIHBpeGVsQXQoaWRhdGEsIHgsIHkpIHtcbiAgICB2YXIgaWR4ID0gKHkgKiBpZGF0YS53aWR0aCArIHgpICogNDtcbiAgICB2YXIgZCA9IFtdO1xuICAgIGQucHVzaChcbiAgICAgIGlkYXRhLmRhdGFbaWR4KytdLFxuICAgICAgaWRhdGEuZGF0YVtpZHgrK10sXG4gICAgICBpZGF0YS5kYXRhW2lkeCsrXSxcbiAgICAgIGlkYXRhLmRhdGFbaWR4KytdXG4gICAgKTtcbiAgICByZXR1cm4gZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJnYkRpc3RhbmNlKHAxLCBwMikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoXG4gICAgICBNYXRoLnBvdyhwMVswXSAtIHAyWzBdLCAyKSArXG4gICAgICAgIE1hdGgucG93KHAxWzFdIC0gcDJbMV0sIDIpICtcbiAgICAgICAgTWF0aC5wb3cocDFbMl0gLSBwMlsyXSwgMilcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gcmdiTWVhbihwVGFiKSB7XG4gICAgdmFyIG0gPSBbMCwgMCwgMF07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBUYWIubGVuZ3RoOyBpKyspIHtcbiAgICAgIG1bMF0gKz0gcFRhYltpXVswXTtcbiAgICAgIG1bMV0gKz0gcFRhYltpXVsxXTtcbiAgICAgIG1bMl0gKz0gcFRhYltpXVsyXTtcbiAgICB9XG5cbiAgICBtWzBdIC89IHBUYWIubGVuZ3RoO1xuICAgIG1bMV0gLz0gcFRhYi5sZW5ndGg7XG4gICAgbVsyXSAvPSBwVGFiLmxlbmd0aDtcblxuICAgIHJldHVybiBtO1xuICB9XG5cbiAgZnVuY3Rpb24gYmFja2dyb3VuZE1hc2soaWRhdGEsIHRocmVzaG9sZCkge1xuICAgIHZhciByZ2J2X25vID0gcGl4ZWxBdChpZGF0YSwgMCwgMCk7XG4gICAgdmFyIHJnYnZfbmUgPSBwaXhlbEF0KGlkYXRhLCBpZGF0YS53aWR0aCAtIDEsIDApO1xuICAgIHZhciByZ2J2X3NvID0gcGl4ZWxBdChpZGF0YSwgMCwgaWRhdGEuaGVpZ2h0IC0gMSk7XG4gICAgdmFyIHJnYnZfc2UgPSBwaXhlbEF0KGlkYXRhLCBpZGF0YS53aWR0aCAtIDEsIGlkYXRhLmhlaWdodCAtIDEpO1xuXG4gICAgdmFyIHRocmVzID0gdGhyZXNob2xkIHx8IDEwO1xuICAgIGlmIChcbiAgICAgIHJnYkRpc3RhbmNlKHJnYnZfbm8sIHJnYnZfbmUpIDwgdGhyZXMgJiZcbiAgICAgIHJnYkRpc3RhbmNlKHJnYnZfbmUsIHJnYnZfc2UpIDwgdGhyZXMgJiZcbiAgICAgIHJnYkRpc3RhbmNlKHJnYnZfc2UsIHJnYnZfc28pIDwgdGhyZXMgJiZcbiAgICAgIHJnYkRpc3RhbmNlKHJnYnZfc28sIHJnYnZfbm8pIDwgdGhyZXNcbiAgICApIHtcbiAgICAgIC8vIE1lYW4gY29sb3JcbiAgICAgIHZhciBtZWFuID0gcmdiTWVhbihbcmdidl9uZSwgcmdidl9ubywgcmdidl9zZSwgcmdidl9zb10pO1xuXG4gICAgICAvLyBNYXNrIGJhc2VkIG9uIGNvbG9yIGRpc3RhbmNlXG4gICAgICB2YXIgbWFzayA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZGF0YS53aWR0aCAqIGlkYXRhLmhlaWdodDsgaSsrKSB7XG4gICAgICAgIHZhciBkID0gcmdiRGlzdGFuY2UobWVhbiwgW1xuICAgICAgICAgIGlkYXRhLmRhdGFbaSAqIDRdLFxuICAgICAgICAgIGlkYXRhLmRhdGFbaSAqIDQgKyAxXSxcbiAgICAgICAgICBpZGF0YS5kYXRhW2kgKiA0ICsgMl1cbiAgICAgICAgXSk7XG4gICAgICAgIG1hc2tbaV0gPSBkIDwgdGhyZXMgPyAwIDogMjU1O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFzaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseU1hc2soaWRhdGEsIG1hc2spIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkYXRhLndpZHRoICogaWRhdGEuaGVpZ2h0OyBpKyspIHtcbiAgICAgIGlkYXRhLmRhdGFbNCAqIGkgKyAzXSA9IG1hc2tbaV07XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZXJvZGVNYXNrKG1hc2ssIHN3LCBzaCkge1xuICAgIHZhciB3ZWlnaHRzID0gWzEsIDEsIDEsIDEsIDAsIDEsIDEsIDEsIDFdO1xuICAgIHZhciBzaWRlID0gTWF0aC5yb3VuZChNYXRoLnNxcnQod2VpZ2h0cy5sZW5ndGgpKTtcbiAgICB2YXIgaGFsZlNpZGUgPSBNYXRoLmZsb29yKHNpZGUgLyAyKTtcblxuICAgIHZhciBtYXNrUmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgeSA9IDA7IHkgPCBzaDsgeSsrKSB7XG4gICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHN3OyB4KyspIHtcbiAgICAgICAgdmFyIHNvID0geSAqIHN3ICsgeDtcbiAgICAgICAgdmFyIGEgPSAwO1xuICAgICAgICBmb3IgKHZhciBjeSA9IDA7IGN5IDwgc2lkZTsgY3krKykge1xuICAgICAgICAgIGZvciAodmFyIGN4ID0gMDsgY3ggPCBzaWRlOyBjeCsrKSB7XG4gICAgICAgICAgICB2YXIgc2N5ID0geSArIGN5IC0gaGFsZlNpZGU7XG4gICAgICAgICAgICB2YXIgc2N4ID0geCArIGN4IC0gaGFsZlNpZGU7XG5cbiAgICAgICAgICAgIGlmIChzY3kgPj0gMCAmJiBzY3kgPCBzaCAmJiBzY3ggPj0gMCAmJiBzY3ggPCBzdykge1xuICAgICAgICAgICAgICB2YXIgc3JjT2ZmID0gc2N5ICogc3cgKyBzY3g7XG4gICAgICAgICAgICAgIHZhciB3dCA9IHdlaWdodHNbY3kgKiBzaWRlICsgY3hdO1xuXG4gICAgICAgICAgICAgIGEgKz0gbWFza1tzcmNPZmZdICogd3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWFza1Jlc3VsdFtzb10gPSBhID09PSAyNTUgKiA4ID8gMjU1IDogMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWFza1Jlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRpbGF0ZU1hc2sobWFzaywgc3csIHNoKSB7XG4gICAgdmFyIHdlaWdodHMgPSBbMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMV07XG4gICAgdmFyIHNpZGUgPSBNYXRoLnJvdW5kKE1hdGguc3FydCh3ZWlnaHRzLmxlbmd0aCkpO1xuICAgIHZhciBoYWxmU2lkZSA9IE1hdGguZmxvb3Ioc2lkZSAvIDIpO1xuXG4gICAgdmFyIG1hc2tSZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciB5ID0gMDsgeSA8IHNoOyB5KyspIHtcbiAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgc3c7IHgrKykge1xuICAgICAgICB2YXIgc28gPSB5ICogc3cgKyB4O1xuICAgICAgICB2YXIgYSA9IDA7XG4gICAgICAgIGZvciAodmFyIGN5ID0gMDsgY3kgPCBzaWRlOyBjeSsrKSB7XG4gICAgICAgICAgZm9yICh2YXIgY3ggPSAwOyBjeCA8IHNpZGU7IGN4KyspIHtcbiAgICAgICAgICAgIHZhciBzY3kgPSB5ICsgY3kgLSBoYWxmU2lkZTtcbiAgICAgICAgICAgIHZhciBzY3ggPSB4ICsgY3ggLSBoYWxmU2lkZTtcblxuICAgICAgICAgICAgaWYgKHNjeSA+PSAwICYmIHNjeSA8IHNoICYmIHNjeCA+PSAwICYmIHNjeCA8IHN3KSB7XG4gICAgICAgICAgICAgIHZhciBzcmNPZmYgPSBzY3kgKiBzdyArIHNjeDtcbiAgICAgICAgICAgICAgdmFyIHd0ID0gd2VpZ2h0c1tjeSAqIHNpZGUgKyBjeF07XG5cbiAgICAgICAgICAgICAgYSArPSBtYXNrW3NyY09mZl0gKiB3dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtYXNrUmVzdWx0W3NvXSA9IGEgPj0gMjU1ICogNCA/IDI1NSA6IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hc2tSZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBzbW9vdGhFZGdlTWFzayhtYXNrLCBzdywgc2gpIHtcbiAgICB2YXIgd2VpZ2h0cyA9IFtcbiAgICAgIDEgLyA5LFxuICAgICAgMSAvIDksXG4gICAgICAxIC8gOSxcbiAgICAgIDEgLyA5LFxuICAgICAgMSAvIDksXG4gICAgICAxIC8gOSxcbiAgICAgIDEgLyA5LFxuICAgICAgMSAvIDksXG4gICAgICAxIC8gOVxuICAgIF07XG4gICAgdmFyIHNpZGUgPSBNYXRoLnJvdW5kKE1hdGguc3FydCh3ZWlnaHRzLmxlbmd0aCkpO1xuICAgIHZhciBoYWxmU2lkZSA9IE1hdGguZmxvb3Ioc2lkZSAvIDIpO1xuXG4gICAgdmFyIG1hc2tSZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciB5ID0gMDsgeSA8IHNoOyB5KyspIHtcbiAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgc3c7IHgrKykge1xuICAgICAgICB2YXIgc28gPSB5ICogc3cgKyB4O1xuICAgICAgICB2YXIgYSA9IDA7XG4gICAgICAgIGZvciAodmFyIGN5ID0gMDsgY3kgPCBzaWRlOyBjeSsrKSB7XG4gICAgICAgICAgZm9yICh2YXIgY3ggPSAwOyBjeCA8IHNpZGU7IGN4KyspIHtcbiAgICAgICAgICAgIHZhciBzY3kgPSB5ICsgY3kgLSBoYWxmU2lkZTtcbiAgICAgICAgICAgIHZhciBzY3ggPSB4ICsgY3ggLSBoYWxmU2lkZTtcblxuICAgICAgICAgICAgaWYgKHNjeSA+PSAwICYmIHNjeSA8IHNoICYmIHNjeCA+PSAwICYmIHNjeCA8IHN3KSB7XG4gICAgICAgICAgICAgIHZhciBzcmNPZmYgPSBzY3kgKiBzdyArIHNjeDtcbiAgICAgICAgICAgICAgdmFyIHd0ID0gd2VpZ2h0c1tjeSAqIHNpZGUgKyBjeF07XG5cbiAgICAgICAgICAgICAgYSArPSBtYXNrW3NyY09mZl0gKiB3dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtYXNrUmVzdWx0W3NvXSA9IGE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hc2tSZXN1bHQ7XG4gIH1cblxuICAvKipcblx0ICogTWFzayBGaWx0ZXJcblx0ICogQGZ1bmN0aW9uXG5cdCAqIEBuYW1lIE1hc2tcblx0ICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcblx0ICogQHBhcmFtIHtPYmplY3R9IGltYWdlRGF0YVxuXHQgKiBAZXhhbXBsZVxuICAgICAqIG5vZGUuY2FjaGUoKTtcbiAgICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuTWFza10pO1xuICAgICAqIG5vZGUudGhyZXNob2xkKDIwMCk7XG5cdCAqL1xuICBLb252YS5GaWx0ZXJzLk1hc2sgPSBmdW5jdGlvbihpbWFnZURhdGEpIHtcbiAgICAvLyBEZXRlY3QgcGl4ZWxzIGNsb3NlIHRvIHRoZSBiYWNrZ3JvdW5kIGNvbG9yXG4gICAgdmFyIHRocmVzaG9sZCA9IHRoaXMudGhyZXNob2xkKCksXG4gICAgICBtYXNrID0gYmFja2dyb3VuZE1hc2soaW1hZ2VEYXRhLCB0aHJlc2hvbGQpO1xuICAgIGlmIChtYXNrKSB7XG4gICAgICAvLyBFcm9kZVxuICAgICAgbWFzayA9IGVyb2RlTWFzayhtYXNrLCBpbWFnZURhdGEud2lkdGgsIGltYWdlRGF0YS5oZWlnaHQpO1xuXG4gICAgICAvLyBEaWxhdGVcbiAgICAgIG1hc2sgPSBkaWxhdGVNYXNrKG1hc2ssIGltYWdlRGF0YS53aWR0aCwgaW1hZ2VEYXRhLmhlaWdodCk7XG5cbiAgICAgIC8vIEdyYWRpZW50XG4gICAgICBtYXNrID0gc21vb3RoRWRnZU1hc2sobWFzaywgaW1hZ2VEYXRhLndpZHRoLCBpbWFnZURhdGEuaGVpZ2h0KTtcblxuICAgICAgLy8gQXBwbHkgbWFza1xuICAgICAgYXBwbHlNYXNrKGltYWdlRGF0YSwgbWFzayk7XG5cbiAgICAgIC8vIHRvZG8gOiBVcGRhdGUgaGl0IHJlZ2lvbiBmdW5jdGlvbiBhY2NvcmRpbmcgdG8gbWFza1xuICAgIH1cblxuICAgIHJldHVybiBpbWFnZURhdGE7XG4gIH07XG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuTm9kZSxcbiAgICAndGhyZXNob2xkJyxcbiAgICAwLFxuICAgIG51bGwsXG4gICAgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlclxuICApO1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIC8qKlxuICAgICAqIFJHQiBGaWx0ZXJcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbmFtZSBSR0JcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcbiAgICAgKiBAYXV0aG9yIGlwcG82MTVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG5vZGUuY2FjaGUoKTtcbiAgICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuUkdCXSk7XG4gICAgICogbm9kZS5ibHVlKDEyMCk7XG4gICAgICogbm9kZS5ncmVlbigyMDApO1xuICAgICAqL1xuICBLb252YS5GaWx0ZXJzLlJHQiA9IGZ1bmN0aW9uKGltYWdlRGF0YSkge1xuICAgIHZhciBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICBuUGl4ZWxzID0gZGF0YS5sZW5ndGgsXG4gICAgICByZWQgPSB0aGlzLnJlZCgpLFxuICAgICAgZ3JlZW4gPSB0aGlzLmdyZWVuKCksXG4gICAgICBibHVlID0gdGhpcy5ibHVlKCksXG4gICAgICBpLFxuICAgICAgYnJpZ2h0bmVzcztcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuUGl4ZWxzOyBpICs9IDQpIHtcbiAgICAgIGJyaWdodG5lc3MgPVxuICAgICAgICAoMC4zNCAqIGRhdGFbaV0gKyAwLjUgKiBkYXRhW2kgKyAxXSArIDAuMTYgKiBkYXRhW2kgKyAyXSkgLyAyNTU7XG4gICAgICBkYXRhW2ldID0gYnJpZ2h0bmVzcyAqIHJlZDsgLy8gclxuICAgICAgZGF0YVtpICsgMV0gPSBicmlnaHRuZXNzICogZ3JlZW47IC8vIGdcbiAgICAgIGRhdGFbaSArIDJdID0gYnJpZ2h0bmVzcyAqIGJsdWU7IC8vIGJcbiAgICAgIGRhdGFbaSArIDNdID0gZGF0YVtpICsgM107IC8vIGFscGhhXG4gICAgfVxuICB9O1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdyZWQnLCAwLCBmdW5jdGlvbih2YWwpIHtcbiAgICB0aGlzLl9maWx0ZXJVcFRvRGF0ZSA9IGZhbHNlO1xuICAgIGlmICh2YWwgPiAyNTUpIHtcbiAgICAgIHJldHVybiAyNTU7XG4gICAgfSBlbHNlIGlmICh2YWwgPCAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQodmFsKTtcbiAgICB9XG4gIH0pO1xuICAvKipcbiAgICAqIGdldC9zZXQgZmlsdGVyIHJlZCB2YWx1ZS4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuUkdCfSBmaWx0ZXIuXG4gICAgKiBAbmFtZSByZWRcbiAgICAqIEBtZXRob2RcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICogQHBhcmFtIHtJbnRlZ2VyfSByZWQgdmFsdWUgYmV0d2VlbiAwIGFuZCAyNTVcbiAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfVxuICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2dyZWVuJywgMCwgZnVuY3Rpb24odmFsKSB7XG4gICAgdGhpcy5fZmlsdGVyVXBUb0RhdGUgPSBmYWxzZTtcbiAgICBpZiAodmFsID4gMjU1KSB7XG4gICAgICByZXR1cm4gMjU1O1xuICAgIH0gZWxzZSBpZiAodmFsIDwgMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbCk7XG4gICAgfVxuICB9KTtcbiAgLyoqXG4gICAgKiBnZXQvc2V0IGZpbHRlciBncmVlbiB2YWx1ZS4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuUkdCfSBmaWx0ZXIuXG4gICAgKiBAbmFtZSBncmVlblxuICAgICogQG1ldGhvZFxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgKiBAcGFyYW0ge0ludGVnZXJ9IGdyZWVuIHZhbHVlIGJldHdlZW4gMCBhbmQgMjU1XG4gICAgKiBAcmV0dXJucyB7SW50ZWdlcn1cbiAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLk5vZGUsXG4gICAgJ2JsdWUnLFxuICAgIDAsXG4gICAgS29udmEuVmFsaWRhdG9ycy5SR0JDb21wb25lbnQsXG4gICAgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlclxuICApO1xuICAvKipcbiAgICAqIGdldC9zZXQgZmlsdGVyIGJsdWUgdmFsdWUuIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLlJHQn0gZmlsdGVyLlxuICAgICogQG5hbWUgYmx1ZVxuICAgICogQG1ldGhvZFxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgKiBAcGFyYW0ge0ludGVnZXJ9IGJsdWUgdmFsdWUgYmV0d2VlbiAwIGFuZCAyNTVcbiAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfVxuICAgICovXG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLyoqXG4gICAgICogUkdCQSBGaWx0ZXJcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbmFtZSBSR0JBXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VEYXRhXG4gICAgICogQGF1dGhvciBjb2RlZm9cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG5vZGUuY2FjaGUoKTtcbiAgICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuUkdCQV0pO1xuICAgICAqIG5vZGUuYmx1ZSgxMjApO1xuICAgICAqIG5vZGUuZ3JlZW4oMjAwKTtcbiAgICAgKiBub2RlLmFscGhhKDAuMyk7XG4gICAgICovXG4gIEtvbnZhLkZpbHRlcnMuUkdCQSA9IGZ1bmN0aW9uKGltYWdlRGF0YSkge1xuICAgIHZhciBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICBuUGl4ZWxzID0gZGF0YS5sZW5ndGgsXG4gICAgICByZWQgPSB0aGlzLnJlZCgpLFxuICAgICAgZ3JlZW4gPSB0aGlzLmdyZWVuKCksXG4gICAgICBibHVlID0gdGhpcy5ibHVlKCksXG4gICAgICBhbHBoYSA9IHRoaXMuYWxwaGEoKSxcbiAgICAgIGksXG4gICAgICBpYTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuUGl4ZWxzOyBpICs9IDQpIHtcbiAgICAgIGlhID0gMSAtIGFscGhhO1xuXG4gICAgICBkYXRhW2ldID0gcmVkICogYWxwaGEgKyBkYXRhW2ldICogaWE7IC8vIHJcbiAgICAgIGRhdGFbaSArIDFdID0gZ3JlZW4gKiBhbHBoYSArIGRhdGFbaSArIDFdICogaWE7IC8vIGdcbiAgICAgIGRhdGFbaSArIDJdID0gYmx1ZSAqIGFscGhhICsgZGF0YVtpICsgMl0gKiBpYTsgLy8gYlxuICAgIH1cbiAgfTtcblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAncmVkJywgMCwgZnVuY3Rpb24odmFsKSB7XG4gICAgdGhpcy5fZmlsdGVyVXBUb0RhdGUgPSBmYWxzZTtcbiAgICBpZiAodmFsID4gMjU1KSB7XG4gICAgICByZXR1cm4gMjU1O1xuICAgIH0gZWxzZSBpZiAodmFsIDwgMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbCk7XG4gICAgfVxuICB9KTtcbiAgLyoqXG4gICAgKiBnZXQvc2V0IGZpbHRlciByZWQgdmFsdWUuIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLlJHQkF9IGZpbHRlci5cbiAgICAqIEBuYW1lIHJlZFxuICAgICogQG1ldGhvZFxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgKiBAcGFyYW0ge0ludGVnZXJ9IHJlZCB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDI1NVxuICAgICogQHJldHVybnMge0ludGVnZXJ9XG4gICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnZ3JlZW4nLCAwLCBmdW5jdGlvbih2YWwpIHtcbiAgICB0aGlzLl9maWx0ZXJVcFRvRGF0ZSA9IGZhbHNlO1xuICAgIGlmICh2YWwgPiAyNTUpIHtcbiAgICAgIHJldHVybiAyNTU7XG4gICAgfSBlbHNlIGlmICh2YWwgPCAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQodmFsKTtcbiAgICB9XG4gIH0pO1xuICAvKipcbiAgICAqIGdldC9zZXQgZmlsdGVyIGdyZWVuIHZhbHVlLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5SR0JBfSBmaWx0ZXIuXG4gICAgKiBAbmFtZSBncmVlblxuICAgICogQG1ldGhvZFxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgKiBAcGFyYW0ge0ludGVnZXJ9IGdyZWVuIHZhbHVlIGJldHdlZW4gMCBhbmQgMjU1XG4gICAgKiBAcmV0dXJucyB7SW50ZWdlcn1cbiAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLk5vZGUsXG4gICAgJ2JsdWUnLFxuICAgIDAsXG4gICAgS29udmEuVmFsaWRhdG9ycy5SR0JDb21wb25lbnQsXG4gICAgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlclxuICApO1xuICAvKipcbiAgICAqIGdldC9zZXQgZmlsdGVyIGJsdWUgdmFsdWUuIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLlJHQkF9IGZpbHRlci5cbiAgICAqIEBuYW1lIGJsdWVcbiAgICAqIEBtZXRob2RcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICogQHBhcmFtIHtJbnRlZ2VyfSBibHVlIHZhbHVlIGJldHdlZW4gMCBhbmQgMjU1XG4gICAgKiBAcmV0dXJucyB7SW50ZWdlcn1cbiAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdhbHBoYScsIDEsIGZ1bmN0aW9uKHZhbCkge1xuICAgIHRoaXMuX2ZpbHRlclVwVG9EYXRlID0gZmFsc2U7XG4gICAgaWYgKHZhbCA+IDEpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAodmFsIDwgMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICB9KTtcbiAgLyoqXG4gICAgICogZ2V0L3NldCBmaWx0ZXIgYWxwaGEgdmFsdWUuIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLlJHQkF9IGZpbHRlci5cbiAgICAgKiBAbmFtZSBhbHBoYVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0Zsb2F0fSBhbHBoYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcmV0dXJucyB7RmxvYXR9XG4gICAgICovXG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLyoqXG4gICAgKiBIU1YgRmlsdGVyLiBBZGp1c3RzIHRoZSBodWUsIHNhdHVyYXRpb24gYW5kIHZhbHVlXG4gICAgKiBAZnVuY3Rpb25cbiAgICAqIEBuYW1lIEhTVlxuICAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcbiAgICAqIEBhdXRob3IgaXBwbzYxNVxuICAgICogQGV4YW1wbGVcbiAgICAqIGltYWdlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuSFNWXSk7XG4gICAgKiBpbWFnZS52YWx1ZSgyMDApO1xuICAgICovXG5cbiAgS29udmEuRmlsdGVycy5IU1YgPSBmdW5jdGlvbihpbWFnZURhdGEpIHtcbiAgICB2YXIgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgblBpeGVscyA9IGRhdGEubGVuZ3RoLFxuICAgICAgdiA9IE1hdGgucG93KDIsIHRoaXMudmFsdWUoKSksXG4gICAgICBzID0gTWF0aC5wb3coMiwgdGhpcy5zYXR1cmF0aW9uKCkpLFxuICAgICAgaCA9IE1hdGguYWJzKHRoaXMuaHVlKCkgKyAzNjApICUgMzYwLFxuICAgICAgaTtcblxuICAgIC8vIEJhc2lzIGZvciB0aGUgdGVjaG5pcXVlIHVzZWQ6XG4gICAgLy8gaHR0cDovL2JlZXNidXp6LmJpei9jb2RlL2hzdl9jb2xvcl90cmFuc2Zvcm1zLnBocFxuICAgIC8vIFYgaXMgdGhlIHZhbHVlIG11bHRpcGxpZXIgKDEgZm9yIG5vbmUsIDIgZm9yIGRvdWJsZSwgMC41IGZvciBoYWxmKVxuICAgIC8vIFMgaXMgdGhlIHNhdHVyYXRpb24gbXVsdGlwbGllciAoMSBmb3Igbm9uZSwgMiBmb3IgZG91YmxlLCAwLjUgZm9yIGhhbGYpXG4gICAgLy8gSCBpcyB0aGUgaHVlIHNoaWZ0IGluIGRlZ3JlZXMgKDAgdG8gMzYwKVxuICAgIC8vIHZzdSA9IFYqUypjb3MoSCpQSS8xODApO1xuICAgIC8vIHZzdyA9IFYqUypzaW4oSCpQSS8xODApO1xuICAgIC8vWyAuMjk5VisuNzAxdnN1Ky4xNjh2c3cgICAgLjU4N1YtLjU4N3ZzdSsuMzMwdnN3ICAgIC4xMTRWLS4xMTR2c3UtLjQ5N3ZzdyBdIFtSXVxuICAgIC8vWyAuMjk5Vi0uMjk5dnN1LS4zMjh2c3cgICAgLjU4N1YrLjQxM3ZzdSsuMDM1dnN3ICAgIC4xMTRWLS4xMTR2c3UrLjI5MnZzdyBdKltHXVxuICAgIC8vWyAuMjk5Vi0uMzAwdnN1KzEuMjV2c3cgICAgLjU4N1YtLjU4OHZzdS0xLjA1dnN3ICAgIC4xMTRWKy44ODZ2c3UtLjIwM3ZzdyBdIFtCXVxuXG4gICAgLy8gUHJlY29tcHV0ZSB0aGUgdmFsdWVzIGluIHRoZSBtYXRyaXg6XG4gICAgdmFyIHZzdSA9IHYgKiBzICogTWF0aC5jb3MoaCAqIE1hdGguUEkgLyAxODApLFxuICAgICAgdnN3ID0gdiAqIHMgKiBNYXRoLnNpbihoICogTWF0aC5QSSAvIDE4MCk7XG4gICAgLy8gKHJlc3VsdCBzcG90KShzb3VyY2Ugc3BvdClcbiAgICB2YXIgcnIgPSAwLjI5OSAqIHYgKyAwLjcwMSAqIHZzdSArIDAuMTY3ICogdnN3LFxuICAgICAgcmcgPSAwLjU4NyAqIHYgLSAwLjU4NyAqIHZzdSArIDAuMzMwICogdnN3LFxuICAgICAgcmIgPSAwLjExNCAqIHYgLSAwLjExNCAqIHZzdSAtIDAuNDk3ICogdnN3O1xuICAgIHZhciBnciA9IDAuMjk5ICogdiAtIDAuMjk5ICogdnN1IC0gMC4zMjggKiB2c3csXG4gICAgICBnZyA9IDAuNTg3ICogdiArIDAuNDEzICogdnN1ICsgMC4wMzUgKiB2c3csXG4gICAgICBnYiA9IDAuMTE0ICogdiAtIDAuMTE0ICogdnN1ICsgMC4yOTMgKiB2c3c7XG4gICAgdmFyIGJyID0gMC4yOTkgKiB2IC0gMC4zMDAgKiB2c3UgKyAxLjI1MCAqIHZzdyxcbiAgICAgIGJnID0gMC41ODcgKiB2IC0gMC41ODYgKiB2c3UgLSAxLjA1MCAqIHZzdyxcbiAgICAgIGJiID0gMC4xMTQgKiB2ICsgMC44ODYgKiB2c3UgLSAwLjIwMCAqIHZzdztcblxuICAgIHZhciByLCBnLCBiLCBhO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG5QaXhlbHM7IGkgKz0gNCkge1xuICAgICAgciA9IGRhdGFbaSArIDBdO1xuICAgICAgZyA9IGRhdGFbaSArIDFdO1xuICAgICAgYiA9IGRhdGFbaSArIDJdO1xuICAgICAgYSA9IGRhdGFbaSArIDNdO1xuXG4gICAgICBkYXRhW2kgKyAwXSA9IHJyICogciArIHJnICogZyArIHJiICogYjtcbiAgICAgIGRhdGFbaSArIDFdID0gZ3IgKiByICsgZ2cgKiBnICsgZ2IgKiBiO1xuICAgICAgZGF0YVtpICsgMl0gPSBiciAqIHIgKyBiZyAqIGcgKyBiYiAqIGI7XG4gICAgICBkYXRhW2kgKyAzXSA9IGE7IC8vIGFscGhhXG4gICAgfVxuICB9O1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLk5vZGUsXG4gICAgJ2h1ZScsXG4gICAgMCxcbiAgICBudWxsLFxuICAgIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXJcbiAgKTtcbiAgLyoqXG4gICAgKiBnZXQvc2V0IGhzdiBodWUgaW4gZGVncmVlcy4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuSFNWfSBvciB7QGxpbmsgS29udmEuRmlsdGVycy5IU0x9IGZpbHRlci5cbiAgICAqIEBuYW1lIGh1ZVxuICAgICogQG1ldGhvZFxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgKiBAcGFyYW0ge051bWJlcn0gaHVlIHZhbHVlIGJldHdlZW4gMCBhbmQgMzU5XG4gICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuTm9kZSxcbiAgICAnc2F0dXJhdGlvbicsXG4gICAgMCxcbiAgICBudWxsLFxuICAgIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXJcbiAgKTtcbiAgLyoqXG4gICAgKiBnZXQvc2V0IGhzdiBzYXR1cmF0aW9uLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5IU1Z9IG9yIHtAbGluayBLb252YS5GaWx0ZXJzLkhTTH0gZmlsdGVyLlxuICAgICogQG5hbWUgc2F0dXJhdGlvblxuICAgICogQG1ldGhvZFxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgKiBAcGFyYW0ge051bWJlcn0gc2F0dXJhdGlvbiAwIGlzIG5vIGNoYW5nZSwgLTEuMCBoYWx2ZXMgdGhlIHNhdHVyYXRpb24sIDEuMCBkb3VibGVzLCBldGMuLlxuICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLk5vZGUsXG4gICAgJ3ZhbHVlJyxcbiAgICAwLFxuICAgIG51bGwsXG4gICAgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlclxuICApO1xuICAvKipcbiAgICAqIGdldC9zZXQgaHN2IHZhbHVlLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5IU1Z9IGZpbHRlci5cbiAgICAqIEBuYW1lIHZhbHVlXG4gICAgKiBAbWV0aG9kXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAwIGlzIG5vIGNoYW5nZSwgLTEuMCBoYWx2ZXMgdGhlIHZhbHVlLCAxLjAgZG91YmxlcywgZXRjLi5cbiAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgKi9cbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5Ob2RlLFxuICAgICdodWUnLFxuICAgIDAsXG4gICAgbnVsbCxcbiAgICBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyXG4gICk7XG4gIC8qKlxuICAgICogZ2V0L3NldCBoc3YgaHVlIGluIGRlZ3JlZXMuIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkhTVn0gb3Ige0BsaW5rIEtvbnZhLkZpbHRlcnMuSFNMfSBmaWx0ZXIuXG4gICAgKiBAbmFtZSBodWVcbiAgICAqIEBtZXRob2RcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICogQHBhcmFtIHtOdW1iZXJ9IGh1ZSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDM1OVxuICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLk5vZGUsXG4gICAgJ3NhdHVyYXRpb24nLFxuICAgIDAsXG4gICAgbnVsbCxcbiAgICBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyXG4gICk7XG4gIC8qKlxuICAgICogZ2V0L3NldCBoc3Ygc2F0dXJhdGlvbi4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuSFNWfSBvciB7QGxpbmsgS29udmEuRmlsdGVycy5IU0x9IGZpbHRlci5cbiAgICAqIEBuYW1lIHNhdHVyYXRpb25cbiAgICAqIEBtZXRob2RcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICogQHBhcmFtIHtOdW1iZXJ9IHNhdHVyYXRpb24gMCBpcyBubyBjaGFuZ2UsIC0xLjAgaGFsdmVzIHRoZSBzYXR1cmF0aW9uLCAxLjAgZG91YmxlcywgZXRjLi5cbiAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5Ob2RlLFxuICAgICdsdW1pbmFuY2UnLFxuICAgIDAsXG4gICAgbnVsbCxcbiAgICBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyXG4gICk7XG4gIC8qKlxuICAgICogZ2V0L3NldCBoc2wgbHVtaW5hbmNlLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5IU0x9IGZpbHRlci5cbiAgICAqIEBuYW1lIHZhbHVlXG4gICAgKiBAbWV0aG9kXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAwIGlzIG5vIGNoYW5nZSwgLTEuMCBoYWx2ZXMgdGhlIHZhbHVlLCAxLjAgZG91YmxlcywgZXRjLi5cbiAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgKi9cblxuICAvKipcbiAgICAqIEhTTCBGaWx0ZXIuIEFkanVzdHMgdGhlIGh1ZSwgc2F0dXJhdGlvbiBhbmQgbHVtaW5hbmNlIChvciBsaWdodG5lc3MpXG4gICAgKiBAZnVuY3Rpb25cbiAgICAqIEBtZW1iZXJvZiBLb252YS5GaWx0ZXJzXG4gICAgKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VEYXRhXG4gICAgKiBAYXV0aG9yIGlwcG82MTVcbiAgICAqIEBleGFtcGxlXG4gICAgKiBpbWFnZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLkhTTF0pO1xuICAgICogaW1hZ2UubHVtaW5hbmNlKDIwMCk7XG4gICAgKi9cblxuICBLb252YS5GaWx0ZXJzLkhTTCA9IGZ1bmN0aW9uKGltYWdlRGF0YSkge1xuICAgIHZhciBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICBuUGl4ZWxzID0gZGF0YS5sZW5ndGgsXG4gICAgICB2ID0gMSxcbiAgICAgIHMgPSBNYXRoLnBvdygyLCB0aGlzLnNhdHVyYXRpb24oKSksXG4gICAgICBoID0gTWF0aC5hYnModGhpcy5odWUoKSArIDM2MCkgJSAzNjAsXG4gICAgICBsID0gdGhpcy5sdW1pbmFuY2UoKSAqIDEyNyxcbiAgICAgIGk7XG5cbiAgICAvLyBCYXNpcyBmb3IgdGhlIHRlY2huaXF1ZSB1c2VkOlxuICAgIC8vIGh0dHA6Ly9iZWVzYnV6ei5iaXovY29kZS9oc3ZfY29sb3JfdHJhbnNmb3Jtcy5waHBcbiAgICAvLyBWIGlzIHRoZSB2YWx1ZSBtdWx0aXBsaWVyICgxIGZvciBub25lLCAyIGZvciBkb3VibGUsIDAuNSBmb3IgaGFsZilcbiAgICAvLyBTIGlzIHRoZSBzYXR1cmF0aW9uIG11bHRpcGxpZXIgKDEgZm9yIG5vbmUsIDIgZm9yIGRvdWJsZSwgMC41IGZvciBoYWxmKVxuICAgIC8vIEggaXMgdGhlIGh1ZSBzaGlmdCBpbiBkZWdyZWVzICgwIHRvIDM2MClcbiAgICAvLyB2c3UgPSBWKlMqY29zKEgqUEkvMTgwKTtcbiAgICAvLyB2c3cgPSBWKlMqc2luKEgqUEkvMTgwKTtcbiAgICAvL1sgLjI5OVYrLjcwMXZzdSsuMTY4dnN3ICAgIC41ODdWLS41ODd2c3UrLjMzMHZzdyAgICAuMTE0Vi0uMTE0dnN1LS40OTd2c3cgXSBbUl1cbiAgICAvL1sgLjI5OVYtLjI5OXZzdS0uMzI4dnN3ICAgIC41ODdWKy40MTN2c3UrLjAzNXZzdyAgICAuMTE0Vi0uMTE0dnN1Ky4yOTJ2c3cgXSpbR11cbiAgICAvL1sgLjI5OVYtLjMwMHZzdSsxLjI1dnN3ICAgIC41ODdWLS41ODh2c3UtMS4wNXZzdyAgICAuMTE0VisuODg2dnN1LS4yMDN2c3cgXSBbQl1cblxuICAgIC8vIFByZWNvbXB1dGUgdGhlIHZhbHVlcyBpbiB0aGUgbWF0cml4OlxuICAgIHZhciB2c3UgPSB2ICogcyAqIE1hdGguY29zKGggKiBNYXRoLlBJIC8gMTgwKSxcbiAgICAgIHZzdyA9IHYgKiBzICogTWF0aC5zaW4oaCAqIE1hdGguUEkgLyAxODApO1xuICAgIC8vIChyZXN1bHQgc3BvdCkoc291cmNlIHNwb3QpXG4gICAgdmFyIHJyID0gMC4yOTkgKiB2ICsgMC43MDEgKiB2c3UgKyAwLjE2NyAqIHZzdyxcbiAgICAgIHJnID0gMC41ODcgKiB2IC0gMC41ODcgKiB2c3UgKyAwLjMzMCAqIHZzdyxcbiAgICAgIHJiID0gMC4xMTQgKiB2IC0gMC4xMTQgKiB2c3UgLSAwLjQ5NyAqIHZzdztcbiAgICB2YXIgZ3IgPSAwLjI5OSAqIHYgLSAwLjI5OSAqIHZzdSAtIDAuMzI4ICogdnN3LFxuICAgICAgZ2cgPSAwLjU4NyAqIHYgKyAwLjQxMyAqIHZzdSArIDAuMDM1ICogdnN3LFxuICAgICAgZ2IgPSAwLjExNCAqIHYgLSAwLjExNCAqIHZzdSArIDAuMjkzICogdnN3O1xuICAgIHZhciBiciA9IDAuMjk5ICogdiAtIDAuMzAwICogdnN1ICsgMS4yNTAgKiB2c3csXG4gICAgICBiZyA9IDAuNTg3ICogdiAtIDAuNTg2ICogdnN1IC0gMS4wNTAgKiB2c3csXG4gICAgICBiYiA9IDAuMTE0ICogdiArIDAuODg2ICogdnN1IC0gMC4yMDAgKiB2c3c7XG5cbiAgICB2YXIgciwgZywgYiwgYTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuUGl4ZWxzOyBpICs9IDQpIHtcbiAgICAgIHIgPSBkYXRhW2kgKyAwXTtcbiAgICAgIGcgPSBkYXRhW2kgKyAxXTtcbiAgICAgIGIgPSBkYXRhW2kgKyAyXTtcbiAgICAgIGEgPSBkYXRhW2kgKyAzXTtcblxuICAgICAgZGF0YVtpICsgMF0gPSByciAqIHIgKyByZyAqIGcgKyByYiAqIGIgKyBsO1xuICAgICAgZGF0YVtpICsgMV0gPSBnciAqIHIgKyBnZyAqIGcgKyBnYiAqIGIgKyBsO1xuICAgICAgZGF0YVtpICsgMl0gPSBiciAqIHIgKyBiZyAqIGcgKyBiYiAqIGIgKyBsO1xuICAgICAgZGF0YVtpICsgM10gPSBhOyAvLyBhbHBoYVxuICAgIH1cbiAgfTtcbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvKipcbiAgICAgKiBFbWJvc3MgRmlsdGVyLlxuICAgICAqIFBpeGFzdGljIExpYiAtIEVtYm9zcyBmaWx0ZXIgLSB2MC4xLjBcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMDggSmFjb2IgU2VpZGVsaW4sIGpzZWlkZWxpbkBuaWhpbG9naWMuZGssIGh0dHA6Ly9ibG9nLm5paGlsb2dpYy5kay9cbiAgICAgKiBMaWNlbnNlOiBbaHR0cDovL3d3dy5waXhhc3RpYy5jb20vbGliL2xpY2Vuc2UudHh0XVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBLb252YS5GaWx0ZXJzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGltYWdlRGF0YVxuICAgICAqIEBleGFtcGxlXG4gICAgICogbm9kZS5jYWNoZSgpO1xuICAgICAqIG5vZGUuZmlsdGVycyhbS29udmEuRmlsdGVycy5FbWJvc3NdKTtcbiAgICAgKiBub2RlLmVtYm9zc1N0cmVuZ3RoKDAuOCk7XG4gICAgICogbm9kZS5lbWJvc3NXaGl0ZUxldmVsKDAuMyk7XG4gICAgICogbm9kZS5lbWJvc3NEaXJlY3Rpb24oJ3JpZ2h0Jyk7XG4gICAgICogbm9kZS5lbWJvc3NCbGVuZCh0cnVlKTtcbiAgICAgKi9cbiAgS29udmEuRmlsdGVycy5FbWJvc3MgPSBmdW5jdGlvbihpbWFnZURhdGEpIHtcbiAgICAvLyBwaXhhc3RpYyBzdHJlbmd0aCBpcyBiZXR3ZWVuIDAgYW5kIDEwLiAgSSB3YW50IGl0IGJldHdlZW4gMCBhbmQgMVxuICAgIC8vIHBpeGFzdGljIGdyZXlMZXZlbCBpcyBiZXR3ZWVuIDAgYW5kIDI1NS4gIEkgd2FudCBpdCBiZXR3ZWVuIDAgYW5kIDEuICBBbHNvLFxuICAgIC8vIGEgbWF4IHZhbHVlIG9mIGdyZXlMZXZlbCB5aWVsZHMgYSB3aGl0ZSBlbWJvc3MsIGFuZCB0aGUgbWluIHZhbHVlIHlpZWxkcyBhIGJsYWNrXG4gICAgLy8gZW1ib3NzLiAgVGhlcmVmb3JlLCBJIGNoYW5nZWQgZ3JleUxldmVsIHRvIHdoaXRlTGV2ZWxcbiAgICB2YXIgc3RyZW5ndGggPSB0aGlzLmVtYm9zc1N0cmVuZ3RoKCkgKiAxMCxcbiAgICAgIGdyZXlMZXZlbCA9IHRoaXMuZW1ib3NzV2hpdGVMZXZlbCgpICogMjU1LFxuICAgICAgZGlyZWN0aW9uID0gdGhpcy5lbWJvc3NEaXJlY3Rpb24oKSxcbiAgICAgIGJsZW5kID0gdGhpcy5lbWJvc3NCbGVuZCgpLFxuICAgICAgZGlyWSA9IDAsXG4gICAgICBkaXJYID0gMCxcbiAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgIHcgPSBpbWFnZURhdGEud2lkdGgsXG4gICAgICBoID0gaW1hZ2VEYXRhLmhlaWdodCxcbiAgICAgIHc0ID0gdyAqIDQsXG4gICAgICB5ID0gaDtcblxuICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICBjYXNlICd0b3AtbGVmdCc6XG4gICAgICAgIGRpclkgPSAtMTtcbiAgICAgICAgZGlyWCA9IC0xO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgIGRpclkgPSAtMTtcbiAgICAgICAgZGlyWCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wLXJpZ2h0JzpcbiAgICAgICAgZGlyWSA9IC0xO1xuICAgICAgICBkaXJYID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgIGRpclkgPSAwO1xuICAgICAgICBkaXJYID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdib3R0b20tcmlnaHQnOlxuICAgICAgICBkaXJZID0gMTtcbiAgICAgICAgZGlyWCA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgZGlyWSA9IDE7XG4gICAgICAgIGRpclggPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JvdHRvbS1sZWZ0JzpcbiAgICAgICAgZGlyWSA9IDE7XG4gICAgICAgIGRpclggPSAtMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgZGlyWSA9IDA7XG4gICAgICAgIGRpclggPSAtMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBLb252YS5VdGlsLmVycm9yKCdVbmtub3duIGVtYm9zcyBkaXJlY3Rpb246ICcgKyBkaXJlY3Rpb24pO1xuICAgIH1cblxuICAgIGRvIHtcbiAgICAgIHZhciBvZmZzZXRZID0gKHkgLSAxKSAqIHc0O1xuXG4gICAgICB2YXIgb3RoZXJZID0gZGlyWTtcbiAgICAgIGlmICh5ICsgb3RoZXJZIDwgMSkge1xuICAgICAgICBvdGhlclkgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKHkgKyBvdGhlclkgPiBoKSB7XG4gICAgICAgIG90aGVyWSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBvZmZzZXRZT3RoZXIgPSAoeSAtIDEgKyBvdGhlclkpICogdyAqIDQ7XG5cbiAgICAgIHZhciB4ID0gdztcbiAgICAgIGRvIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IG9mZnNldFkgKyAoeCAtIDEpICogNDtcblxuICAgICAgICB2YXIgb3RoZXJYID0gZGlyWDtcbiAgICAgICAgaWYgKHggKyBvdGhlclggPCAxKSB7XG4gICAgICAgICAgb3RoZXJYID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCArIG90aGVyWCA+IHcpIHtcbiAgICAgICAgICBvdGhlclggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9mZnNldE90aGVyID0gb2Zmc2V0WU90aGVyICsgKHggLSAxICsgb3RoZXJYKSAqIDQ7XG5cbiAgICAgICAgdmFyIGRSID0gZGF0YVtvZmZzZXRdIC0gZGF0YVtvZmZzZXRPdGhlcl07XG4gICAgICAgIHZhciBkRyA9IGRhdGFbb2Zmc2V0ICsgMV0gLSBkYXRhW29mZnNldE90aGVyICsgMV07XG4gICAgICAgIHZhciBkQiA9IGRhdGFbb2Zmc2V0ICsgMl0gLSBkYXRhW29mZnNldE90aGVyICsgMl07XG5cbiAgICAgICAgdmFyIGRpZiA9IGRSO1xuICAgICAgICB2YXIgYWJzRGlmID0gZGlmID4gMCA/IGRpZiA6IC1kaWY7XG5cbiAgICAgICAgdmFyIGFic0cgPSBkRyA+IDAgPyBkRyA6IC1kRztcbiAgICAgICAgdmFyIGFic0IgPSBkQiA+IDAgPyBkQiA6IC1kQjtcblxuICAgICAgICBpZiAoYWJzRyA+IGFic0RpZikge1xuICAgICAgICAgIGRpZiA9IGRHO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhYnNCID4gYWJzRGlmKSB7XG4gICAgICAgICAgZGlmID0gZEI7XG4gICAgICAgIH1cblxuICAgICAgICBkaWYgKj0gc3RyZW5ndGg7XG5cbiAgICAgICAgaWYgKGJsZW5kKSB7XG4gICAgICAgICAgdmFyIHIgPSBkYXRhW29mZnNldF0gKyBkaWY7XG4gICAgICAgICAgdmFyIGcgPSBkYXRhW29mZnNldCArIDFdICsgZGlmO1xuICAgICAgICAgIHZhciBiID0gZGF0YVtvZmZzZXQgKyAyXSArIGRpZjtcblxuICAgICAgICAgIGRhdGFbb2Zmc2V0XSA9IHIgPiAyNTUgPyAyNTUgOiByIDwgMCA/IDAgOiByO1xuICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgMV0gPSBnID4gMjU1ID8gMjU1IDogZyA8IDAgPyAwIDogZztcbiAgICAgICAgICBkYXRhW29mZnNldCArIDJdID0gYiA+IDI1NSA/IDI1NSA6IGIgPCAwID8gMCA6IGI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGdyZXkgPSBncmV5TGV2ZWwgLSBkaWY7XG4gICAgICAgICAgaWYgKGdyZXkgPCAwKSB7XG4gICAgICAgICAgICBncmV5ID0gMDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGdyZXkgPiAyNTUpIHtcbiAgICAgICAgICAgIGdyZXkgPSAyNTU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGF0YVtvZmZzZXRdID0gZGF0YVtvZmZzZXQgKyAxXSA9IGRhdGFbb2Zmc2V0ICsgMl0gPSBncmV5O1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICgtLXgpO1xuICAgIH0gd2hpbGUgKC0teSk7XG4gIH07XG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuTm9kZSxcbiAgICAnZW1ib3NzU3RyZW5ndGgnLFxuICAgIDAuNSxcbiAgICBudWxsLFxuICAgIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXJcbiAgKTtcbiAgLyoqXG4gICAgKiBnZXQvc2V0IGVtYm9zcyBzdHJlbmd0aC4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuRW1ib3NzfSBmaWx0ZXIuXG4gICAgKiBAbmFtZSBlbWJvc3NTdHJlbmd0aFxuICAgICogQG1ldGhvZFxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgKiBAcGFyYW0ge051bWJlcn0gbGV2ZWwgYmV0d2VlbiAwIGFuZCAxLiAgRGVmYXVsdCBpcyAwLjVcbiAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5Ob2RlLFxuICAgICdlbWJvc3NXaGl0ZUxldmVsJyxcbiAgICAwLjUsXG4gICAgbnVsbCxcbiAgICBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyXG4gICk7XG4gIC8qKlxuICAgICogZ2V0L3NldCBlbWJvc3Mgd2hpdGUgbGV2ZWwuIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkVtYm9zc30gZmlsdGVyLlxuICAgICogQG5hbWUgZW1ib3NzV2hpdGVMZXZlbFxuICAgICogQG1ldGhvZFxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgKiBAcGFyYW0ge051bWJlcn0gZW1ib3NzV2hpdGVMZXZlbCBiZXR3ZWVuIDAgYW5kIDEuICBEZWZhdWx0IGlzIDAuNVxuICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLk5vZGUsXG4gICAgJ2VtYm9zc0RpcmVjdGlvbicsXG4gICAgJ3RvcC1sZWZ0JyxcbiAgICBudWxsLFxuICAgIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXJcbiAgKTtcbiAgLyoqXG4gICAgKiBnZXQvc2V0IGVtYm9zcyBkaXJlY3Rpb24uIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkVtYm9zc30gZmlsdGVyLlxuICAgICogQG5hbWUgZW1ib3NzRGlyZWN0aW9uXG4gICAgKiBAbWV0aG9kXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBlbWJvc3NEaXJlY3Rpb24gY2FuIGJlIHRvcC1sZWZ0LCB0b3AsIHRvcC1yaWdodCwgcmlnaHQsIGJvdHRvbS1yaWdodCwgYm90dG9tLCBib3R0b20tbGVmdCBvciBsZWZ0XG4gICAgKiAgIFRoZSBkZWZhdWx0IGlzIHRvcC1sZWZ0XG4gICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuTm9kZSxcbiAgICAnZW1ib3NzQmxlbmQnLFxuICAgIGZhbHNlLFxuICAgIG51bGwsXG4gICAgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlclxuICApO1xuICAvKipcbiAgICAqIGdldC9zZXQgZW1ib3NzIGJsZW5kLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5FbWJvc3N9IGZpbHRlci5cbiAgICAqIEBuYW1lIGVtYm9zc0JsZW5kXG4gICAgKiBAbWV0aG9kXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZW1ib3NzQmxlbmRcbiAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICovXG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgZnVuY3Rpb24gcmVtYXAoZnJvbVZhbHVlLCBmcm9tTWluLCBmcm9tTWF4LCB0b01pbiwgdG9NYXgpIHtcbiAgICAvLyBDb21wdXRlIHRoZSByYW5nZSBvZiB0aGUgZGF0YVxuICAgIHZhciBmcm9tUmFuZ2UgPSBmcm9tTWF4IC0gZnJvbU1pbiwgdG9SYW5nZSA9IHRvTWF4IC0gdG9NaW4sIHRvVmFsdWU7XG5cbiAgICAvLyBJZiBlaXRoZXIgcmFuZ2UgaXMgMCwgdGhlbiB0aGUgdmFsdWUgY2FuIG9ubHkgYmUgbWFwcGVkIHRvIDEgdmFsdWVcbiAgICBpZiAoZnJvbVJhbmdlID09PSAwKSB7XG4gICAgICByZXR1cm4gdG9NaW4gKyB0b1JhbmdlIC8gMjtcbiAgICB9XG4gICAgaWYgKHRvUmFuZ2UgPT09IDApIHtcbiAgICAgIHJldHVybiB0b01pbjtcbiAgICB9XG5cbiAgICAvLyAoMSkgdW50cmFuc2xhdGUsICgyKSB1bnNjYWxlLCAoMykgcmVzY2FsZSwgKDQpIHJldHJhbnNsYXRlXG4gICAgdG9WYWx1ZSA9IChmcm9tVmFsdWUgLSBmcm9tTWluKSAvIGZyb21SYW5nZTtcbiAgICB0b1ZhbHVlID0gdG9SYW5nZSAqIHRvVmFsdWUgKyB0b01pbjtcblxuICAgIHJldHVybiB0b1ZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAgKiBFbmhhbmNlIEZpbHRlci4gQWRqdXN0cyB0aGUgY29sb3JzIHNvIHRoYXQgdGhleSBzcGFuIHRoZSB3aWRlc3RcbiAgICAqICBwb3NzaWJsZSByYW5nZSAoaWUgMC0yNTUpLiBQZXJmb3JtcyB3KmggcGl4ZWwgcmVhZHMgYW5kIHcqaCBwaXhlbFxuICAgICogIHdyaXRlcy5cbiAgICAqIEBmdW5jdGlvblxuICAgICogQG5hbWUgRW5oYW5jZVxuICAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcbiAgICAqIEBhdXRob3IgaXBwbzYxNVxuICAgICogQGV4YW1wbGVcbiAgICAqIG5vZGUuY2FjaGUoKTtcbiAgICAqIG5vZGUuZmlsdGVycyhbS29udmEuRmlsdGVycy5FbmhhbmNlXSk7XG4gICAgKiBub2RlLmVuaGFuY2UoMC40KTtcbiAgICAqL1xuICBLb252YS5GaWx0ZXJzLkVuaGFuY2UgPSBmdW5jdGlvbihpbWFnZURhdGEpIHtcbiAgICB2YXIgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgblN1YlBpeGVscyA9IGRhdGEubGVuZ3RoLFxuICAgICAgck1pbiA9IGRhdGFbMF0sXG4gICAgICByTWF4ID0gck1pbixcbiAgICAgIHIsXG4gICAgICBnTWluID0gZGF0YVsxXSxcbiAgICAgIGdNYXggPSBnTWluLFxuICAgICAgZyxcbiAgICAgIGJNaW4gPSBkYXRhWzJdLFxuICAgICAgYk1heCA9IGJNaW4sXG4gICAgICBiLFxuICAgICAgaTtcblxuICAgIC8vIElmIHdlIGFyZSBub3QgZW5oYW5jaW5nIGFueXRoaW5nIC0gZG9uJ3QgZG8gYW55IGNvbXB1dGF0aW9uXG4gICAgdmFyIGVuaGFuY2VBbW91bnQgPSB0aGlzLmVuaGFuY2UoKTtcbiAgICBpZiAoZW5oYW5jZUFtb3VudCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIDFzdCBQYXNzIC0gZmluZCB0aGUgbWluIGFuZCBtYXggZm9yIGVhY2ggY2hhbm5lbDpcbiAgICBmb3IgKGkgPSAwOyBpIDwgblN1YlBpeGVsczsgaSArPSA0KSB7XG4gICAgICByID0gZGF0YVtpICsgMF07XG4gICAgICBpZiAociA8IHJNaW4pIHtcbiAgICAgICAgck1pbiA9IHI7XG4gICAgICB9IGVsc2UgaWYgKHIgPiByTWF4KSB7XG4gICAgICAgIHJNYXggPSByO1xuICAgICAgfVxuICAgICAgZyA9IGRhdGFbaSArIDFdO1xuICAgICAgaWYgKGcgPCBnTWluKSB7XG4gICAgICAgIGdNaW4gPSBnO1xuICAgICAgfSBlbHNlIGlmIChnID4gZ01heCkge1xuICAgICAgICBnTWF4ID0gZztcbiAgICAgIH1cbiAgICAgIGIgPSBkYXRhW2kgKyAyXTtcbiAgICAgIGlmIChiIDwgYk1pbikge1xuICAgICAgICBiTWluID0gYjtcbiAgICAgIH0gZWxzZSBpZiAoYiA+IGJNYXgpIHtcbiAgICAgICAgYk1heCA9IGI7XG4gICAgICB9XG4gICAgICAvL2EgPSBkYXRhW2kgKyAzXTtcbiAgICAgIC8vaWYgKGEgPCBhTWluKSB7IGFNaW4gPSBhOyB9IGVsc2VcbiAgICAgIC8vaWYgKGEgPiBhTWF4KSB7IGFNYXggPSBhOyB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgaXMgb25seSAxIGxldmVsIC0gZG9uJ3QgcmVtYXBcbiAgICBpZiAock1heCA9PT0gck1pbikge1xuICAgICAgck1heCA9IDI1NTtcbiAgICAgIHJNaW4gPSAwO1xuICAgIH1cbiAgICBpZiAoZ01heCA9PT0gZ01pbikge1xuICAgICAgZ01heCA9IDI1NTtcbiAgICAgIGdNaW4gPSAwO1xuICAgIH1cbiAgICBpZiAoYk1heCA9PT0gYk1pbikge1xuICAgICAgYk1heCA9IDI1NTtcbiAgICAgIGJNaW4gPSAwO1xuICAgIH1cblxuICAgIHZhciByTWlkLFxuICAgICAgckdvYWxNYXgsXG4gICAgICByR29hbE1pbixcbiAgICAgIGdNaWQsXG4gICAgICBnR29hbE1heCxcbiAgICAgIGdHb2FsTWluLFxuICAgICAgYk1pZCxcbiAgICAgIGJHb2FsTWF4LFxuICAgICAgYkdvYWxNaW47XG5cbiAgICAvLyBJZiB0aGUgZW5oYW5jZW1lbnQgaXMgcG9zaXRpdmUgLSBzdHJldGNoIHRoZSBoaXN0b2dyYW1cbiAgICBpZiAoZW5oYW5jZUFtb3VudCA+IDApIHtcbiAgICAgIHJHb2FsTWF4ID0gck1heCArIGVuaGFuY2VBbW91bnQgKiAoMjU1IC0gck1heCk7XG4gICAgICByR29hbE1pbiA9IHJNaW4gLSBlbmhhbmNlQW1vdW50ICogKHJNaW4gLSAwKTtcbiAgICAgIGdHb2FsTWF4ID0gZ01heCArIGVuaGFuY2VBbW91bnQgKiAoMjU1IC0gZ01heCk7XG4gICAgICBnR29hbE1pbiA9IGdNaW4gLSBlbmhhbmNlQW1vdW50ICogKGdNaW4gLSAwKTtcbiAgICAgIGJHb2FsTWF4ID0gYk1heCArIGVuaGFuY2VBbW91bnQgKiAoMjU1IC0gYk1heCk7XG4gICAgICBiR29hbE1pbiA9IGJNaW4gLSBlbmhhbmNlQW1vdW50ICogKGJNaW4gLSAwKTtcbiAgICAgIC8vIElmIHRoZSBlbmhhbmNlbWVudCBpcyBuZWdhdGl2ZSAtICAgY29tcHJlc3MgdGhlIGhpc3RvZ3JhbVxuICAgIH0gZWxzZSB7XG4gICAgICByTWlkID0gKHJNYXggKyByTWluKSAqIDAuNTtcbiAgICAgIHJHb2FsTWF4ID0gck1heCArIGVuaGFuY2VBbW91bnQgKiAock1heCAtIHJNaWQpO1xuICAgICAgckdvYWxNaW4gPSByTWluICsgZW5oYW5jZUFtb3VudCAqIChyTWluIC0gck1pZCk7XG4gICAgICBnTWlkID0gKGdNYXggKyBnTWluKSAqIDAuNTtcbiAgICAgIGdHb2FsTWF4ID0gZ01heCArIGVuaGFuY2VBbW91bnQgKiAoZ01heCAtIGdNaWQpO1xuICAgICAgZ0dvYWxNaW4gPSBnTWluICsgZW5oYW5jZUFtb3VudCAqIChnTWluIC0gZ01pZCk7XG4gICAgICBiTWlkID0gKGJNYXggKyBiTWluKSAqIDAuNTtcbiAgICAgIGJHb2FsTWF4ID0gYk1heCArIGVuaGFuY2VBbW91bnQgKiAoYk1heCAtIGJNaWQpO1xuICAgICAgYkdvYWxNaW4gPSBiTWluICsgZW5oYW5jZUFtb3VudCAqIChiTWluIC0gYk1pZCk7XG4gICAgfVxuXG4gICAgLy8gUGFzcyAyIC0gcmVtYXAgZXZlcnl0aGluZywgZXhjZXB0IHRoZSBhbHBoYVxuICAgIGZvciAoaSA9IDA7IGkgPCBuU3ViUGl4ZWxzOyBpICs9IDQpIHtcbiAgICAgIGRhdGFbaSArIDBdID0gcmVtYXAoZGF0YVtpICsgMF0sIHJNaW4sIHJNYXgsIHJHb2FsTWluLCByR29hbE1heCk7XG4gICAgICBkYXRhW2kgKyAxXSA9IHJlbWFwKGRhdGFbaSArIDFdLCBnTWluLCBnTWF4LCBnR29hbE1pbiwgZ0dvYWxNYXgpO1xuICAgICAgZGF0YVtpICsgMl0gPSByZW1hcChkYXRhW2kgKyAyXSwgYk1pbiwgYk1heCwgYkdvYWxNaW4sIGJHb2FsTWF4KTtcbiAgICAgIC8vZGF0YVtpICsgM10gPSByZW1hcChkYXRhW2kgKyAzXSwgYU1pbiwgYU1heCwgYUdvYWxNaW4sIGFHb2FsTWF4KTtcbiAgICB9XG4gIH07XG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuTm9kZSxcbiAgICAnZW5oYW5jZScsXG4gICAgMCxcbiAgICBudWxsLFxuICAgIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXJcbiAgKTtcblxuICAvKipcbiAgICAqIGdldC9zZXQgZW5oYW5jZS4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuRW5oYW5jZX0gZmlsdGVyLlxuICAgICogQG5hbWUgZW5oYW5jZVxuICAgICogQG1ldGhvZFxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgKiBAcGFyYW0ge0Zsb2F0fSBhbW91bnRcbiAgICAqIEByZXR1cm5zIHtGbG9hdH1cbiAgICAqL1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIC8qKlxuICAgICAqIFBvc3Rlcml6ZSBGaWx0ZXIuIEFkanVzdHMgdGhlIGNoYW5uZWxzIHNvIHRoYXQgdGhlcmUgYXJlIG5vIG1vcmVcbiAgICAgKiAgdGhhbiBuIGRpZmZlcmVudCB2YWx1ZXMgZm9yIHRoYXQgY2hhbm5lbC4gVGhpcyBpcyBhbHNvIGFwcGxpZWRcbiAgICAgKiAgdG8gdGhlIGFscGhhIGNoYW5uZWwuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG5hbWUgUG9zdGVyaXplXG4gICAgICogQGF1dGhvciBpcHBvNjE1XG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VEYXRhXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBub2RlLmNhY2hlKCk7XG4gICAgICogbm9kZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLlBvc3Rlcml6ZV0pO1xuICAgICAqIG5vZGUubGV2ZWxzKDAuOCk7IC8vIGJldHdlZW4gMCBhbmQgMVxuICAgICAqL1xuXG4gIEtvbnZhLkZpbHRlcnMuUG9zdGVyaXplID0gZnVuY3Rpb24oaW1hZ2VEYXRhKSB7XG4gICAgLy8gbGV2ZWwgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDI1NVxuICAgIHZhciBsZXZlbHMgPSBNYXRoLnJvdW5kKHRoaXMubGV2ZWxzKCkgKiAyNTQpICsgMSxcbiAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgIGxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgc2NhbGUgPSAyNTUgLyBsZXZlbHMsXG4gICAgICBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBkYXRhW2ldID0gTWF0aC5mbG9vcihkYXRhW2ldIC8gc2NhbGUpICogc2NhbGU7XG4gICAgfVxuICB9O1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLk5vZGUsXG4gICAgJ2xldmVscycsXG4gICAgMC41LFxuICAgIG51bGwsXG4gICAgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlclxuICApO1xuXG4gIC8qKlxuICAgICogZ2V0L3NldCBsZXZlbHMuICBNdXN0IGJlIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMS4gIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLlBvc3Rlcml6ZX0gZmlsdGVyLlxuICAgICogQG5hbWUgbGV2ZWxzXG4gICAgKiBAbWV0aG9kXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbCBiZXR3ZWVuIDAgYW5kIDFcbiAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgKi9cbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcclxuICAndXNlIHN0cmljdCc7XHJcbiAgLyoqXHJcbiAgICAgKiBOb2lzZSBGaWx0ZXIuIFJhbmRvbWx5IGFkZHMgb3Igc3Vic3RyYWN0cyB0byB0aGUgY29sb3IgY2hhbm5lbHNcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQG5hbWUgTm9pc2VcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5GaWx0ZXJzXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VEYXRhXHJcbiAgICAgKiBAYXV0aG9yIGlwcG82MTVcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBub2RlLmNhY2hlKCk7XHJcbiAgICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuTm9pc2VdKTtcclxuICAgICAqIG5vZGUubm9pc2UoMC44KTtcclxuICAgICAqL1xyXG4gIEtvbnZhLkZpbHRlcnMuTm9pc2UgPSBmdW5jdGlvbihpbWFnZURhdGEpIHtcclxuICAgIHZhciBhbW91bnQgPSB0aGlzLm5vaXNlKCkgKiAyNTUsXHJcbiAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcclxuICAgICAgblBpeGVscyA9IGRhdGEubGVuZ3RoLFxyXG4gICAgICBoYWxmID0gYW1vdW50IC8gMixcclxuICAgICAgaTtcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgblBpeGVsczsgaSArPSA0KSB7XHJcbiAgICAgIGRhdGFbaSArIDBdICs9IGhhbGYgLSAyICogaGFsZiAqIE1hdGgucmFuZG9tKCk7XHJcbiAgICAgIGRhdGFbaSArIDFdICs9IGhhbGYgLSAyICogaGFsZiAqIE1hdGgucmFuZG9tKCk7XHJcbiAgICAgIGRhdGFbaSArIDJdICs9IGhhbGYgLSAyICogaGFsZiAqIE1hdGgucmFuZG9tKCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXHJcbiAgICBLb252YS5Ob2RlLFxyXG4gICAgJ25vaXNlJyxcclxuICAgIDAuMixcclxuICAgIG51bGwsXHJcbiAgICBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyXHJcbiAgKTtcclxuICAvKipcclxuICAgICogZ2V0L3NldCBub2lzZSBhbW91bnQuICBNdXN0IGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5Ob2lzZX0gZmlsdGVyLlxyXG4gICAgKiBAbmFtZSBub2lzZVxyXG4gICAgKiBAbWV0aG9kXHJcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxyXG4gICAgKiBAcGFyYW0ge051bWJlcn0gbm9pc2VcclxuICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICovXHJcbn0pKCk7XHJcblxuLyplc2xpbnQtZGlzYWJsZSBtYXgtZGVwdGggKi9cclxuKGZ1bmN0aW9uKCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuICAvKipcclxuICAgICAqIFBpeGVsYXRlIEZpbHRlci4gQXZlcmFnZXMgZ3JvdXBzIG9mIHBpeGVscyBhbmQgcmVkcmF3c1xyXG4gICAgICogIHRoZW0gYXMgbGFyZ2VyIHBpeGVsc1xyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAbmFtZSBQaXhlbGF0ZVxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcclxuICAgICAqIEBhdXRob3IgaXBwbzYxNVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIG5vZGUuY2FjaGUoKTtcclxuICAgICAqIG5vZGUuZmlsdGVycyhbS29udmEuRmlsdGVycy5QaXhlbGF0ZV0pO1xyXG4gICAgICogbm9kZS5waXhlbFNpemUoMTApO1xyXG4gICAgICovXHJcblxyXG4gIEtvbnZhLkZpbHRlcnMuUGl4ZWxhdGUgPSBmdW5jdGlvbihpbWFnZURhdGEpIHtcclxuICAgIHZhciBwaXhlbFNpemUgPSBNYXRoLmNlaWwodGhpcy5waXhlbFNpemUoKSksXHJcbiAgICAgIHdpZHRoID0gaW1hZ2VEYXRhLndpZHRoLFxyXG4gICAgICBoZWlnaHQgPSBpbWFnZURhdGEuaGVpZ2h0LFxyXG4gICAgICB4LFxyXG4gICAgICB5LFxyXG4gICAgICBpLFxyXG4gICAgICAvL3BpeGVsc1BlckJpbiA9IHBpeGVsU2l6ZSAqIHBpeGVsU2l6ZSxcclxuICAgICAgcmVkLFxyXG4gICAgICBncmVlbixcclxuICAgICAgYmx1ZSxcclxuICAgICAgYWxwaGEsXHJcbiAgICAgIG5CaW5zWCA9IE1hdGguY2VpbCh3aWR0aCAvIHBpeGVsU2l6ZSksXHJcbiAgICAgIG5CaW5zWSA9IE1hdGguY2VpbChoZWlnaHQgLyBwaXhlbFNpemUpLFxyXG4gICAgICB4QmluU3RhcnQsXHJcbiAgICAgIHhCaW5FbmQsXHJcbiAgICAgIHlCaW5TdGFydCxcclxuICAgICAgeUJpbkVuZCxcclxuICAgICAgeEJpbixcclxuICAgICAgeUJpbixcclxuICAgICAgcGl4ZWxzSW5CaW47XHJcbiAgICBpbWFnZURhdGEgPSBpbWFnZURhdGEuZGF0YTtcclxuXHJcbiAgICBpZiAocGl4ZWxTaXplIDw9IDApIHtcclxuICAgICAgS29udmEuVXRpbC5lcnJvcigncGl4ZWxTaXplIHZhbHVlIGNhbiBub3QgYmUgPD0gMCcpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgZm9yICh4QmluID0gMDsgeEJpbiA8IG5CaW5zWDsgeEJpbiArPSAxKSB7XHJcbiAgICAgIGZvciAoeUJpbiA9IDA7IHlCaW4gPCBuQmluc1k7IHlCaW4gKz0gMSkge1xyXG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIGNvbG9yIGFjY3VtbGF0b3JzIHRvIDBcclxuICAgICAgICByZWQgPSAwO1xyXG4gICAgICAgIGdyZWVuID0gMDtcclxuICAgICAgICBibHVlID0gMDtcclxuICAgICAgICBhbHBoYSA9IDA7XHJcblxyXG4gICAgICAgIC8vIERldGVybWluZSB3aGljaCBwaXhlbHMgYXJlIGluY2x1ZGVkIGluIHRoaXMgYmluXHJcbiAgICAgICAgeEJpblN0YXJ0ID0geEJpbiAqIHBpeGVsU2l6ZTtcclxuICAgICAgICB4QmluRW5kID0geEJpblN0YXJ0ICsgcGl4ZWxTaXplO1xyXG4gICAgICAgIHlCaW5TdGFydCA9IHlCaW4gKiBwaXhlbFNpemU7XHJcbiAgICAgICAgeUJpbkVuZCA9IHlCaW5TdGFydCArIHBpeGVsU2l6ZTtcclxuXHJcbiAgICAgICAgLy8gQWRkIGFsbCBvZiB0aGUgcGl4ZWxzIHRvIHRoaXMgYmluIVxyXG4gICAgICAgIHBpeGVsc0luQmluID0gMDtcclxuICAgICAgICBmb3IgKHggPSB4QmluU3RhcnQ7IHggPCB4QmluRW5kOyB4ICs9IDEpIHtcclxuICAgICAgICAgIGlmICh4ID49IHdpZHRoKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZm9yICh5ID0geUJpblN0YXJ0OyB5IDwgeUJpbkVuZDsgeSArPSAxKSB7XHJcbiAgICAgICAgICAgIGlmICh5ID49IGhlaWdodCkge1xyXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkgPSAod2lkdGggKiB5ICsgeCkgKiA0O1xyXG4gICAgICAgICAgICByZWQgKz0gaW1hZ2VEYXRhW2kgKyAwXTtcclxuICAgICAgICAgICAgZ3JlZW4gKz0gaW1hZ2VEYXRhW2kgKyAxXTtcclxuICAgICAgICAgICAgYmx1ZSArPSBpbWFnZURhdGFbaSArIDJdO1xyXG4gICAgICAgICAgICBhbHBoYSArPSBpbWFnZURhdGFbaSArIDNdO1xyXG4gICAgICAgICAgICBwaXhlbHNJbkJpbiArPSAxO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBjaGFubmVscyBhcmUgYmV0d2VlbiAwLTI1NVxyXG4gICAgICAgIHJlZCA9IHJlZCAvIHBpeGVsc0luQmluO1xyXG4gICAgICAgIGdyZWVuID0gZ3JlZW4gLyBwaXhlbHNJbkJpbjtcclxuICAgICAgICBibHVlID0gYmx1ZSAvIHBpeGVsc0luQmluO1xyXG5cclxuICAgICAgICAvLyBEcmF3IHRoaXMgYmluXHJcbiAgICAgICAgZm9yICh4ID0geEJpblN0YXJ0OyB4IDwgeEJpbkVuZDsgeCArPSAxKSB7XHJcbiAgICAgICAgICBpZiAoeCA+PSB3aWR0aCkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGZvciAoeSA9IHlCaW5TdGFydDsgeSA8IHlCaW5FbmQ7IHkgKz0gMSkge1xyXG4gICAgICAgICAgICBpZiAoeSA+PSBoZWlnaHQpIHtcclxuICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpID0gKHdpZHRoICogeSArIHgpICogNDtcclxuICAgICAgICAgICAgaW1hZ2VEYXRhW2kgKyAwXSA9IHJlZDtcclxuICAgICAgICAgICAgaW1hZ2VEYXRhW2kgKyAxXSA9IGdyZWVuO1xyXG4gICAgICAgICAgICBpbWFnZURhdGFbaSArIDJdID0gYmx1ZTtcclxuICAgICAgICAgICAgaW1hZ2VEYXRhW2kgKyAzXSA9IGFscGhhO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxyXG4gICAgS29udmEuTm9kZSxcclxuICAgICdwaXhlbFNpemUnLFxyXG4gICAgOCxcclxuICAgIG51bGwsXHJcbiAgICBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyXHJcbiAgKTtcclxuICAvKipcclxuICAgICogZ2V0L3NldCBwaXhlbCBzaXplLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5QaXhlbGF0ZX0gZmlsdGVyLlxyXG4gICAgKiBAbmFtZSBwaXhlbFNpemVcclxuICAgICogQG1ldGhvZFxyXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcclxuICAgICogQHBhcmFtIHtJbnRlZ2VyfSBwaXhlbFNpemVcclxuICAgICogQHJldHVybnMge0ludGVnZXJ9XHJcbiAgICAqL1xyXG59KSgpO1xyXG5cbihmdW5jdGlvbigpIHtcclxuICAndXNlIHN0cmljdCc7XHJcbiAgLyoqXHJcbiAgICAgKiBUaHJlc2hvbGQgRmlsdGVyLiBQdXNoZXMgYW55IHZhbHVlIGFib3ZlIHRoZSBtaWQgcG9pbnQgdG9cclxuICAgICAqICB0aGUgbWF4IGFuZCBhbnkgdmFsdWUgYmVsb3cgdGhlIG1pZCBwb2ludCB0byB0aGUgbWluLlxyXG4gICAgICogIFRoaXMgYWZmZWN0cyB0aGUgYWxwaGEgY2hhbm5lbC5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQG5hbWUgVGhyZXNob2xkXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGltYWdlRGF0YVxyXG4gICAgICogQGF1dGhvciBpcHBvNjE1XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogbm9kZS5jYWNoZSgpO1xyXG4gICAgICogbm9kZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLlRocmVzaG9sZF0pO1xyXG4gICAgICogbm9kZS50aHJlc2hvbGQoMC4xKTtcclxuICAgICAqL1xyXG5cclxuICBLb252YS5GaWx0ZXJzLlRocmVzaG9sZCA9IGZ1bmN0aW9uKGltYWdlRGF0YSkge1xyXG4gICAgdmFyIGxldmVsID0gdGhpcy50aHJlc2hvbGQoKSAqIDI1NSxcclxuICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxyXG4gICAgICBsZW4gPSBkYXRhLmxlbmd0aCxcclxuICAgICAgaTtcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgZGF0YVtpXSA9IGRhdGFbaV0gPCBsZXZlbCA/IDAgOiAyNTU7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXHJcbiAgICBLb252YS5Ob2RlLFxyXG4gICAgJ3RocmVzaG9sZCcsXHJcbiAgICAwLjUsXHJcbiAgICBudWxsLFxyXG4gICAgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlclxyXG4gICk7XHJcbiAgLyoqXHJcbiAgICAqIGdldC9zZXQgdGhyZXNob2xkLiAgTXVzdCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMS4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuVGhyZXNob2xkfSBvciB7QGxpbmsgS29udmEuRmlsdGVycy5NYXNrfSBmaWx0ZXIuXHJcbiAgICAqIEBuYW1lIHRocmVzaG9sZFxyXG4gICAgKiBAbWV0aG9kXHJcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxyXG4gICAgKiBAcGFyYW0ge051bWJlcn0gdGhyZXNob2xkXHJcbiAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAqL1xyXG59KSgpO1xyXG5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvKipcbiAgICAgKiBTZXBpYSBGaWx0ZXJcbiAgICAgKiBCYXNlZCBvbjogUGl4YXN0aWMgTGliIC0gU2VwaWEgZmlsdGVyIC0gdjAuMS4wXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDA4IEphY29iIFNlaWRlbGluLCBqc2VpZGVsaW5AbmloaWxvZ2ljLmRrLCBodHRwOi8vYmxvZy5uaWhpbG9naWMuZGsvXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG5hbWUgU2VwaWFcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcbiAgICAgKiBAYXV0aG9yIEphY29iIFNlaWRlbGluIDxqc2VpZGVsaW5AbmloaWxvZ2ljLmRrPlxuICAgICAqIEBsaWNlbnNlIE1QTCB2MS4xIFtodHRwOi8vd3d3LnBpeGFzdGljLmNvbS9saWIvbGljZW5zZS50eHRdXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBub2RlLmNhY2hlKCk7XG4gICAgICogbm9kZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLlNlcGlhXSk7XG4gICAgICovXG4gIEtvbnZhLkZpbHRlcnMuU2VwaWEgPSBmdW5jdGlvbihpbWFnZURhdGEpIHtcbiAgICB2YXIgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgdyA9IGltYWdlRGF0YS53aWR0aCxcbiAgICAgIHkgPSBpbWFnZURhdGEuaGVpZ2h0LFxuICAgICAgdzQgPSB3ICogNCxcbiAgICAgIG9mZnNldFksXG4gICAgICB4LFxuICAgICAgb2Zmc2V0LFxuICAgICAgb3IsXG4gICAgICBvZyxcbiAgICAgIG9iLFxuICAgICAgcixcbiAgICAgIGcsXG4gICAgICBiO1xuXG4gICAgZG8ge1xuICAgICAgb2Zmc2V0WSA9ICh5IC0gMSkgKiB3NDtcbiAgICAgIHggPSB3O1xuICAgICAgZG8ge1xuICAgICAgICBvZmZzZXQgPSBvZmZzZXRZICsgKHggLSAxKSAqIDQ7XG5cbiAgICAgICAgb3IgPSBkYXRhW29mZnNldF07XG4gICAgICAgIG9nID0gZGF0YVtvZmZzZXQgKyAxXTtcbiAgICAgICAgb2IgPSBkYXRhW29mZnNldCArIDJdO1xuXG4gICAgICAgIHIgPSBvciAqIDAuMzkzICsgb2cgKiAwLjc2OSArIG9iICogMC4xODk7XG4gICAgICAgIGcgPSBvciAqIDAuMzQ5ICsgb2cgKiAwLjY4NiArIG9iICogMC4xNjg7XG4gICAgICAgIGIgPSBvciAqIDAuMjcyICsgb2cgKiAwLjUzNCArIG9iICogMC4xMzE7XG5cbiAgICAgICAgZGF0YVtvZmZzZXRdID0gciA+IDI1NSA/IDI1NSA6IHI7XG4gICAgICAgIGRhdGFbb2Zmc2V0ICsgMV0gPSBnID4gMjU1ID8gMjU1IDogZztcbiAgICAgICAgZGF0YVtvZmZzZXQgKyAyXSA9IGIgPiAyNTUgPyAyNTUgOiBiO1xuICAgICAgICBkYXRhW29mZnNldCArIDNdID0gZGF0YVtvZmZzZXQgKyAzXTtcbiAgICAgIH0gd2hpbGUgKC0teCk7XG4gICAgfSB3aGlsZSAoLS15KTtcbiAgfTtcbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvKipcbiAgICAgKiBTb2xhcml6ZSBGaWx0ZXJcbiAgICAgKiBQaXhhc3RpYyBMaWIgLSBTb2xhcml6ZSBmaWx0ZXIgLSB2MC4xLjBcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMDggSmFjb2IgU2VpZGVsaW4sIGpzZWlkZWxpbkBuaWhpbG9naWMuZGssIGh0dHA6Ly9ibG9nLm5paGlsb2dpYy5kay9cbiAgICAgKiBMaWNlbnNlOiBbaHR0cDovL3d3dy5waXhhc3RpYy5jb20vbGliL2xpY2Vuc2UudHh0XVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBuYW1lIFNvbGFyaXplXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VEYXRhXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBub2RlLmNhY2hlKCk7XG4gICAgICogbm9kZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLlNvbGFyaXplXSk7XG4gICAgICovXG4gIEtvbnZhLkZpbHRlcnMuU29sYXJpemUgPSBmdW5jdGlvbihpbWFnZURhdGEpIHtcbiAgICB2YXIgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgdyA9IGltYWdlRGF0YS53aWR0aCxcbiAgICAgIGggPSBpbWFnZURhdGEuaGVpZ2h0LFxuICAgICAgdzQgPSB3ICogNCxcbiAgICAgIHkgPSBoO1xuXG4gICAgZG8ge1xuICAgICAgdmFyIG9mZnNldFkgPSAoeSAtIDEpICogdzQ7XG4gICAgICB2YXIgeCA9IHc7XG4gICAgICBkbyB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBvZmZzZXRZICsgKHggLSAxKSAqIDQ7XG4gICAgICAgIHZhciByID0gZGF0YVtvZmZzZXRdO1xuICAgICAgICB2YXIgZyA9IGRhdGFbb2Zmc2V0ICsgMV07XG4gICAgICAgIHZhciBiID0gZGF0YVtvZmZzZXQgKyAyXTtcblxuICAgICAgICBpZiAociA+IDEyNykge1xuICAgICAgICAgIHIgPSAyNTUgLSByO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnID4gMTI3KSB7XG4gICAgICAgICAgZyA9IDI1NSAtIGc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGIgPiAxMjcpIHtcbiAgICAgICAgICBiID0gMjU1IC0gYjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGFbb2Zmc2V0XSA9IHI7XG4gICAgICAgIGRhdGFbb2Zmc2V0ICsgMV0gPSBnO1xuICAgICAgICBkYXRhW29mZnNldCArIDJdID0gYjtcbiAgICAgIH0gd2hpbGUgKC0teCk7XG4gICAgfSB3aGlsZSAoLS15KTtcbiAgfTtcbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvKlxuICAgKiBUb1BvbGFyIEZpbHRlci4gQ29udmVydHMgaW1hZ2UgZGF0YSB0byBwb2xhciBjb29yZGluYXRlcy4gUGVyZm9ybXNcbiAgICogIHcqaCo0IHBpeGVsIHJlYWRzIGFuZCB3KmggcGl4ZWwgd3JpdGVzLiBUaGUgciBheGlzIGlzIHBsYWNlZCBhbG9uZ1xuICAgKiAgd2hhdCB3b3VsZCBiZSB0aGUgeSBheGlzIGFuZCB0aGUgdGhldGEgYXhpcyBhbG9uZyB0aGUgeCBheGlzLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQGF1dGhvciBpcHBvNjE1XG4gICAqIEBtZW1iZXJvZiBLb252YS5GaWx0ZXJzXG4gICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBzcmMsIHRoZSBzb3VyY2UgaW1hZ2UgZGF0YSAod2hhdCB3aWxsIGJlIHRyYW5zZm9ybWVkKVxuICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gZHN0LCB0aGUgZGVzdGluYXRpb24gaW1hZ2UgZGF0YSAod2hlcmUgaXQgd2lsbCBiZSBzYXZlZClcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdFxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdC5wb2xhckNlbnRlclhdIGhvcml6b250YWwgbG9jYXRpb24gZm9yIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZSxcbiAgICogIGRlZmF1bHQgaXMgaW4gdGhlIG1pZGRsZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdC5wb2xhckNlbnRlclldIHZlcnRpY2FsIGxvY2F0aW9uIGZvciB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGUsXG4gICAqICBkZWZhdWx0IGlzIGluIHRoZSBtaWRkbGVcbiAgICovXG5cbiAgdmFyIFRvUG9sYXIgPSBmdW5jdGlvbihzcmMsIGRzdCwgb3B0KSB7XG4gICAgdmFyIHNyY1BpeGVscyA9IHNyYy5kYXRhLFxuICAgICAgZHN0UGl4ZWxzID0gZHN0LmRhdGEsXG4gICAgICB4U2l6ZSA9IHNyYy53aWR0aCxcbiAgICAgIHlTaXplID0gc3JjLmhlaWdodCxcbiAgICAgIHhNaWQgPSBvcHQucG9sYXJDZW50ZXJYIHx8IHhTaXplIC8gMixcbiAgICAgIHlNaWQgPSBvcHQucG9sYXJDZW50ZXJZIHx8IHlTaXplIC8gMixcbiAgICAgIGksXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHIgPSAwLFxuICAgICAgZyA9IDAsXG4gICAgICBiID0gMCxcbiAgICAgIGEgPSAwO1xuXG4gICAgLy8gRmluZCB0aGUgbGFyZ2VzdCByYWRpdXNcbiAgICB2YXIgcmFkLFxuICAgICAgck1heCA9IE1hdGguc3FydCh4TWlkICogeE1pZCArIHlNaWQgKiB5TWlkKTtcbiAgICB4ID0geFNpemUgLSB4TWlkO1xuICAgIHkgPSB5U2l6ZSAtIHlNaWQ7XG4gICAgcmFkID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuICAgIHJNYXggPSByYWQgPiByTWF4ID8gcmFkIDogck1heDtcblxuICAgIC8vIFdlJ2xsIGJlIHVpc25nIHkgYXMgdGhlIHJhZGl1cywgYW5kIHggYXMgdGhlIGFuZ2xlICh0aGV0YT10KVxuICAgIHZhciByU2l6ZSA9IHlTaXplLFxuICAgICAgdFNpemUgPSB4U2l6ZSxcbiAgICAgIHJhZGl1cyxcbiAgICAgIHRoZXRhO1xuXG4gICAgLy8gV2Ugd2FudCB0byBjb3ZlciBhbGwgYW5nbGVzICgwLTM2MCkgYW5kIHdlIG5lZWQgdG8gY29udmVydCB0b1xuICAgIC8vIHJhZGlhbnMgKCpQSS8xODApXG4gICAgdmFyIGNvbnZlcnNpb24gPSAzNjAgLyB0U2l6ZSAqIE1hdGguUEkgLyAxODAsXG4gICAgICBzaW4sXG4gICAgICBjb3M7XG5cbiAgICAvLyB2YXIgeDEsIHgyLCB4MWksIHgyaSwgeTEsIHkyLCB5MWksIHkyaSwgc2NhbGU7XG5cbiAgICBmb3IgKHRoZXRhID0gMDsgdGhldGEgPCB0U2l6ZTsgdGhldGEgKz0gMSkge1xuICAgICAgc2luID0gTWF0aC5zaW4odGhldGEgKiBjb252ZXJzaW9uKTtcbiAgICAgIGNvcyA9IE1hdGguY29zKHRoZXRhICogY29udmVyc2lvbik7XG4gICAgICBmb3IgKHJhZGl1cyA9IDA7IHJhZGl1cyA8IHJTaXplOyByYWRpdXMgKz0gMSkge1xuICAgICAgICB4ID0gTWF0aC5mbG9vcih4TWlkICsgck1heCAqIHJhZGl1cyAvIHJTaXplICogY29zKTtcbiAgICAgICAgeSA9IE1hdGguZmxvb3IoeU1pZCArIHJNYXggKiByYWRpdXMgLyByU2l6ZSAqIHNpbik7XG4gICAgICAgIGkgPSAoeSAqIHhTaXplICsgeCkgKiA0O1xuICAgICAgICByID0gc3JjUGl4ZWxzW2kgKyAwXTtcbiAgICAgICAgZyA9IHNyY1BpeGVsc1tpICsgMV07XG4gICAgICAgIGIgPSBzcmNQaXhlbHNbaSArIDJdO1xuICAgICAgICBhID0gc3JjUGl4ZWxzW2kgKyAzXTtcblxuICAgICAgICAvLyBTdG9yZSBpdFxuICAgICAgICAvL2kgPSAodGhldGEgKiB4U2l6ZSAgKyAgcmFkaXVzKSAqIDQ7XG4gICAgICAgIGkgPSAodGhldGEgKyByYWRpdXMgKiB4U2l6ZSkgKiA0O1xuICAgICAgICBkc3RQaXhlbHNbaSArIDBdID0gcjtcbiAgICAgICAgZHN0UGl4ZWxzW2kgKyAxXSA9IGc7XG4gICAgICAgIGRzdFBpeGVsc1tpICsgMl0gPSBiO1xuICAgICAgICBkc3RQaXhlbHNbaSArIDNdID0gYTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLypcbiAgICAgKiBGcm9tUG9sYXIgRmlsdGVyLiBDb252ZXJ0cyBpbWFnZSBkYXRhIGZyb20gcG9sYXIgY29vcmRpbmF0ZXMgYmFjayB0byByZWN0YW5ndWxhci5cbiAgICAgKiAgUGVyZm9ybXMgdypoKjQgcGl4ZWwgcmVhZHMgYW5kIHcqaCBwaXhlbCB3cml0ZXMuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGF1dGhvciBpcHBvNjE1XG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcbiAgICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gc3JjLCB0aGUgc291cmNlIGltYWdlIGRhdGEgKHdoYXQgd2lsbCBiZSB0cmFuc2Zvcm1lZClcbiAgICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gZHN0LCB0aGUgZGVzdGluYXRpb24gaW1hZ2UgZGF0YSAod2hlcmUgaXQgd2lsbCBiZSBzYXZlZClcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHQucG9sYXJDZW50ZXJYXSBob3Jpem9udGFsIGxvY2F0aW9uIGZvciB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGUsXG4gICAgICogIGRlZmF1bHQgaXMgaW4gdGhlIG1pZGRsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0LnBvbGFyQ2VudGVyWV0gdmVydGljYWwgbG9jYXRpb24gZm9yIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZSxcbiAgICAgKiAgZGVmYXVsdCBpcyBpbiB0aGUgbWlkZGxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHQucG9sYXJSb3RhdGlvbl0gYW1vdW50IHRvIHJvdGF0ZSB0aGUgaW1hZ2UgY291bnRlcmNsb2Nrd2lzLFxuICAgICAqICAwIGlzIG5vIHJvdGF0aW9uLCAzNjAgZGVncmVlcyBpcyBhIGZ1bGwgcm90YXRpb25cbiAgICAgKi9cblxuICB2YXIgRnJvbVBvbGFyID0gZnVuY3Rpb24oc3JjLCBkc3QsIG9wdCkge1xuICAgIHZhciBzcmNQaXhlbHMgPSBzcmMuZGF0YSxcbiAgICAgIGRzdFBpeGVscyA9IGRzdC5kYXRhLFxuICAgICAgeFNpemUgPSBzcmMud2lkdGgsXG4gICAgICB5U2l6ZSA9IHNyYy5oZWlnaHQsXG4gICAgICB4TWlkID0gb3B0LnBvbGFyQ2VudGVyWCB8fCB4U2l6ZSAvIDIsXG4gICAgICB5TWlkID0gb3B0LnBvbGFyQ2VudGVyWSB8fCB5U2l6ZSAvIDIsXG4gICAgICBpLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBkeCxcbiAgICAgIGR5LFxuICAgICAgciA9IDAsXG4gICAgICBnID0gMCxcbiAgICAgIGIgPSAwLFxuICAgICAgYSA9IDA7XG5cbiAgICAvLyBGaW5kIHRoZSBsYXJnZXN0IHJhZGl1c1xuICAgIHZhciByYWQsXG4gICAgICByTWF4ID0gTWF0aC5zcXJ0KHhNaWQgKiB4TWlkICsgeU1pZCAqIHlNaWQpO1xuICAgIHggPSB4U2l6ZSAtIHhNaWQ7XG4gICAgeSA9IHlTaXplIC0geU1pZDtcbiAgICByYWQgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG4gICAgck1heCA9IHJhZCA+IHJNYXggPyByYWQgOiByTWF4O1xuXG4gICAgLy8gV2UnbGwgYmUgdWlzbmcgeCBhcyB0aGUgcmFkaXVzLCBhbmQgeSBhcyB0aGUgYW5nbGUgKHRoZXRhPXQpXG4gICAgdmFyIHJTaXplID0geVNpemUsXG4gICAgICB0U2l6ZSA9IHhTaXplLFxuICAgICAgcmFkaXVzLFxuICAgICAgdGhldGEsXG4gICAgICBwaGFzZVNoaWZ0ID0gb3B0LnBvbGFyUm90YXRpb24gfHwgMDtcblxuICAgIC8vIFdlIG5lZWQgdG8gY29udmVydCB0byBkZWdyZWVzIGFuZCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZVxuICAgIC8vIGl0J3MgYmV0d2VlbiAoMC0zNjApXG4gICAgLy8gdmFyIGNvbnZlcnNpb24gPSB0U2l6ZS8zNjAqMTgwL01hdGguUEk7XG4gICAgLy92YXIgY29udmVyc2lvbiA9IHRTaXplLzM2MCoxODAvTWF0aC5QSTtcblxuICAgIHZhciB4MSwgeTE7XG5cbiAgICBmb3IgKHggPSAwOyB4IDwgeFNpemU7IHggKz0gMSkge1xuICAgICAgZm9yICh5ID0gMDsgeSA8IHlTaXplOyB5ICs9IDEpIHtcbiAgICAgICAgZHggPSB4IC0geE1pZDtcbiAgICAgICAgZHkgPSB5IC0geU1pZDtcbiAgICAgICAgcmFkaXVzID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KSAqIHJTaXplIC8gck1heDtcbiAgICAgICAgdGhldGEgPSAoTWF0aC5hdGFuMihkeSwgZHgpICogMTgwIC8gTWF0aC5QSSArIDM2MCArIHBoYXNlU2hpZnQpICUgMzYwO1xuICAgICAgICB0aGV0YSA9IHRoZXRhICogdFNpemUgLyAzNjA7XG4gICAgICAgIHgxID0gTWF0aC5mbG9vcih0aGV0YSk7XG4gICAgICAgIHkxID0gTWF0aC5mbG9vcihyYWRpdXMpO1xuICAgICAgICBpID0gKHkxICogeFNpemUgKyB4MSkgKiA0O1xuICAgICAgICByID0gc3JjUGl4ZWxzW2kgKyAwXTtcbiAgICAgICAgZyA9IHNyY1BpeGVsc1tpICsgMV07XG4gICAgICAgIGIgPSBzcmNQaXhlbHNbaSArIDJdO1xuICAgICAgICBhID0gc3JjUGl4ZWxzW2kgKyAzXTtcblxuICAgICAgICAvLyBTdG9yZSBpdFxuICAgICAgICBpID0gKHkgKiB4U2l6ZSArIHgpICogNDtcbiAgICAgICAgZHN0UGl4ZWxzW2kgKyAwXSA9IHI7XG4gICAgICAgIGRzdFBpeGVsc1tpICsgMV0gPSBnO1xuICAgICAgICBkc3RQaXhlbHNbaSArIDJdID0gYjtcbiAgICAgICAgZHN0UGl4ZWxzW2kgKyAzXSA9IGE7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vS29udmEuRmlsdGVycy5Ub1BvbGFyID0gS29udmEuVXRpbC5fRmlsdGVyV3JhcERvdWJsZUJ1ZmZlcihUb1BvbGFyKTtcbiAgLy9Lb252YS5GaWx0ZXJzLkZyb21Qb2xhciA9IEtvbnZhLlV0aWwuX0ZpbHRlcldyYXBEb3VibGVCdWZmZXIoRnJvbVBvbGFyKTtcblxuICAvLyBjcmVhdGUgYSB0ZW1wb3JhcnkgY2FudmFzIGZvciB3b3JraW5nIC0gc2hhcmVkIGJldHdlZW4gbXVsdGlwbGUgY2FsbHNcblxuICAvKlxuICAgICAqIEthbGVpZG9zY29wZSBGaWx0ZXIuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG5hbWUgS2FsZWlkb3Njb3BlXG4gICAgICogQGF1dGhvciBpcHBvNjE1XG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG5vZGUuY2FjaGUoKTtcbiAgICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuS2FsZWlkb3Njb3BlXSk7XG4gICAgICogbm9kZS5rYWxlaWRvc2NvcGVQb3dlcigzKTtcbiAgICAgKiBub2RlLmthbGVpZG9zY29wZUFuZ2xlKDQ1KTtcbiAgICAgKi9cbiAgS29udmEuRmlsdGVycy5LYWxlaWRvc2NvcGUgPSBmdW5jdGlvbihpbWFnZURhdGEpIHtcbiAgICB2YXIgeFNpemUgPSBpbWFnZURhdGEud2lkdGgsXG4gICAgICB5U2l6ZSA9IGltYWdlRGF0YS5oZWlnaHQ7XG5cbiAgICB2YXIgeCwgeSwgeG9mZiwgaSwgciwgZywgYiwgYSwgc3JjUG9zLCBkc3RQb3M7XG4gICAgdmFyIHBvd2VyID0gTWF0aC5yb3VuZCh0aGlzLmthbGVpZG9zY29wZVBvd2VyKCkpO1xuICAgIHZhciBhbmdsZSA9IE1hdGgucm91bmQodGhpcy5rYWxlaWRvc2NvcGVBbmdsZSgpKTtcbiAgICB2YXIgb2Zmc2V0ID0gTWF0aC5mbG9vcih4U2l6ZSAqIChhbmdsZSAlIDM2MCkgLyAzNjApO1xuXG4gICAgaWYgKHBvd2VyIDwgMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFdvcmsgd2l0aCBvdXIgc2hhcmVkIGJ1ZmZlciBjYW52YXNcbiAgICB2YXIgdGVtcENhbnZhcyA9IEtvbnZhLlV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgIHRlbXBDYW52YXMud2lkdGggPSB4U2l6ZTtcbiAgICB0ZW1wQ2FudmFzLmhlaWdodCA9IHlTaXplO1xuICAgIHZhciBzY3JhdGNoRGF0YSA9IHRlbXBDYW52YXNcbiAgICAgIC5nZXRDb250ZXh0KCcyZCcpXG4gICAgICAuZ2V0SW1hZ2VEYXRhKDAsIDAsIHhTaXplLCB5U2l6ZSk7XG5cbiAgICAvLyBDb252ZXJ0IHRoaGUgb3JpZ2luYWwgdG8gcG9sYXIgY29vcmRpbmF0ZXNcbiAgICBUb1BvbGFyKGltYWdlRGF0YSwgc2NyYXRjaERhdGEsIHtcbiAgICAgIHBvbGFyQ2VudGVyWDogeFNpemUgLyAyLFxuICAgICAgcG9sYXJDZW50ZXJZOiB5U2l6ZSAvIDJcbiAgICB9KTtcblxuICAgIC8vIERldGVybWluZSBob3cgYmlnIGVhY2ggc2VjdGlvbiB3aWxsIGJlLCBpZiBpdCdzIHRvbyBzbWFsbFxuICAgIC8vIG1ha2UgaXQgYmlnZ2VyXG4gICAgdmFyIG1pblNlY3Rpb25TaXplID0geFNpemUgLyBNYXRoLnBvdygyLCBwb3dlcik7XG4gICAgd2hpbGUgKG1pblNlY3Rpb25TaXplIDw9IDgpIHtcbiAgICAgIG1pblNlY3Rpb25TaXplID0gbWluU2VjdGlvblNpemUgKiAyO1xuICAgICAgcG93ZXIgLT0gMTtcbiAgICB9XG4gICAgbWluU2VjdGlvblNpemUgPSBNYXRoLmNlaWwobWluU2VjdGlvblNpemUpO1xuICAgIHZhciBzZWN0aW9uU2l6ZSA9IG1pblNlY3Rpb25TaXplO1xuXG4gICAgLy8gQ29weSB0aGUgb2Zmc2V0IHJlZ2lvbiB0byAwXG4gICAgLy8gRGVwZW5kaW5nIG9uIHRoZSBzaXplIG9mIGZpbHRlciBhbmQgbG9jYXRpb24gb2YgdGhlIG9mZnNldCB3ZSBtYXkgbmVlZFxuICAgIC8vIHRvIGNvcHkgdGhlIHNlY3Rpb24gYmFja3dhcmRzIHRvIHByZXZlbnQgaXQgZnJvbSByZXdyaXRpbmcgaXRzZWxmXG4gICAgdmFyIHhTdGFydCA9IDAsXG4gICAgICB4RW5kID0gc2VjdGlvblNpemUsXG4gICAgICB4RGVsdGEgPSAxO1xuICAgIGlmIChvZmZzZXQgKyBtaW5TZWN0aW9uU2l6ZSA+IHhTaXplKSB7XG4gICAgICB4U3RhcnQgPSBzZWN0aW9uU2l6ZTtcbiAgICAgIHhFbmQgPSAwO1xuICAgICAgeERlbHRhID0gLTE7XG4gICAgfVxuICAgIGZvciAoeSA9IDA7IHkgPCB5U2l6ZTsgeSArPSAxKSB7XG4gICAgICBmb3IgKHggPSB4U3RhcnQ7IHggIT09IHhFbmQ7IHggKz0geERlbHRhKSB7XG4gICAgICAgIHhvZmYgPSBNYXRoLnJvdW5kKHggKyBvZmZzZXQpICUgeFNpemU7XG4gICAgICAgIHNyY1BvcyA9ICh4U2l6ZSAqIHkgKyB4b2ZmKSAqIDQ7XG4gICAgICAgIHIgPSBzY3JhdGNoRGF0YS5kYXRhW3NyY1BvcyArIDBdO1xuICAgICAgICBnID0gc2NyYXRjaERhdGEuZGF0YVtzcmNQb3MgKyAxXTtcbiAgICAgICAgYiA9IHNjcmF0Y2hEYXRhLmRhdGFbc3JjUG9zICsgMl07XG4gICAgICAgIGEgPSBzY3JhdGNoRGF0YS5kYXRhW3NyY1BvcyArIDNdO1xuICAgICAgICBkc3RQb3MgPSAoeFNpemUgKiB5ICsgeCkgKiA0O1xuICAgICAgICBzY3JhdGNoRGF0YS5kYXRhW2RzdFBvcyArIDBdID0gcjtcbiAgICAgICAgc2NyYXRjaERhdGEuZGF0YVtkc3RQb3MgKyAxXSA9IGc7XG4gICAgICAgIHNjcmF0Y2hEYXRhLmRhdGFbZHN0UG9zICsgMl0gPSBiO1xuICAgICAgICBzY3JhdGNoRGF0YS5kYXRhW2RzdFBvcyArIDNdID0gYTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIHRoZSBhY3R1YWwgZWZmZWN0XG4gICAgZm9yICh5ID0gMDsgeSA8IHlTaXplOyB5ICs9IDEpIHtcbiAgICAgIHNlY3Rpb25TaXplID0gTWF0aC5mbG9vcihtaW5TZWN0aW9uU2l6ZSk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcG93ZXI7IGkgKz0gMSkge1xuICAgICAgICBmb3IgKHggPSAwOyB4IDwgc2VjdGlvblNpemUgKyAxOyB4ICs9IDEpIHtcbiAgICAgICAgICBzcmNQb3MgPSAoeFNpemUgKiB5ICsgeCkgKiA0O1xuICAgICAgICAgIHIgPSBzY3JhdGNoRGF0YS5kYXRhW3NyY1BvcyArIDBdO1xuICAgICAgICAgIGcgPSBzY3JhdGNoRGF0YS5kYXRhW3NyY1BvcyArIDFdO1xuICAgICAgICAgIGIgPSBzY3JhdGNoRGF0YS5kYXRhW3NyY1BvcyArIDJdO1xuICAgICAgICAgIGEgPSBzY3JhdGNoRGF0YS5kYXRhW3NyY1BvcyArIDNdO1xuICAgICAgICAgIGRzdFBvcyA9ICh4U2l6ZSAqIHkgKyBzZWN0aW9uU2l6ZSAqIDIgLSB4IC0gMSkgKiA0O1xuICAgICAgICAgIHNjcmF0Y2hEYXRhLmRhdGFbZHN0UG9zICsgMF0gPSByO1xuICAgICAgICAgIHNjcmF0Y2hEYXRhLmRhdGFbZHN0UG9zICsgMV0gPSBnO1xuICAgICAgICAgIHNjcmF0Y2hEYXRhLmRhdGFbZHN0UG9zICsgMl0gPSBiO1xuICAgICAgICAgIHNjcmF0Y2hEYXRhLmRhdGFbZHN0UG9zICsgM10gPSBhO1xuICAgICAgICB9XG4gICAgICAgIHNlY3Rpb25TaXplICo9IDI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29udmVydCBiYWNrIGZyb20gcG9sYXIgY29vcmRpbmF0ZXNcbiAgICBGcm9tUG9sYXIoc2NyYXRjaERhdGEsIGltYWdlRGF0YSwgeyBwb2xhclJvdGF0aW9uOiAwIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgICogZ2V0L3NldCBrYWxlaWRvc2NvcGUgcG93ZXIuIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkthbGVpZG9zY29wZX0gZmlsdGVyLlxuICAgICogQG5hbWUga2FsZWlkb3Njb3BlUG93ZXJcbiAgICAqIEBtZXRob2RcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICogQHBhcmFtIHtJbnRlZ2VyfSBwb3dlciBvZiBrYWxlaWRvc2NvcGVcbiAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfVxuICAgICovXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLk5vZGUsXG4gICAgJ2thbGVpZG9zY29wZVBvd2VyJyxcbiAgICAyLFxuICAgIG51bGwsXG4gICAgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlclxuICApO1xuXG4gIC8qKlxuICAgICogZ2V0L3NldCBrYWxlaWRvc2NvcGUgYW5nbGUuIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkthbGVpZG9zY29wZX0gZmlsdGVyLlxuICAgICogQG5hbWUga2FsZWlkb3Njb3BlQW5nbGVcbiAgICAqIEBtZXRob2RcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICogQHBhcmFtIHtJbnRlZ2VyfSBkZWdyZWVzXG4gICAgKiBAcmV0dXJucyB7SW50ZWdlcn1cbiAgICAqL1xuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5Ob2RlLFxuICAgICdrYWxlaWRvc2NvcGVBbmdsZScsXG4gICAgMCxcbiAgICBudWxsLFxuICAgIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXJcbiAgKTtcbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvKipcbiAgICAgKiBDb250YWluZXIgY29uc3RydWN0b3IuJm5ic3A7IENvbnRhaW5lcnMgYXJlIHVzZWQgdG8gY29udGFpbiBub2RlcyBvciBvdGhlciBjb250YWluZXJzXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLk5vZGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICAgKiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmNsaXBdIHNldCBjbGlwXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY2xpcFhdIHNldCBjbGlwIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwWV0gc2V0IGNsaXAgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBXaWR0aF0gc2V0IGNsaXAgd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwSGVpZ2h0XSBzZXQgY2xpcCBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmNsaXBGdW5jXSBzZXQgY2xpcCBmdW5jXG5cbiAgICAgKi9cbiAgS29udmEuQ29udGFpbmVyID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdGhpcy5fX2luaXQoY29uZmlnKTtcbiAgfTtcblxuICBLb252YS5VdGlsLmFkZE1ldGhvZHMoS29udmEuQ29udGFpbmVyLCB7XG4gICAgX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4gPSBuZXcgS29udmEuQ29sbGVjdGlvbigpO1xuICAgICAgS29udmEuTm9kZS5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogcmV0dXJucyBhIHtAbGluayBLb252YS5Db2xsZWN0aW9ufSBvZiBkaXJlY3QgZGVzY2VuZGFudCBub2Rlc1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250YWluZXIucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtmaWx0ZXJGdW5jXSBmaWx0ZXIgZnVuY3Rpb25cbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLkNvbGxlY3Rpb259XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIGdldCBhbGwgY2hpbGRyZW5cbiAgICAgICAgICogdmFyIGNoaWxkcmVuID0gbGF5ZXIuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gZ2V0IG9ubHkgY2lyY2xlc1xuICAgICAgICAgKiB2YXIgY2lyY2xlcyA9IGxheWVyLmdldENoaWxkcmVuKGZ1bmN0aW9uKG5vZGUpe1xuICAgICAgICAgKiAgICByZXR1cm4gbm9kZS5nZXRDbGFzc05hbWUoKSA9PT0gJ0NpcmNsZSc7XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKi9cbiAgICBnZXRDaGlsZHJlbjogZnVuY3Rpb24oZmlsdGVyRnVuYykge1xuICAgICAgaWYgKCFmaWx0ZXJGdW5jKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0cyA9IG5ldyBLb252YS5Db2xsZWN0aW9uKCk7XG4gICAgICB0aGlzLmNoaWxkcmVuLmVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgaWYgKGZpbHRlckZ1bmMoY2hpbGQpKSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiBkZXRlcm1pbmUgaWYgbm9kZSBoYXMgY2hpbGRyZW5cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgaGFzQ2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2hpbGRyZW4oKS5sZW5ndGggPiAwO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIHJlbW92ZSBhbGwgY2hpbGRyZW5cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICByZW1vdmVDaGlsZHJlbjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBLb252YS5Db2xsZWN0aW9uLnRvQ29sbGVjdGlvbih0aGlzLmNoaWxkcmVuKTtcbiAgICAgIHZhciBjaGlsZDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgLy8gcmVzZXQgcGFyZW50IHRvIHByZXZlbnQgbWFueSBfc2V0Q2hpbGRyZW5JbmRpY2VzIGNhbGxzXG4gICAgICAgIGRlbGV0ZSBjaGlsZC5wYXJlbnQ7XG4gICAgICAgIGNoaWxkLmluZGV4ID0gMDtcbiAgICAgICAgY2hpbGQucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbiA9IG51bGw7XG4gICAgICB0aGlzLmNoaWxkcmVuID0gbmV3IEtvbnZhLkNvbGxlY3Rpb24oKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIGRlc3Ryb3kgYWxsIGNoaWxkcmVuXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgZGVzdHJveUNoaWxkcmVuOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IEtvbnZhLkNvbGxlY3Rpb24udG9Db2xsZWN0aW9uKHRoaXMuY2hpbGRyZW4pO1xuICAgICAgdmFyIGNoaWxkO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAvLyByZXNldCBwYXJlbnQgdG8gcHJldmVudCBtYW55IF9zZXRDaGlsZHJlbkluZGljZXMgY2FsbHNcbiAgICAgICAgZGVsZXRlIGNoaWxkLnBhcmVudDtcbiAgICAgICAgY2hpbGQuaW5kZXggPSAwO1xuICAgICAgICBjaGlsZC5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbiA9IG51bGw7XG4gICAgICB0aGlzLmNoaWxkcmVuID0gbmV3IEtvbnZhLkNvbGxlY3Rpb24oKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIEFkZCBub2RlIG9yIG5vZGVzIHRvIGNvbnRhaW5lci5cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0gey4uLktvbnZhLk5vZGV9IGNoaWxkXG4gICAgICAgICAqIEByZXR1cm5zIHtDb250YWluZXJ9XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGxheWVyLmFkZChzaGFwZTEsIHNoYXBlMiwgc2hhcGUzKTtcbiAgICAgICAgICovXG4gICAgYWRkOiBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5hZGQoYXJndW1lbnRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZC5nZXRQYXJlbnQoKSkge1xuICAgICAgICBjaGlsZC5tb3ZlVG8odGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICAgIHRoaXMuX3ZhbGlkYXRlQWRkKGNoaWxkKTtcbiAgICAgIGNoaWxkLmluZGV4ID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgdGhpcy5fZmlyZSgnYWRkJywge1xuICAgICAgICBjaGlsZDogY2hpbGRcbiAgICAgIH0pO1xuXG4gICAgICAvLyBpZiBub2RlIHVuZGVyIGRyYWcgd2UgbmVlZCB0byB1cGRhdGUgZHJhZyBhbmltYXRpb25cbiAgICAgIGlmIChLb252YS5ERCAmJiBjaGlsZC5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgS29udmEuREQuYW5pbS5zZXRMYXllcnMoY2hpbGQuZ2V0TGF5ZXIoKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNoYWluYWJsZVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGRlc3Ryb3kgY2hpbGRyZW5cbiAgICAgIGlmICh0aGlzLmhhc0NoaWxkcmVuKCkpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95Q2hpbGRyZW4oKTtcbiAgICAgIH1cbiAgICAgIC8vIHRoZW4gZGVzdHJveSBzZWxmXG4gICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiByZXR1cm4gYSB7QGxpbmsgS29udmEuQ29sbGVjdGlvbn0gb2Ygbm9kZXMgdGhhdCBtYXRjaCB0aGUgc2VsZWN0b3IuICBVc2UgJyMnIGZvciBpZCBzZWxlY3Rpb25zXG4gICAgICAgICAqIGFuZCAnLicgZm9yIG5hbWUgc2VsZWN0aW9ucy4gIFlvdSBjYW4gYWxzbyBzZWxlY3QgYnkgdHlwZSBvciBjbGFzcyBuYW1lLiBQYXNzIG11bHRpcGxlIHNlbGVjdG9yc1xuICAgICAgICAgKiBzZXBhcmF0ZWQgYnkgYSBzcGFjZS5cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3JcbiAgICAgICAgICogQHJldHVybnMge0NvbGxlY3Rpb259XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIHNlbGVjdCBub2RlIHdpdGggaWQgZm9vXG4gICAgICAgICAqIHZhciBub2RlID0gc3RhZ2UuZmluZCgnI2ZvbycpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBzZWxlY3Qgbm9kZXMgd2l0aCBuYW1lIGJhciBpbnNpZGUgbGF5ZXJcbiAgICAgICAgICogdmFyIG5vZGVzID0gbGF5ZXIuZmluZCgnLmJhcicpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBzZWxlY3QgYWxsIGdyb3VwcyBpbnNpZGUgbGF5ZXJcbiAgICAgICAgICogdmFyIG5vZGVzID0gbGF5ZXIuZmluZCgnR3JvdXAnKTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gc2VsZWN0IGFsbCByZWN0YW5nbGVzIGluc2lkZSBsYXllclxuICAgICAgICAgKiB2YXIgbm9kZXMgPSBsYXllci5maW5kKCdSZWN0Jyk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIHNlbGVjdCBub2RlIHdpdGggYW4gaWQgb2YgZm9vIG9yIGEgbmFtZSBvZiBiYXIgaW5zaWRlIGxheWVyXG4gICAgICAgICAqIHZhciBub2RlcyA9IGxheWVyLmZpbmQoJyNmb28sIC5iYXInKTtcbiAgICAgICAgICovXG4gICAgZmluZDogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgIHZhciByZXRBcnIgPSBbXSxcbiAgICAgICAgc2VsZWN0b3JBcnIgPSBzZWxlY3Rvci5yZXBsYWNlKC8gL2csICcnKS5zcGxpdCgnLCcpLFxuICAgICAgICBsZW4gPSBzZWxlY3RvckFyci5sZW5ndGgsXG4gICAgICAgIG4sXG4gICAgICAgIGksXG4gICAgICAgIHNlbCxcbiAgICAgICAgYXJyLFxuICAgICAgICBub2RlLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgY2xlbjtcblxuICAgICAgZm9yIChuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgIHNlbCA9IHNlbGVjdG9yQXJyW25dO1xuICAgICAgICBpZiAoIUtvbnZhLlV0aWwuaXNWYWxpZFNlbGVjdG9yKHNlbCkpIHtcbiAgICAgICAgICBLb252YS5VdGlsLndhcm4oXG4gICAgICAgICAgICAnU2VsZWN0b3IgXCInICtcbiAgICAgICAgICAgICAgc2VsICtcbiAgICAgICAgICAgICAgJ1wiIGlzIGludmFsaWQuIEFsbG93ZWQgc2VsZWN0b3JzIGV4YW1wbGVzIGFyZSBcIiNmb29cIiwgXCIuYmFyXCIgb3IgXCJHcm91cFwiLidcbiAgICAgICAgICApO1xuICAgICAgICAgIEtvbnZhLlV0aWwud2FybihcbiAgICAgICAgICAgICdJZiB5b3UgaGF2ZSBhIGN1c3RvbSBzaGFwZSB3aXRoIHN1Y2ggY2xhc3NOYW1lLCBwbGVhc2UgY2hhbmdlIGl0IHRvIHN0YXJ0IHdpdGggdXBwZXIgbGV0dGVyIGxpa2UgXCJUcmlhbmdsZVwiLidcbiAgICAgICAgICApO1xuICAgICAgICAgIEtvbnZhLlV0aWwud2FybignS29udmEgaXMgYXdlc29tZSwgcmlnaHQ/Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWQgc2VsZWN0b3JcbiAgICAgICAgaWYgKHNlbC5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICAgIG5vZGUgPSB0aGlzLl9nZXROb2RlQnlJZChzZWwuc2xpY2UoMSkpO1xuICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICByZXRBcnIucHVzaChub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsLmNoYXJBdCgwKSA9PT0gJy4nKSB7XG4gICAgICAgICAgLy8gbmFtZSBzZWxlY3RvclxuICAgICAgICAgIGFyciA9IHRoaXMuX2dldE5vZGVzQnlOYW1lKHNlbC5zbGljZSgxKSk7XG4gICAgICAgICAgcmV0QXJyID0gcmV0QXJyLmNvbmNhdChhcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHVucmVjb2duaXplZCBzZWxlY3RvciwgcGFzcyB0byBjaGlsZHJlblxuICAgICAgICAgIGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbigpO1xuICAgICAgICAgIGNsZW4gPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNsZW47IGkrKykge1xuICAgICAgICAgICAgcmV0QXJyID0gcmV0QXJyLmNvbmNhdChjaGlsZHJlbltpXS5fZ2V0KHNlbCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gS29udmEuQ29sbGVjdGlvbi50b0NvbGxlY3Rpb24ocmV0QXJyKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiByZXR1cm4gYSBmaXJzdCBub2RlIGZyb20gYGZpbmRgIG1ldGhvZFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250YWluZXIucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvclxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogLy8gc2VsZWN0IG5vZGUgd2l0aCBpZCBmb29cbiAgICAgICAgICogdmFyIG5vZGUgPSBzdGFnZS5maW5kT25lKCcjZm9vJyk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIHNlbGVjdCBub2RlIHdpdGggbmFtZSBiYXIgaW5zaWRlIGxheWVyXG4gICAgICAgICAqIHZhciBub2RlcyA9IGxheWVyLmZpbmRPbmUoJy5iYXInKTtcbiAgICAgICAgICovXG4gICAgZmluZE9uZTogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmQoc2VsZWN0b3IpWzBdO1xuICAgIH0sXG4gICAgX2dldE5vZGVCeUlkOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHZhciBub2RlID0gS29udmEuaWRzW2tleV07XG5cbiAgICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5pc0FuY2VzdG9yT2Yobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIF9nZXROb2Rlc0J5TmFtZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICB2YXIgYXJyID0gS29udmEubmFtZXNba2V5XSB8fCBbXTtcbiAgICAgIHJldHVybiB0aGlzLl9nZXREZXNjZW5kYW50cyhhcnIpO1xuICAgIH0sXG4gICAgX2dldDogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgIHZhciByZXRBcnIgPSBLb252YS5Ob2RlLnByb3RvdHlwZS5fZ2V0LmNhbGwodGhpcywgc2VsZWN0b3IpO1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbigpO1xuICAgICAgdmFyIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgcmV0QXJyID0gcmV0QXJyLmNvbmNhdChjaGlsZHJlbltuXS5fZ2V0KHNlbGVjdG9yKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0QXJyO1xuICAgIH0sXG4gICAgLy8gZXh0ZW5kZXJzXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9iaiA9IEtvbnZhLk5vZGUucHJvdG90eXBlLnRvT2JqZWN0LmNhbGwodGhpcyk7XG5cbiAgICAgIG9iai5jaGlsZHJlbiA9IFtdO1xuXG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmdldENoaWxkcmVuKCk7XG4gICAgICB2YXIgbGVuID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltuXTtcbiAgICAgICAgb2JqLmNoaWxkcmVuLnB1c2goY2hpbGQudG9PYmplY3QoKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBfZ2V0RGVzY2VuZGFudHM6IGZ1bmN0aW9uKGFycikge1xuICAgICAgdmFyIHJldEFyciA9IFtdO1xuICAgICAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgIHZhciBub2RlID0gYXJyW25dO1xuICAgICAgICBpZiAodGhpcy5pc0FuY2VzdG9yT2Yobm9kZSkpIHtcbiAgICAgICAgICByZXRBcnIucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0QXJyO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIGRldGVybWluZSBpZiBub2RlIGlzIGFuIGFuY2VzdG9yXG4gICAgICAgICAqIG9mIGRlc2NlbmRhbnRcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge0tvbnZhLk5vZGV9IG5vZGVcbiAgICAgICAgICovXG4gICAgaXNBbmNlc3Rvck9mOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgaWYgKHBhcmVudC5faWQgPT09IHRoaXMuX2lkKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBjbG9uZTogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAvLyBjYWxsIHN1cGVyIG1ldGhvZFxuICAgICAgdmFyIG5vZGUgPSBLb252YS5Ob2RlLnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMsIG9iaik7XG5cbiAgICAgIHRoaXMuZ2V0Q2hpbGRyZW4oKS5lYWNoKGZ1bmN0aW9uKG5vKSB7XG4gICAgICAgIG5vZGUuYWRkKG5vLmNsb25lKCkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiBnZXQgYWxsIHNoYXBlcyB0aGF0IGludGVyc2VjdCBhIHBvaW50LiAgTm90ZTogYmVjYXVzZSB0aGlzIG1ldGhvZCBtdXN0IGNsZWFyIGEgdGVtcG9yYXJ5XG4gICAgICAgICAqIGNhbnZhcyBhbmQgcmVkcmF3IGV2ZXJ5IHNoYXBlIGluc2lkZSB0aGUgY29udGFpbmVyLCBpdCBzaG91bGQgb25seSBiZSB1c2VkIGZvciBzcGVjaWFsIHNpdGF0aW9uc1xuICAgICAgICAgKiBiZWNhdXNlIGl0IHBlcmZvcm1zIHZlcnkgcG9vcmx5LiAgUGxlYXNlIHVzZSB0aGUge0BsaW5rIEtvbnZhLlN0YWdlI2dldEludGVyc2VjdGlvbn0gbWV0aG9kIGlmIGF0IGFsbCBwb3NzaWJsZVxuICAgICAgICAgKiBiZWNhdXNlIGl0IHBlcmZvcm1zIG11Y2ggYmV0dGVyXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBvc1xuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gcG9zLnhcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvcy55XG4gICAgICAgICAqIEByZXR1cm5zIHtBcnJheX0gYXJyYXkgb2Ygc2hhcGVzXG4gICAgICAgICAqL1xuICAgIGdldEFsbEludGVyc2VjdGlvbnM6IGZ1bmN0aW9uKHBvcykge1xuICAgICAgdmFyIGFyciA9IFtdO1xuXG4gICAgICB0aGlzLmZpbmQoJ1NoYXBlJykuZWFjaChmdW5jdGlvbihzaGFwZSkge1xuICAgICAgICBpZiAoc2hhcGUuaXNWaXNpYmxlKCkgJiYgc2hhcGUuaW50ZXJzZWN0cyhwb3MpKSB7XG4gICAgICAgICAgYXJyLnB1c2goc2hhcGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIF9zZXRDaGlsZHJlbkluZGljZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5jaGlsZHJlbi5lYWNoKGZ1bmN0aW9uKGNoaWxkLCBuKSB7XG4gICAgICAgIGNoaWxkLmluZGV4ID0gbjtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZHJhd1NjZW5lOiBmdW5jdGlvbihjYW4sIHRvcCwgY2FjaGluZykge1xuICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpLFxuICAgICAgICBjYW52YXMgPSBjYW4gfHwgKGxheWVyICYmIGxheWVyLmdldENhbnZhcygpKSxcbiAgICAgICAgY29udGV4dCA9IGNhbnZhcyAmJiBjYW52YXMuZ2V0Q29udGV4dCgpLFxuICAgICAgICBjYWNoZWRDYW52YXMgPSB0aGlzLl9jYWNoZS5jYW52YXMsXG4gICAgICAgIGNhY2hlZFNjZW5lQ2FudmFzID0gY2FjaGVkQ2FudmFzICYmIGNhY2hlZENhbnZhcy5zY2VuZTtcblxuICAgICAgaWYgKHRoaXMuaXNWaXNpYmxlKCkpIHtcbiAgICAgICAgaWYgKCFjYWNoaW5nICYmIGNhY2hlZFNjZW5lQ2FudmFzKSB7XG4gICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgbGF5ZXIuX2FwcGx5VHJhbnNmb3JtKHRoaXMsIGNvbnRleHQsIHRvcCk7XG4gICAgICAgICAgdGhpcy5fZHJhd0NhY2hlZFNjZW5lQ2FudmFzKGNvbnRleHQpO1xuICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2RyYXdDaGlsZHJlbihjYW52YXMsICdkcmF3U2NlbmUnLCB0b3AsIGZhbHNlLCBjYWNoaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBkcmF3SGl0OiBmdW5jdGlvbihjYW4sIHRvcCwgY2FjaGluZykge1xuICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpLFxuICAgICAgICBjYW52YXMgPSBjYW4gfHwgKGxheWVyICYmIGxheWVyLmhpdENhbnZhcyksXG4gICAgICAgIGNvbnRleHQgPSBjYW52YXMgJiYgY2FudmFzLmdldENvbnRleHQoKSxcbiAgICAgICAgY2FjaGVkQ2FudmFzID0gdGhpcy5fY2FjaGUuY2FudmFzLFxuICAgICAgICBjYWNoZWRIaXRDYW52YXMgPSBjYWNoZWRDYW52YXMgJiYgY2FjaGVkQ2FudmFzLmhpdDtcblxuICAgICAgaWYgKHRoaXMuc2hvdWxkRHJhd0hpdChjYW52YXMpKSB7XG4gICAgICAgIGlmIChsYXllcikge1xuICAgICAgICAgIGxheWVyLmNsZWFySGl0Q2FjaGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNhY2hpbmcgJiYgY2FjaGVkSGl0Q2FudmFzKSB7XG4gICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgbGF5ZXIuX2FwcGx5VHJhbnNmb3JtKHRoaXMsIGNvbnRleHQsIHRvcCk7XG4gICAgICAgICAgdGhpcy5fZHJhd0NhY2hlZEhpdENhbnZhcyhjb250ZXh0KTtcbiAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9kcmF3Q2hpbGRyZW4oY2FudmFzLCAnZHJhd0hpdCcsIHRvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgX2RyYXdDaGlsZHJlbjogZnVuY3Rpb24oY2FudmFzLCBkcmF3TWV0aG9kLCB0b3AsIGNhY2hpbmcsIHNraXBCdWZmZXIpIHtcbiAgICAgIHZhciBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKSxcbiAgICAgICAgY29udGV4dCA9IGNhbnZhcyAmJiBjYW52YXMuZ2V0Q29udGV4dCgpLFxuICAgICAgICBjbGlwV2lkdGggPSB0aGlzLmdldENsaXBXaWR0aCgpLFxuICAgICAgICBjbGlwSGVpZ2h0ID0gdGhpcy5nZXRDbGlwSGVpZ2h0KCksXG4gICAgICAgIGNsaXBGdW5jID0gdGhpcy5nZXRDbGlwRnVuYygpLFxuICAgICAgICBoYXNDbGlwID0gKGNsaXBXaWR0aCAmJiBjbGlwSGVpZ2h0KSB8fCBjbGlwRnVuYyxcbiAgICAgICAgY2xpcFgsXG4gICAgICAgIGNsaXBZO1xuXG4gICAgICBpZiAoaGFzQ2xpcCAmJiBsYXllcikge1xuICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMuZ2V0QWJzb2x1dGVUcmFuc2Zvcm0odG9wKTtcbiAgICAgICAgdmFyIG0gPSB0cmFuc2Zvcm0uZ2V0TWF0cml4KCk7XG4gICAgICAgIGNvbnRleHQudHJhbnNmb3JtKG1bMF0sIG1bMV0sIG1bMl0sIG1bM10sIG1bNF0sIG1bNV0pO1xuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBpZiAoY2xpcEZ1bmMpIHtcbiAgICAgICAgICBjbGlwRnVuYy5jYWxsKHRoaXMsIGNvbnRleHQsIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsaXBYID0gdGhpcy5nZXRDbGlwWCgpO1xuICAgICAgICAgIGNsaXBZID0gdGhpcy5nZXRDbGlwWSgpO1xuICAgICAgICAgIGNvbnRleHQucmVjdChjbGlwWCwgY2xpcFksIGNsaXBXaWR0aCwgY2xpcEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5jbGlwKCk7XG4gICAgICAgIG0gPSB0cmFuc2Zvcm0uY29weSgpLmludmVydCgpLmdldE1hdHJpeCgpO1xuICAgICAgICBjb250ZXh0LnRyYW5zZm9ybShtWzBdLCBtWzFdLCBtWzJdLCBtWzNdLCBtWzRdLCBtWzVdKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jaGlsZHJlbi5lYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgIGNoaWxkW2RyYXdNZXRob2RdKGNhbnZhcywgdG9wLCBjYWNoaW5nLCBza2lwQnVmZmVyKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaGFzQ2xpcCkge1xuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNob3VsZERyYXdIaXQ6IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpO1xuICAgICAgdmFyIGRkID0gS29udmEuREQ7XG4gICAgICB2YXIgbGF5ZXJVbmRlckRyYWcgPVxuICAgICAgICBkZCAmJlxuICAgICAgICBLb252YS5pc0RyYWdnaW5nKCkgJiZcbiAgICAgICAgS29udmEuREQuYW5pbS5nZXRMYXllcnMoKS5pbmRleE9mKGxheWVyKSAhPT0gLTE7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAoY2FudmFzICYmIGNhbnZhcy5pc0NhY2hlKSB8fFxuICAgICAgICAobGF5ZXIgJiZcbiAgICAgICAgICBsYXllci5oaXRHcmFwaEVuYWJsZWQoKSAmJlxuICAgICAgICAgIHRoaXMuaXNWaXNpYmxlKCkgJiZcbiAgICAgICAgICAhbGF5ZXJVbmRlckRyYWcpXG4gICAgICApO1xuICAgIH0sXG4gICAgZ2V0Q2xpZW50UmVjdDogZnVuY3Rpb24oYXR0cnMpIHtcbiAgICAgIGF0dHJzID0gYXR0cnMgfHwge307XG4gICAgICB2YXIgc2tpcFRyYW5zZm9ybSA9IGF0dHJzLnNraXBUcmFuc2Zvcm07XG4gICAgICB2YXIgcmVsYXRpdmVUbyA9IGF0dHJzLnJlbGF0aXZlVG87XG5cbiAgICAgIHZhciBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZO1xuICAgICAgdmFyIHNlbGZSZWN0ID0ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwXG4gICAgICB9O1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgdGhpcy5jaGlsZHJlbi5lYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgIC8vIHNraXAgaW52aXNpYmxlIGNoaWxkcmVuXG4gICAgICAgIGlmICghY2hpbGQuaXNWaXNpYmxlKCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlY3QgPSBjaGlsZC5nZXRDbGllbnRSZWN0KHsgcmVsYXRpdmVUbzogdGhhdCB9KTtcblxuICAgICAgICAvLyBza2lwIGludmlzaWJsZSBjaGlsZHJlbiAobGlrZSBlbXB0eSBncm91cHMpXG4gICAgICAgIC8vIG9yIGRvbid0IHNraXAuLi4gaG1tbS4uLlxuICAgICAgICAvLyBpZiAocmVjdC53aWR0aCA9PT0gMCAmJiByZWN0LmhlaWdodCA9PT0gMCkge1xuICAgICAgICAvLyAgICAgcmV0dXJuO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgaWYgKG1pblggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIGluaXRpYWwgdmFsdWUgZm9yIGZpcnN0IGNoaWxkXG4gICAgICAgICAgbWluWCA9IHJlY3QueDtcbiAgICAgICAgICBtaW5ZID0gcmVjdC55O1xuICAgICAgICAgIG1heFggPSByZWN0LnggKyByZWN0LndpZHRoO1xuICAgICAgICAgIG1heFkgPSByZWN0LnkgKyByZWN0LmhlaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgcmVjdC54KTtcbiAgICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgcmVjdC55KTtcbiAgICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgcmVjdC54ICsgcmVjdC53aWR0aCk7XG4gICAgICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHJlY3QueSArIHJlY3QuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBzZWxmUmVjdCA9IHtcbiAgICAgICAgICB4OiBtaW5YLFxuICAgICAgICAgIHk6IG1pblksXG4gICAgICAgICAgd2lkdGg6IG1heFggLSBtaW5YLFxuICAgICAgICAgIGhlaWdodDogbWF4WSAtIG1pbllcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFza2lwVHJhbnNmb3JtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2Zvcm1lZFJlY3Qoc2VsZlJlY3QsIHJlbGF0aXZlVG8pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGZSZWN0O1xuICAgIH1cbiAgfSk7XG5cbiAgS29udmEuVXRpbC5leHRlbmQoS29udmEuQ29udGFpbmVyLCBLb252YS5Ob2RlKTtcbiAgLy8gZGVwcmVjYXRlZCBtZXRob2RzXG4gIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGUuZ2V0ID0gS29udmEuQ29udGFpbmVyLnByb3RvdHlwZS5maW5kO1xuXG4gIC8vIGFkZCBnZXR0ZXJzIHNldHRlcnNcbiAgS29udmEuRmFjdG9yeS5hZGRDb21wb25lbnRzR2V0dGVyU2V0dGVyKEtvbnZhLkNvbnRhaW5lciwgJ2NsaXAnLCBbXG4gICAgJ3gnLFxuICAgICd5JyxcbiAgICAnd2lkdGgnLFxuICAgICdoZWlnaHQnXG4gIF0pO1xuICAvKipcbiAgICAgKiBnZXQvc2V0IGNsaXBcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG5hbWUgY2xpcFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250YWluZXIucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNsaXBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2xpcC54XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNsaXAueVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjbGlwLndpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNsaXAuaGVpZ2h0XG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBjbGlwXG4gICAgICogdmFyIGNsaXAgPSBjb250YWluZXIuY2xpcCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGNsaXBcbiAgICAgKiBjb250YWluZXIuc2V0Q2xpcCh7XG4gICAgICogICB4OiAyMCxcbiAgICAgKiAgIHk6IDIwLFxuICAgICAqICAgd2lkdGg6IDIwLFxuICAgICAqICAgaGVpZ2h0OiAyMFxuICAgICAqIH0pO1xuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkNvbnRhaW5lciwgJ2NsaXBYJyk7XG4gIC8qKlxuICAgICAqIGdldC9zZXQgY2xpcCB4XG4gICAgICogQG5hbWUgY2xpcFhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgY2xpcCB4XG4gICAgICogdmFyIGNsaXBYID0gY29udGFpbmVyLmNsaXBYKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgY2xpcCB4XG4gICAgICogY29udGFpbmVyLmNsaXBYKDEwKTtcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Db250YWluZXIsICdjbGlwWScpO1xuICAvKipcbiAgICAgKiBnZXQvc2V0IGNsaXAgeVxuICAgICAqIEBuYW1lIGNsaXBZXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250YWluZXIucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGNsaXAgeVxuICAgICAqIHZhciBjbGlwWSA9IGNvbnRhaW5lci5jbGlwWSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGNsaXAgeVxuICAgICAqIGNvbnRhaW5lci5jbGlwWSgxMCk7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuQ29udGFpbmVyLCAnY2xpcFdpZHRoJyk7XG4gIC8qKlxuICAgICAqIGdldC9zZXQgY2xpcCB3aWR0aFxuICAgICAqIEBuYW1lIGNsaXBXaWR0aFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgY2xpcCB3aWR0aFxuICAgICAqIHZhciBjbGlwV2lkdGggPSBjb250YWluZXIuY2xpcFdpZHRoKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgY2xpcCB3aWR0aFxuICAgICAqIGNvbnRhaW5lci5jbGlwV2lkdGgoMTAwKTtcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Db250YWluZXIsICdjbGlwSGVpZ2h0Jyk7XG4gIC8qKlxuICAgICAqIGdldC9zZXQgY2xpcCBoZWlnaHRcbiAgICAgKiBAbmFtZSBjbGlwSGVpZ2h0XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250YWluZXIucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgY2xpcCBoZWlnaHRcbiAgICAgKiB2YXIgY2xpcEhlaWdodCA9IGNvbnRhaW5lci5jbGlwSGVpZ2h0KCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgY2xpcCBoZWlnaHRcbiAgICAgKiBjb250YWluZXIuY2xpcEhlaWdodCgxMDApO1xuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkNvbnRhaW5lciwgJ2NsaXBGdW5jJyk7XG4gIC8qKlxuICAgICAgKiBnZXQvc2V0IGNsaXAgZnVuY3Rpb25cbiAgICAgICogQG5hbWUgY2xpcEZ1bmNcbiAgICAgICogQG1ldGhvZFxuICAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZVxuICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jdGlvblxuICAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gICAgICAqIEBleGFtcGxlXG4gICAgICAqIC8vIGdldCBjbGlwIGZ1bmN0aW9uXG4gICAgICAqIHZhciBjbGlwRnVuY3Rpb24gPSBjb250YWluZXIuY2xpcEZ1bmMoKTtcbiAgICAgICpcbiAgICAgICogLy8gc2V0IGNsaXAgaGVpZ2h0XG4gICAgICAqIGNvbnRhaW5lci5jbGlwRnVuYyhmdW5jdGlvbihjdHgpIHtcbiAgICAgICogICBjdHgucmVjdCgwLCAwLCAxMDAsIDEwMCk7XG4gICAgICAqIH0pO1xuICAgICAgKi9cblxuICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuQ29udGFpbmVyKTtcbn0pKCk7XG5cbihmdW5jdGlvbihLb252YSkge1xuICAndXNlIHN0cmljdCc7XG4gIHZhciBIQVNfU0hBRE9XID0gJ2hhc1NoYWRvdyc7XG4gIHZhciBTSEFET1dfUkdCQSA9ICdzaGFkb3dSR0JBJztcblxuICBmdW5jdGlvbiBfZmlsbEZ1bmMoY29udGV4dCkge1xuICAgIGNvbnRleHQuZmlsbCgpO1xuICB9XG4gIGZ1bmN0aW9uIF9zdHJva2VGdW5jKGNvbnRleHQpIHtcbiAgICBjb250ZXh0LnN0cm9rZSgpO1xuICB9XG4gIGZ1bmN0aW9uIF9maWxsRnVuY0hpdChjb250ZXh0KSB7XG4gICAgY29udGV4dC5maWxsKCk7XG4gIH1cbiAgZnVuY3Rpb24gX3N0cm9rZUZ1bmNIaXQoY29udGV4dCkge1xuICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBfY2xlYXJIYXNTaGFkb3dDYWNoZSgpIHtcbiAgICB0aGlzLl9jbGVhckNhY2hlKEhBU19TSEFET1cpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NsZWFyR2V0U2hhZG93UkdCQUNhY2hlKCkge1xuICAgIHRoaXMuX2NsZWFyQ2FjaGUoU0hBRE9XX1JHQkEpO1xuICB9XG5cbiAgLyoqXG4gICAgICogU2hhcGUgY29uc3RydWN0b3IuICBTaGFwZXMgYXJlIHByaW1pdGl2ZSBvYmplY3RzIHN1Y2ggYXMgcmVjdGFuZ2xlcyxcbiAgICAgKiAgY2lyY2xlcywgdGV4dCwgbGluZXMsIGV0Yy5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKiBAYXVnbWVudHMgS29udmEuTm9kZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsXSBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW2NvbmZpZy5maWxsUGF0dGVybkltYWdlXSBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5ZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRZXSBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlXSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuUm90YXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFBhdHRlcm5SZXBlYXRdIGNhbiBiZSBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gIFRoZSBkZWZhdWx0IGlzIFwibm8tcmVwZWF0XCJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFldXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFldIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZpbGxFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZpbGwuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFByaW9yaXR5XSBjYW4gYmUgY29sb3IsIGxpbmVhci1ncmFkaWVudCwgcmFkaWFsLWdyYWlkZW50LCBvciBwYXR0ZXJuLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgY29sb3IuICBUaGUgZmlsbFByaW9yaXR5IHByb3BlcnR5IG1ha2VzIGl0IHJlYWxseSBlYXN5IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGEgZmlsbCBjb2xvciBzdHlsZSBhbmQgYSBmaWxsIHBhdHRlcm4gc3R5bGUsIHNpbXBseSBzZXQgdGhlIGZpbGwgcHJvcGVydHkgYW5kIHRoZSBmaWxsUGF0dGVybiBwcm9wZXJ0aWVzLCBhbmQgdGhlbiB1c2Ugc2V0RmlsbFByaW9yaXR5KCdjb2xvcicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCBhIGNvbG9yIGZpbGwsIG9yIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ3BhdHRlcm4nKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggdGhlIHBhdHRlcm4gZmlsbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc3Ryb2tlXSBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdHJva2VXaWR0aF0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUhpdEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2UgaGl0IHJlZ2lvbi4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucGVyZmVjdERyYXdFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdXNpbmcgYnVmZmVyIGNhbnZhcy4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXNvdyBmb3Igc3Ryb2tlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VTY2FsZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2Ugc2NhbGUuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc3Ryb2tlLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVKb2luXSBjYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIG1pdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUNhcF0gY2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcWFyZS4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIGJ1dHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaGFkb3dDb2xvcl1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dCbHVyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNoYWRvd09mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T3BhY2l0eV0gc2hhZG93IG9wYWNpdHkuICBDYW4gYmUgYW55IHJlYWwgbnVtYmVyXG4gICAgICogIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRhc2hdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRhc2hFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGRhc2hBcnJheS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGN1c3RvbVNoYXBlID0gbmV3IEtvbnZhLlNoYXBlKHtcbiAgICAgICAgICogICB4OiA1LFxuICAgICAgICAgKiAgIHk6IDEwLFxuICAgICAgICAgKiAgIGZpbGw6ICdyZWQnLFxuICAgICAgICAgKiAgIC8vIGEgS29udmEuQ2FudmFzIHJlbmRlcmVyIGlzIHBhc3NlZCBpbnRvIHRoZSBkcmF3RnVuYyBmdW5jdGlvblxuICAgICAgICAgKiAgIGRyYXdGdW5jOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICAgICAqICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgKiAgICAgY29udGV4dC5tb3ZlVG8oMjAwLCA1MCk7XG4gICAgICAgICAqICAgICBjb250ZXh0LmxpbmVUbyg0MjAsIDgwKTtcbiAgICAgICAgICogICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbygzMDAsIDEwMCwgMjYwLCAxNzApO1xuICAgICAgICAgKiAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICogICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgICAgICAgKiAgIH1cbiAgICAgICAgICp9KTtcbiAgICAgKi9cbiAgS29udmEuU2hhcGUgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICB0aGlzLl9faW5pdChjb25maWcpO1xuICB9O1xuXG4gIEtvbnZhLlV0aWwuYWRkTWV0aG9kcyhLb252YS5TaGFwZSwge1xuICAgIF9faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICB0aGlzLm5vZGVUeXBlID0gJ1NoYXBlJztcbiAgICAgIHRoaXMuX2ZpbGxGdW5jID0gX2ZpbGxGdW5jO1xuICAgICAgdGhpcy5fc3Ryb2tlRnVuYyA9IF9zdHJva2VGdW5jO1xuICAgICAgdGhpcy5fZmlsbEZ1bmNIaXQgPSBfZmlsbEZ1bmNIaXQ7XG4gICAgICB0aGlzLl9zdHJva2VGdW5jSGl0ID0gX3N0cm9rZUZ1bmNIaXQ7XG5cbiAgICAgIC8vIHNldCBjb2xvcktleVxuICAgICAgdmFyIHNoYXBlcyA9IEtvbnZhLnNoYXBlcztcbiAgICAgIHZhciBrZXk7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGtleSA9IEtvbnZhLlV0aWwuZ2V0UmFuZG9tQ29sb3IoKTtcbiAgICAgICAgaWYgKGtleSAmJiAhKGtleSBpbiBzaGFwZXMpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5jb2xvcktleSA9IGtleTtcbiAgICAgIHNoYXBlc1trZXldID0gdGhpcztcblxuICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxuICAgICAgS29udmEuTm9kZS5jYWxsKHRoaXMsIGNvbmZpZyk7XG5cbiAgICAgIHRoaXMub24oXG4gICAgICAgICdzaGFkb3dDb2xvckNoYW5nZS5rb252YSBzaGFkb3dCbHVyQ2hhbmdlLmtvbnZhIHNoYWRvd09mZnNldENoYW5nZS5rb252YSBzaGFkb3dPcGFjaXR5Q2hhbmdlLmtvbnZhIHNoYWRvd0VuYWJsZWRDaGFuZ2Uua29udmEnLFxuICAgICAgICBfY2xlYXJIYXNTaGFkb3dDYWNoZVxuICAgICAgKTtcblxuICAgICAgdGhpcy5vbihcbiAgICAgICAgJ3NoYWRvd0NvbG9yQ2hhbmdlLmtvbnZhIHNoYWRvd09wYWNpdHlDaGFuZ2Uua29udmEgc2hhZG93RW5hYmxlZENoYW5nZS5rb252YScsXG4gICAgICAgIF9jbGVhckdldFNoYWRvd1JHQkFDYWNoZVxuICAgICAgKTtcbiAgICB9LFxuICAgIGhhc0NoaWxkcmVuOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGdldENoaWxkcmVuOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiBnZXQgY2FudmFzIGNvbnRleHQgdGllZCB0byB0aGUgbGF5ZXJcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Db250ZXh0fVxuICAgICAgICAgKi9cbiAgICBnZXRDb250ZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldExheWVyKCkuZ2V0Q29udGV4dCgpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIGdldCBjYW52YXMgcmVuZGVyZXIgdGllZCB0byB0aGUgbGF5ZXIuICBOb3RlIHRoYXQgdGhpcyByZXR1cm5zIGEgY2FudmFzIHJlbmRlcmVyLCBub3QgYSBjYW52YXMgZWxlbWVudFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLkNhbnZhc31cbiAgICAgICAgICovXG4gICAgZ2V0Q2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldExheWVyKCkuZ2V0Q2FudmFzKCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogcmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhIHNoYWRvdyB3aWxsIGJlIHJlbmRlcmVkXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgaGFzU2hhZG93OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRDYWNoZShIQVNfU0hBRE9XLCB0aGlzLl9oYXNTaGFkb3cpO1xuICAgIH0sXG4gICAgX2hhc1NoYWRvdzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLmdldFNoYWRvd0VuYWJsZWQoKSAmJlxuICAgICAgICAodGhpcy5nZXRTaGFkb3dPcGFjaXR5KCkgIT09IDAgJiZcbiAgICAgICAgICAhISh0aGlzLmdldFNoYWRvd0NvbG9yKCkgfHxcbiAgICAgICAgICAgIHRoaXMuZ2V0U2hhZG93Qmx1cigpIHx8XG4gICAgICAgICAgICB0aGlzLmdldFNoYWRvd09mZnNldFgoKSB8fFxuICAgICAgICAgICAgdGhpcy5nZXRTaGFkb3dPZmZzZXRZKCkpKVxuICAgICAgKTtcbiAgICB9LFxuICAgIGdldFNoYWRvd1JHQkE6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldENhY2hlKFNIQURPV19SR0JBLCB0aGlzLl9nZXRTaGFkb3dSR0JBKTtcbiAgICB9LFxuICAgIF9nZXRTaGFkb3dSR0JBOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmhhc1NoYWRvdygpKSB7XG4gICAgICAgIHZhciByZ2JhID0gS29udmEuVXRpbC5jb2xvclRvUkdCQSh0aGlzLnNoYWRvd0NvbG9yKCkpO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICdyZ2JhKCcgK1xuICAgICAgICAgIHJnYmEuciArXG4gICAgICAgICAgJywnICtcbiAgICAgICAgICByZ2JhLmcgK1xuICAgICAgICAgICcsJyArXG4gICAgICAgICAgcmdiYS5iICtcbiAgICAgICAgICAnLCcgK1xuICAgICAgICAgIHJnYmEuYSAqICh0aGlzLmdldFNoYWRvd09wYWNpdHkoKSB8fCAxKSArXG4gICAgICAgICAgJyknXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogcmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgc2hhcGUgd2lsbCBiZSBmaWxsZWRcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICBoYXNGaWxsOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhISh0aGlzLmdldEZpbGwoKSB8fFxuICAgICAgICB0aGlzLmdldEZpbGxQYXR0ZXJuSW1hZ2UoKSB8fFxuICAgICAgICB0aGlzLmdldEZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHMoKSB8fFxuICAgICAgICB0aGlzLmdldEZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHMoKSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogcmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgc2hhcGUgd2lsbCBiZSBzdHJva2VkXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgaGFzU3Ryb2tlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0cm9rZUVuYWJsZWQoKSAmJiAhIXRoaXMuc3Ryb2tlKCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogZGV0ZXJtaW5lcyBpZiBwb2ludCBpcyBpbiB0aGUgc2hhcGUsIHJlZ2FyZGxlc3MgaWYgb3RoZXIgc2hhcGVzIGFyZSBvbiB0b3Agb2YgaXQuICBOb3RlOiBiZWNhdXNlXG4gICAgICAgICAqICB0aGlzIG1ldGhvZCBjbGVhcnMgYSB0ZW1wb3JhcnkgY2FudmFzIGFuZCB0aGVuIHJlZHJhd3MgdGhlIHNoYXBlLCBpdCBwZXJmb3JtcyB2ZXJ5IHBvb3JseSBpZiBleGVjdXRlZCBtYW55IHRpbWVzXG4gICAgICAgICAqICBjb25zZWN1dGl2ZWx5LiAgUGxlYXNlIHVzZSB0aGUge0BsaW5rIEtvbnZhLlN0YWdlI2dldEludGVyc2VjdGlvbn0gbWV0aG9kIGlmIGF0IGFsbCBwb3NzaWJsZVxuICAgICAgICAgKiAgYmVjYXVzZSBpdCBwZXJmb3JtcyBtdWNoIGJldHRlclxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50XG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb2ludC54XG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb2ludC55XG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICBpbnRlcnNlY3RzOiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgdmFyIHN0YWdlID0gdGhpcy5nZXRTdGFnZSgpLCBidWZmZXJIaXRDYW52YXMgPSBzdGFnZS5idWZmZXJIaXRDYW52YXMsIHA7XG5cbiAgICAgIGJ1ZmZlckhpdENhbnZhcy5nZXRDb250ZXh0KCkuY2xlYXIoKTtcbiAgICAgIHRoaXMuZHJhd0hpdChidWZmZXJIaXRDYW52YXMpO1xuICAgICAgcCA9IGJ1ZmZlckhpdENhbnZhcy5jb250ZXh0LmdldEltYWdlRGF0YShcbiAgICAgICAgTWF0aC5yb3VuZChwb2ludC54KSxcbiAgICAgICAgTWF0aC5yb3VuZChwb2ludC55KSxcbiAgICAgICAgMSxcbiAgICAgICAgMVxuICAgICAgKS5kYXRhO1xuICAgICAgcmV0dXJuIHBbM10gPiAwO1xuICAgIH0sXG4gICAgLy8gZXh0ZW5kcyBOb2RlLnByb3RvdHlwZS5kZXN0cm95XG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgICBkZWxldGUgS29udmEuc2hhcGVzW3RoaXMuY29sb3JLZXldO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBfdXNlQnVmZmVyQ2FudmFzOiBmdW5jdGlvbihjYWNoaW5nKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAoIWNhY2hpbmcgJiZcbiAgICAgICAgICAodGhpcy5wZXJmZWN0RHJhd0VuYWJsZWQoKSAmJlxuICAgICAgICAgICAgdGhpcy5nZXRBYnNvbHV0ZU9wYWNpdHkoKSAhPT0gMSAmJlxuICAgICAgICAgICAgdGhpcy5oYXNGaWxsKCkgJiZcbiAgICAgICAgICAgIHRoaXMuaGFzU3Ryb2tlKCkgJiZcbiAgICAgICAgICAgIHRoaXMuZ2V0U3RhZ2UoKSkpIHx8XG4gICAgICAgICh0aGlzLnBlcmZlY3REcmF3RW5hYmxlZCgpICYmXG4gICAgICAgICAgdGhpcy5oYXNTaGFkb3coKSAmJlxuICAgICAgICAgIHRoaXMuZ2V0QWJzb2x1dGVPcGFjaXR5KCkgIT09IDEgJiZcbiAgICAgICAgICB0aGlzLmhhc0ZpbGwoKSAmJlxuICAgICAgICAgIHRoaXMuaGFzU3Ryb2tlKCkgJiZcbiAgICAgICAgICB0aGlzLmdldFN0YWdlKCkpXG4gICAgICApO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIHJldHVybiBzZWxmIHJlY3RhbmdsZSAoeCwgeSwgd2lkdGgsIGhlaWdodCkgb2Ygc2hhcGUuXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGFyZSBub3QgdGFrZW4gaW50byBhY2NvdW50IHRyYW5zZm9ybWF0aW9uIGFuZCBzdHlsZXMuXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSByZWN0IHdpdGgge3gsIHksIHdpZHRoLCBoZWlnaHR9IHByb3BlcnRpZXNcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogcmVjdC5nZXRTZWxmUmVjdCgpOyAgLy8gcmV0dXJuIHt4OjAsIHk6MCwgd2lkdGg6cmVjdC53aWR0aCgpLCBoZWlnaHQ6cmVjdC5oZWlnaHQoKX1cbiAgICAgICAgICogY2lyY2xlLmdldFNlbGZSZWN0KCk7ICAvLyByZXR1cm4ge3g6IC0gY2lyY2xlLndpZHRoKCkgLyAyLCB5OiAtIGNpcmNsZS5oZWlnaHQoKSAvIDIsIHdpZHRoOmNpcmNsZS53aWR0aCgpLCBoZWlnaHQ6Y2lyY2xlLmhlaWdodCgpfVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICBnZXRTZWxmUmVjdDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogdGhpcy5fY2VudHJvaWQgPyBNYXRoLnJvdW5kKC1zaXplLndpZHRoIC8gMikgOiAwLFxuICAgICAgICB5OiB0aGlzLl9jZW50cm9pZCA/IE1hdGgucm91bmQoLXNpemUuaGVpZ2h0IC8gMikgOiAwLFxuICAgICAgICB3aWR0aDogc2l6ZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBzaXplLmhlaWdodFxuICAgICAgfTtcbiAgICB9LFxuICAgIGdldENsaWVudFJlY3Q6IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgICBhdHRycyA9IGF0dHJzIHx8IHt9O1xuICAgICAgdmFyIHNraXBUcmFuc2Zvcm0gPSBhdHRycy5za2lwVHJhbnNmb3JtO1xuICAgICAgdmFyIHJlbGF0aXZlVG8gPSBhdHRycy5yZWxhdGl2ZVRvO1xuXG4gICAgICB2YXIgZmlsbFJlY3QgPSB0aGlzLmdldFNlbGZSZWN0KCk7XG5cbiAgICAgIHZhciBzdHJva2VXaWR0aCA9ICh0aGlzLmhhc1N0cm9rZSgpICYmIHRoaXMuc3Ryb2tlV2lkdGgoKSkgfHwgMDtcbiAgICAgIHZhciBmaWxsQW5kU3Ryb2tlV2lkdGggPSBmaWxsUmVjdC53aWR0aCArIHN0cm9rZVdpZHRoO1xuICAgICAgdmFyIGZpbGxBbmRTdHJva2VIZWlnaHQgPSBmaWxsUmVjdC5oZWlnaHQgKyBzdHJva2VXaWR0aDtcblxuICAgICAgdmFyIHNoYWRvd09mZnNldFggPSB0aGlzLmhhc1NoYWRvdygpID8gdGhpcy5zaGFkb3dPZmZzZXRYKCkgOiAwO1xuICAgICAgdmFyIHNoYWRvd09mZnNldFkgPSB0aGlzLmhhc1NoYWRvdygpID8gdGhpcy5zaGFkb3dPZmZzZXRZKCkgOiAwO1xuXG4gICAgICB2YXIgcHJlV2lkdGggPSBmaWxsQW5kU3Ryb2tlV2lkdGggKyBNYXRoLmFicyhzaGFkb3dPZmZzZXRYKTtcbiAgICAgIHZhciBwcmVIZWlnaHQgPSBmaWxsQW5kU3Ryb2tlSGVpZ2h0ICsgTWF0aC5hYnMoc2hhZG93T2Zmc2V0WSk7XG5cbiAgICAgIHZhciBibHVyUmFkaXVzID0gKHRoaXMuaGFzU2hhZG93KCkgJiYgdGhpcy5zaGFkb3dCbHVyKCkpIHx8IDA7XG5cbiAgICAgIHZhciB3aWR0aCA9IHByZVdpZHRoICsgYmx1clJhZGl1cyAqIDI7XG4gICAgICB2YXIgaGVpZ2h0ID0gcHJlSGVpZ2h0ICsgYmx1clJhZGl1cyAqIDI7XG5cbiAgICAgIC8vIGlmIHN0cm9rZSwgZm9yIGV4YW1wbGUgPSAzXG4gICAgICAvLyB3ZSBuZWVkIHRvIHNldCB4IHRvIDEuNSwgYnV0IGFmdGVyIE1hdGgucm91bmQgaXQgd2lsbCBiZSAyXG4gICAgICAvLyBhcyB3ZSBoYXZlIGFkZGl0aW9uYWwgb2Zmc2V0IHdlIG5lZWQgdG8gaW5jcmVhc2Ugd2lkdGggYW5kIGhlaWdodCBieSAxIHBpeGVsXG4gICAgICB2YXIgcm91bmRpbmdPZmZzZXQgPSAwO1xuICAgICAgaWYgKE1hdGgucm91bmQoc3Ryb2tlV2lkdGggLyAyKSAhPT0gc3Ryb2tlV2lkdGggLyAyKSB7XG4gICAgICAgIHJvdW5kaW5nT2Zmc2V0ID0gMTtcbiAgICAgIH1cbiAgICAgIHZhciByZWN0ID0ge1xuICAgICAgICB3aWR0aDogd2lkdGggKyByb3VuZGluZ09mZnNldCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQgKyByb3VuZGluZ09mZnNldCxcbiAgICAgICAgeDogLU1hdGgucm91bmQoc3Ryb2tlV2lkdGggLyAyICsgYmx1clJhZGl1cykgK1xuICAgICAgICAgIE1hdGgubWluKHNoYWRvd09mZnNldFgsIDApICtcbiAgICAgICAgICBmaWxsUmVjdC54LFxuICAgICAgICB5OiAtTWF0aC5yb3VuZChzdHJva2VXaWR0aCAvIDIgKyBibHVyUmFkaXVzKSArXG4gICAgICAgICAgTWF0aC5taW4oc2hhZG93T2Zmc2V0WSwgMCkgK1xuICAgICAgICAgIGZpbGxSZWN0LnlcbiAgICAgIH07XG4gICAgICBpZiAoIXNraXBUcmFuc2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybWVkUmVjdChyZWN0LCByZWxhdGl2ZVRvKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZWN0O1xuICAgIH0sXG4gICAgZHJhd1NjZW5lOiBmdW5jdGlvbihjYW4sIHRvcCwgY2FjaGluZywgc2tpcEJ1ZmZlcikge1xuICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpLFxuICAgICAgICBjYW52YXMgPSBjYW4gfHwgbGF5ZXIuZ2V0Q2FudmFzKCksXG4gICAgICAgIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgpLFxuICAgICAgICBjYWNoZWRDYW52YXMgPSB0aGlzLl9jYWNoZS5jYW52YXMsXG4gICAgICAgIGRyYXdGdW5jID0gdGhpcy5zY2VuZUZ1bmMoKSxcbiAgICAgICAgaGFzU2hhZG93ID0gdGhpcy5oYXNTaGFkb3coKSxcbiAgICAgICAgaGFzU3Ryb2tlID0gdGhpcy5oYXNTdHJva2UoKSxcbiAgICAgICAgc3RhZ2UsXG4gICAgICAgIGJ1ZmZlckNhbnZhcyxcbiAgICAgICAgYnVmZmVyQ29udGV4dDtcblxuICAgICAgaWYgKCF0aGlzLmlzVmlzaWJsZSgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKGNhY2hlZENhbnZhcykge1xuICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgbGF5ZXIuX2FwcGx5VHJhbnNmb3JtKHRoaXMsIGNvbnRleHQsIHRvcCk7XG4gICAgICAgIHRoaXMuX2RyYXdDYWNoZWRTY2VuZUNhbnZhcyhjb250ZXh0KTtcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKCFkcmF3RnVuYykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgLy8gaWYgYnVmZmVyIGNhbnZhcyBpcyBuZWVkZWRcbiAgICAgIGlmICh0aGlzLl91c2VCdWZmZXJDYW52YXMoY2FjaGluZykgJiYgIXNraXBCdWZmZXIpIHtcbiAgICAgICAgc3RhZ2UgPSB0aGlzLmdldFN0YWdlKCk7XG4gICAgICAgIGJ1ZmZlckNhbnZhcyA9IHN0YWdlLmJ1ZmZlckNhbnZhcztcbiAgICAgICAgYnVmZmVyQ29udGV4dCA9IGJ1ZmZlckNhbnZhcy5nZXRDb250ZXh0KCk7XG4gICAgICAgIGJ1ZmZlckNvbnRleHQuY2xlYXIoKTtcbiAgICAgICAgYnVmZmVyQ29udGV4dC5zYXZlKCk7XG4gICAgICAgIGJ1ZmZlckNvbnRleHQuX2FwcGx5TGluZUpvaW4odGhpcyk7XG4gICAgICAgIC8vIGxheWVyIG1pZ2h0IGJlIHVuZGVmaW5lZCBpZiB3ZSBhcmUgdXNpbmcgY2FjaGUgYmVmb3JlIGFkZGluZyB0byBsYXllclxuICAgICAgICBpZiAoIWNhY2hpbmcpIHtcbiAgICAgICAgICBpZiAobGF5ZXIpIHtcbiAgICAgICAgICAgIGxheWVyLl9hcHBseVRyYW5zZm9ybSh0aGlzLCBidWZmZXJDb250ZXh0LCB0b3ApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbSA9IHRoaXMuZ2V0QWJzb2x1dGVUcmFuc2Zvcm0odG9wKS5nZXRNYXRyaXgoKTtcbiAgICAgICAgICAgIGNvbnRleHQudHJhbnNmb3JtKG1bMF0sIG1bMV0sIG1bMl0sIG1bM10sIG1bNF0sIG1bNV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRyYXdGdW5jLmNhbGwodGhpcywgYnVmZmVyQ29udGV4dCk7XG4gICAgICAgIGJ1ZmZlckNvbnRleHQucmVzdG9yZSgpO1xuXG4gICAgICAgIHZhciByYXRpbyA9IGJ1ZmZlckNhbnZhcy5waXhlbFJhdGlvO1xuICAgICAgICBpZiAoaGFzU2hhZG93ICYmICFjYW52YXMuaGl0Q2FudmFzKSB7XG4gICAgICAgICAgY29udGV4dC5zYXZlKCk7XG5cbiAgICAgICAgICBjb250ZXh0Ll9hcHBseVNoYWRvdyh0aGlzKTtcbiAgICAgICAgICBjb250ZXh0Ll9hcHBseU9wYWNpdHkodGhpcyk7XG4gICAgICAgICAgY29udGV4dC5fYXBwbHlHbG9iYWxDb21wb3NpdGVPcGVyYXRpb24odGhpcyk7XG4gICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoXG4gICAgICAgICAgICBidWZmZXJDYW52YXMuX2NhbnZhcyxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgYnVmZmVyQ2FudmFzLndpZHRoIC8gcmF0aW8sXG4gICAgICAgICAgICBidWZmZXJDYW52YXMuaGVpZ2h0IC8gcmF0aW9cbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQuX2FwcGx5T3BhY2l0eSh0aGlzKTtcbiAgICAgICAgICBjb250ZXh0Ll9hcHBseUdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbih0aGlzKTtcbiAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShcbiAgICAgICAgICAgIGJ1ZmZlckNhbnZhcy5fY2FudmFzLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBidWZmZXJDYW52YXMud2lkdGggLyByYXRpbyxcbiAgICAgICAgICAgIGJ1ZmZlckNhbnZhcy5oZWlnaHQgLyByYXRpb1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIGJ1ZmZlciBjYW52YXMgaXMgbm90IG5lZWRlZFxuICAgICAgICBjb250ZXh0Ll9hcHBseUxpbmVKb2luKHRoaXMpO1xuICAgICAgICAvLyBsYXllciBtaWdodCBiZSB1bmRlZmluZWQgaWYgd2UgYXJlIHVzaW5nIGNhY2hlIGJlZm9yZSBhZGRpbmcgdG8gbGF5ZXJcbiAgICAgICAgaWYgKCFjYWNoaW5nKSB7XG4gICAgICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgICAgICBsYXllci5fYXBwbHlUcmFuc2Zvcm0odGhpcywgY29udGV4dCwgdG9wKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG8gPSB0aGlzLmdldEFic29sdXRlVHJhbnNmb3JtKHRvcCkuZ2V0TWF0cml4KCk7XG4gICAgICAgICAgICBjb250ZXh0LnRyYW5zZm9ybShvWzBdLCBvWzFdLCBvWzJdLCBvWzNdLCBvWzRdLCBvWzVdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzU2hhZG93ICYmIGhhc1N0cm9rZSAmJiAhY2FudmFzLmhpdENhbnZhcykge1xuICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgIC8vIGFwcGx5IHNoYWRvd1xuICAgICAgICAgIGlmICghY2FjaGluZykge1xuICAgICAgICAgICAgY29udGV4dC5fYXBwbHlPcGFjaXR5KHRoaXMpO1xuICAgICAgICAgICAgY29udGV4dC5fYXBwbHlHbG9iYWxDb21wb3NpdGVPcGVyYXRpb24odGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRleHQuX2FwcGx5U2hhZG93KHRoaXMpO1xuXG4gICAgICAgICAgZHJhd0Z1bmMuY2FsbCh0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgICAvLyBpZiBzaGFwZSBoYXMgc3Ryb2tlIHdlIG5lZWQgdG8gcmVkcmF3IHNoYXBlXG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIHdpbGwgc2VlIGEgc2hhZG93IHVuZGVyIHN0cm9rZSAoYW5kIG92ZXIgZmlsbClcbiAgICAgICAgICAvLyBidXQgSSB0aGluayB0aGlzIGlzIHVuZXhwZWN0ZWQgYmVoYXZpb3JcbiAgICAgICAgICBpZiAodGhpcy5oYXNGaWxsKCkgJiYgdGhpcy5nZXRTaGFkb3dGb3JTdHJva2VFbmFibGVkKCkpIHtcbiAgICAgICAgICAgIGRyYXdGdW5jLmNhbGwodGhpcywgY29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGhhc1NoYWRvdyAmJiAhY2FudmFzLmhpdENhbnZhcykge1xuICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgIGlmICghY2FjaGluZykge1xuICAgICAgICAgICAgY29udGV4dC5fYXBwbHlPcGFjaXR5KHRoaXMpO1xuICAgICAgICAgICAgY29udGV4dC5fYXBwbHlHbG9iYWxDb21wb3NpdGVPcGVyYXRpb24odGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRleHQuX2FwcGx5U2hhZG93KHRoaXMpO1xuICAgICAgICAgIGRyYXdGdW5jLmNhbGwodGhpcywgY29udGV4dCk7XG4gICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFjYWNoaW5nKSB7XG4gICAgICAgICAgICBjb250ZXh0Ll9hcHBseU9wYWNpdHkodGhpcyk7XG4gICAgICAgICAgICBjb250ZXh0Ll9hcHBseUdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbih0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZHJhd0Z1bmMuY2FsbCh0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGRyYXdIaXQ6IGZ1bmN0aW9uKGNhbiwgdG9wLCBjYWNoaW5nKSB7XG4gICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKCksXG4gICAgICAgIGNhbnZhcyA9IGNhbiB8fCBsYXllci5oaXRDYW52YXMsXG4gICAgICAgIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgpLFxuICAgICAgICBkcmF3RnVuYyA9IHRoaXMuaGl0RnVuYygpIHx8IHRoaXMuc2NlbmVGdW5jKCksXG4gICAgICAgIGNhY2hlZENhbnZhcyA9IHRoaXMuX2NhY2hlLmNhbnZhcyxcbiAgICAgICAgY2FjaGVkSGl0Q2FudmFzID0gY2FjaGVkQ2FudmFzICYmIGNhY2hlZENhbnZhcy5oaXQ7XG5cbiAgICAgIGlmICghdGhpcy5zaG91bGREcmF3SGl0KGNhbnZhcykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAobGF5ZXIpIHtcbiAgICAgICAgbGF5ZXIuY2xlYXJIaXRDYWNoZSgpO1xuICAgICAgfVxuICAgICAgaWYgKGNhY2hlZEhpdENhbnZhcykge1xuICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgbGF5ZXIuX2FwcGx5VHJhbnNmb3JtKHRoaXMsIGNvbnRleHQsIHRvcCk7XG4gICAgICAgIHRoaXMuX2RyYXdDYWNoZWRIaXRDYW52YXMoY29udGV4dCk7XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmICghZHJhd0Z1bmMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgIGNvbnRleHQuX2FwcGx5TGluZUpvaW4odGhpcyk7XG4gICAgICBpZiAoIWNhY2hpbmcpIHtcbiAgICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgICAgbGF5ZXIuX2FwcGx5VHJhbnNmb3JtKHRoaXMsIGNvbnRleHQsIHRvcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG8gPSB0aGlzLmdldEFic29sdXRlVHJhbnNmb3JtKHRvcCkuZ2V0TWF0cml4KCk7XG4gICAgICAgICAgY29udGV4dC50cmFuc2Zvcm0ob1swXSwgb1sxXSwgb1syXSwgb1szXSwgb1s0XSwgb1s1XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRyYXdGdW5jLmNhbGwodGhpcywgY29udGV4dCk7XG4gICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICogZHJhdyBoaXQgZ3JhcGggdXNpbmcgdGhlIGNhY2hlZCBzY2VuZSBjYW52YXNcbiAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gYWxwaGFUaHJlc2hvbGQgYWxwaGEgY2hhbm5lbCB0aHJlc2hvbGQgdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90XG4gICAgICAgICogIGEgcGl4ZWwgc2hvdWxkIGJlIGRyYXduIG9udG8gdGhlIGhpdCBncmFwaC4gIE11c3QgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDI1NS5cbiAgICAgICAgKiAgVGhlIGRlZmF1bHQgaXMgMFxuICAgICAgICAqIEByZXR1cm5zIHtLb252YS5TaGFwZX1cbiAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAqIHNoYXBlLmNhY2hlKCk7XG4gICAgICAgICogc2hhcGUuZHJhd0hpdEZyb21DYWNoZSgpO1xuICAgICAgICAqL1xuICAgIGRyYXdIaXRGcm9tQ2FjaGU6IGZ1bmN0aW9uKGFscGhhVGhyZXNob2xkKSB7XG4gICAgICB2YXIgdGhyZXNob2xkID0gYWxwaGFUaHJlc2hvbGQgfHwgMCxcbiAgICAgICAgY2FjaGVkQ2FudmFzID0gdGhpcy5fY2FjaGUuY2FudmFzLFxuICAgICAgICBzY2VuZUNhbnZhcyA9IHRoaXMuX2dldENhY2hlZFNjZW5lQ2FudmFzKCksXG4gICAgICAgIGhpdENhbnZhcyA9IGNhY2hlZENhbnZhcy5oaXQsXG4gICAgICAgIGhpdENvbnRleHQgPSBoaXRDYW52YXMuZ2V0Q29udGV4dCgpLFxuICAgICAgICBoaXRXaWR0aCA9IGhpdENhbnZhcy5nZXRXaWR0aCgpLFxuICAgICAgICBoaXRIZWlnaHQgPSBoaXRDYW52YXMuZ2V0SGVpZ2h0KCksXG4gICAgICAgIGhpdEltYWdlRGF0YSxcbiAgICAgICAgaGl0RGF0YSxcbiAgICAgICAgbGVuLFxuICAgICAgICByZ2JDb2xvcktleSxcbiAgICAgICAgaSxcbiAgICAgICAgYWxwaGE7XG5cbiAgICAgIGhpdENvbnRleHQuY2xlYXIoKTtcbiAgICAgIGhpdENvbnRleHQuZHJhd0ltYWdlKHNjZW5lQ2FudmFzLl9jYW52YXMsIDAsIDAsIGhpdFdpZHRoLCBoaXRIZWlnaHQpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBoaXRJbWFnZURhdGEgPSBoaXRDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBoaXRXaWR0aCwgaGl0SGVpZ2h0KTtcbiAgICAgICAgaGl0RGF0YSA9IGhpdEltYWdlRGF0YS5kYXRhO1xuICAgICAgICBsZW4gPSBoaXREYXRhLmxlbmd0aDtcbiAgICAgICAgcmdiQ29sb3JLZXkgPSBLb252YS5VdGlsLl9oZXhUb1JnYih0aGlzLmNvbG9yS2V5KTtcblxuICAgICAgICAvLyByZXBsYWNlIG5vbiB0cmFuc3BhcmVudCBwaXhlbHMgd2l0aCBjb2xvciBrZXlcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAgICAgYWxwaGEgPSBoaXREYXRhW2kgKyAzXTtcbiAgICAgICAgICBpZiAoYWxwaGEgPiB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgIGhpdERhdGFbaV0gPSByZ2JDb2xvcktleS5yO1xuICAgICAgICAgICAgaGl0RGF0YVtpICsgMV0gPSByZ2JDb2xvcktleS5nO1xuICAgICAgICAgICAgaGl0RGF0YVtpICsgMl0gPSByZ2JDb2xvcktleS5iO1xuICAgICAgICAgICAgaGl0RGF0YVtpICsgM10gPSAyNTU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhpdERhdGFbaSArIDNdID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaGl0Q29udGV4dC5wdXRJbWFnZURhdGEoaGl0SW1hZ2VEYXRhLCAwLCAwKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgS29udmEuVXRpbC5lcnJvcihcbiAgICAgICAgICAnVW5hYmxlIHRvIGRyYXcgaGl0IGdyYXBoIGZyb20gY2FjaGVkIHNjZW5lIGNhbnZhcy4gJyArIGUubWVzc2FnZVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0pO1xuICBLb252YS5VdGlsLmV4dGVuZChLb252YS5TaGFwZSwgS29udmEuTm9kZSk7XG5cbiAgLy8gYWRkIGdldHRlcnMgYW5kIHNldHRlcnNcbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdzdHJva2UnKTtcblxuICAvKipcbiAgICAgKiBnZXQvc2V0IHN0cm9rZSBjb2xvclxuICAgICAqIEBuYW1lIHN0cm9rZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBzdHJva2UgY29sb3JcbiAgICAgKiB2YXIgc3Ryb2tlID0gc2hhcGUuc3Ryb2tlKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgc3Ryb2tlIGNvbG9yIHdpdGggY29sb3Igc3RyaW5nXG4gICAgICogc2hhcGUuc3Ryb2tlKCdncmVlbicpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHN0cm9rZSBjb2xvciB3aXRoIGhleFxuICAgICAqIHNoYXBlLnN0cm9rZSgnIzAwZmYwMCcpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHN0cm9rZSBjb2xvciB3aXRoIHJnYlxuICAgICAqIHNoYXBlLnN0cm9rZSgncmdiKDAsMjU1LDApJyk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgc3Ryb2tlIGNvbG9yIHdpdGggcmdiYSBhbmQgbWFrZSBpdCA1MCUgb3BhcXVlXG4gICAgICogc2hhcGUuc3Ryb2tlKCdyZ2JhKDAsMjU1LDAsMC41Jyk7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGREZXByZWNhdGVkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLlNoYXBlLFxuICAgICdzdHJva2VSZWQnLFxuICAgIDAsXG4gICAgS29udmEuVmFsaWRhdG9ycy5SR0JDb21wb25lbnRcbiAgKTtcbiAgS29udmEuRmFjdG9yeS5hZGREZXByZWNhdGVkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLlNoYXBlLFxuICAgICdzdHJva2VHcmVlbicsXG4gICAgMCxcbiAgICBLb252YS5WYWxpZGF0b3JzLlJHQkNvbXBvbmVudFxuICApO1xuICBLb252YS5GYWN0b3J5LmFkZERlcHJlY2F0ZWRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuU2hhcGUsXG4gICAgJ3N0cm9rZUJsdWUnLFxuICAgIDAsXG4gICAgS29udmEuVmFsaWRhdG9ycy5SR0JDb21wb25lbnRcbiAgKTtcbiAgS29udmEuRmFjdG9yeS5hZGREZXByZWNhdGVkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLlNoYXBlLFxuICAgICdzdHJva2VBbHBoYScsXG4gICAgMSxcbiAgICBLb252YS5WYWxpZGF0b3JzLmFscGhhQ29tcG9uZW50XG4gICk7XG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdzdHJva2VXaWR0aCcsIDIpO1xuXG4gIC8qKlxuICAgICAqIGdldC9zZXQgc3Ryb2tlIHdpZHRoXG4gICAgICogQG5hbWUgc3Ryb2tlV2lkdGhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdHJva2VXaWR0aFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgc3Ryb2tlIHdpZHRoXG4gICAgICogdmFyIHN0cm9rZVdpZHRoID0gc2hhcGUuc3Ryb2tlV2lkdGgoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBzdHJva2Ugd2lkdGhcbiAgICAgKiBzaGFwZS5zdHJva2VXaWR0aCgpO1xuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc3Ryb2tlSGl0RW5hYmxlZCcsIHRydWUpO1xuXG4gIC8qKlxuICAgICAqIGdldC9zZXQgc3Ryb2tlSGl0RW5hYmxlZCBwcm9wZXJ0eS4gVXNlZnVsIGZvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24uXG4gICAgICogWW91IG1heSBzZXQgYHNoYXBlLnN0cm9rZUhpdEVuYWJsZWQoZmFsc2UpYC4gSW4gdGhpcyBjYXNlIHN0cm9rZSB3aWxsIGJlIG5vIGRyYXcgb24gaGl0IGNhbnZhcywgc28gaGl0IGFyZWFcbiAgICAgKiBvZiBzaGFwZSB3aWxsIGJlIGRlY3JlYXNlZCAoYnkgbGluZVdpZHRoIC8gMikuIFJlbWVtYmVyIHRoYXQgbm9uIGNsb3NlZCBsaW5lIHdpdGggYHN0cm9rZUhpdEVuYWJsZWQgPSBmYWxzZWBcbiAgICAgKiB3aWxsIGJlIG5vdCBkcmF3biBvbiBoaXQgY2FudmFzLCB0aGF0IGlzIG1lYW4gbGluZSB3aWxsIG5vIHRyaWdnZXIgcG9pbnRlciBldmVudHMgKGxpa2UgbW91c2VvdmVyKVxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBuYW1lIHN0cm9rZUhpdEVuYWJsZWRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc3Ryb2tlSGl0RW5hYmxlZFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHN0cm9rZUhpdEVuYWJsZWRcbiAgICAgKiB2YXIgc3Ryb2tlSGl0RW5hYmxlZCA9IHNoYXBlLnN0cm9rZUhpdEVuYWJsZWQoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBzdHJva2VIaXRFbmFibGVkXG4gICAgICogc2hhcGUuc3Ryb2tlSGl0RW5hYmxlZCgpO1xuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAncGVyZmVjdERyYXdFbmFibGVkJywgdHJ1ZSk7XG5cbiAgLyoqXG4gICAgICogZ2V0L3NldCBwZXJmZWN0RHJhd0VuYWJsZWQuIElmIGEgc2hhcGUgaGFzIGZpbGwsIHN0cm9rZSBhbmQgb3BhY2l0eSB5b3UgbWF5IHNldCBgcGVyZmVjdERyYXdFbmFibGVkYCB0byBmYWxzZSB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLlxuICAgICAqIFNlZSBodHRwOi8va29udmFqcy5naXRodWIuaW8vZG9jcy9wZXJmb3JtYW5jZS9EaXNhYmxlX1BlcmZlY3RfRHJhdy5odG1sIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBuYW1lIHBlcmZlY3REcmF3RW5hYmxlZFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBwZXJmZWN0RHJhd0VuYWJsZWRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBwZXJmZWN0RHJhd0VuYWJsZWRcbiAgICAgKiB2YXIgcGVyZmVjdERyYXdFbmFibGVkID0gc2hhcGUucGVyZmVjdERyYXdFbmFibGVkKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgcGVyZmVjdERyYXdFbmFibGVkXG4gICAgICogc2hhcGUucGVyZmVjdERyYXdFbmFibGVkKCk7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdzaGFkb3dGb3JTdHJva2VFbmFibGVkJywgdHJ1ZSk7XG5cbiAgLyoqXG4gICAgICogZ2V0L3NldCBzaGFkb3dGb3JTdHJva2VFbmFibGVkLiBVc2VmdWwgZm9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbi5cbiAgICAgKiBZb3UgbWF5IHNldCBgc2hhcGUuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZChmYWxzZSlgLiBJbiB0aGlzIGNhc2Ugc3Ryb2tlIHdpbGwgYmUgbm8gZHJhdyBzaGFkb3cgZm9yIHN0cm9rZS5cbiAgICAgKiBSZW1lbWJlciBpZiB5b3Ugc2V0IGBzaGFkb3dGb3JTdHJva2VFbmFibGVkID0gZmFsc2VgIGZvciBub24gY2xvc2VkIGxpbmUgLSB0aGF0IGxpbmUgd2l0aCBoYXZlIG5vIHNoYWRvdyEuXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQG5hbWUgc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaGFkb3dGb3JTdHJva2VFbmFibGVkXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZFxuICAgICAqIHZhciBzaGFkb3dGb3JTdHJva2VFbmFibGVkID0gc2hhcGUuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHNoYWRvd0ZvclN0cm9rZUVuYWJsZWRcbiAgICAgKiBzaGFwZS5zaGFkb3dGb3JTdHJva2VFbmFibGVkKCk7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdsaW5lSm9pbicpO1xuXG4gIC8qKlxuICAgICAqIGdldC9zZXQgbGluZSBqb2luLiAgQ2FuIGJlIG1pdGVyLCByb3VuZCwgb3IgYmV2ZWwuICBUaGVcbiAgICAgKiAgZGVmYXVsdCBpcyBtaXRlclxuICAgICAqIEBuYW1lIGxpbmVKb2luXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbGluZUpvaW5cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGxpbmUgam9pblxuICAgICAqIHZhciBsaW5lSm9pbiA9IHNoYXBlLmxpbmVKb2luKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgbGluZSBqb2luXG4gICAgICogc2hhcGUubGluZUpvaW4oJ3JvdW5kJyk7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdsaW5lQ2FwJyk7XG5cbiAgLyoqXG4gICAgICogZ2V0L3NldCBsaW5lIGNhcC4gIENhbiBiZSBidXR0LCByb3VuZCwgb3Igc3F1YXJlXG4gICAgICogQG5hbWUgbGluZUNhcFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxpbmVDYXBcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGxpbmUgY2FwXG4gICAgICogdmFyIGxpbmVDYXAgPSBzaGFwZS5saW5lQ2FwKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgbGluZSBjYXBcbiAgICAgKiBzaGFwZS5saW5lQ2FwKCdyb3VuZCcpO1xuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc2NlbmVGdW5jJyk7XG5cbiAgLyoqXG4gICAgICogZ2V0L3NldCBzY2VuZSBkcmF3IGZ1bmN0aW9uXG4gICAgICogQG5hbWUgc2NlbmVGdW5jXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkcmF3RnVuYyBkcmF3aW5nIGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHNjZW5lIGRyYXcgZnVuY3Rpb25cbiAgICAgKiB2YXIgc2NlbmVGdW5jID0gc2hhcGUuc2NlbmVGdW5jKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgc2NlbmUgZHJhdyBmdW5jdGlvblxuICAgICAqIHNoYXBlLnNjZW5lRnVuYyhmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICogICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAqICAgY29udGV4dC5yZWN0KDAsIDAsIHRoaXMud2lkdGgoKSwgdGhpcy5oZWlnaHQoKSk7XG4gICAgICogICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAqICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgICogfSk7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdoaXRGdW5jJyk7XG5cbiAgLyoqXG4gICAgICogZ2V0L3NldCBoaXQgZHJhdyBmdW5jdGlvblxuICAgICAqIEBuYW1lIGhpdEZ1bmNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGRyYXdGdW5jIGRyYXdpbmcgZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgaGl0IGRyYXcgZnVuY3Rpb25cbiAgICAgKiB2YXIgaGl0RnVuYyA9IHNoYXBlLmhpdEZ1bmMoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBoaXQgZHJhdyBmdW5jdGlvblxuICAgICAqIHNoYXBlLmhpdEZ1bmMoZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAqICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgKiAgIGNvbnRleHQucmVjdCgwLCAwLCB0aGlzLndpZHRoKCksIHRoaXMuaGVpZ2h0KCkpO1xuICAgICAqICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgKiAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgICAqIH0pO1xuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZGFzaCcpO1xuXG4gIC8qKlxuICAgICAqIGdldC9zZXQgZGFzaCBhcnJheSBmb3Igc3Ryb2tlLlxuICAgICAqIEBuYW1lIGRhc2hcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGRhc2hcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgLy8gYXBwbHkgZGFzaGVkIHN0cm9rZSB0aGF0IGlzIDEwcHggbG9uZyBhbmQgNSBwaXhlbHMgYXBhcnRcbiAgICAgKiAgbGluZS5kYXNoKFsxMCwgNV0pO1xuICAgICAqICAvLyBhcHBseSBkYXNoZWQgc3Ryb2tlIHRoYXQgaXMgbWFkZSB1cCBvZiBhbHRlcm5hdGluZyBkYXNoZWRcbiAgICAgKiAgLy8gbGluZXMgdGhhdCBhcmUgMTBweCBsb25nIGFuZCAyMHB4IGFwYXJ0LCBhbmQgZG90cyB0aGF0IGhhdmVcbiAgICAgKiAgLy8gYSByYWRpdXMgb2YgNXB4IGFuZCBhcmUgMjBweCBhcGFydFxuICAgICAqICBsaW5lLmRhc2goWzEwLCAyMCwgMC4wMDEsIDIwXSk7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdkYXNoT2Zmc2V0JywgMCk7XG5cbiAgLyoqXG4gICAgICogZ2V0L3NldCBkYXNoIG9mZnNldCBmb3Igc3Ryb2tlLlxuICAgICAqIEBuYW1lIGRhc2hcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXNoIG9mZnNldFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgLy8gYXBwbHkgZGFzaGVkIHN0cm9rZSB0aGF0IGlzIDEwcHggbG9uZyBhbmQgNSBwaXhlbHMgYXBhcnQgd2l0aCBhbiBvZmZzZXQgb2YgNXB4XG4gICAgICogIGxpbmUuZGFzaChbMTAsIDVdKTtcbiAgICAgKiAgbGluZS5kYXNoT2Zmc2V0KDUpO1xuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc2hhZG93Q29sb3InKTtcblxuICAvKipcbiAgICAgKiBnZXQvc2V0IHNoYWRvdyBjb2xvclxuICAgICAqIEBuYW1lIHNoYWRvd0NvbG9yXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3JcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHNoYWRvdyBjb2xvclxuICAgICAqIHZhciBzaGFkb3cgPSBzaGFwZS5zaGFkb3dDb2xvcigpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHNoYWRvdyBjb2xvciB3aXRoIGNvbG9yIHN0cmluZ1xuICAgICAqIHNoYXBlLnNoYWRvd0NvbG9yKCdncmVlbicpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHNoYWRvdyBjb2xvciB3aXRoIGhleFxuICAgICAqIHNoYXBlLnNoYWRvd0NvbG9yKCcjMDBmZjAwJyk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgc2hhZG93IGNvbG9yIHdpdGggcmdiXG4gICAgICogc2hhcGUuc2hhZG93Q29sb3IoJ3JnYigwLDI1NSwwKScpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHNoYWRvdyBjb2xvciB3aXRoIHJnYmEgYW5kIG1ha2UgaXQgNTAlIG9wYXF1ZVxuICAgICAqIHNoYXBlLnNoYWRvd0NvbG9yKCdyZ2JhKDAsMjU1LDAsMC41Jyk7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGREZXByZWNhdGVkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLlNoYXBlLFxuICAgICdzaGFkb3dSZWQnLFxuICAgIDAsXG4gICAgS29udmEuVmFsaWRhdG9ycy5SR0JDb21wb25lbnRcbiAgKTtcbiAgS29udmEuRmFjdG9yeS5hZGREZXByZWNhdGVkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLlNoYXBlLFxuICAgICdzaGFkb3dHcmVlbicsXG4gICAgMCxcbiAgICBLb252YS5WYWxpZGF0b3JzLlJHQkNvbXBvbmVudFxuICApO1xuICBLb252YS5GYWN0b3J5LmFkZERlcHJlY2F0ZWRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuU2hhcGUsXG4gICAgJ3NoYWRvd0JsdWUnLFxuICAgIDAsXG4gICAgS29udmEuVmFsaWRhdG9ycy5SR0JDb21wb25lbnRcbiAgKTtcbiAgS29udmEuRmFjdG9yeS5hZGREZXByZWNhdGVkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLlNoYXBlLFxuICAgICdzaGFkb3dBbHBoYScsXG4gICAgMSxcbiAgICBLb252YS5WYWxpZGF0b3JzLmFscGhhQ29tcG9uZW50XG4gICk7XG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdzaGFkb3dCbHVyJyk7XG5cbiAgLyoqXG4gICAgICogZ2V0L3NldCBzaGFkb3cgYmx1clxuICAgICAqIEBuYW1lIHNoYWRvd0JsdXJcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBibHVyXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBzaGFkb3cgYmx1clxuICAgICAqIHZhciBzaGFkb3dCbHVyID0gc2hhcGUuc2hhZG93Qmx1cigpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHNoYWRvdyBibHVyXG4gICAgICogc2hhcGUuc2hhZG93Qmx1cigxMCk7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdzaGFkb3dPcGFjaXR5Jyk7XG5cbiAgLyoqXG4gICAgICogZ2V0L3NldCBzaGFkb3cgb3BhY2l0eS4gIG11c3QgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAbmFtZSBzaGFkb3dPcGFjaXR5XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb3BhY2l0eVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgc2hhZG93IG9wYWNpdHlcbiAgICAgKiB2YXIgc2hhZG93T3BhY2l0eSA9IHNoYXBlLnNoYWRvd09wYWNpdHkoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBzaGFkb3cgb3BhY2l0eVxuICAgICAqIHNoYXBlLnNoYWRvd09wYWNpdHkoMC41KTtcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZENvbXBvbmVudHNHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdzaGFkb3dPZmZzZXQnLCBbXG4gICAgJ3gnLFxuICAgICd5J1xuICBdKTtcblxuICAvKipcbiAgICAgKiBnZXQvc2V0IHNoYWRvdyBvZmZzZXRcbiAgICAgKiBAbmFtZSBzaGFkb3dPZmZzZXRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvZmZzZXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0LnhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0LnlcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHNoYWRvdyBvZmZzZXRcbiAgICAgKiB2YXIgc2hhZG93T2Zmc2V0ID0gc2hhcGUuc2hhZG93T2Zmc2V0KCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgc2hhZG93IG9mZnNldFxuICAgICAqIHNoYXBlLnNoYWRvd09mZnNldCh7XG4gICAgICogICB4OiAyMFxuICAgICAqICAgeTogMTBcbiAgICAgKiB9KTtcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ3NoYWRvd09mZnNldFgnLCAwKTtcblxuICAvKipcbiAgICAgKiBnZXQvc2V0IHNoYWRvdyBvZmZzZXQgeFxuICAgICAqIEBuYW1lIHNoYWRvd09mZnNldFhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBzaGFkb3cgb2Zmc2V0IHhcbiAgICAgKiB2YXIgc2hhZG93T2Zmc2V0WCA9IHNoYXBlLnNoYWRvd09mZnNldFgoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBzaGFkb3cgb2Zmc2V0IHhcbiAgICAgKiBzaGFwZS5zaGFkb3dPZmZzZXRYKDUpO1xuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc2hhZG93T2Zmc2V0WScsIDApO1xuXG4gIC8qKlxuICAgICAqIGdldC9zZXQgc2hhZG93IG9mZnNldCB5XG4gICAgICogQG5hbWUgc2hhZG93T2Zmc2V0WVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHNoYWRvdyBvZmZzZXQgeVxuICAgICAqIHZhciBzaGFkb3dPZmZzZXRZID0gc2hhcGUuc2hhZG93T2Zmc2V0WSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHNoYWRvdyBvZmZzZXQgeVxuICAgICAqIHNoYXBlLnNoYWRvd09mZnNldFkoNSk7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsUGF0dGVybkltYWdlJyk7XG5cbiAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAbmFtZSBmaWxsUGF0dGVybkltYWdlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBpbWFnZSBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7SW1hZ2V9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAgICogdmFyIGZpbGxQYXR0ZXJuSW1hZ2UgPSBzaGFwZS5maWxsUGF0dGVybkltYWdlKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAgICogdmFyIGltYWdlT2JqID0gbmV3IEltYWdlKCk7XG4gICAgICogaW1hZ2VPYmoub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICogICBzaGFwZS5maWxsUGF0dGVybkltYWdlKGltYWdlT2JqKTtcbiAgICAgKiB9O1xuICAgICAqIGltYWdlT2JqLnNyYyA9ICdwYXRoL3RvL2ltYWdlL2pwZyc7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsJyk7XG5cbiAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIGNvbG9yXG4gICAgICogQG5hbWUgZmlsbFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmaWxsIGNvbG9yXG4gICAgICogdmFyIGZpbGwgPSBzaGFwZS5maWxsKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZmlsbCBjb2xvciB3aXRoIGNvbG9yIHN0cmluZ1xuICAgICAqIHNoYXBlLmZpbGwoJ2dyZWVuJyk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZmlsbCBjb2xvciB3aXRoIGhleFxuICAgICAqIHNoYXBlLmZpbGwoJyMwMGZmMDAnKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBmaWxsIGNvbG9yIHdpdGggcmdiXG4gICAgICogc2hhcGUuZmlsbCgncmdiKDAsMjU1LDApJyk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZmlsbCBjb2xvciB3aXRoIHJnYmEgYW5kIG1ha2UgaXQgNTAlIG9wYXF1ZVxuICAgICAqIHNoYXBlLmZpbGwoJ3JnYmEoMCwyNTUsMCwwLjUnKTtcbiAgICAgKlxuICAgICAqIC8vIHNoYXBlIHdpdGhvdXQgZmlsbFxuICAgICAqIHNoYXBlLmZpbGwobnVsbCk7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGREZXByZWNhdGVkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLlNoYXBlLFxuICAgICdmaWxsUmVkJyxcbiAgICAwLFxuICAgIEtvbnZhLlZhbGlkYXRvcnMuUkdCQ29tcG9uZW50XG4gICk7XG4gIEtvbnZhLkZhY3RvcnkuYWRkRGVwcmVjYXRlZEdldHRlclNldHRlcihcbiAgICBLb252YS5TaGFwZSxcbiAgICAnZmlsbEdyZWVuJyxcbiAgICAwLFxuICAgIEtvbnZhLlZhbGlkYXRvcnMuUkdCQ29tcG9uZW50XG4gICk7XG4gIEtvbnZhLkZhY3RvcnkuYWRkRGVwcmVjYXRlZEdldHRlclNldHRlcihcbiAgICBLb252YS5TaGFwZSxcbiAgICAnZmlsbEJsdWUnLFxuICAgIDAsXG4gICAgS29udmEuVmFsaWRhdG9ycy5SR0JDb21wb25lbnRcbiAgKTtcbiAgS29udmEuRmFjdG9yeS5hZGREZXByZWNhdGVkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLlNoYXBlLFxuICAgICdmaWxsQWxwaGEnLFxuICAgIDEsXG4gICAgS29udmEuVmFsaWRhdG9ycy5hbHBoYUNvbXBvbmVudFxuICApO1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFBhdHRlcm5YJywgMCk7XG5cbiAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIHBhdHRlcm4geFxuICAgICAqIEBuYW1lIGZpbGxQYXR0ZXJuWFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZpbGwgcGF0dGVybiB4XG4gICAgICogdmFyIGZpbGxQYXR0ZXJuWCA9IHNoYXBlLmZpbGxQYXR0ZXJuWCgpO1xuICAgICAqIC8vIHNldCBmaWxsIHBhdHRlcm4geFxuICAgICAqIHNoYXBlLmZpbGxQYXR0ZXJuWCgyMCk7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsUGF0dGVyblknLCAwKTtcblxuICAvKipcbiAgICAgKiBnZXQvc2V0IGZpbGwgcGF0dGVybiB5XG4gICAgICogQG5hbWUgZmlsbFBhdHRlcm5ZXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZmlsbCBwYXR0ZXJuIHlcbiAgICAgKiB2YXIgZmlsbFBhdHRlcm5ZID0gc2hhcGUuZmlsbFBhdHRlcm5ZKCk7XG4gICAgICogLy8gc2V0IGZpbGwgcGF0dGVybiB5XG4gICAgICogc2hhcGUuZmlsbFBhdHRlcm5ZKDIwKTtcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHMnKTtcblxuICAvKipcbiAgICAgKiBnZXQvc2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IGNvbG9yIHN0b3BzXG4gICAgICogQG5hbWUgZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wc1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtBcnJheX0gY29sb3JTdG9wc1xuICAgICAqIEByZXR1cm5zIHtBcnJheX0gY29sb3JTdG9wc1xuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IGNvbG9yIHN0b3BzXG4gICAgICogdmFyIGNvbG9yU3RvcHMgPSBzaGFwZS5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzKCk7XG4gICAgICpcbiAgICAgKiAvLyBjcmVhdGUgYSBsaW5lYXIgZ3JhZGllbnQgdGhhdCBzdGFydHMgd2l0aCByZWQsIGNoYW5nZXMgdG8gYmx1ZVxuICAgICAqIC8vIGhhbGZ3YXkgdGhyb3VnaCwgYW5kIHRoZW4gY2hhbmdlcyB0byBncmVlblxuICAgICAqIHNoYXBlLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHMoMCwgJ3JlZCcsIDAuNSwgJ2JsdWUnLCAxLCAnZ3JlZW4nKTtcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5TaGFwZSxcbiAgICAnZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXMnLFxuICAgIDBcbiAgKTtcblxuICAvKipcbiAgICAgKiBnZXQvc2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IHN0YXJ0IHJhZGl1c1xuICAgICAqIEBuYW1lIGZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCByYWRpYWwgZ3JhZGllbnQgc3RhcnQgcmFkaXVzXG4gICAgICogdmFyIHN0YXJ0UmFkaXVzID0gc2hhcGUuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXMoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCByYWRpYWwgZ3JhZGllbnQgc3RhcnQgcmFkaXVzXG4gICAgICogc2hhcGUuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXMoMCk7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXMnLCAwKTtcblxuICAvKipcbiAgICAgKiBnZXQvc2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IGVuZCByYWRpdXNcbiAgICAgKiBAbmFtZSBmaWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHJhZGlhbCBncmFkaWVudCBlbmQgcmFkaXVzXG4gICAgICogdmFyIGVuZFJhZGl1cyA9IHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1cygpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHJhZGlhbCBncmFkaWVudCBlbmQgcmFkaXVzXG4gICAgICogc2hhcGUuZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzKDEwMCk7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzJyk7XG5cbiAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIHJhZGlhbCBncmFkaWVudCBjb2xvciBzdG9wc1xuICAgICAqIEBuYW1lIGZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb2xvclN0b3BzXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IGNvbG9yIHN0b3BzXG4gICAgICogdmFyIGNvbG9yU3RvcHMgPSBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzKCk7XG4gICAgICpcbiAgICAgKiAvLyBjcmVhdGUgYSByYWRpYWwgZ3JhZGllbnQgdGhhdCBzdGFydHMgd2l0aCByZWQsIGNoYW5nZXMgdG8gYmx1ZVxuICAgICAqIC8vIGhhbGZ3YXkgdGhyb3VnaCwgYW5kIHRoZW4gY2hhbmdlcyB0byBncmVlblxuICAgICAqIHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHMoMCwgJ3JlZCcsIDAuNSwgJ2JsdWUnLCAxLCAnZ3JlZW4nKTtcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxQYXR0ZXJuUmVwZWF0JywgJ3JlcGVhdCcpO1xuXG4gIC8qKlxuICAgICAqIGdldC9zZXQgZmlsbCBwYXR0ZXJuIHJlcGVhdC4gIENhbiBiZSAncmVwZWF0JywgJ3JlcGVhdC14JywgJ3JlcGVhdC15Jywgb3IgJ25vLXJlcGVhdCcuICBUaGUgZGVmYXVsdCBpcyAncmVwZWF0J1xuICAgICAqIEBuYW1lIGZpbGxQYXR0ZXJuUmVwZWF0XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcmVwZWF0XG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmaWxsIHBhdHRlcm4gcmVwZWF0XG4gICAgICogdmFyIHJlcGVhdCA9IHNoYXBlLmZpbGxQYXR0ZXJuUmVwZWF0KCk7XG4gICAgICpcbiAgICAgKiAvLyByZXBlYXQgcGF0dGVybiBpbiB4IGRpcmVjdGlvbiBvbmx5XG4gICAgICogc2hhcGUuZmlsbFBhdHRlcm5SZXBlYXQoJ3JlcGVhdC14Jyk7XG4gICAgICpcbiAgICAgKiAvLyBkbyBub3QgcmVwZWF0IHRoZSBwYXR0ZXJuXG4gICAgICogc2hhcGUuZmlsbFBhdHRlcm5SZXBlYXQoJ25vIHJlcGVhdCcpO1xuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbEVuYWJsZWQnLCB0cnVlKTtcblxuICAvKipcbiAgICAgKiBnZXQvc2V0IGZpbGwgZW5hYmxlZCBmbGFnXG4gICAgICogQG5hbWUgZmlsbEVuYWJsZWRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5hYmxlZFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZpbGwgZW5hYmxlZCBmbGFnXG4gICAgICogdmFyIGZpbGxFbmFibGVkID0gc2hhcGUuZmlsbEVuYWJsZWQoKTtcbiAgICAgKlxuICAgICAqIC8vIGRpc2FibGUgZmlsbFxuICAgICAqIHNoYXBlLmZpbGxFbmFibGVkKGZhbHNlKTtcbiAgICAgKlxuICAgICAqIC8vIGVuYWJsZSBmaWxsXG4gICAgICogc2hhcGUuZmlsbEVuYWJsZWQodHJ1ZSk7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdzdHJva2VFbmFibGVkJywgdHJ1ZSk7XG5cbiAgLyoqXG4gICAgICogZ2V0L3NldCBzdHJva2UgZW5hYmxlZCBmbGFnXG4gICAgICogQG5hbWUgc3Ryb2tlRW5hYmxlZFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBlbmFibGVkXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgc3Ryb2tlIGVuYWJsZWQgZmxhZ1xuICAgICAqIHZhciBzdHJva2VFbmFibGVkID0gc2hhcGUuc3Ryb2tlRW5hYmxlZCgpO1xuICAgICAqXG4gICAgICogLy8gZGlzYWJsZSBzdHJva2VcbiAgICAgKiBzaGFwZS5zdHJva2VFbmFibGVkKGZhbHNlKTtcbiAgICAgKlxuICAgICAqIC8vIGVuYWJsZSBzdHJva2VcbiAgICAgKiBzaGFwZS5zdHJva2VFbmFibGVkKHRydWUpO1xuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc2hhZG93RW5hYmxlZCcsIHRydWUpO1xuXG4gIC8qKlxuICAgICAqIGdldC9zZXQgc2hhZG93IGVuYWJsZWQgZmxhZ1xuICAgICAqIEBuYW1lIHNoYWRvd0VuYWJsZWRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5hYmxlZFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHNoYWRvdyBlbmFibGVkIGZsYWdcbiAgICAgKiB2YXIgc2hhZG93RW5hYmxlZCA9IHNoYXBlLnNoYWRvd0VuYWJsZWQoKTtcbiAgICAgKlxuICAgICAqIC8vIGRpc2FibGUgc2hhZG93XG4gICAgICogc2hhcGUuc2hhZG93RW5hYmxlZChmYWxzZSk7XG4gICAgICpcbiAgICAgKiAvLyBlbmFibGUgc2hhZG93XG4gICAgICogc2hhcGUuc2hhZG93RW5hYmxlZCh0cnVlKTtcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2Rhc2hFbmFibGVkJywgdHJ1ZSk7XG5cbiAgLyoqXG4gICAgICogZ2V0L3NldCBkYXNoIGVuYWJsZWQgZmxhZ1xuICAgICAqIEBuYW1lIGRhc2hFbmFibGVkXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuYWJsZWRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBkYXNoIGVuYWJsZWQgZmxhZ1xuICAgICAqIHZhciBkYXNoRW5hYmxlZCA9IHNoYXBlLmRhc2hFbmFibGVkKCk7XG4gICAgICpcbiAgICAgKiAvLyBkaXNhYmxlIGRhc2hcbiAgICAgKiBzaGFwZS5kYXNoRW5hYmxlZChmYWxzZSk7XG4gICAgICpcbiAgICAgKiAvLyBlbmFibGUgZGFzaFxuICAgICAqIHNoYXBlLmRhc2hFbmFibGVkKHRydWUpO1xuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc3Ryb2tlU2NhbGVFbmFibGVkJywgdHJ1ZSk7XG5cbiAgLyoqXG4gICAgICogZ2V0L3NldCBzdHJva2VTY2FsZSBlbmFibGVkIGZsYWdcbiAgICAgKiBAbmFtZSBzdHJva2VTY2FsZUVuYWJsZWRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5hYmxlZFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHN0cm9rZSBzY2FsZSBlbmFibGVkIGZsYWdcbiAgICAgKiB2YXIgc3Ryb2tlU2NhbGVFbmFibGVkID0gc2hhcGUuc3Ryb2tlU2NhbGVFbmFibGVkKCk7XG4gICAgICpcbiAgICAgKiAvLyBkaXNhYmxlIHN0cm9rZSBzY2FsZVxuICAgICAqIHNoYXBlLnN0cm9rZVNjYWxlRW5hYmxlZChmYWxzZSk7XG4gICAgICpcbiAgICAgKiAvLyBlbmFibGUgc3Ryb2tlIHNjYWxlXG4gICAgICogc2hhcGUuc3Ryb2tlU2NhbGVFbmFibGVkKHRydWUpO1xuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFByaW9yaXR5JywgJ2NvbG9yJyk7XG5cbiAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIHByaW9yaXR5LiAgY2FuIGJlIGNvbG9yLCBwYXR0ZXJuLCBsaW5lYXItZ3JhZGllbnQsIG9yIHJhZGlhbC1ncmFkaWVudC4gIFRoZSBkZWZhdWx0IGlzIGNvbG9yLlxuICAgICAqICAgVGhpcyBpcyBoYW5keSBpZiB5b3Ugd2FudCB0byB0b2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgZmlsbCB0eXBlcy5cbiAgICAgKiBAbmFtZSBmaWxsUHJpb3JpdHlcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcmlvcml0eVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZmlsbCBwcmlvcml0eVxuICAgICAqIHZhciBmaWxsUHJpb3JpdHkgPSBzaGFwZS5maWxsUHJpb3JpdHkoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBmaWxsIHByaW9yaXR5XG4gICAgICogc2hhcGUuZmlsbFByaW9yaXR5KCdsaW5lYXItZ3JhZGllbnQnKTtcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZENvbXBvbmVudHNHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsUGF0dGVybk9mZnNldCcsIFtcbiAgICAneCcsXG4gICAgJ3knXG4gIF0pO1xuXG4gIC8qKlxuICAgICAqIGdldC9zZXQgZmlsbCBwYXR0ZXJuIG9mZnNldFxuICAgICAqIEBuYW1lIGZpbGxQYXR0ZXJuT2Zmc2V0XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2Zmc2V0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldC54XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldC55XG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmaWxsIHBhdHRlcm4gb2Zmc2V0XG4gICAgICogdmFyIHBhdHRlcm5PZmZzZXQgPSBzaGFwZS5maWxsUGF0dGVybk9mZnNldCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGZpbGwgcGF0dGVybiBvZmZzZXRcbiAgICAgKiBzaGFwZS5maWxsUGF0dGVybk9mZnNldCh7XG4gICAgICogICB4OiAyMFxuICAgICAqICAgeTogMTBcbiAgICAgKiB9KTtcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxQYXR0ZXJuT2Zmc2V0WCcsIDApO1xuICAvKipcbiAgICAgKiBnZXQvc2V0IGZpbGwgcGF0dGVybiBvZmZzZXQgeFxuICAgICAqIEBuYW1lIGZpbGxQYXR0ZXJuT2Zmc2V0WFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZpbGwgcGF0dGVybiBvZmZzZXQgeFxuICAgICAqIHZhciBwYXR0ZXJuT2Zmc2V0WCA9IHNoYXBlLmZpbGxQYXR0ZXJuT2Zmc2V0WCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGZpbGwgcGF0dGVybiBvZmZzZXQgeFxuICAgICAqIHNoYXBlLmZpbGxQYXR0ZXJuT2Zmc2V0WCgyMCk7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsUGF0dGVybk9mZnNldFknLCAwKTtcbiAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIHBhdHRlcm4gb2Zmc2V0IHlcbiAgICAgKiBAbmFtZSBmaWxsUGF0dGVybk9mZnNldFlcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmaWxsIHBhdHRlcm4gb2Zmc2V0IHlcbiAgICAgKiB2YXIgcGF0dGVybk9mZnNldFkgPSBzaGFwZS5maWxsUGF0dGVybk9mZnNldFkoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBmaWxsIHBhdHRlcm4gb2Zmc2V0IHlcbiAgICAgKiBzaGFwZS5maWxsUGF0dGVybk9mZnNldFkoMTApO1xuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkQ29tcG9uZW50c0dldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxQYXR0ZXJuU2NhbGUnLCBbXG4gICAgJ3gnLFxuICAgICd5J1xuICBdKTtcblxuICAvKipcbiAgICAgKiBnZXQvc2V0IGZpbGwgcGF0dGVybiBzY2FsZVxuICAgICAqIEBuYW1lIGZpbGxQYXR0ZXJuU2NhbGVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZS54XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlLnlcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZpbGwgcGF0dGVybiBzY2FsZVxuICAgICAqIHZhciBwYXR0ZXJuU2NhbGUgPSBzaGFwZS5maWxsUGF0dGVyblNjYWxlKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZmlsbCBwYXR0ZXJuIHNjYWxlXG4gICAgICogc2hhcGUuZmlsbFBhdHRlcm5TY2FsZSh7XG4gICAgICogICB4OiAyXG4gICAgICogICB5OiAyXG4gICAgICogfSk7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsUGF0dGVyblNjYWxlWCcsIDEpO1xuICAvKipcbiAgICAgKiBnZXQvc2V0IGZpbGwgcGF0dGVybiBzY2FsZSB4XG4gICAgICogQG5hbWUgZmlsbFBhdHRlcm5TY2FsZVhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmaWxsIHBhdHRlcm4gc2NhbGUgeFxuICAgICAqIHZhciBwYXR0ZXJuU2NhbGVYID0gc2hhcGUuZmlsbFBhdHRlcm5TY2FsZVgoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBmaWxsIHBhdHRlcm4gc2NhbGUgeFxuICAgICAqIHNoYXBlLmZpbGxQYXR0ZXJuU2NhbGVYKDIpO1xuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFBhdHRlcm5TY2FsZVknLCAxKTtcbiAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIHBhdHRlcm4gc2NhbGUgeVxuICAgICAqIEBuYW1lIGZpbGxQYXR0ZXJuU2NhbGVZXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZmlsbCBwYXR0ZXJuIHNjYWxlIHlcbiAgICAgKiB2YXIgcGF0dGVyblNjYWxlWSA9IHNoYXBlLmZpbGxQYXR0ZXJuU2NhbGVZKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZmlsbCBwYXR0ZXJuIHNjYWxlIHlcbiAgICAgKiBzaGFwZS5maWxsUGF0dGVyblNjYWxlWSgyKTtcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZENvbXBvbmVudHNHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuU2hhcGUsXG4gICAgJ2ZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnQnLFxuICAgIFsneCcsICd5J11cbiAgKTtcblxuICAvKipcbiAgICAgKiBnZXQvc2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IHN0YXJ0IHBvaW50XG4gICAgICogQG5hbWUgZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YXJ0UG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRQb2ludC54XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0UG9pbnQueVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgc3RhcnQgcG9pbnRcbiAgICAgKiB2YXIgc3RhcnRQb2ludCA9IHNoYXBlLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnQoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBmaWxsIGxpbmVhciBncmFkaWVudCBzdGFydCBwb2ludFxuICAgICAqIHNoYXBlLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnQoe1xuICAgICAqICAgeDogMjBcbiAgICAgKiAgIHk6IDEwXG4gICAgICogfSk7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuU2hhcGUsXG4gICAgJ2ZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYJyxcbiAgICAwXG4gICk7XG4gIC8qKlxuICAgICAqIGdldC9zZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgc3RhcnQgcG9pbnQgeFxuICAgICAqIEBuYW1lIGZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgc3RhcnQgcG9pbnQgeFxuICAgICAqIHZhciBzdGFydFBvaW50WCA9IHNoYXBlLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgc3RhcnQgcG9pbnQgeFxuICAgICAqIHNoYXBlLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYKDIwKTtcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5TaGFwZSxcbiAgICAnZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFknLFxuICAgIDBcbiAgKTtcbiAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIGxpbmVhciBncmFkaWVudCBzdGFydCBwb2ludCB5XG4gICAgICogQG5hbWUgZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFlcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmaWxsIGxpbmVhciBncmFkaWVudCBzdGFydCBwb2ludCB5XG4gICAgICogdmFyIHN0YXJ0UG9pbnRZID0gc2hhcGUuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFkoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBmaWxsIGxpbmVhciBncmFkaWVudCBzdGFydCBwb2ludCB5XG4gICAgICogc2hhcGUuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFkoMjApO1xuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkQ29tcG9uZW50c0dldHRlclNldHRlcihcbiAgICBLb252YS5TaGFwZSxcbiAgICAnZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnQnLFxuICAgIFsneCcsICd5J11cbiAgKTtcblxuICAvKipcbiAgICAgKiBnZXQvc2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IGVuZCBwb2ludFxuICAgICAqIEBuYW1lIGZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW5kUG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZW5kUG9pbnQueFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmRQb2ludC55XG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmaWxsIGxpbmVhciBncmFkaWVudCBlbmQgcG9pbnRcbiAgICAgKiB2YXIgZW5kUG9pbnQgPSBzaGFwZS5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IGVuZCBwb2ludFxuICAgICAqIHNoYXBlLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50KHtcbiAgICAgKiAgIHg6IDIwXG4gICAgICogICB5OiAxMFxuICAgICAqIH0pO1xuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYJywgMCk7XG4gIC8qKlxuICAgICAqIGdldC9zZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgZW5kIHBvaW50IHhcbiAgICAgKiBAbmFtZSBmaWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmaWxsIGxpbmVhciBncmFkaWVudCBlbmQgcG9pbnQgeFxuICAgICAqIHZhciBlbmRQb2ludFggPSBzaGFwZS5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFgoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBmaWxsIGxpbmVhciBncmFkaWVudCBlbmQgcG9pbnQgeFxuICAgICAqIHNoYXBlLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WCgyMCk7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFknLCAwKTtcbiAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIGxpbmVhciBncmFkaWVudCBlbmQgcG9pbnQgeVxuICAgICAqIEBuYW1lIGZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IGVuZCBwb2ludCB5XG4gICAgICogdmFyIGVuZFBvaW50WSA9IHNoYXBlLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IGVuZCBwb2ludCB5XG4gICAgICogc2hhcGUuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZKDIwKTtcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZENvbXBvbmVudHNHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuU2hhcGUsXG4gICAgJ2ZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnQnLFxuICAgIFsneCcsICd5J11cbiAgKTtcblxuICAvKipcbiAgICAgKiBnZXQvc2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IHN0YXJ0IHBvaW50XG4gICAgICogQG5hbWUgZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YXJ0UG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRQb2ludC54XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0UG9pbnQueVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgc3RhcnQgcG9pbnRcbiAgICAgKiB2YXIgc3RhcnRQb2ludCA9IHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnQoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBmaWxsIHJhZGlhbCBncmFkaWVudCBzdGFydCBwb2ludFxuICAgICAqIHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnQoe1xuICAgICAqICAgeDogMjBcbiAgICAgKiAgIHk6IDEwXG4gICAgICogfSk7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuU2hhcGUsXG4gICAgJ2ZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYJyxcbiAgICAwXG4gICk7XG4gIC8qKlxuICAgICAqIGdldC9zZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgc3RhcnQgcG9pbnQgeFxuICAgICAqIEBuYW1lIGZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgc3RhcnQgcG9pbnQgeFxuICAgICAqIHZhciBzdGFydFBvaW50WCA9IHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgc3RhcnQgcG9pbnQgeFxuICAgICAqIHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYKDIwKTtcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5TaGFwZSxcbiAgICAnZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFknLFxuICAgIDBcbiAgKTtcbiAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIHJhZGlhbCBncmFkaWVudCBzdGFydCBwb2ludCB5XG4gICAgICogQG5hbWUgZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFlcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmaWxsIHJhZGlhbCBncmFkaWVudCBzdGFydCBwb2ludCB5XG4gICAgICogdmFyIHN0YXJ0UG9pbnRZID0gc2hhcGUuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFkoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBmaWxsIHJhZGlhbCBncmFkaWVudCBzdGFydCBwb2ludCB5XG4gICAgICogc2hhcGUuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFkoMjApO1xuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkQ29tcG9uZW50c0dldHRlclNldHRlcihcbiAgICBLb252YS5TaGFwZSxcbiAgICAnZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnQnLFxuICAgIFsneCcsICd5J11cbiAgKTtcblxuICAvKipcbiAgICAgKiBnZXQvc2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IGVuZCBwb2ludFxuICAgICAqIEBuYW1lIGZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW5kUG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZW5kUG9pbnQueFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmRQb2ludC55XG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmaWxsIHJhZGlhbCBncmFkaWVudCBlbmQgcG9pbnRcbiAgICAgKiB2YXIgZW5kUG9pbnQgPSBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IGVuZCBwb2ludFxuICAgICAqIHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50KHtcbiAgICAgKiAgIHg6IDIwXG4gICAgICogICB5OiAxMFxuICAgICAqIH0pO1xuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYJywgMCk7XG4gIC8qKlxuICAgICAqIGdldC9zZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgZW5kIHBvaW50IHhcbiAgICAgKiBAbmFtZSBmaWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmaWxsIHJhZGlhbCBncmFkaWVudCBlbmQgcG9pbnQgeFxuICAgICAqIHZhciBlbmRQb2ludFggPSBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFgoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBmaWxsIHJhZGlhbCBncmFkaWVudCBlbmQgcG9pbnQgeFxuICAgICAqIHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WCgyMCk7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFknLCAwKTtcbiAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIHJhZGlhbCBncmFkaWVudCBlbmQgcG9pbnQgeVxuICAgICAqIEBuYW1lIGZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IGVuZCBwb2ludCB5XG4gICAgICogdmFyIGVuZFBvaW50WSA9IHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IGVuZCBwb2ludCB5XG4gICAgICogc2hhcGUuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZKDIwKTtcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxQYXR0ZXJuUm90YXRpb24nLCAwKTtcblxuICAvKipcbiAgICAgKiBnZXQvc2V0IGZpbGwgcGF0dGVybiByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQG5hbWUgZmlsbFBhdHRlcm5Sb3RhdGlvblxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJvdGF0aW9uXG4gICAgICogQHJldHVybnMge0tvbnZhLlNoYXBlfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZpbGwgcGF0dGVybiByb3RhdGlvblxuICAgICAqIHZhciBwYXR0ZXJuUm90YXRpb24gPSBzaGFwZS5maWxsUGF0dGVyblJvdGF0aW9uKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZmlsbCBwYXR0ZXJuIHJvdGF0aW9uXG4gICAgICogc2hhcGUuZmlsbFBhdHRlcm5Sb3RhdGlvbigyMCk7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5iYWNrQ29tcGF0KEtvbnZhLlNoYXBlLCB7XG4gICAgZGFzaEFycmF5OiAnZGFzaCcsXG4gICAgZ2V0RGFzaEFycmF5OiAnZ2V0RGFzaCcsXG4gICAgc2V0RGFzaEFycmF5OiAnZ2V0RGFzaCcsXG5cbiAgICBkcmF3RnVuYzogJ3NjZW5lRnVuYycsXG4gICAgZ2V0RHJhd0Z1bmM6ICdnZXRTY2VuZUZ1bmMnLFxuICAgIHNldERyYXdGdW5jOiAnc2V0U2NlbmVGdW5jJyxcblxuICAgIGRyYXdIaXRGdW5jOiAnaGl0RnVuYycsXG4gICAgZ2V0RHJhd0hpdEZ1bmM6ICdnZXRIaXRGdW5jJyxcbiAgICBzZXREcmF3SGl0RnVuYzogJ3NldEhpdEZ1bmMnXG4gIH0pO1xuXG4gIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5TaGFwZSk7XG59KShLb252YSk7XG5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvLyBDT05TVEFOVFNcbiAgdmFyIFNUQUdFID0gJ1N0YWdlJyxcbiAgICBTVFJJTkcgPSAnc3RyaW5nJyxcbiAgICBQWCA9ICdweCcsXG4gICAgTU9VU0VPVVQgPSAnbW91c2VvdXQnLFxuICAgIE1PVVNFTEVBVkUgPSAnbW91c2VsZWF2ZScsXG4gICAgTU9VU0VPVkVSID0gJ21vdXNlb3ZlcicsXG4gICAgTU9VU0VFTlRFUiA9ICdtb3VzZWVudGVyJyxcbiAgICBNT1VTRU1PVkUgPSAnbW91c2Vtb3ZlJyxcbiAgICBNT1VTRURPV04gPSAnbW91c2Vkb3duJyxcbiAgICBNT1VTRVVQID0gJ21vdXNldXAnLFxuICAgIENPTlRFWFRNRU5VID0gJ2NvbnRleHRtZW51JyxcbiAgICBDTElDSyA9ICdjbGljaycsXG4gICAgREJMX0NMSUNLID0gJ2RibGNsaWNrJyxcbiAgICBUT1VDSFNUQVJUID0gJ3RvdWNoc3RhcnQnLFxuICAgIFRPVUNIRU5EID0gJ3RvdWNoZW5kJyxcbiAgICBUQVAgPSAndGFwJyxcbiAgICBEQkxfVEFQID0gJ2RibHRhcCcsXG4gICAgVE9VQ0hNT1ZFID0gJ3RvdWNobW92ZScsXG4gICAgV0hFRUwgPSAnd2hlZWwnLFxuICAgIENPTlRFTlRfTU9VU0VPVVQgPSAnY29udGVudE1vdXNlb3V0JyxcbiAgICBDT05URU5UX01PVVNFT1ZFUiA9ICdjb250ZW50TW91c2VvdmVyJyxcbiAgICBDT05URU5UX01PVVNFTU9WRSA9ICdjb250ZW50TW91c2Vtb3ZlJyxcbiAgICBDT05URU5UX01PVVNFRE9XTiA9ICdjb250ZW50TW91c2Vkb3duJyxcbiAgICBDT05URU5UX01PVVNFVVAgPSAnY29udGVudE1vdXNldXAnLFxuICAgIENPTlRFTlRfQ09OVEVYVE1FTlUgPSAnY29udGVudENvbnRleHRtZW51JyxcbiAgICBDT05URU5UX0NMSUNLID0gJ2NvbnRlbnRDbGljaycsXG4gICAgQ09OVEVOVF9EQkxfQ0xJQ0sgPSAnY29udGVudERibGNsaWNrJyxcbiAgICBDT05URU5UX1RPVUNIU1RBUlQgPSAnY29udGVudFRvdWNoc3RhcnQnLFxuICAgIENPTlRFTlRfVE9VQ0hFTkQgPSAnY29udGVudFRvdWNoZW5kJyxcbiAgICBDT05URU5UX0RCTF9UQVAgPSAnY29udGVudERibHRhcCcsXG4gICAgQ09OVEVOVF9UQVAgPSAnY29udGVudFRhcCcsXG4gICAgQ09OVEVOVF9UT1VDSE1PVkUgPSAnY29udGVudFRvdWNobW92ZScsXG4gICAgQ09OVEVOVF9XSEVFTCA9ICdjb250ZW50V2hlZWwnLFxuICAgIERJViA9ICdkaXYnLFxuICAgIFJFTEFUSVZFID0gJ3JlbGF0aXZlJyxcbiAgICBLT05WQV9DT05URU5UID0gJ2tvbnZhanMtY29udGVudCcsXG4gICAgU1BBQ0UgPSAnICcsXG4gICAgVU5ERVJTQ09SRSA9ICdfJyxcbiAgICBDT05UQUlORVIgPSAnY29udGFpbmVyJyxcbiAgICBFTVBUWV9TVFJJTkcgPSAnJyxcbiAgICBFVkVOVFMgPSBbXG4gICAgICBNT1VTRURPV04sXG4gICAgICBNT1VTRU1PVkUsXG4gICAgICBNT1VTRVVQLFxuICAgICAgTU9VU0VPVVQsXG4gICAgICBUT1VDSFNUQVJULFxuICAgICAgVE9VQ0hNT1ZFLFxuICAgICAgVE9VQ0hFTkQsXG4gICAgICBNT1VTRU9WRVIsXG4gICAgICBXSEVFTCxcbiAgICAgIENPTlRFWFRNRU5VXG4gICAgXSxcbiAgICAvLyBjYWNoZWQgdmFyaWFibGVzXG4gICAgZXZlbnRzTGVuZ3RoID0gRVZFTlRTLmxlbmd0aDtcblxuICBmdW5jdGlvbiBhZGRFdmVudChjdHgsIGV2ZW50TmFtZSkge1xuICAgIGN0eC5jb250ZW50LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBldmVudE5hbWUsXG4gICAgICBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgY3R4W1VOREVSU0NPUkUgKyBldmVudE5hbWVdKGV2dCk7XG4gICAgICB9LFxuICAgICAgZmFsc2VcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAgICogU3RhZ2UgY29uc3RydWN0b3IuICBBIHN0YWdlIGlzIHVzZWQgdG8gY29udGFpbiBtdWx0aXBsZSBsYXllcnNcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKiBAYXVnbWVudHMgS29udmEuQ29udGFpbmVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfEVsZW1lbnR9IGNvbmZpZy5jb250YWluZXIgQ29udGFpbmVyIHNlbGVjdG9yIG9yIERPTSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBzdGFnZSA9IG5ldyBLb252YS5TdGFnZSh7XG4gICAgICAgICAqICAgd2lkdGg6IDUwMCxcbiAgICAgICAgICogICBoZWlnaHQ6IDgwMCxcbiAgICAgICAgICogICBjb250YWluZXI6ICdjb250YWluZXJJZCcgLy8gb3IgXCIjY29udGFpbmVySWRcIiBvciBcIi5jb250YWluZXJDbGFzc1wiXG4gICAgICAgICAqIH0pO1xuICAgICAqL1xuICBLb252YS5TdGFnZSA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHRoaXMuX19faW5pdChjb25maWcpO1xuICB9O1xuXG4gIEtvbnZhLlV0aWwuYWRkTWV0aG9kcyhLb252YS5TdGFnZSwge1xuICAgIF9fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgdGhpcy5ub2RlVHlwZSA9IFNUQUdFO1xuICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxuICAgICAgS29udmEuQ29udGFpbmVyLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICAgIHRoaXMuX2lkID0gS29udmEuaWRDb3VudGVyKys7XG4gICAgICB0aGlzLl9idWlsZERPTSgpO1xuICAgICAgdGhpcy5fYmluZENvbnRlbnRFdmVudHMoKTtcbiAgICAgIHRoaXMuX2VuYWJsZU5lc3RlZFRyYW5zZm9ybXMgPSBmYWxzZTtcbiAgICAgIEtvbnZhLnN0YWdlcy5wdXNoKHRoaXMpO1xuICAgIH0sXG4gICAgX3ZhbGlkYXRlQWRkOiBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkLmdldFR5cGUoKSAhPT0gJ0xheWVyJykge1xuICAgICAgICBLb252YS5VdGlsLnRocm93KCdZb3UgbWF5IG9ubHkgYWRkIGxheWVycyB0byB0aGUgc3RhZ2UuJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogc2V0IGNvbnRhaW5lciBkb20gZWxlbWVudCB3aGljaCBjb250YWlucyB0aGUgc3RhZ2Ugd3JhcHBlciBkaXYgZWxlbWVudFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFnZS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtEb21FbGVtZW50fSBjb250YWluZXIgY2FuIHBhc3MgaW4gYSBkb20gZWxlbWVudCBvciBpZCBzdHJpbmdcbiAgICAgICAgICovXG4gICAgc2V0Q29udGFpbmVyOiBmdW5jdGlvbihjb250YWluZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgY29udGFpbmVyID09PSBTVFJJTkcpIHtcbiAgICAgICAgaWYgKGNvbnRhaW5lci5jaGFyQXQoMCkgPT09ICcuJykge1xuICAgICAgICAgIHZhciBjbGFzc05hbWUgPSBjb250YWluZXIuc2xpY2UoMSk7XG4gICAgICAgICAgY29udGFpbmVyID0gS29udmEuZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShjbGFzc05hbWUpWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBpZDtcbiAgICAgICAgICBpZiAoY29udGFpbmVyLmNoYXJBdCgwKSAhPT0gJyMnKSB7XG4gICAgICAgICAgICBpZCA9IGNvbnRhaW5lcjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWQgPSBjb250YWluZXIuc2xpY2UoMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRhaW5lciA9IEtvbnZhLmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICAgIHRocm93ICdDYW4gbm90IGZpbmQgY29udGFpbmVyIGluIGRvY3VtZW50IHdpdGggaWQgJyArIGlkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9zZXRBdHRyKENPTlRBSU5FUiwgY29udGFpbmVyKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgc2hvdWxkRHJhd0hpdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGRyYXc6IGZ1bmN0aW9uKCkge1xuICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuZHJhdy5jYWxsKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogZHJhdyBsYXllciBzY2VuZSBncmFwaHNcbiAgICAgICAgICogQG5hbWUgZHJhd1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFnZS5wcm90b3R5cGVcbiAgICAgICAgICovXG5cbiAgICAvKipcbiAgICAgICAgICogZHJhdyBsYXllciBoaXQgZ3JhcGhzXG4gICAgICAgICAqIEBuYW1lIGRyYXdIaXRcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU3RhZ2UucHJvdG90eXBlXG4gICAgICAgICAqL1xuXG4gICAgLyoqXG4gICAgICAgICAqIHNldCBoZWlnaHRcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU3RhZ2UucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgICAgICovXG4gICAgc2V0SGVpZ2h0OiBmdW5jdGlvbihoZWlnaHQpIHtcbiAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldEhlaWdodC5jYWxsKHRoaXMsIGhlaWdodCk7XG4gICAgICB0aGlzLl9yZXNpemVET00oKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIHNldCB3aWR0aFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFnZS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICAgICAqL1xuICAgIHNldFdpZHRoOiBmdW5jdGlvbih3aWR0aCkge1xuICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0V2lkdGguY2FsbCh0aGlzLCB3aWR0aCk7XG4gICAgICB0aGlzLl9yZXNpemVET00oKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIGNsZWFyIGFsbCBsYXllcnNcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU3RhZ2UucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgIGNsZWFyOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsYXllcnMgPSB0aGlzLmNoaWxkcmVuLFxuICAgICAgICBsZW4gPSBsYXllcnMubGVuZ3RoLFxuICAgICAgICBuO1xuXG4gICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgbGF5ZXJzW25dLmNsZWFyKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGNsb25lOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIGlmICghb2JqKSB7XG4gICAgICAgIG9iaiA9IHt9O1xuICAgICAgfVxuICAgICAgb2JqLmNvbnRhaW5lciA9IEtvbnZhLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoRElWKTtcbiAgICAgIHJldHVybiBLb252YS5Db250YWluZXIucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcywgb2JqKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiBkZXN0cm95IHN0YWdlXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YWdlLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb250ZW50ID0gdGhpcy5jb250ZW50O1xuICAgICAgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG5cbiAgICAgIGlmIChjb250ZW50ICYmIEtvbnZhLlV0aWwuX2lzSW5Eb2N1bWVudChjb250ZW50KSkge1xuICAgICAgICB0aGlzLmdldENvbnRhaW5lcigpLnJlbW92ZUNoaWxkKGNvbnRlbnQpO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gS29udmEuc3RhZ2VzLmluZGV4T2YodGhpcyk7XG4gICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICBLb252YS5zdGFnZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIGdldCBwb2ludGVyIHBvc2l0aW9uIHdoaWNoIGNhbiBiZSBhIHRvdWNoIHBvc2l0aW9uIG9yIG1vdXNlIHBvc2l0aW9uXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YWdlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICBnZXRQb2ludGVyUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucG9pbnRlclBvcztcbiAgICB9LFxuICAgIGdldFN0YWdlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIGdldCBzdGFnZSBjb250ZW50IGRpdiBlbGVtZW50IHdoaWNoIGhhcyB0aGVcbiAgICAgICAgICogIHRoZSBjbGFzcyBuYW1lIFwia29udmFqcy1jb250ZW50XCJcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU3RhZ2UucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgIGdldENvbnRlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVudDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgY29tcG9zaXRlIGRhdGEgVVJMXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YWdlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuY2FsbGJhY2tdIGZ1bmN0aW9uIGV4ZWN1dGVkIHdoZW4gdGhlIGNvbXBvc2l0ZSBoYXMgY29tcGxldGVkLiBEZXByZWNhdGVkIGFzIG1ldGhvZCBpcyBzeW5jIG5vdy5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubWltZVR5cGVdIGNhbiBiZSBcImltYWdlL3BuZ1wiIG9yIFwiaW1hZ2UvanBlZ1wiLlxuICAgICAgICAgKiAgXCJpbWFnZS9wbmdcIiBpcyB0aGUgZGVmYXVsdFxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XSB4IHBvc2l0aW9uIG9mIGNhbnZhcyBzZWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldIHkgcG9zaXRpb24gb2YgY2FudmFzIHNlY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdIHdpZHRoIG9mIGNhbnZhcyBzZWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF0gaGVpZ2h0IG9mIGNhbnZhcyBzZWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnF1YWxpdHldIGpwZWcgcXVhbGl0eS4gIElmIHVzaW5nIGFuIFwiaW1hZ2UvanBlZ1wiIG1pbWVUeXBlLFxuICAgICAgICAgKiAgeW91IGNhbiBzcGVjaWZ5IHRoZSBxdWFsaXR5IGZyb20gMCB0byAxLCB3aGVyZSAwIGlzIHZlcnkgcG9vciBxdWFsaXR5IGFuZCAxXG4gICAgICAgICAqICBpcyB2ZXJ5IGhpZ2ggcXVhbGl0eVxuICAgICAgICAgKi9cbiAgICB0b0RhdGFVUkw6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG4gICAgICB2YXIgbWltZVR5cGUgPSBjb25maWcubWltZVR5cGUgfHwgbnVsbCxcbiAgICAgICAgcXVhbGl0eSA9IGNvbmZpZy5xdWFsaXR5IHx8IG51bGwsXG4gICAgICAgIHggPSBjb25maWcueCB8fCAwLFxuICAgICAgICB5ID0gY29uZmlnLnkgfHwgMCxcbiAgICAgICAgY2FudmFzID0gbmV3IEtvbnZhLlNjZW5lQ2FudmFzKHtcbiAgICAgICAgICB3aWR0aDogY29uZmlnLndpZHRoIHx8IHRoaXMuZ2V0V2lkdGgoKSxcbiAgICAgICAgICBoZWlnaHQ6IGNvbmZpZy5oZWlnaHQgfHwgdGhpcy5nZXRIZWlnaHQoKSxcbiAgICAgICAgICBwaXhlbFJhdGlvOiBjb25maWcucGl4ZWxSYXRpb1xuICAgICAgICB9KSxcbiAgICAgICAgX2NvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgpLl9jb250ZXh0LFxuICAgICAgICBsYXllcnMgPSB0aGlzLmNoaWxkcmVuO1xuXG4gICAgICBpZiAoeCB8fCB5KSB7XG4gICAgICAgIF9jb250ZXh0LnRyYW5zbGF0ZSgtMSAqIHgsIC0xICogeSk7XG4gICAgICB9XG5cbiAgICAgIGxheWVycy5lYWNoKGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IGxheWVyLmdldENhbnZhcygpLmdldFdpZHRoKCk7XG4gICAgICAgIHZhciBoZWlnaHQgPSBsYXllci5nZXRDYW52YXMoKS5nZXRIZWlnaHQoKTtcbiAgICAgICAgdmFyIHJhdGlvID0gbGF5ZXIuZ2V0Q2FudmFzKCkuZ2V0UGl4ZWxSYXRpbygpO1xuICAgICAgICBfY29udGV4dC5kcmF3SW1hZ2UoXG4gICAgICAgICAgbGF5ZXIuZ2V0Q2FudmFzKCkuX2NhbnZhcyxcbiAgICAgICAgICAwLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgd2lkdGggLyByYXRpbyxcbiAgICAgICAgICBoZWlnaHQgLyByYXRpb1xuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgICB2YXIgc3JjID0gY2FudmFzLnRvRGF0YVVSTChtaW1lVHlwZSwgcXVhbGl0eSk7XG5cbiAgICAgIGlmIChjb25maWcuY2FsbGJhY2spIHtcbiAgICAgICAgY29uZmlnLmNhbGxiYWNrKHNyYyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzcmM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogY29udmVydHMgc3RhZ2UgaW50byBhbiBpbWFnZS5cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU3RhZ2UucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29uZmlnLmNhbGxiYWNrIGZ1bmN0aW9uIGV4ZWN1dGVkIHdoZW4gdGhlIGNvbXBvc2l0ZSBoYXMgY29tcGxldGVkXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm1pbWVUeXBlXSBjYW4gYmUgXCJpbWFnZS9wbmdcIiBvciBcImltYWdlL2pwZWdcIi5cbiAgICAgICAgICogIFwiaW1hZ2UvcG5nXCIgaXMgdGhlIGRlZmF1bHRcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF0geCBwb3NpdGlvbiBvZiBjYW52YXMgc2VjdGlvblxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XSB5IHBvc2l0aW9uIG9mIGNhbnZhcyBzZWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXSB3aWR0aCBvZiBjYW52YXMgc2VjdGlvblxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdIGhlaWdodCBvZiBjYW52YXMgc2VjdGlvblxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5xdWFsaXR5XSBqcGVnIHF1YWxpdHkuICBJZiB1c2luZyBhbiBcImltYWdlL2pwZWdcIiBtaW1lVHlwZSxcbiAgICAgICAgICogIHlvdSBjYW4gc3BlY2lmeSB0aGUgcXVhbGl0eSBmcm9tIDAgdG8gMSwgd2hlcmUgMCBpcyB2ZXJ5IHBvb3IgcXVhbGl0eSBhbmQgMVxuICAgICAgICAgKiAgaXMgdmVyeSBoaWdoIHF1YWxpdHlcbiAgICAgICAgICovXG4gICAgdG9JbWFnZTogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICB2YXIgY2IgPSBjb25maWcuY2FsbGJhY2s7XG5cbiAgICAgIGNvbmZpZy5jYWxsYmFjayA9IGZ1bmN0aW9uKGRhdGFVcmwpIHtcbiAgICAgICAgS29udmEuVXRpbC5fZ2V0SW1hZ2UoZGF0YVVybCwgZnVuY3Rpb24oaW1nKSB7XG4gICAgICAgICAgY2IoaW1nKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgdGhpcy50b0RhdGFVUkwoY29uZmlnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiBnZXQgdmlzaWJsZSBpbnRlcnNlY3Rpb24gc2hhcGUuIFRoaXMgaXMgdGhlIHByZWZlcnJlZFxuICAgICAgICAgKiAgbWV0aG9kIGZvciBkZXRlcm1pbmluZyBpZiBhIHBvaW50IGludGVyc2VjdHMgYSBzaGFwZSBvciBub3RcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU3RhZ2UucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb3NcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvcy54XG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb3MueVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NlbGVjdG9yXVxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogdmFyIHNoYXBlID0gc3RhZ2UuZ2V0SW50ZXJzZWN0aW9uKHt4OiA1MCwgeTogNTB9KTtcbiAgICAgICAgICogLy8gb3IgaWYgeW91IGludGVyZXN0ZWQgaW4gc2hhcGUgcGFyZW50OlxuICAgICAgICAgKiB2YXIgZ3JvdXAgPSBzdGFnZS5nZXRJbnRlcnNlY3Rpb24oe3g6IDUwLCB5OiA1MH0sICdHcm91cCcpO1xuICAgICAgICAgKi9cbiAgICBnZXRJbnRlcnNlY3Rpb246IGZ1bmN0aW9uKHBvcywgc2VsZWN0b3IpIHtcbiAgICAgIHZhciBsYXllcnMgPSB0aGlzLmdldENoaWxkcmVuKCksXG4gICAgICAgIGxlbiA9IGxheWVycy5sZW5ndGgsXG4gICAgICAgIGVuZCA9IGxlbiAtIDEsXG4gICAgICAgIG4sXG4gICAgICAgIHNoYXBlO1xuXG4gICAgICBmb3IgKG4gPSBlbmQ7IG4gPj0gMDsgbi0tKSB7XG4gICAgICAgIHNoYXBlID0gbGF5ZXJzW25dLmdldEludGVyc2VjdGlvbihwb3MsIHNlbGVjdG9yKTtcbiAgICAgICAgaWYgKHNoYXBlKSB7XG4gICAgICAgICAgcmV0dXJuIHNoYXBlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgX3Jlc2l6ZURPTTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5jb250ZW50KSB7XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKSxcbiAgICAgICAgICBoZWlnaHQgPSB0aGlzLmdldEhlaWdodCgpLFxuICAgICAgICAgIGxheWVycyA9IHRoaXMuZ2V0Q2hpbGRyZW4oKSxcbiAgICAgICAgICBsZW4gPSBsYXllcnMubGVuZ3RoLFxuICAgICAgICAgIG4sXG4gICAgICAgICAgbGF5ZXI7XG5cbiAgICAgICAgLy8gc2V0IGNvbnRlbnQgZGltZW5zaW9uc1xuICAgICAgICB0aGlzLmNvbnRlbnQuc3R5bGUud2lkdGggPSB3aWR0aCArIFBYO1xuICAgICAgICB0aGlzLmNvbnRlbnQuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgUFg7XG5cbiAgICAgICAgdGhpcy5idWZmZXJDYW52YXMuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5idWZmZXJIaXRDYW52YXMuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICAvLyBzZXQgbGF5ZXIgZGltZW5zaW9uc1xuICAgICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICBsYXllciA9IGxheWVyc1tuXTtcbiAgICAgICAgICBsYXllci5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgIGxheWVyLmRyYXcoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIGFkZCBsYXllciBvciBsYXllcnMgdG8gc3RhZ2VcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU3RhZ2UucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7Li4uS29udmEuTGF5ZXJ9IGxheWVyXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIHN0YWdlLmFkZChsYXllcjEsIGxheWVyMiwgbGF5ZXIzKTtcbiAgICAgICAgICovXG4gICAgYWRkOiBmdW5jdGlvbihsYXllcikge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5hZGQoYXJndW1lbnRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGUuYWRkLmNhbGwodGhpcywgbGF5ZXIpO1xuICAgICAgbGF5ZXIuX3NldENhbnZhc1NpemUodGhpcy53aWR0aCgpLCB0aGlzLmhlaWdodCgpKTtcblxuICAgICAgLy8gZHJhdyBsYXllciBhbmQgYXBwZW5kIGNhbnZhcyB0byBjb250YWluZXJcbiAgICAgIGxheWVyLmRyYXcoKTtcblxuICAgICAgaWYgKEtvbnZhLmlzQnJvd3Nlcikge1xuICAgICAgICB0aGlzLmNvbnRlbnQuYXBwZW5kQ2hpbGQobGF5ZXIuY2FudmFzLl9jYW52YXMpO1xuICAgICAgfVxuXG4gICAgICAvLyBjaGFpbmFibGVcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZ2V0UGFyZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgZ2V0TGF5ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogcmV0dXJucyBhIHtAbGluayBLb252YS5Db2xsZWN0aW9ufSBvZiBsYXllcnNcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU3RhZ2UucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgIGdldExheWVyczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRDaGlsZHJlbigpO1xuICAgIH0sXG4gICAgX2JpbmRDb250ZW50RXZlbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghS29udmEuaXNCcm93c2VyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgZXZlbnRzTGVuZ3RoOyBuKyspIHtcbiAgICAgICAgYWRkRXZlbnQodGhpcywgRVZFTlRTW25dKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9tb3VzZW92ZXI6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgaWYgKCFLb252YS5VQS5tb2JpbGUpIHtcbiAgICAgICAgdGhpcy5fc2V0UG9pbnRlclBvc2l0aW9uKGV2dCk7XG4gICAgICAgIHRoaXMuX2ZpcmUoQ09OVEVOVF9NT1VTRU9WRVIsIHsgZXZ0OiBldnQgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfbW91c2VvdXQ6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgaWYgKCFLb252YS5VQS5tb2JpbGUpIHtcbiAgICAgICAgdGhpcy5fc2V0UG9pbnRlclBvc2l0aW9uKGV2dCk7XG4gICAgICAgIHZhciB0YXJnZXRTaGFwZSA9IHRoaXMudGFyZ2V0U2hhcGU7XG5cbiAgICAgICAgaWYgKHRhcmdldFNoYXBlICYmICFLb252YS5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICB0YXJnZXRTaGFwZS5fZmlyZUFuZEJ1YmJsZShNT1VTRU9VVCwgeyBldnQ6IGV2dCB9KTtcbiAgICAgICAgICB0YXJnZXRTaGFwZS5fZmlyZUFuZEJ1YmJsZShNT1VTRUxFQVZFLCB7IGV2dDogZXZ0IH0pO1xuICAgICAgICAgIHRoaXMudGFyZ2V0U2hhcGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9pbnRlclBvcyA9IHVuZGVmaW5lZDtcblxuICAgICAgICB0aGlzLl9maXJlKENPTlRFTlRfTU9VU0VPVVQsIHsgZXZ0OiBldnQgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfbW91c2Vtb3ZlOiBmdW5jdGlvbihldnQpIHtcbiAgICAgIC8vIHdvcmthcm91bmQgZm9yIG1vYmlsZSBJRSB0byBmb3JjZSB0b3VjaCBldmVudCB3aGVuIHVuaGFuZGxlZCBwb2ludGVyIGV2ZW50IGVsZXZhdGVzIGludG8gYSBtb3VzZSBldmVudFxuICAgICAgaWYgKEtvbnZhLlVBLmllTW9iaWxlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b3VjaG1vdmUoZXZ0KTtcbiAgICAgIH1cbiAgICAgIC8vIHdvcmthcm91bmQgZmFrZSBtb3VzZW1vdmUgZXZlbnQgaW4gY2hyb21lIGJyb3dzZXIgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTE2MTQ2NFxuICAgICAgaWYgKFxuICAgICAgICAodHlwZW9mIGV2dC5tb3ZlbWVudFggIT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgICAgdHlwZW9mIGV2dC5tb3ZlbWVudFkgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICBldnQubW92ZW1lbnRZID09PSAwICYmXG4gICAgICAgIGV2dC5tb3ZlbWVudFggPT09IDBcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChLb252YS5VQS5tb2JpbGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLl9zZXRQb2ludGVyUG9zaXRpb24oZXZ0KTtcbiAgICAgIHZhciBzaGFwZTtcblxuICAgICAgaWYgKCFLb252YS5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgc2hhcGUgPSB0aGlzLmdldEludGVyc2VjdGlvbih0aGlzLmdldFBvaW50ZXJQb3NpdGlvbigpKTtcbiAgICAgICAgaWYgKHNoYXBlICYmIHNoYXBlLmlzTGlzdGVuaW5nKCkpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhS29udmEuaXNEcmFnZ2luZygpICYmXG4gICAgICAgICAgICAoIXRoaXMudGFyZ2V0U2hhcGUgfHwgdGhpcy50YXJnZXRTaGFwZS5faWQgIT09IHNoYXBlLl9pZClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRhcmdldFNoYXBlKSB7XG4gICAgICAgICAgICAgIHRoaXMudGFyZ2V0U2hhcGUuX2ZpcmVBbmRCdWJibGUoTU9VU0VPVVQsIHsgZXZ0OiBldnQgfSwgc2hhcGUpO1xuICAgICAgICAgICAgICB0aGlzLnRhcmdldFNoYXBlLl9maXJlQW5kQnViYmxlKE1PVVNFTEVBVkUsIHsgZXZ0OiBldnQgfSwgc2hhcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2hhcGUuX2ZpcmVBbmRCdWJibGUoTU9VU0VPVkVSLCB7IGV2dDogZXZ0IH0sIHRoaXMudGFyZ2V0U2hhcGUpO1xuICAgICAgICAgICAgc2hhcGUuX2ZpcmVBbmRCdWJibGUoTU9VU0VFTlRFUiwgeyBldnQ6IGV2dCB9LCB0aGlzLnRhcmdldFNoYXBlKTtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0U2hhcGUgPSBzaGFwZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2hhcGUuX2ZpcmVBbmRCdWJibGUoTU9VU0VNT1ZFLCB7IGV2dDogZXZ0IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIGlmIG5vIHNoYXBlIHdhcyBkZXRlY3RlZCwgY2xlYXIgdGFyZ2V0IHNoYXBlIGFuZCB0cnlcbiAgICAgICAgICAgICAgICAgKiB0byBydW4gbW91c2VvdXQgZnJvbSBwcmV2aW91cyB0YXJnZXQgc2hhcGVcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICBpZiAodGhpcy50YXJnZXRTaGFwZSAmJiAhS29udmEuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldFNoYXBlLl9maXJlQW5kQnViYmxlKE1PVVNFT1VULCB7IGV2dDogZXZ0IH0pO1xuICAgICAgICAgICAgdGhpcy50YXJnZXRTaGFwZS5fZmlyZUFuZEJ1YmJsZShNT1VTRUxFQVZFLCB7IGV2dDogZXZ0IH0pO1xuICAgICAgICAgICAgdGhpcy50YXJnZXRTaGFwZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29udGVudCBldmVudFxuICAgICAgICB0aGlzLl9maXJlKENPTlRFTlRfTU9VU0VNT1ZFLCB7IGV2dDogZXZ0IH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBhbHdheXMgY2FsbCBwcmV2ZW50RGVmYXVsdCBmb3IgZGVza3RvcCBldmVudHMgYmVjYXVzZSBzb21lIGJyb3dzZXJzXG4gICAgICAvLyB0cnkgdG8gZHJhZyBhbmQgZHJvcCB0aGUgY2FudmFzIGVsZW1lbnRcbiAgICAgIGlmIChldnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfbW91c2Vkb3duOiBmdW5jdGlvbihldnQpIHtcbiAgICAgIC8vIHdvcmthcm91bmQgZm9yIG1vYmlsZSBJRSB0byBmb3JjZSB0b3VjaCBldmVudCB3aGVuIHVuaGFuZGxlZCBwb2ludGVyIGV2ZW50IGVsZXZhdGVzIGludG8gYSBtb3VzZSBldmVudFxuICAgICAgaWYgKEtvbnZhLlVBLmllTW9iaWxlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b3VjaHN0YXJ0KGV2dCk7XG4gICAgICB9XG4gICAgICBpZiAoIUtvbnZhLlVBLm1vYmlsZSkge1xuICAgICAgICB0aGlzLl9zZXRQb2ludGVyUG9zaXRpb24oZXZ0KTtcbiAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5nZXRJbnRlcnNlY3Rpb24odGhpcy5nZXRQb2ludGVyUG9zaXRpb24oKSk7XG5cbiAgICAgICAgS29udmEubGlzdGVuQ2xpY2tUYXAgPSB0cnVlO1xuXG4gICAgICAgIGlmIChzaGFwZSAmJiBzaGFwZS5pc0xpc3RlbmluZygpKSB7XG4gICAgICAgICAgdGhpcy5jbGlja1N0YXJ0U2hhcGUgPSBzaGFwZTtcbiAgICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShNT1VTRURPV04sIHsgZXZ0OiBldnQgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb250ZW50IGV2ZW50XG4gICAgICAgIHRoaXMuX2ZpcmUoQ09OVEVOVF9NT1VTRURPV04sIHsgZXZ0OiBldnQgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFsd2F5cyBjYWxsIHByZXZlbnREZWZhdWx0IGZvciBkZXNrdG9wIGV2ZW50cyBiZWNhdXNlIHNvbWUgYnJvd3NlcnNcbiAgICAgIC8vIHRyeSB0byBkcmFnIGFuZCBkcm9wIHRoZSBjYW52YXMgZWxlbWVudFxuICAgICAgaWYgKGV2dC5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9tb3VzZXVwOiBmdW5jdGlvbihldnQpIHtcbiAgICAgIC8vIHdvcmthcm91bmQgZm9yIG1vYmlsZSBJRSB0byBmb3JjZSB0b3VjaCBldmVudCB3aGVuIHVuaGFuZGxlZCBwb2ludGVyIGV2ZW50IGVsZXZhdGVzIGludG8gYSBtb3VzZSBldmVudFxuICAgICAgaWYgKEtvbnZhLlVBLmllTW9iaWxlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b3VjaGVuZChldnQpO1xuICAgICAgfVxuICAgICAgaWYgKCFLb252YS5VQS5tb2JpbGUpIHtcbiAgICAgICAgdGhpcy5fc2V0UG9pbnRlclBvc2l0aW9uKGV2dCk7XG4gICAgICAgIHZhciBzaGFwZSA9IHRoaXMuZ2V0SW50ZXJzZWN0aW9uKHRoaXMuZ2V0UG9pbnRlclBvc2l0aW9uKCkpLFxuICAgICAgICAgIGNsaWNrU3RhcnRTaGFwZSA9IHRoaXMuY2xpY2tTdGFydFNoYXBlLFxuICAgICAgICAgIGNsaWNrRW5kU2hhcGUgPSB0aGlzLmNsaWNrRW5kU2hhcGUsXG4gICAgICAgICAgZmlyZURibENsaWNrID0gZmFsc2UsXG4gICAgICAgICAgZGQgPSBLb252YS5ERDtcblxuICAgICAgICBpZiAoS29udmEuaW5EYmxDbGlja1dpbmRvdykge1xuICAgICAgICAgIGZpcmVEYmxDbGljayA9IHRydWU7XG4gICAgICAgICAgS29udmEuaW5EYmxDbGlja1dpbmRvdyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKCFkZCB8fCAhZGQuanVzdERyYWdnZWQpIHtcbiAgICAgICAgICAvLyBkb24ndCBzZXQgaW5EYmxDbGlja1dpbmRvdyBhZnRlciBkcmFnZ2luZ1xuICAgICAgICAgIEtvbnZhLmluRGJsQ2xpY2tXaW5kb3cgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGRkKSB7XG4gICAgICAgICAgZGQuanVzdERyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgS29udmEuaW5EYmxDbGlja1dpbmRvdyA9IGZhbHNlO1xuICAgICAgICB9LCBLb252YS5kYmxDbGlja1dpbmRvdyk7XG5cbiAgICAgICAgaWYgKHNoYXBlICYmIHNoYXBlLmlzTGlzdGVuaW5nKCkpIHtcbiAgICAgICAgICB0aGlzLmNsaWNrRW5kU2hhcGUgPSBzaGFwZTtcbiAgICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShNT1VTRVVQLCB7IGV2dDogZXZ0IH0pO1xuXG4gICAgICAgICAgLy8gZGV0ZWN0IGlmIGNsaWNrIG9yIGRvdWJsZSBjbGljayBvY2N1cnJlZFxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIEtvbnZhLmxpc3RlbkNsaWNrVGFwICYmXG4gICAgICAgICAgICBjbGlja1N0YXJ0U2hhcGUgJiZcbiAgICAgICAgICAgIGNsaWNrU3RhcnRTaGFwZS5faWQgPT09IHNoYXBlLl9pZFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgc2hhcGUuX2ZpcmVBbmRCdWJibGUoQ0xJQ0ssIHsgZXZ0OiBldnQgfSk7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgZmlyZURibENsaWNrICYmXG4gICAgICAgICAgICAgIGNsaWNrRW5kU2hhcGUgJiZcbiAgICAgICAgICAgICAgY2xpY2tFbmRTaGFwZS5faWQgPT09IHNoYXBlLl9pZFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHNoYXBlLl9maXJlQW5kQnViYmxlKERCTF9DTElDSywgeyBldnQ6IGV2dCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29udGVudCBldmVudHNcbiAgICAgICAgdGhpcy5fZmlyZShDT05URU5UX01PVVNFVVAsIHsgZXZ0OiBldnQgfSk7XG4gICAgICAgIGlmIChLb252YS5saXN0ZW5DbGlja1RhcCkge1xuICAgICAgICAgIHRoaXMuX2ZpcmUoQ09OVEVOVF9DTElDSywgeyBldnQ6IGV2dCB9KTtcbiAgICAgICAgICBpZiAoZmlyZURibENsaWNrKSB7XG4gICAgICAgICAgICB0aGlzLl9maXJlKENPTlRFTlRfREJMX0NMSUNLLCB7IGV2dDogZXZ0IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIEtvbnZhLmxpc3RlbkNsaWNrVGFwID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIGFsd2F5cyBjYWxsIHByZXZlbnREZWZhdWx0IGZvciBkZXNrdG9wIGV2ZW50cyBiZWNhdXNlIHNvbWUgYnJvd3NlcnNcbiAgICAgIC8vIHRyeSB0byBkcmFnIGFuZCBkcm9wIHRoZSBjYW52YXMgZWxlbWVudFxuICAgICAgaWYgKGV2dC5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9jb250ZXh0bWVudTogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICB0aGlzLl9maXJlKENPTlRFTlRfQ09OVEVYVE1FTlUsIHsgZXZ0OiBldnQgfSk7XG4gICAgfSxcbiAgICBfdG91Y2hzdGFydDogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICB0aGlzLl9zZXRQb2ludGVyUG9zaXRpb24oZXZ0KTtcbiAgICAgIHZhciBzaGFwZSA9IHRoaXMuZ2V0SW50ZXJzZWN0aW9uKHRoaXMuZ2V0UG9pbnRlclBvc2l0aW9uKCkpO1xuXG4gICAgICBLb252YS5saXN0ZW5DbGlja1RhcCA9IHRydWU7XG5cbiAgICAgIGlmIChzaGFwZSAmJiBzaGFwZS5pc0xpc3RlbmluZygpKSB7XG4gICAgICAgIHRoaXMudGFwU3RhcnRTaGFwZSA9IHNoYXBlO1xuICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShUT1VDSFNUQVJULCB7IGV2dDogZXZ0IH0pO1xuXG4gICAgICAgIC8vIG9ubHkgY2FsbCBwcmV2ZW50RGVmYXVsdCBpZiB0aGUgc2hhcGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHNoYXBlLmlzTGlzdGVuaW5nKCkgJiZcbiAgICAgICAgICBzaGFwZS5wcmV2ZW50RGVmYXVsdCgpICYmXG4gICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0XG4gICAgICAgICkge1xuICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBjb250ZW50IGV2ZW50XG4gICAgICB0aGlzLl9maXJlKENPTlRFTlRfVE9VQ0hTVEFSVCwgeyBldnQ6IGV2dCB9KTtcbiAgICB9LFxuICAgIF90b3VjaGVuZDogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICB0aGlzLl9zZXRQb2ludGVyUG9zaXRpb24oZXZ0KTtcbiAgICAgIHZhciBzaGFwZSA9IHRoaXMuZ2V0SW50ZXJzZWN0aW9uKHRoaXMuZ2V0UG9pbnRlclBvc2l0aW9uKCkpLFxuICAgICAgICBmaXJlRGJsQ2xpY2sgPSBmYWxzZTtcblxuICAgICAgaWYgKEtvbnZhLmluRGJsQ2xpY2tXaW5kb3cpIHtcbiAgICAgICAgZmlyZURibENsaWNrID0gdHJ1ZTtcbiAgICAgICAgS29udmEuaW5EYmxDbGlja1dpbmRvdyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgS29udmEuaW5EYmxDbGlja1dpbmRvdyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIEtvbnZhLmluRGJsQ2xpY2tXaW5kb3cgPSBmYWxzZTtcbiAgICAgIH0sIEtvbnZhLmRibENsaWNrV2luZG93KTtcblxuICAgICAgaWYgKHNoYXBlICYmIHNoYXBlLmlzTGlzdGVuaW5nKCkpIHtcbiAgICAgICAgc2hhcGUuX2ZpcmVBbmRCdWJibGUoVE9VQ0hFTkQsIHsgZXZ0OiBldnQgfSk7XG5cbiAgICAgICAgLy8gZGV0ZWN0IGlmIHRhcCBvciBkb3VibGUgdGFwIG9jY3VycmVkXG4gICAgICAgIGlmIChcbiAgICAgICAgICBLb252YS5saXN0ZW5DbGlja1RhcCAmJlxuICAgICAgICAgIHRoaXMudGFwU3RhcnRTaGFwZSAmJlxuICAgICAgICAgIHNoYXBlLl9pZCA9PT0gdGhpcy50YXBTdGFydFNoYXBlLl9pZFxuICAgICAgICApIHtcbiAgICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShUQVAsIHsgZXZ0OiBldnQgfSk7XG5cbiAgICAgICAgICBpZiAoZmlyZURibENsaWNrKSB7XG4gICAgICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShEQkxfVEFQLCB7IGV2dDogZXZ0IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBvbmx5IGNhbGwgcHJldmVudERlZmF1bHQgaWYgdGhlIHNoYXBlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICAgIGlmIChcbiAgICAgICAgICBzaGFwZS5pc0xpc3RlbmluZygpICYmXG4gICAgICAgICAgc2hhcGUucHJldmVudERlZmF1bHQoKSAmJlxuICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdFxuICAgICAgICApIHtcbiAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gY29udGVudCBldmVudHNcbiAgICAgIHRoaXMuX2ZpcmUoQ09OVEVOVF9UT1VDSEVORCwgeyBldnQ6IGV2dCB9KTtcbiAgICAgIGlmIChLb252YS5saXN0ZW5DbGlja1RhcCkge1xuICAgICAgICB0aGlzLl9maXJlKENPTlRFTlRfVEFQLCB7IGV2dDogZXZ0IH0pO1xuICAgICAgICBpZiAoZmlyZURibENsaWNrKSB7XG4gICAgICAgICAgdGhpcy5fZmlyZShDT05URU5UX0RCTF9UQVAsIHsgZXZ0OiBldnQgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgS29udmEubGlzdGVuQ2xpY2tUYXAgPSBmYWxzZTtcbiAgICB9LFxuICAgIF90b3VjaG1vdmU6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgdGhpcy5fc2V0UG9pbnRlclBvc2l0aW9uKGV2dCk7XG4gICAgICB2YXIgZGQgPSBLb252YS5ERCxcbiAgICAgICAgc2hhcGU7XG4gICAgICBpZiAoIUtvbnZhLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICBzaGFwZSA9IHRoaXMuZ2V0SW50ZXJzZWN0aW9uKHRoaXMuZ2V0UG9pbnRlclBvc2l0aW9uKCkpO1xuICAgICAgICBpZiAoc2hhcGUgJiYgc2hhcGUuaXNMaXN0ZW5pbmcoKSkge1xuICAgICAgICAgIHNoYXBlLl9maXJlQW5kQnViYmxlKFRPVUNITU9WRSwgeyBldnQ6IGV2dCB9KTtcbiAgICAgICAgICAvLyBvbmx5IGNhbGwgcHJldmVudERlZmF1bHQgaWYgdGhlIHNoYXBlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgc2hhcGUuaXNMaXN0ZW5pbmcoKSAmJlxuICAgICAgICAgICAgc2hhcGUucHJldmVudERlZmF1bHQoKSAmJlxuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0XG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZmlyZShDT05URU5UX1RPVUNITU9WRSwgeyBldnQ6IGV2dCB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChkZCkge1xuICAgICAgICBpZiAoS29udmEuaXNEcmFnZ2luZygpICYmIEtvbnZhLkRELm5vZGUucHJldmVudERlZmF1bHQoKSkge1xuICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBfd2hlZWw6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgdGhpcy5fc2V0UG9pbnRlclBvc2l0aW9uKGV2dCk7XG4gICAgICB2YXIgc2hhcGUgPSB0aGlzLmdldEludGVyc2VjdGlvbih0aGlzLmdldFBvaW50ZXJQb3NpdGlvbigpKTtcblxuICAgICAgaWYgKHNoYXBlICYmIHNoYXBlLmlzTGlzdGVuaW5nKCkpIHtcbiAgICAgICAgc2hhcGUuX2ZpcmVBbmRCdWJibGUoV0hFRUwsIHsgZXZ0OiBldnQgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9maXJlKENPTlRFTlRfV0hFRUwsIHsgZXZ0OiBldnQgfSk7XG4gICAgfSxcbiAgICBfc2V0UG9pbnRlclBvc2l0aW9uOiBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciBjb250ZW50UG9zaXRpb24gPSB0aGlzLl9nZXRDb250ZW50UG9zaXRpb24oKSxcbiAgICAgICAgeCA9IG51bGwsXG4gICAgICAgIHkgPSBudWxsO1xuICAgICAgZXZ0ID0gZXZ0ID8gZXZ0IDogd2luZG93LmV2ZW50O1xuXG4gICAgICAvLyB0b3VjaCBldmVudHNcbiAgICAgIGlmIChldnQudG91Y2hlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGN1cnJlbnRseSwgb25seSBoYW5kbGUgb25lIGZpbmdlclxuICAgICAgICBpZiAoZXZ0LnRvdWNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciB0b3VjaCA9IGV2dC50b3VjaGVzWzBdO1xuICAgICAgICAgIC8vIGdldCB0aGUgaW5mb3JtYXRpb24gZm9yIGZpbmdlciAjMVxuICAgICAgICAgIHggPSB0b3VjaC5jbGllbnRYIC0gY29udGVudFBvc2l0aW9uLmxlZnQ7XG4gICAgICAgICAgeSA9IHRvdWNoLmNsaWVudFkgLSBjb250ZW50UG9zaXRpb24udG9wO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBtb3VzZSBldmVudHNcbiAgICAgICAgeCA9IGV2dC5jbGllbnRYIC0gY29udGVudFBvc2l0aW9uLmxlZnQ7XG4gICAgICAgIHkgPSBldnQuY2xpZW50WSAtIGNvbnRlbnRQb3NpdGlvbi50b3A7XG4gICAgICB9XG4gICAgICBpZiAoeCAhPT0gbnVsbCAmJiB5ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMucG9pbnRlclBvcyA9IHtcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIHk6IHlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9nZXRDb250ZW50UG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlY3QgPSB0aGlzLmNvbnRlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gICAgICAgID8gdGhpcy5jb250ZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgIDogeyB0b3A6IDAsIGxlZnQ6IDAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogcmVjdC50b3AsXG4gICAgICAgIGxlZnQ6IHJlY3QubGVmdFxuICAgICAgfTtcbiAgICB9LFxuICAgIF9idWlsZERPTTogZnVuY3Rpb24oKSB7XG4gICAgICAvLyB0aGUgYnVmZmVyIGNhbnZhcyBwaXhlbCByYXRpbyBtdXN0IGJlIDEgYmVjYXVzZSBpdCBpcyB1c2VkIGFzIGFuXG4gICAgICAvLyBpbnRlcm1lZGlhdGUgY2FudmFzIGJlZm9yZSBjb3B5aW5nIHRoZSByZXN1bHQgb250byBhIHNjZW5lIGNhbnZhcy5cbiAgICAgIC8vIG5vdCBzZXR0aW5nIGl0IHRvIDEgd2lsbCByZXN1bHQgaW4gYW4gb3ZlciBjb21wZW5zYXRpb25cbiAgICAgIHRoaXMuYnVmZmVyQ2FudmFzID0gbmV3IEtvbnZhLlNjZW5lQ2FudmFzKCk7XG4gICAgICB0aGlzLmJ1ZmZlckhpdENhbnZhcyA9IG5ldyBLb252YS5IaXRDYW52YXMoeyBwaXhlbFJhdGlvOiAxIH0pO1xuXG4gICAgICBpZiAoIUtvbnZhLmlzQnJvd3Nlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5nZXRDb250YWluZXIoKTtcbiAgICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgIHRocm93ICdTdGFnZSBoYXMgbm8gY29udGFpbmVyLiBBIGNvbnRhaW5lciBpcyByZXF1aXJlZC4nO1xuICAgICAgfVxuICAgICAgLy8gY2xlYXIgY29udGVudCBpbnNpZGUgY29udGFpbmVyXG4gICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gRU1QVFlfU1RSSU5HO1xuXG4gICAgICAvLyBjb250ZW50XG4gICAgICB0aGlzLmNvbnRlbnQgPSBLb252YS5kb2N1bWVudC5jcmVhdGVFbGVtZW50KERJVik7XG4gICAgICB0aGlzLmNvbnRlbnQuc3R5bGUucG9zaXRpb24gPSBSRUxBVElWRTtcbiAgICAgIHRoaXMuY29udGVudC5jbGFzc05hbWUgPSBLT05WQV9DT05URU5UO1xuICAgICAgdGhpcy5jb250ZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICdwcmVzZW50YXRpb24nKTtcblxuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuY29udGVudCk7XG5cbiAgICAgIHRoaXMuX3Jlc2l6ZURPTSgpO1xuICAgIH0sXG4gICAgX29uQ29udGVudDogZnVuY3Rpb24odHlwZXNTdHIsIGhhbmRsZXIpIHtcbiAgICAgIHZhciB0eXBlcyA9IHR5cGVzU3RyLnNwbGl0KFNQQUNFKSxcbiAgICAgICAgbGVuID0gdHlwZXMubGVuZ3RoLFxuICAgICAgICBuLFxuICAgICAgICBiYXNlRXZlbnQ7XG5cbiAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICBiYXNlRXZlbnQgPSB0eXBlc1tuXTtcbiAgICAgICAgdGhpcy5jb250ZW50LmFkZEV2ZW50TGlzdGVuZXIoYmFzZUV2ZW50LCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBjdXJyZW50bHkgY2FjaGUgZnVuY3Rpb24gaXMgbm93IHdvcmtpbmcgZm9yIHN0YWdlLCBiZWNhdXNlIHN0YWdlIGhhcyBubyBpdHMgb3duIGNhbnZhcyBlbGVtZW50XG4gICAgLy8gVE9ETzogbWF5IGJlIGl0IGlzIGJldHRlciB0byBjYWNoZSBhbGwgY2hpbGRyZW4gbGF5ZXJzP1xuICAgIGNhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgIEtvbnZhLlV0aWwud2FybihcbiAgICAgICAgJ0NhY2hlIGZ1bmN0aW9uIGlzIG5vdCBhbGxvd2VkIGZvciBzdGFnZS4gWW91IG1heSB1c2UgY2FjaGUgb25seSBmb3IgbGF5ZXJzLCBncm91cHMgYW5kIHNoYXBlcy4nXG4gICAgICApO1xuICAgIH0sXG4gICAgY2xlYXJDYWNoZTogZnVuY3Rpb24oKSB7fVxuICB9KTtcbiAgS29udmEuVXRpbC5leHRlbmQoS29udmEuU3RhZ2UsIEtvbnZhLkNvbnRhaW5lcik7XG5cbiAgLy8gYWRkIGdldHRlcnMgYW5kIHNldHRlcnNcbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXIoS29udmEuU3RhZ2UsICdjb250YWluZXInKTtcbiAgS29udmEuRmFjdG9yeS5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKEtvbnZhLlN0YWdlLCAnY29udGFpbmVyJyk7XG5cbiAgLyoqXG4gICAgICogZ2V0IGNvbnRhaW5lciBET00gZWxlbWVudFxuICAgICAqIEBuYW1lIGNvbnRhaW5lclxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU3RhZ2UucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0RvbUVsZW1lbnR9IGNvbnRhaW5lclxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGNvbnRhaW5lclxuICAgICAqIHZhciBjb250YWluZXIgPSBzdGFnZS5jb250YWluZXIoKTtcbiAgICAgKiAvLyBzZXQgY29udGFpbmVyXG4gICAgICogdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAqIGJvZHkuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICAgKiBzdGFnZS5jb250YWluZXIoY29udGFpbmVyKTtcbiAgICAgKi9cbn0pKCk7XG5cbihmdW5jdGlvbihLb252YSkge1xuICAndXNlIHN0cmljdCc7XG4gIC8qKlxuICAgICAqIEJhc2VMYXllciBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKiBAYXVnbWVudHMgS29udmEuQ29udGFpbmVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5jbGVhckJlZm9yZURyYXddIHNldCB0aGlzIHByb3BlcnR5IHRvIGZhbHNlIGlmIHlvdSBkb24ndCB3YW50XG4gICAgICogdG8gY2xlYXIgdGhlIGNhbnZhcyBiZWZvcmUgZWFjaCBsYXllciBkcmF3LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuY2xpcF0gc2V0IGNsaXBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwWF0gc2V0IGNsaXAgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBZXSBzZXQgY2xpcCB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY2xpcFdpZHRoXSBzZXQgY2xpcCB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBIZWlnaHRdIHNldCBjbGlwIGhlaWdodFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuY2xpcEZ1bmNdIHNldCBjbGlwIGZ1bmNcblxuICAgICAqL1xuICBLb252YS5CYXNlTGF5ZXIgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICB0aGlzLl9fX2luaXQoY29uZmlnKTtcbiAgfTtcblxuICBLb252YS5VdGlsLmFkZE1ldGhvZHMoS29udmEuQmFzZUxheWVyLCB7XG4gICAgX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICB0aGlzLm5vZGVUeXBlID0gJ0xheWVyJztcbiAgICAgIEtvbnZhLkNvbnRhaW5lci5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgfSxcbiAgICBjcmVhdGVQTkdTdHJlYW06IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLl9jYW52YXMuY3JlYXRlUE5HU3RyZWFtKCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBnZXQgbGF5ZXIgY2FudmFzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5CYXNlTGF5ZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0Q2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbnZhcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGdldCBsYXllciBoaXQgY2FudmFzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5CYXNlTGF5ZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0SGl0Q2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmhpdENhbnZhcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGdldCBsYXllciBjYW52YXMgY29udGV4dFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQmFzZUxheWVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldENvbnRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2FudmFzKCkuZ2V0Q29udGV4dCgpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogY2xlYXIgc2NlbmUgYW5kIGhpdCBjYW52YXMgY29udGV4dHMgdGllZCB0byB0aGUgbGF5ZXJcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkJhc2VMYXllci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2JvdW5kc11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2JvdW5kcy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbYm91bmRzLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtib3VuZHMud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtib3VuZHMuaGVpZ2h0XVxuICAgICAqIEBleGFtcGxlXG4gICAgICogbGF5ZXIuY2xlYXIoKTtcbiAgICAgKiBsYXllci5jbGVhcih7XG4gICAgICogICB4IDogMCxcbiAgICAgKiAgIHkgOiAwLFxuICAgICAqICAgd2lkdGggOiAxMDAsXG4gICAgICogICBoZWlnaHQgOiAxMDBcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBjbGVhcjogZnVuY3Rpb24oYm91bmRzKSB7XG4gICAgICB0aGlzLmdldENvbnRleHQoKS5jbGVhcihib3VuZHMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBjbGVhckhpdENhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2hpdEltYWdlRGF0YSA9IHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIC8vIGV4dGVuZCBOb2RlLnByb3RvdHlwZS5zZXRaSW5kZXhcbiAgICBzZXRaSW5kZXg6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRaSW5kZXguY2FsbCh0aGlzLCBpbmRleCk7XG4gICAgICB2YXIgc3RhZ2UgPSB0aGlzLmdldFN0YWdlKCk7XG4gICAgICBpZiAoc3RhZ2UpIHtcbiAgICAgICAgc3RhZ2UuY29udGVudC5yZW1vdmVDaGlsZCh0aGlzLmdldENhbnZhcygpLl9jYW52YXMpO1xuXG4gICAgICAgIGlmIChpbmRleCA8IHN0YWdlLmdldENoaWxkcmVuKCkubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIHN0YWdlLmNvbnRlbnQuaW5zZXJ0QmVmb3JlKFxuICAgICAgICAgICAgdGhpcy5nZXRDYW52YXMoKS5fY2FudmFzLFxuICAgICAgICAgICAgc3RhZ2UuZ2V0Q2hpbGRyZW4oKVtpbmRleCArIDFdLmdldENhbnZhcygpLl9jYW52YXNcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YWdlLmNvbnRlbnQuYXBwZW5kQ2hpbGQodGhpcy5nZXRDYW52YXMoKS5fY2FudmFzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBleHRlbmQgTm9kZS5wcm90b3R5cGUubW92ZVRvVG9wXG4gICAgbW92ZVRvVG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLm1vdmVUb1RvcC5jYWxsKHRoaXMpO1xuICAgICAgdmFyIHN0YWdlID0gdGhpcy5nZXRTdGFnZSgpO1xuICAgICAgaWYgKHN0YWdlKSB7XG4gICAgICAgIHN0YWdlLmNvbnRlbnQucmVtb3ZlQ2hpbGQodGhpcy5nZXRDYW52YXMoKS5fY2FudmFzKTtcbiAgICAgICAgc3RhZ2UuY29udGVudC5hcHBlbmRDaGlsZCh0aGlzLmdldENhbnZhcygpLl9jYW52YXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBleHRlbmQgTm9kZS5wcm90b3R5cGUubW92ZVVwXG4gICAgbW92ZVVwOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtb3ZlZCA9IEtvbnZhLk5vZGUucHJvdG90eXBlLm1vdmVVcC5jYWxsKHRoaXMpO1xuICAgICAgaWYgKCFtb3ZlZCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBzdGFnZSA9IHRoaXMuZ2V0U3RhZ2UoKTtcbiAgICAgIGlmICghc3RhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBzdGFnZS5jb250ZW50LnJlbW92ZUNoaWxkKHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcyk7XG5cbiAgICAgIGlmICh0aGlzLmluZGV4IDwgc3RhZ2UuZ2V0Q2hpbGRyZW4oKS5sZW5ndGggLSAxKSB7XG4gICAgICAgIHN0YWdlLmNvbnRlbnQuaW5zZXJ0QmVmb3JlKFxuICAgICAgICAgIHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcyxcbiAgICAgICAgICBzdGFnZS5nZXRDaGlsZHJlbigpW3RoaXMuaW5kZXggKyAxXS5nZXRDYW52YXMoKS5fY2FudmFzXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFnZS5jb250ZW50LmFwcGVuZENoaWxkKHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIGV4dGVuZCBOb2RlLnByb3RvdHlwZS5tb3ZlRG93blxuICAgIG1vdmVEb3duOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChLb252YS5Ob2RlLnByb3RvdHlwZS5tb3ZlRG93bi5jYWxsKHRoaXMpKSB7XG4gICAgICAgIHZhciBzdGFnZSA9IHRoaXMuZ2V0U3RhZ2UoKTtcbiAgICAgICAgaWYgKHN0YWdlKSB7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuID0gc3RhZ2UuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgICBzdGFnZS5jb250ZW50LnJlbW92ZUNoaWxkKHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcyk7XG4gICAgICAgICAgc3RhZ2UuY29udGVudC5pbnNlcnRCZWZvcmUoXG4gICAgICAgICAgICB0aGlzLmdldENhbnZhcygpLl9jYW52YXMsXG4gICAgICAgICAgICBjaGlsZHJlblt0aGlzLmluZGV4ICsgMV0uZ2V0Q2FudmFzKCkuX2NhbnZhc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gZXh0ZW5kIE5vZGUucHJvdG90eXBlLm1vdmVUb0JvdHRvbVxuICAgIG1vdmVUb0JvdHRvbTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoS29udmEuTm9kZS5wcm90b3R5cGUubW92ZVRvQm90dG9tLmNhbGwodGhpcykpIHtcbiAgICAgICAgdmFyIHN0YWdlID0gdGhpcy5nZXRTdGFnZSgpO1xuICAgICAgICBpZiAoc3RhZ2UpIHtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBzdGFnZS5nZXRDaGlsZHJlbigpO1xuICAgICAgICAgIHN0YWdlLmNvbnRlbnQucmVtb3ZlQ2hpbGQodGhpcy5nZXRDYW52YXMoKS5fY2FudmFzKTtcbiAgICAgICAgICBzdGFnZS5jb250ZW50Lmluc2VydEJlZm9yZShcbiAgICAgICAgICAgIHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcyxcbiAgICAgICAgICAgIGNoaWxkcmVuWzFdLmdldENhbnZhcygpLl9jYW52YXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGdldExheWVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfY2FudmFzID0gdGhpcy5nZXRDYW52YXMoKS5fY2FudmFzO1xuXG4gICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5yZW1vdmUuY2FsbCh0aGlzKTtcblxuICAgICAgaWYgKF9jYW52YXMgJiYgX2NhbnZhcy5wYXJlbnROb2RlICYmIEtvbnZhLlV0aWwuX2lzSW5Eb2N1bWVudChfY2FudmFzKSkge1xuICAgICAgICBfY2FudmFzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoX2NhbnZhcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGdldFN0YWdlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudDtcbiAgICB9LFxuICAgIHNldFNpemU6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHRoaXMuY2FudmFzLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgd2lkdGggb2YgbGF5ZXIuZ2V0dGVyIHJldHVybiB3aWR0aCBvZiBzdGFnZS4gc2V0dGVyIGRvaW5nIG5vdGhpbmcuXG4gICAgICogaWYgeW91IHdhbnQgY2hhbmdlIHdpZHRoIHVzZSBgc3RhZ2Uud2lkdGgodmFsdWUpO2BcbiAgICAgKiBAbmFtZSB3aWR0aFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQmFzZUxheWVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgd2lkdGggPSBsYXllci53aWR0aCgpO1xuICAgICAqL1xuICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZ2V0V2lkdGgoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgIEtvbnZhLlV0aWwud2FybihcbiAgICAgICAgJ0NhbiBub3QgY2hhbmdlIHdpZHRoIG9mIGxheWVyLiBVc2UgXCJzdGFnZS53aWR0aCh2YWx1ZSlcIiBmdW5jdGlvbiBpbnN0ZWFkLidcbiAgICAgICk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGhlaWdodCBvZiBsYXllci5nZXR0ZXIgcmV0dXJuIGhlaWdodCBvZiBzdGFnZS4gc2V0dGVyIGRvaW5nIG5vdGhpbmcuXG4gICAgICogaWYgeW91IHdhbnQgY2hhbmdlIGhlaWdodCB1c2UgYHN0YWdlLmhlaWdodCh2YWx1ZSk7YFxuICAgICAqIEBuYW1lIGhlaWdodFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQmFzZUxheWVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgaGVpZ2h0ID0gbGF5ZXIuaGVpZ2h0KCk7XG4gICAgICovXG4gICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZ2V0SGVpZ2h0KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgS29udmEuVXRpbC53YXJuKFxuICAgICAgICAnQ2FuIG5vdCBjaGFuZ2UgaGVpZ2h0IG9mIGxheWVyLiBVc2UgXCJzdGFnZS5oZWlnaHQodmFsdWUpXCIgZnVuY3Rpb24gaW5zdGVhZC4nXG4gICAgICApO1xuICAgIH0sXG4gICAgLy8gdGhlIGFwcGx5IHRyYW5zZm9ybSBtZXRob2QgaXMgaGFuZGxlZCBieSB0aGUgTGF5ZXIgYW5kIEZhc3RMYXllciBjbGFzc1xuICAgIC8vIGJlY2F1c2UgaXQgaXMgdXAgdG8gdGhlIGxheWVyIHRvIGRlY2lkZSBpZiBhbiBhYnNvbHV0ZSBvciByZWxhdGl2ZSB0cmFuc2Zvcm1cbiAgICAvLyBzaG91bGQgYmUgdXNlZFxuICAgIF9hcHBseVRyYW5zZm9ybTogZnVuY3Rpb24oc2hhcGUsIGNvbnRleHQsIHRvcCkge1xuICAgICAgdmFyIG0gPSBzaGFwZS5nZXRBYnNvbHV0ZVRyYW5zZm9ybSh0b3ApLmdldE1hdHJpeCgpO1xuICAgICAgY29udGV4dC50cmFuc2Zvcm0obVswXSwgbVsxXSwgbVsyXSwgbVszXSwgbVs0XSwgbVs1XSk7XG4gICAgfVxuICB9KTtcbiAgS29udmEuVXRpbC5leHRlbmQoS29udmEuQmFzZUxheWVyLCBLb252YS5Db250YWluZXIpO1xuXG4gIC8vIGFkZCBnZXR0ZXJzIGFuZCBzZXR0ZXJzXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkJhc2VMYXllciwgJ2NsZWFyQmVmb3JlRHJhdycsIHRydWUpO1xuICAvKipcbiAgICogZ2V0L3NldCBjbGVhckJlZm9yZURyYXcgZmxhZyB3aGljaCBkZXRlcm1pbmVzIGlmIHRoZSBsYXllciBpcyBjbGVhcmVkIG9yIG5vdFxuICAgKiAgYmVmb3JlIGRyYXdpbmdcbiAgICogQG5hbWUgY2xlYXJCZWZvcmVEcmF3XG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLkJhc2VMYXllci5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBjbGVhckJlZm9yZURyYXdcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBjbGVhckJlZm9yZURyYXcgZmxhZ1xuICAgKiB2YXIgY2xlYXJCZWZvcmVEcmF3ID0gbGF5ZXIuY2xlYXJCZWZvcmVEcmF3KCk7XG4gICAqXG4gICAqIC8vIGRpc2FibGUgY2xlYXIgYmVmb3JlIGRyYXdcbiAgICogbGF5ZXIuY2xlYXJCZWZvcmVEcmF3KGZhbHNlKTtcbiAgICpcbiAgICogLy8gZW5hYmxlIGNsZWFyIGJlZm9yZSBkcmF3XG4gICAqIGxheWVyLmNsZWFyQmVmb3JlRHJhdyh0cnVlKTtcbiAgICovXG5cbiAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLkJhc2VMYXllcik7XG59KShLb252YSk7XG5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvLyBjb25zdGFudHNcbiAgdmFyIEhBU0ggPSAnIycsXG4gICAgQkVGT1JFX0RSQVcgPSAnYmVmb3JlRHJhdycsXG4gICAgRFJBVyA9ICdkcmF3JyxcbiAgICAvKlxuICAgICAgICAgKiAyIC0gMyAtIDRcbiAgICAgICAgICogfCAgICAgICB8XG4gICAgICAgICAqIDEgLSAwICAgNVxuICAgICAgICAgKiAgICAgICAgIHxcbiAgICAgICAgICogOCAtIDcgLSA2XG4gICAgICAgICAqL1xuICAgIElOVEVSU0VDVElPTl9PRkZTRVRTID0gW1xuICAgICAgeyB4OiAwLCB5OiAwIH0sIC8vIDBcbiAgICAgIHsgeDogLTEsIHk6IDAgfSwgLy8gMVxuICAgICAgeyB4OiAtMSwgeTogLTEgfSwgLy8gMlxuICAgICAgeyB4OiAwLCB5OiAtMSB9LCAvLyAzXG4gICAgICB7IHg6IDEsIHk6IC0xIH0sIC8vIDRcbiAgICAgIHsgeDogMSwgeTogMCB9LCAvLyA1XG4gICAgICB7IHg6IDEsIHk6IDEgfSwgLy8gNlxuICAgICAgeyB4OiAwLCB5OiAxIH0sIC8vIDdcbiAgICAgIHsgeDogLTEsIHk6IDEgfSAvLyA4XG4gICAgXSxcbiAgICBJTlRFUlNFQ1RJT05fT0ZGU0VUU19MRU4gPSBJTlRFUlNFQ1RJT05fT0ZGU0VUUy5sZW5ndGg7XG5cbiAgLyoqXG4gICAgICogTGF5ZXIgY29uc3RydWN0b3IuICBMYXllcnMgYXJlIHRpZWQgdG8gdGhlaXIgb3duIGNhbnZhcyBlbGVtZW50IGFuZCBhcmUgdXNlZFxuICAgICAqIHRvIGNvbnRhaW4gZ3JvdXBzIG9yIHNoYXBlcy5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKiBAYXVnbWVudHMgS29udmEuQmFzZUxheWVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5jbGVhckJlZm9yZURyYXddIHNldCB0aGlzIHByb3BlcnR5IHRvIGZhbHNlIGlmIHlvdSBkb24ndCB3YW50XG4gICAgICogdG8gY2xlYXIgdGhlIGNhbnZhcyBiZWZvcmUgZWFjaCBsYXllciBkcmF3LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuY2xpcF0gc2V0IGNsaXBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwWF0gc2V0IGNsaXAgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBZXSBzZXQgY2xpcCB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY2xpcFdpZHRoXSBzZXQgY2xpcCB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBIZWlnaHRdIHNldCBjbGlwIGhlaWdodFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuY2xpcEZ1bmNdIHNldCBjbGlwIGZ1bmNcblxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGxheWVyID0gbmV3IEtvbnZhLkxheWVyKCk7XG4gICAgICovXG4gIEtvbnZhLkxheWVyID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdGhpcy5fX19faW5pdChjb25maWcpO1xuICB9O1xuXG4gIEtvbnZhLlV0aWwuYWRkTWV0aG9kcyhLb252YS5MYXllciwge1xuICAgIF9fX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIHRoaXMubm9kZVR5cGUgPSAnTGF5ZXInO1xuICAgICAgdGhpcy5jYW52YXMgPSBuZXcgS29udmEuU2NlbmVDYW52YXMoKTtcbiAgICAgIHRoaXMuaGl0Q2FudmFzID0gbmV3IEtvbnZhLkhpdENhbnZhcyh7XG4gICAgICAgIHBpeGVsUmF0aW86IDFcbiAgICAgIH0pO1xuICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxuICAgICAgS29udmEuQmFzZUxheWVyLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICB9LFxuICAgIF9zZXRDYW52YXNTaXplOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB0aGlzLmNhbnZhcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdGhpcy5oaXRDYW52YXMuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuICAgIF92YWxpZGF0ZUFkZDogZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIHZhciB0eXBlID0gY2hpbGQuZ2V0VHlwZSgpO1xuICAgICAgaWYgKHR5cGUgIT09ICdHcm91cCcgJiYgdHlwZSAhPT0gJ1NoYXBlJykge1xuICAgICAgICBLb252YS5VdGlsLnRocm93KCdZb3UgbWF5IG9ubHkgYWRkIGdyb3VwcyBhbmQgc2hhcGVzIHRvIGEgbGF5ZXIuJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogZ2V0IHZpc2libGUgaW50ZXJzZWN0aW9uIHNoYXBlLiBUaGlzIGlzIHRoZSBwcmVmZXJyZWRcbiAgICAgICAgICogbWV0aG9kIGZvciBkZXRlcm1pbmluZyBpZiBhIHBvaW50IGludGVyc2VjdHMgYSBzaGFwZSBvciBub3RcbiAgICAgICAgICogYWxzbyB5b3UgbWF5IHBhc3Mgb3B0aW9uYWwgc2VsZWN0b3IgcGFyYW1ldHIgdG8gcmV0dXJuIGFuY2VzdG9yIG9mIGludGVyc2VjdGVkIHNoYXBlXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkxheWVyLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9zXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb3MueFxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gcG9zLnlcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFtzZWxlY3Rvcl1cbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIHZhciBzaGFwZSA9IGxheWVyLmdldEludGVyc2VjdGlvbih7eDogNTAsIHk6IDUwfSk7XG4gICAgICAgICAqIC8vIG9yIGlmIHlvdSBpbnRlcmVzdGVkIGluIHNoYXBlIHBhcmVudDpcbiAgICAgICAgICogdmFyIGdyb3VwID0gbGF5ZXIuZ2V0SW50ZXJzZWN0aW9uKHt4OiA1MCwgeTogNTB9LCAnR3JvdXAnKTtcbiAgICAgICAgICovXG4gICAgZ2V0SW50ZXJzZWN0aW9uOiBmdW5jdGlvbihwb3MsIHNlbGVjdG9yKSB7XG4gICAgICB2YXIgb2JqLCBpLCBpbnRlcnNlY3Rpb25PZmZzZXQsIHNoYXBlO1xuXG4gICAgICBpZiAoIXRoaXMuaGl0R3JhcGhFbmFibGVkKCkgfHwgIXRoaXMuaXNWaXNpYmxlKCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICAvLyBpbiBzb21lIGNhc2VzIGFudGlhbGlhc2VkIGFyZWEgbWF5IGJlIGJpZ2dlciB0aGFuIDFweFxuICAgICAgLy8gaXQgaXMgcG9zc2libGUgaWYgd2Ugd2lsbCBjYWNoZSBub2RlLCB0aGVuIHNjYWxlIGl0IGEgbG90XG4gICAgICAvLyBUT0RPOiBjaGVjayB7IDA7IDAgfSBwb2ludCBiZWZvcmUgbG9vcCwgYW5kIHJlbW92ZSBpdCBmcm9tIElOVEVSU0VDVElPTl9PRkZTRVRTLlxuICAgICAgdmFyIHNwaXJhbFNlYXJjaERpc3RhbmNlID0gMTtcbiAgICAgIHZhciBjb250aW51ZVNlYXJjaCA9IGZhbHNlO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IElOVEVSU0VDVElPTl9PRkZTRVRTX0xFTjsgaSsrKSB7XG4gICAgICAgICAgaW50ZXJzZWN0aW9uT2Zmc2V0ID0gSU5URVJTRUNUSU9OX09GRlNFVFNbaV07XG4gICAgICAgICAgb2JqID0gdGhpcy5fZ2V0SW50ZXJzZWN0aW9uKHtcbiAgICAgICAgICAgIHg6IHBvcy54ICsgaW50ZXJzZWN0aW9uT2Zmc2V0LnggKiBzcGlyYWxTZWFyY2hEaXN0YW5jZSxcbiAgICAgICAgICAgIHk6IHBvcy55ICsgaW50ZXJzZWN0aW9uT2Zmc2V0LnkgKiBzcGlyYWxTZWFyY2hEaXN0YW5jZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNoYXBlID0gb2JqLnNoYXBlO1xuICAgICAgICAgIGlmIChzaGFwZSAmJiBzZWxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIHNoYXBlLmZpbmRBbmNlc3RvcihzZWxlY3RvciwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzaGFwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNoYXBlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSBzaG91bGQgY29udGludWUgc2VhcmNoIGlmIHdlIGZvdW5kIGFudGlhbGlhc2VkIHBpeGVsXG4gICAgICAgICAgLy8gdGhhdCBtZWFucyBvdXIgbm9kZSBzb21ld2hlcmUgdmVyeSBjbG9zZVxuICAgICAgICAgIGNvbnRpbnVlU2VhcmNoID0gISFvYmouYW50aWFsaWFzZWQ7XG4gICAgICAgICAgLy8gc3RvcCBzZWFyY2ggaWYgZm91bmQgZW1wdHkgcGl4ZWxcbiAgICAgICAgICBpZiAoIW9iai5hbnRpYWxpYXNlZCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIG5vIHNoYXBlLCBhbmQgbm8gYW50aWFsaWFzZWQgcGl4ZWwsIHdlIHNob3VsZCBlbmQgc2VhcmNoaW5nXG4gICAgICAgIGlmIChjb250aW51ZVNlYXJjaCkge1xuICAgICAgICAgIHNwaXJhbFNlYXJjaERpc3RhbmNlICs9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIF9nZXRJbWFnZURhdGE6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMuaGl0Q2FudmFzLndpZHRoIHx8IDEsXG4gICAgICAgIGhlaWdodCA9IHRoaXMuaGl0Q2FudmFzLmhlaWdodCB8fCAxLFxuICAgICAgICBpbmRleCA9IE1hdGgucm91bmQoeSkgKiB3aWR0aCArIE1hdGgucm91bmQoeCk7XG5cbiAgICAgIGlmICghdGhpcy5faGl0SW1hZ2VEYXRhKSB7XG4gICAgICAgIHRoaXMuX2hpdEltYWdlRGF0YSA9IHRoaXMuaGl0Q2FudmFzLmNvbnRleHQuZ2V0SW1hZ2VEYXRhKFxuICAgICAgICAgIDAsXG4gICAgICAgICAgMCxcbiAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICBoZWlnaHRcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgdGhpcy5faGl0SW1hZ2VEYXRhLmRhdGFbNCAqIGluZGV4ICsgMF0sIC8vIFJlZFxuICAgICAgICB0aGlzLl9oaXRJbWFnZURhdGEuZGF0YVs0ICogaW5kZXggKyAxXSwgLy8gR3JlZW5cbiAgICAgICAgdGhpcy5faGl0SW1hZ2VEYXRhLmRhdGFbNCAqIGluZGV4ICsgMl0sIC8vIEJsdWVcbiAgICAgICAgdGhpcy5faGl0SW1hZ2VEYXRhLmRhdGFbNCAqIGluZGV4ICsgM10gLy8gQWxwaGFcbiAgICAgIF07XG4gICAgfSxcbiAgICBfZ2V0SW50ZXJzZWN0aW9uOiBmdW5jdGlvbihwb3MpIHtcbiAgICAgIHZhciByYXRpbyA9IHRoaXMuaGl0Q2FudmFzLnBpeGVsUmF0aW87XG4gICAgICB2YXIgcCA9IHRoaXMuaGl0Q2FudmFzLmNvbnRleHQuZ2V0SW1hZ2VEYXRhKFxuICAgICAgICBNYXRoLnJvdW5kKHBvcy54ICogcmF0aW8pLFxuICAgICAgICBNYXRoLnJvdW5kKHBvcy55ICogcmF0aW8pLFxuICAgICAgICAxLFxuICAgICAgICAxXG4gICAgICApLmRhdGEsXG4gICAgICAgIHAzID0gcFszXSxcbiAgICAgICAgY29sb3JLZXksXG4gICAgICAgIHNoYXBlO1xuICAgICAgLy8gZnVsbHkgb3BhcXVlIHBpeGVsXG4gICAgICBpZiAocDMgPT09IDI1NSkge1xuICAgICAgICBjb2xvcktleSA9IEtvbnZhLlV0aWwuX3JnYlRvSGV4KHBbMF0sIHBbMV0sIHBbMl0pO1xuICAgICAgICBzaGFwZSA9IEtvbnZhLnNoYXBlc1tIQVNIICsgY29sb3JLZXldO1xuICAgICAgICBpZiAoc2hhcGUpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2hhcGU6IHNoYXBlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFudGlhbGlhc2VkOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHAzID4gMCkge1xuICAgICAgICAvLyBhbnRpYWxpYXNlZCBwaXhlbFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFudGlhbGlhc2VkOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICAvLyBlbXB0eSBwaXhlbFxuICAgICAgcmV0dXJuIHt9O1xuICAgIH0sXG4gICAgZHJhd1NjZW5lOiBmdW5jdGlvbihjYW4sIHRvcCkge1xuICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpLCBjYW52YXMgPSBjYW4gfHwgKGxheWVyICYmIGxheWVyLmdldENhbnZhcygpKTtcblxuICAgICAgdGhpcy5fZmlyZShCRUZPUkVfRFJBVywge1xuICAgICAgICBub2RlOiB0aGlzXG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuZ2V0Q2xlYXJCZWZvcmVEcmF3KCkpIHtcbiAgICAgICAgY2FudmFzLmdldENvbnRleHQoKS5jbGVhcigpO1xuICAgICAgfVxuXG4gICAgICBLb252YS5Db250YWluZXIucHJvdG90eXBlLmRyYXdTY2VuZS5jYWxsKHRoaXMsIGNhbnZhcywgdG9wKTtcblxuICAgICAgdGhpcy5fZmlyZShEUkFXLCB7XG4gICAgICAgIG5vZGU6IHRoaXNcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGRyYXdIaXQ6IGZ1bmN0aW9uKGNhbiwgdG9wKSB7XG4gICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKCksIGNhbnZhcyA9IGNhbiB8fCAobGF5ZXIgJiYgbGF5ZXIuaGl0Q2FudmFzKTtcblxuICAgICAgaWYgKGxheWVyICYmIGxheWVyLmdldENsZWFyQmVmb3JlRHJhdygpKSB7XG4gICAgICAgIGxheWVyLmdldEhpdENhbnZhcygpLmdldENvbnRleHQoKS5jbGVhcigpO1xuICAgICAgfVxuXG4gICAgICBLb252YS5Db250YWluZXIucHJvdG90eXBlLmRyYXdIaXQuY2FsbCh0aGlzLCBjYW52YXMsIHRvcCk7XG4gICAgICB0aGlzLmltYWdlRGF0YSA9IG51bGw7IC8vIENsZWFyIGltYWdlRGF0YSBjYWNoZVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBjbGVhcjogZnVuY3Rpb24oYm91bmRzKSB7XG4gICAgICBLb252YS5CYXNlTGF5ZXIucHJvdG90eXBlLmNsZWFyLmNhbGwodGhpcywgYm91bmRzKTtcbiAgICAgIHRoaXMuZ2V0SGl0Q2FudmFzKCkuZ2V0Q29udGV4dCgpLmNsZWFyKGJvdW5kcyk7XG4gICAgICB0aGlzLmltYWdlRGF0YSA9IG51bGw7IC8vIENsZWFyIGdldEltYWdlRGF0YSBjYWNoZVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBleHRlbmQgTm9kZS5wcm90b3R5cGUuc2V0VmlzaWJsZVxuICAgIHNldFZpc2libGU6IGZ1bmN0aW9uKHZpc2libGUpIHtcbiAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldFZpc2libGUuY2FsbCh0aGlzLCB2aXNpYmxlKTtcbiAgICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICAgIHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgdGhpcy5oaXRDYW52YXMuX2NhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLmhpdENhbnZhcy5fY2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiBlbmFibGUgaGl0IGdyYXBoXG4gICAgICAgICAqIEBuYW1lIGVuYWJsZUhpdEdyYXBoXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkxheWVyLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7TGF5ZXJ9XG4gICAgICAgICAqL1xuICAgIGVuYWJsZUhpdEdyYXBoOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2V0SGl0R3JhcGhFbmFibGVkKHRydWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogZGlzYWJsZSBoaXQgZ3JhcGhcbiAgICAgICAgICogQG5hbWUgZGlzYWJsZUhpdEdyYXBoXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkxheWVyLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7TGF5ZXJ9XG4gICAgICAgICAqL1xuICAgIGRpc2FibGVIaXRHcmFwaDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnNldEhpdEdyYXBoRW5hYmxlZChmYWxzZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHNldFNpemU6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIEtvbnZhLkJhc2VMYXllci5wcm90b3R5cGUuc2V0U2l6ZS5jYWxsKHRoaXMsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdGhpcy5oaXRDYW52YXMuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG4gIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLkxheWVyLCBLb252YS5CYXNlTGF5ZXIpO1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkxheWVyLCAnaGl0R3JhcGhFbmFibGVkJywgdHJ1ZSk7XG4gIC8qKlxuICAgICAqIGdldC9zZXQgaGl0R3JhcGhFbmFibGVkIGZsYWcuICBEaXNhYmxpbmcgdGhlIGhpdCBncmFwaCB3aWxsIGdyZWF0bHkgaW5jcmVhc2VcbiAgICAgKiAgZHJhdyBwZXJmb3JtYW5jZSBiZWNhdXNlIHRoZSBoaXQgZ3JhcGggd2lsbCBub3QgYmUgcmVkcmF3biBlYWNoIHRpbWUgdGhlIGxheWVyIGlzXG4gICAgICogIGRyYXduLiAgVGhpcywgaG93ZXZlciwgYWxzbyBkaXNhYmxlcyBtb3VzZS90b3VjaCBldmVudCBkZXRlY3Rpb25cbiAgICAgKiBAbmFtZSBoaXRHcmFwaEVuYWJsZWRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkxheWVyLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5hYmxlZFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGhpdEdyYXBoRW5hYmxlZCBmbGFnXG4gICAgICogdmFyIGhpdEdyYXBoRW5hYmxlZCA9IGxheWVyLmhpdEdyYXBoRW5hYmxlZCgpO1xuICAgICAqXG4gICAgICogLy8gZGlzYWJsZSBoaXQgZ3JhcGhcbiAgICAgKiBsYXllci5oaXRHcmFwaEVuYWJsZWQoZmFsc2UpO1xuICAgICAqXG4gICAgICogLy8gZW5hYmxlIGhpdCBncmFwaFxuICAgICAqIGxheWVyLmhpdEdyYXBoRW5hYmxlZCh0cnVlKTtcbiAgICAgKi9cbiAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLkxheWVyKTtcbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvKipcbiAgICAgKiBGYXN0TGF5ZXIgY29uc3RydWN0b3IuIExheWVycyBhcmUgdGllZCB0byB0aGVpciBvd24gY2FudmFzIGVsZW1lbnQgYW5kIGFyZSB1c2VkXG4gICAgICogdG8gY29udGFpbiBzaGFwZXMgb25seS4gIElmIHlvdSBkb24ndCBuZWVkIG5vZGUgbmVzdGluZywgbW91c2UgYW5kIHRvdWNoIGludGVyYWN0aW9ucyxcbiAgICAgKiBvciBldmVudCBwdWIvc3ViLCB5b3Ugc2hvdWxkIHVzZSBGYXN0TGF5ZXIgaW5zdGVhZCBvZiBMYXllciB0byBjcmVhdGUgeW91ciBsYXllcnMuXG4gICAgICogSXQgcmVuZGVycyBhYm91dCAyeCBmYXN0ZXIgdGhhbiBub3JtYWwgbGF5ZXJzLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBhdWdtZW50cyBLb252YS5CYXNlTGF5ZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmNsZWFyQmVmb3JlRHJhd10gc2V0IHRoaXMgcHJvcGVydHkgdG8gZmFsc2UgaWYgeW91IGRvbid0IHdhbnRcbiAgICAgKiB0byBjbGVhciB0aGUgY2FudmFzIGJlZm9yZSBlYWNoIGxheWVyIGRyYXcuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuY2xpcF0gc2V0IGNsaXBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwWF0gc2V0IGNsaXAgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBZXSBzZXQgY2xpcCB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY2xpcFdpZHRoXSBzZXQgY2xpcCB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBIZWlnaHRdIHNldCBjbGlwIGhlaWdodFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuY2xpcEZ1bmNdIHNldCBjbGlwIGZ1bmNcblxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGxheWVyID0gbmV3IEtvbnZhLkZhc3RMYXllcigpO1xuICAgICAqL1xuICBLb252YS5GYXN0TGF5ZXIgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICB0aGlzLl9fX19pbml0KGNvbmZpZyk7XG4gIH07XG5cbiAgS29udmEuVXRpbC5hZGRNZXRob2RzKEtvbnZhLkZhc3RMYXllciwge1xuICAgIF9fX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIHRoaXMubm9kZVR5cGUgPSAnTGF5ZXInO1xuICAgICAgdGhpcy5jYW52YXMgPSBuZXcgS29udmEuU2NlbmVDYW52YXMoKTtcbiAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgIEtvbnZhLkJhc2VMYXllci5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgfSxcbiAgICBfdmFsaWRhdGVBZGQ6IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICB2YXIgdHlwZSA9IGNoaWxkLmdldFR5cGUoKTtcbiAgICAgIGlmICh0eXBlICE9PSAnU2hhcGUnKSB7XG4gICAgICAgIEtvbnZhLlV0aWwudGhyb3coJ1lvdSBtYXkgb25seSBhZGQgc2hhcGVzIHRvIGEgZmFzdCBsYXllci4nKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9zZXRDYW52YXNTaXplOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB0aGlzLmNhbnZhcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG4gICAgaGl0R3JhcGhFbmFibGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGdldEludGVyc2VjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGRyYXdTY2VuZTogZnVuY3Rpb24oY2FuKSB7XG4gICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKCksIGNhbnZhcyA9IGNhbiB8fCAobGF5ZXIgJiYgbGF5ZXIuZ2V0Q2FudmFzKCkpO1xuXG4gICAgICBpZiAodGhpcy5nZXRDbGVhckJlZm9yZURyYXcoKSkge1xuICAgICAgICBjYW52YXMuZ2V0Q29udGV4dCgpLmNsZWFyKCk7XG4gICAgICB9XG5cbiAgICAgIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGUuZHJhd1NjZW5lLmNhbGwodGhpcywgY2FudmFzKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZHJhd1NjZW5lKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIGV4dGVuZCBOb2RlLnByb3RvdHlwZS5zZXRWaXNpYmxlXG4gICAgc2V0VmlzaWJsZTogZnVuY3Rpb24odmlzaWJsZSkge1xuICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0VmlzaWJsZS5jYWxsKHRoaXMsIHZpc2libGUpO1xuICAgICAgaWYgKHZpc2libGUpIHtcbiAgICAgICAgdGhpcy5nZXRDYW52YXMoKS5fY2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5nZXRDYW52YXMoKS5fY2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0pO1xuICBLb252YS5VdGlsLmV4dGVuZChLb252YS5GYXN0TGF5ZXIsIEtvbnZhLkJhc2VMYXllcik7XG5cbiAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLkZhc3RMYXllcik7XG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLyoqXG4gICAgICogR3JvdXAgY29uc3RydWN0b3IuICBHcm91cHMgYXJlIHVzZWQgdG8gY29udGFpbiBzaGFwZXMgb3Igb3RoZXIgZ3JvdXBzLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBhdWdtZW50cyBLb252YS5Db250YWluZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICAgKiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmNsaXBdIHNldCBjbGlwXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY2xpcFhdIHNldCBjbGlwIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwWV0gc2V0IGNsaXAgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBXaWR0aF0gc2V0IGNsaXAgd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwSGVpZ2h0XSBzZXQgY2xpcCBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmNsaXBGdW5jXSBzZXQgY2xpcCBmdW5jXG5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBncm91cCA9IG5ldyBLb252YS5Hcm91cCgpO1xuICAgICAqL1xuICBLb252YS5Hcm91cCA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHRoaXMuX19faW5pdChjb25maWcpO1xuICB9O1xuXG4gIEtvbnZhLlV0aWwuYWRkTWV0aG9kcyhLb252YS5Hcm91cCwge1xuICAgIF9fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgdGhpcy5ub2RlVHlwZSA9ICdHcm91cCc7XG4gICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXG4gICAgICBLb252YS5Db250YWluZXIuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgIH0sXG4gICAgX3ZhbGlkYXRlQWRkOiBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgdmFyIHR5cGUgPSBjaGlsZC5nZXRUeXBlKCk7XG4gICAgICBpZiAodHlwZSAhPT0gJ0dyb3VwJyAmJiB0eXBlICE9PSAnU2hhcGUnKSB7XG4gICAgICAgIEtvbnZhLlV0aWwudGhyb3coJ1lvdSBtYXkgb25seSBhZGQgZ3JvdXBzIGFuZCBzaGFwZXMgdG8gZ3JvdXBzLicpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLkdyb3VwLCBLb252YS5Db250YWluZXIpO1xuXG4gIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5Hcm91cCk7XG59KSgpO1xuXG4oZnVuY3Rpb24oS29udmEpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICB2YXIgbm93ID0gKGZ1bmN0aW9uKCkge1xuICAgIGlmIChLb252YS5nbG9iYWwucGVyZm9ybWFuY2UgJiYgS29udmEuZ2xvYmFsLnBlcmZvcm1hbmNlLm5vdykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gS29udmEuZ2xvYmFsLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgfTtcbiAgfSkoKTtcblxuICBmdW5jdGlvbiBGUkFGKGNhbGxiYWNrKSB7XG4gICAgc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcbiAgfVxuXG4gIHZhciBSQUYgPSAoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIEtvbnZhLmdsb2JhbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgIEtvbnZhLmdsb2JhbC53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgIEtvbnZhLmdsb2JhbC5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgIEtvbnZhLmdsb2JhbC5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICBLb252YS5nbG9iYWwubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgIEZSQUZcbiAgICApO1xuICB9KSgpO1xuXG4gIGZ1bmN0aW9uIHJlcXVlc3RBbmltRnJhbWUoKSB7XG4gICAgcmV0dXJuIFJBRi5hcHBseShLb252YS5nbG9iYWwsIGFyZ3VtZW50cyk7XG4gIH1cblxuICAvKipcbiAgICAgKiBBbmltYXRpb24gY29uc3RydWN0b3IuICBBIHN0YWdlIGlzIHVzZWQgdG8gY29udGFpbiBtdWx0aXBsZSBsYXllcnMgYW5kIGhhbmRsZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgZnVuY3Rpb24gZXhlY3V0ZWQgb24gZWFjaCBhbmltYXRpb24gZnJhbWUuICBUaGUgZnVuY3Rpb24gaXMgcGFzc2VkIGEgZnJhbWUgb2JqZWN0LCB3aGljaCBjb250YWluc1xuICAgICAqICB0aW1lRGlmZiwgbGFzdFRpbWUsIHRpbWUsIGFuZCBmcmFtZVJhdGUgcHJvcGVydGllcy4gIFRoZSB0aW1lRGlmZiBwcm9wZXJ0eSBpcyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgcGFzc2VkXG4gICAgICogIHNpbmNlIHRoZSBsYXN0IGFuaW1hdGlvbiBmcmFtZS4gIFRoZSBsYXN0VGltZSBwcm9wZXJ0eSBpcyB0aW1lIGluIG1pbGxpc2Vjb25kcyB0aGF0IGVsYXBzZWQgZnJvbSB0aGUgbW9tZW50IHRoZSBhbmltYXRpb24gc3RhcnRlZFxuICAgICAqICB0byB0aGUgbGFzdCBhbmltYXRpb24gZnJhbWUuICBUaGUgdGltZSBwcm9wZXJ0eSBpcyB0aGUgdGltZSBpbiBtaWxsaXNlY29uZHMgdGhhdCBlbGxhcHNlZCBmcm9tIHRoZSBtb21lbnQgdGhlIGFuaW1hdGlvbiBzdGFydGVkXG4gICAgICogIHRvIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBmcmFtZS4gIFRoZSBmcmFtZVJhdGUgcHJvcGVydHkgaXMgdGhlIGN1cnJlbnQgZnJhbWUgcmF0ZSBpbiBmcmFtZXMgLyBzZWNvbmQuIFJldHVybiBmYWxzZSBmcm9tIGZ1bmN0aW9uLFxuICAgICAqICBpZiB5b3UgZG9uJ3QgbmVlZCB0byByZWRyYXcgbGF5ZXIvbGF5ZXJzIG9uIHNvbWUgZnJhbWVzLlxuICAgICAqIEBwYXJhbSB7S29udmEuTGF5ZXJ8QXJyYXl9IFtsYXllcnNdIGxheWVyKHMpIHRvIGJlIHJlZHJhd24gb24gZWFjaCBhbmltYXRpb24gZnJhbWUuIENhbiBiZSBhIGxheWVyLCBhbiBhcnJheSBvZiBsYXllcnMsIG9yIG51bGwuXG4gICAgICogIE5vdCBzcGVjaWZ5aW5nIGEgbm9kZSB3aWxsIHJlc3VsdCBpbiBubyByZWRyYXcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBtb3ZlIGEgbm9kZSB0byB0aGUgcmlnaHQgYXQgNTAgcGl4ZWxzIC8gc2Vjb25kXG4gICAgICogdmFyIHZlbG9jaXR5ID0gNTA7XG4gICAgICpcbiAgICAgKiB2YXIgYW5pbSA9IG5ldyBLb252YS5BbmltYXRpb24oZnVuY3Rpb24oZnJhbWUpIHtcbiAgICAgKiAgIHZhciBkaXN0ID0gdmVsb2NpdHkgKiAoZnJhbWUudGltZURpZmYgLyAxMDAwKTtcbiAgICAgKiAgIG5vZGUubW92ZShkaXN0LCAwKTtcbiAgICAgKiB9LCBsYXllcik7XG4gICAgICpcbiAgICAgKiBhbmltLnN0YXJ0KCk7XG4gICAgICovXG4gIEtvbnZhLkFuaW1hdGlvbiA9IGZ1bmN0aW9uKGZ1bmMsIGxheWVycykge1xuICAgIHZhciBBbmltID0gS29udmEuQW5pbWF0aW9uO1xuICAgIHRoaXMuZnVuYyA9IGZ1bmM7XG4gICAgdGhpcy5zZXRMYXllcnMobGF5ZXJzKTtcbiAgICB0aGlzLmlkID0gQW5pbS5hbmltSWRDb3VudGVyKys7XG4gICAgdGhpcy5mcmFtZSA9IHtcbiAgICAgIHRpbWU6IDAsXG4gICAgICB0aW1lRGlmZjogMCxcbiAgICAgIGxhc3RUaW1lOiBub3coKVxuICAgIH07XG4gIH07XG4gIC8qXG4gICAgICogQW5pbWF0aW9uIG1ldGhvZHNcbiAgICAgKi9cbiAgS29udmEuQW5pbWF0aW9uLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgICAgICogc2V0IGxheWVycyB0byBiZSByZWRyYXduIG9uIGVhY2ggYW5pbWF0aW9uIGZyYW1lXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkFuaW1hdGlvbi5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtLb252YS5MYXllcnxBcnJheX0gW2xheWVyc10gbGF5ZXIocykgdG8gYmUgcmVkcmF3bi4mbmJzcDsgQ2FuIGJlIGEgbGF5ZXIsIGFuIGFycmF5IG9mIGxheWVycywgb3IgbnVsbC4gIE5vdCBzcGVjaWZ5aW5nIGEgbm9kZSB3aWxsIHJlc3VsdCBpbiBubyByZWRyYXcuXG4gICAgICAgICAqIEByZXR1cm4ge0tvbnZhLkFuaW1hdGlvbn0gdGhpc1xuICAgICAgICAgKi9cbiAgICBzZXRMYXllcnM6IGZ1bmN0aW9uKGxheWVycykge1xuICAgICAgdmFyIGxheXMgPSBbXTtcbiAgICAgIC8vIGlmIHBhc3NpbmcgaW4gbm8gbGF5ZXJzXG4gICAgICBpZiAoIWxheWVycykge1xuICAgICAgICBsYXlzID0gW107XG4gICAgICB9IGVsc2UgaWYgKGxheWVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIGlmIHBhc3NpbmcgaW4gYW4gYXJyYXkgb2YgTGF5ZXJzXG4gICAgICAgIC8vIE5PVEU6IGxheWVycyBjb3VsZCBiZSBhbiBhcnJheSBvciBLb252YS5Db2xsZWN0aW9uLiAgZm9yIHNpbXBsaWNpdHksIEknbSBqdXN0IGluc3BlY3RpbmdcbiAgICAgICAgLy8gdGhlIGxlbmd0aCBwcm9wZXJ0eSB0byBjaGVjayBmb3IgYm90aCBjYXNlc1xuICAgICAgICBsYXlzID0gbGF5ZXJzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgcGFzc2luZyBpbiBhIExheWVyXG4gICAgICAgIGxheXMgPSBbbGF5ZXJzXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sYXllcnMgPSBsYXlzO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogZ2V0IGxheWVyc1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5BbmltYXRpb24ucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiBLb252YS5MYXllclxuICAgICAgICAgKi9cbiAgICBnZXRMYXllcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubGF5ZXJzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIGFkZCBsYXllci4gIFJldHVybnMgdHJ1ZSBpZiB0aGUgbGF5ZXIgd2FzIGFkZGVkLCBhbmQgZmFsc2UgaWYgaXQgd2FzIG5vdFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5BbmltYXRpb24ucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7S29udmEuTGF5ZXJ9IGxheWVyIHRvIGFkZFxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sfSB0cnVlIGlmIGxheWVyIGlzIGFkZGVkIHRvIGFuaW1hdGlvbiwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICAgICAqL1xuICAgIGFkZExheWVyOiBmdW5jdGlvbihsYXllcikge1xuICAgICAgdmFyIGxheWVycyA9IHRoaXMubGF5ZXJzLCBsZW4gPSBsYXllcnMubGVuZ3RoLCBuO1xuXG4gICAgICAvLyBkb24ndCBhZGQgdGhlIGxheWVyIGlmIGl0IGFscmVhZHkgZXhpc3RzXG4gICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgaWYgKGxheWVyc1tuXS5faWQgPT09IGxheWVyLl9pZCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmxheWVycy5wdXNoKGxheWVyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIGRldGVybWluZSBpZiBhbmltYXRpb24gaXMgcnVubmluZyBvciBub3QuICByZXR1cm5zIHRydWUgb3IgZmFsc2VcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQW5pbWF0aW9uLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sfSBpcyBhbmltYXRpb24gcnVubmluZz9cbiAgICAgICAgICovXG4gICAgaXNSdW5uaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhID0gS29udmEuQW5pbWF0aW9uLFxuICAgICAgICBhbmltYXRpb25zID0gYS5hbmltYXRpb25zLFxuICAgICAgICBsZW4gPSBhbmltYXRpb25zLmxlbmd0aCxcbiAgICAgICAgbjtcblxuICAgICAgZm9yIChuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgIGlmIChhbmltYXRpb25zW25dLmlkID09PSB0aGlzLmlkKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiBzdGFydCBhbmltYXRpb25cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQW5pbWF0aW9uLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJuIHtLb252YS5BbmltYXRpb259IHRoaXNcbiAgICAgICAgICovXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIEFuaW0gPSBLb252YS5BbmltYXRpb247XG4gICAgICB0aGlzLnN0b3AoKTtcbiAgICAgIHRoaXMuZnJhbWUudGltZURpZmYgPSAwO1xuICAgICAgdGhpcy5mcmFtZS5sYXN0VGltZSA9IG5vdygpO1xuICAgICAgQW5pbS5fYWRkQW5pbWF0aW9uKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogc3RvcCBhbmltYXRpb25cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQW5pbWF0aW9uLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJuIHtLb252YS5BbmltYXRpb259IHRoaXNcbiAgICAgICAgICovXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICBLb252YS5BbmltYXRpb24uX3JlbW92ZUFuaW1hdGlvbih0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgX3VwZGF0ZUZyYW1lT2JqZWN0OiBmdW5jdGlvbih0aW1lKSB7XG4gICAgICB0aGlzLmZyYW1lLnRpbWVEaWZmID0gdGltZSAtIHRoaXMuZnJhbWUubGFzdFRpbWU7XG4gICAgICB0aGlzLmZyYW1lLmxhc3RUaW1lID0gdGltZTtcbiAgICAgIHRoaXMuZnJhbWUudGltZSArPSB0aGlzLmZyYW1lLnRpbWVEaWZmO1xuICAgICAgdGhpcy5mcmFtZS5mcmFtZVJhdGUgPSAxMDAwIC8gdGhpcy5mcmFtZS50aW1lRGlmZjtcbiAgICB9XG4gIH07XG4gIEtvbnZhLkFuaW1hdGlvbi5hbmltYXRpb25zID0gW107XG4gIEtvbnZhLkFuaW1hdGlvbi5hbmltSWRDb3VudGVyID0gMDtcbiAgS29udmEuQW5pbWF0aW9uLmFuaW1SdW5uaW5nID0gZmFsc2U7XG5cbiAgS29udmEuQW5pbWF0aW9uLl9hZGRBbmltYXRpb24gPSBmdW5jdGlvbihhbmltKSB7XG4gICAgdGhpcy5hbmltYXRpb25zLnB1c2goYW5pbSk7XG4gICAgdGhpcy5faGFuZGxlQW5pbWF0aW9uKCk7XG4gIH07XG4gIEtvbnZhLkFuaW1hdGlvbi5fcmVtb3ZlQW5pbWF0aW9uID0gZnVuY3Rpb24oYW5pbSkge1xuICAgIHZhciBpZCA9IGFuaW0uaWQsIGFuaW1hdGlvbnMgPSB0aGlzLmFuaW1hdGlvbnMsIGxlbiA9IGFuaW1hdGlvbnMubGVuZ3RoLCBuO1xuXG4gICAgZm9yIChuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICBpZiAoYW5pbWF0aW9uc1tuXS5pZCA9PT0gaWQpIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb25zLnNwbGljZShuLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEtvbnZhLkFuaW1hdGlvbi5fcnVuRnJhbWVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxheWVySGFzaCA9IHt9LFxuICAgICAgYW5pbWF0aW9ucyA9IHRoaXMuYW5pbWF0aW9ucyxcbiAgICAgIGFuaW0sXG4gICAgICBsYXllcnMsXG4gICAgICBmdW5jLFxuICAgICAgbixcbiAgICAgIGksXG4gICAgICBsYXllcnNMZW4sXG4gICAgICBsYXllcixcbiAgICAgIGtleSxcbiAgICAgIG5lZWRSZWRyYXc7XG4gICAgLypcbiAgICAgICAgICogbG9vcCB0aHJvdWdoIGFsbCBhbmltYXRpb25zIGFuZCBleGVjdXRlIGFuaW1hdGlvblxuICAgICAgICAgKiAgZnVuY3Rpb24uICBpZiB0aGUgYW5pbWF0aW9uIG9iamVjdCBoYXMgc3BlY2lmaWVkIG5vZGUsXG4gICAgICAgICAqICB3ZSBjYW4gYWRkIHRoZSBub2RlIHRvIHRoZSBub2RlcyBoYXNoIHRvIGVsaW1pbmF0ZVxuICAgICAgICAgKiAgZHJhd2luZyB0aGUgc2FtZSBub2RlIG11bHRpcGxlIHRpbWVzLiAgVGhlIG5vZGUgcHJvcGVydHlcbiAgICAgICAgICogIGNhbiBiZSB0aGUgc3RhZ2UgaXRzZWxmIG9yIGEgbGF5ZXJcbiAgICAgICAgICovXG4gICAgLypcbiAgICAgICAgICogV0FSTklORzogZG9uJ3QgY2FjaGUgYW5pbWF0aW9ucy5sZW5ndGggYmVjYXVzZSBpdCBjb3VsZCBjaGFuZ2Ugd2hpbGVcbiAgICAgICAgICogdGhlIGZvciBsb29wIGlzIHJ1bm5pbmcsIGNhdXNpbmcgYSBKUyBlcnJvclxuICAgICAgICAgKi9cblxuICAgIGZvciAobiA9IDA7IG4gPCBhbmltYXRpb25zLmxlbmd0aDsgbisrKSB7XG4gICAgICBhbmltID0gYW5pbWF0aW9uc1tuXTtcbiAgICAgIGxheWVycyA9IGFuaW0ubGF5ZXJzO1xuICAgICAgZnVuYyA9IGFuaW0uZnVuYztcblxuICAgICAgYW5pbS5fdXBkYXRlRnJhbWVPYmplY3Qobm93KCkpO1xuICAgICAgbGF5ZXJzTGVuID0gbGF5ZXJzLmxlbmd0aDtcblxuICAgICAgLy8gaWYgYW5pbWF0aW9uIG9iamVjdCBoYXMgYSBmdW5jdGlvbiwgZXhlY3V0ZSBpdFxuICAgICAgaWYgKGZ1bmMpIHtcbiAgICAgICAgLy8gYWxsb3cgYW5pbSBieXBhc3NpbmcgZHJhd2luZ1xuICAgICAgICBuZWVkUmVkcmF3ID0gZnVuYy5jYWxsKGFuaW0sIGFuaW0uZnJhbWUpICE9PSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5lZWRSZWRyYXcgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFuZWVkUmVkcmF3KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGxheWVyc0xlbjsgaSsrKSB7XG4gICAgICAgIGxheWVyID0gbGF5ZXJzW2ldO1xuXG4gICAgICAgIGlmIChsYXllci5faWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGxheWVySGFzaFtsYXllci5faWRdID0gbGF5ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGtleSBpbiBsYXllckhhc2gpIHtcbiAgICAgIGlmICghbGF5ZXJIYXNoLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsYXllckhhc2hba2V5XS5kcmF3KCk7XG4gICAgfVxuICB9O1xuICBLb252YS5BbmltYXRpb24uX2FuaW1hdGlvbkxvb3AgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgQW5pbSA9IEtvbnZhLkFuaW1hdGlvbjtcbiAgICBpZiAoQW5pbS5hbmltYXRpb25zLmxlbmd0aCkge1xuICAgICAgQW5pbS5fcnVuRnJhbWVzKCk7XG4gICAgICByZXF1ZXN0QW5pbUZyYW1lKEFuaW0uX2FuaW1hdGlvbkxvb3ApO1xuICAgIH0gZWxzZSB7XG4gICAgICBBbmltLmFuaW1SdW5uaW5nID0gZmFsc2U7XG4gICAgfVxuICB9O1xuICBLb252YS5BbmltYXRpb24uX2hhbmRsZUFuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5hbmltUnVubmluZykge1xuICAgICAgdGhpcy5hbmltUnVubmluZyA9IHRydWU7XG4gICAgICByZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX2FuaW1hdGlvbkxvb3ApO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICAgKiBiYXRjaCBkcmF3LiB0aGlzIGZ1bmN0aW9uIHdpbGwgbm90IGRvIGltbWVkaWF0ZSBkcmF3XG4gICAgICogYnV0IGl0IHdpbGwgc2NoZWR1bGUgZHJhd2luZyB0byBuZXh0IHRpY2sgKHJlcXVlc3RBbmltRnJhbWUpXG4gICAgICogQG1ldGhvZFxuICAgICAqIEByZXR1cm4ge0tvbnZhLkxheWVyfSB0aGlzXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkJhc2UucHJvdG90eXBlXG4gICAgICovXG4gIEtvbnZhLkJhc2VMYXllci5wcm90b3R5cGUuYmF0Y2hEcmF3ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzLCBBbmltID0gS29udmEuQW5pbWF0aW9uO1xuXG4gICAgaWYgKCF0aGlzLmJhdGNoQW5pbSkge1xuICAgICAgdGhpcy5iYXRjaEFuaW0gPSBuZXcgQW5pbShmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gc3RvcCBhbmltYXRpb24gYWZ0ZXIgZmlyc3QgdGlja1xuICAgICAgICB0aGF0LmJhdGNoQW5pbS5zdG9wKCk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuYmF0Y2hBbmltLmlzUnVubmluZygpKSB7XG4gICAgICB0aGlzLmJhdGNoQW5pbS5zdGFydCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICAgKiBiYXRjaCBkcmF3XG4gICAgICogQG1ldGhvZFxuICAgICAqIEByZXR1cm4ge0tvbnZhLlN0YWdlfSB0aGlzXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YWdlLnByb3RvdHlwZVxuICAgICAqL1xuICBLb252YS5TdGFnZS5wcm90b3R5cGUuYmF0Y2hEcmF3ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5nZXRDaGlsZHJlbigpLmVhY2goZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgIGxheWVyLmJhdGNoRHJhdygpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xufSkoS29udmEpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgdmFyIGJsYWNrbGlzdCA9IHtcbiAgICBub2RlOiAxLFxuICAgIGR1cmF0aW9uOiAxLFxuICAgIGVhc2luZzogMSxcbiAgICBvbkZpbmlzaDogMSxcbiAgICB5b3lvOiAxXG4gIH0sXG4gICAgUEFVU0VEID0gMSxcbiAgICBQTEFZSU5HID0gMixcbiAgICBSRVZFUlNJTkcgPSAzLFxuICAgIGlkQ291bnRlciA9IDAsXG4gICAgY29sb3JBdHRycyA9IFsnZmlsbCcsICdzdHJva2UnLCAnc2hhZG93Q29sb3InXTtcblxuICB2YXIgVHdlZW4gPSBmdW5jdGlvbihwcm9wLCBwcm9wRnVuYywgZnVuYywgYmVnaW4sIGZpbmlzaCwgZHVyYXRpb24sIHlveW8pIHtcbiAgICB0aGlzLnByb3AgPSBwcm9wO1xuICAgIHRoaXMucHJvcEZ1bmMgPSBwcm9wRnVuYztcbiAgICB0aGlzLmJlZ2luID0gYmVnaW47XG4gICAgdGhpcy5fcG9zID0gYmVnaW47XG4gICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIHRoaXMuX2NoYW5nZSA9IDA7XG4gICAgdGhpcy5wcmV2UG9zID0gMDtcbiAgICB0aGlzLnlveW8gPSB5b3lvO1xuICAgIHRoaXMuX3RpbWUgPSAwO1xuICAgIHRoaXMuX3Bvc2l0aW9uID0gMDtcbiAgICB0aGlzLl9zdGFydFRpbWUgPSAwO1xuICAgIHRoaXMuX2ZpbmlzaCA9IDA7XG4gICAgdGhpcy5mdW5jID0gZnVuYztcbiAgICB0aGlzLl9jaGFuZ2UgPSBmaW5pc2ggLSB0aGlzLmJlZ2luO1xuICAgIHRoaXMucGF1c2UoKTtcbiAgfTtcbiAgLypcbiAgICAgKiBUd2VlbiBtZXRob2RzXG4gICAgICovXG4gIFR3ZWVuLnByb3RvdHlwZSA9IHtcbiAgICBmaXJlOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHZhciBoYW5kbGVyID0gdGhpc1tzdHJdO1xuICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgaGFuZGxlcigpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0VGltZTogZnVuY3Rpb24odCkge1xuICAgICAgaWYgKHQgPiB0aGlzLmR1cmF0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLnlveW8pIHtcbiAgICAgICAgICB0aGlzLl90aW1lID0gdGhpcy5kdXJhdGlvbjtcbiAgICAgICAgICB0aGlzLnJldmVyc2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHQgPCAwKSB7XG4gICAgICAgIGlmICh0aGlzLnlveW8pIHtcbiAgICAgICAgICB0aGlzLl90aW1lID0gMDtcbiAgICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3RpbWUgPSB0O1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0VGltZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdGltZTtcbiAgICB9LFxuICAgIHNldFBvc2l0aW9uOiBmdW5jdGlvbihwKSB7XG4gICAgICB0aGlzLnByZXZQb3MgPSB0aGlzLl9wb3M7XG4gICAgICB0aGlzLnByb3BGdW5jKHApO1xuICAgICAgdGhpcy5fcG9zID0gcDtcbiAgICB9LFxuICAgIGdldFBvc2l0aW9uOiBmdW5jdGlvbih0KSB7XG4gICAgICBpZiAodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHQgPSB0aGlzLl90aW1lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZnVuYyh0LCB0aGlzLmJlZ2luLCB0aGlzLl9jaGFuZ2UsIHRoaXMuZHVyYXRpb24pO1xuICAgIH0sXG4gICAgcGxheTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnN0YXRlID0gUExBWUlORztcbiAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IHRoaXMuZ2V0VGltZXIoKSAtIHRoaXMuX3RpbWU7XG4gICAgICB0aGlzLm9uRW50ZXJGcmFtZSgpO1xuICAgICAgdGhpcy5maXJlKCdvblBsYXknKTtcbiAgICB9LFxuICAgIHJldmVyc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFJFVkVSU0lORztcbiAgICAgIHRoaXMuX3RpbWUgPSB0aGlzLmR1cmF0aW9uIC0gdGhpcy5fdGltZTtcbiAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IHRoaXMuZ2V0VGltZXIoKSAtIHRoaXMuX3RpbWU7XG4gICAgICB0aGlzLm9uRW50ZXJGcmFtZSgpO1xuICAgICAgdGhpcy5maXJlKCdvblJldmVyc2UnKTtcbiAgICB9LFxuICAgIHNlZWs6IGZ1bmN0aW9uKHQpIHtcbiAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgIHRoaXMuX3RpbWUgPSB0O1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgIHRoaXMuZmlyZSgnb25TZWVrJyk7XG4gICAgfSxcbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICB0aGlzLl90aW1lID0gMDtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICB0aGlzLmZpcmUoJ29uUmVzZXQnKTtcbiAgICB9LFxuICAgIGZpbmlzaDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICB0aGlzLl90aW1lID0gdGhpcy5kdXJhdGlvbjtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICB0aGlzLmZpcmUoJ29uRmluaXNoJyk7XG4gICAgfSxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zZXRQb3NpdGlvbih0aGlzLmdldFBvc2l0aW9uKHRoaXMuX3RpbWUpKTtcbiAgICB9LFxuICAgIG9uRW50ZXJGcmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuZ2V0VGltZXIoKSAtIHRoaXMuX3N0YXJ0VGltZTtcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBQTEFZSU5HKSB7XG4gICAgICAgIHRoaXMuc2V0VGltZSh0KTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gUkVWRVJTSU5HKSB7XG4gICAgICAgIHRoaXMuc2V0VGltZSh0aGlzLmR1cmF0aW9uIC0gdCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBwYXVzZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnN0YXRlID0gUEFVU0VEO1xuICAgICAgdGhpcy5maXJlKCdvblBhdXNlJyk7XG4gICAgfSxcbiAgICBnZXRUaW1lcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgICAqIFR3ZWVuIGNvbnN0cnVjdG9yLiAgVHdlZW5zIGVuYWJsZSB5b3UgdG8gYW5pbWF0ZSBhIG5vZGUgYmV0d2VlbiB0aGUgY3VycmVudCBzdGF0ZSBhbmQgYSBuZXcgc3RhdGUuXG4gICAgICogIFlvdSBjYW4gcGxheSwgcGF1c2UsIHJldmVyc2UsIHNlZWssIHJlc2V0LCBhbmQgZmluaXNoIHR3ZWVucy4gIEJ5IGRlZmF1bHQsIHR3ZWVucyBhcmUgYW5pbWF0ZWQgdXNpbmdcbiAgICAgKiAgYSBsaW5lYXIgZWFzaW5nLiAgRm9yIG1vcmUgdHdlZW5pbmcgb3B0aW9ucywgY2hlY2sgb3V0IHtAbGluayBLb252YS5FYXNpbmdzfVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gaW5zdGFudGlhdGUgbmV3IHR3ZWVuIHdoaWNoIGZ1bGx5IHJvdGF0ZXMgYSBub2RlIGluIDEgc2Vjb25kXG4gICAgICogdmFyIHR3ZWVuID0gbmV3IEtvbnZhLlR3ZWVuKHtcbiAgICAgKiAgIG5vZGU6IG5vZGUsXG4gICAgICogICByb3RhdGlvbkRlZzogMzYwLFxuICAgICAqICAgZHVyYXRpb246IDEsXG4gICAgICogICBlYXNpbmc6IEtvbnZhLkVhc2luZ3MuRWFzZUluT3V0XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBwbGF5IHR3ZWVuXG4gICAgICogdHdlZW4ucGxheSgpO1xuICAgICAqXG4gICAgICogLy8gcGF1c2UgdHdlZW5cbiAgICAgKiB0d2Vlbi5wYXVzZSgpO1xuICAgICAqL1xuICBLb252YS5Ud2VlbiA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgIG5vZGUgPSBjb25maWcubm9kZSxcbiAgICAgIG5vZGVJZCA9IG5vZGUuX2lkLFxuICAgICAgZHVyYXRpb24sXG4gICAgICBlYXNpbmcgPSBjb25maWcuZWFzaW5nIHx8IEtvbnZhLkVhc2luZ3MuTGluZWFyLFxuICAgICAgeW95byA9ICEhY29uZmlnLnlveW8sXG4gICAgICBrZXk7XG5cbiAgICBpZiAodHlwZW9mIGNvbmZpZy5kdXJhdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGR1cmF0aW9uID0gMTtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZy5kdXJhdGlvbiA9PT0gMCkge1xuICAgICAgLy8gemVybyBpcyBiYWQgdmFsdWUgZm9yIGR1cmF0aW9uXG4gICAgICBkdXJhdGlvbiA9IDAuMDAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBkdXJhdGlvbiA9IGNvbmZpZy5kdXJhdGlvbjtcbiAgICB9XG4gICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB0aGlzLl9pZCA9IGlkQ291bnRlcisrO1xuXG4gICAgdmFyIGxheWVycyA9XG4gICAgICBub2RlLmdldExheWVyKCkgfHxcbiAgICAgIChub2RlIGluc3RhbmNlb2YgS29udmEuU3RhZ2UgPyBub2RlLmdldExheWVycygpIDogbnVsbCk7XG4gICAgaWYgKCFsYXllcnMpIHtcbiAgICAgIEtvbnZhLlV0aWwuZXJyb3IoXG4gICAgICAgICdUd2VlbiBjb25zdHJ1Y3RvciBoYXZlIGBub2RlYCB0aGF0IGlzIG5vdCBpbiBhIGxheWVyLiBQbGVhc2UgYWRkIG5vZGUgaW50byBsYXllciBmaXJzdC4nXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmFuaW0gPSBuZXcgS29udmEuQW5pbWF0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgdGhhdC50d2Vlbi5vbkVudGVyRnJhbWUoKTtcbiAgICB9LCBsYXllcnMpO1xuXG4gICAgdGhpcy50d2VlbiA9IG5ldyBUd2VlbihcbiAgICAgIGtleSxcbiAgICAgIGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgdGhhdC5fdHdlZW5GdW5jKGkpO1xuICAgICAgfSxcbiAgICAgIGVhc2luZyxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgZHVyYXRpb24gKiAxMDAwLFxuICAgICAgeW95b1xuICAgICk7XG5cbiAgICB0aGlzLl9hZGRMaXN0ZW5lcnMoKTtcblxuICAgIC8vIGluaXQgYXR0cnMgbWFwXG4gICAgaWYgKCFLb252YS5Ud2Vlbi5hdHRyc1tub2RlSWRdKSB7XG4gICAgICBLb252YS5Ud2Vlbi5hdHRyc1tub2RlSWRdID0ge307XG4gICAgfVxuICAgIGlmICghS29udmEuVHdlZW4uYXR0cnNbbm9kZUlkXVt0aGlzLl9pZF0pIHtcbiAgICAgIEtvbnZhLlR3ZWVuLmF0dHJzW25vZGVJZF1bdGhpcy5faWRdID0ge307XG4gICAgfVxuICAgIC8vIGluaXQgdHdlZW5zIG1hcFxuICAgIGlmICghS29udmEuVHdlZW4udHdlZW5zW25vZGVJZF0pIHtcbiAgICAgIEtvbnZhLlR3ZWVuLnR3ZWVuc1tub2RlSWRdID0ge307XG4gICAgfVxuXG4gICAgZm9yIChrZXkgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoYmxhY2tsaXN0W2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9hZGRBdHRyKGtleSwgY29uZmlnW2tleV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucmVzZXQoKTtcblxuICAgIC8vIGNhbGxiYWNrc1xuICAgIHRoaXMub25GaW5pc2ggPSBjb25maWcub25GaW5pc2g7XG4gICAgdGhpcy5vblJlc2V0ID0gY29uZmlnLm9uUmVzZXQ7XG4gIH07XG5cbiAgLy8gc3RhcnQvZGlmZiBvYmplY3QgPSBhdHRycy5ub2RlSWQudHdlZW5JZC5hdHRyXG4gIEtvbnZhLlR3ZWVuLmF0dHJzID0ge307XG4gIC8vIHR3ZWVuSWQgPSB0d2VlbnMubm9kZUlkLmF0dHJcbiAgS29udmEuVHdlZW4udHdlZW5zID0ge307XG5cbiAgS29udmEuVHdlZW4ucHJvdG90eXBlID0ge1xuICAgIF9hZGRBdHRyOiBmdW5jdGlvbihrZXksIGVuZCkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGUsXG4gICAgICAgIG5vZGVJZCA9IG5vZGUuX2lkLFxuICAgICAgICBzdGFydCxcbiAgICAgICAgZGlmZixcbiAgICAgICAgdHdlZW5JZCxcbiAgICAgICAgbixcbiAgICAgICAgbGVuLFxuICAgICAgICB0cnVlRW5kLFxuICAgICAgICB0cnVlU3RhcnQ7XG5cbiAgICAgIC8vIHJlbW92ZSBjb25mbGljdCBmcm9tIHR3ZWVuIG1hcCBpZiBpdCBleGlzdHNcbiAgICAgIHR3ZWVuSWQgPSBLb252YS5Ud2Vlbi50d2VlbnNbbm9kZUlkXVtrZXldO1xuXG4gICAgICBpZiAodHdlZW5JZCkge1xuICAgICAgICBkZWxldGUgS29udmEuVHdlZW4uYXR0cnNbbm9kZUlkXVt0d2VlbklkXVtrZXldO1xuICAgICAgfVxuXG4gICAgICAvLyBhZGQgdG8gdHdlZW4gbWFwXG4gICAgICBzdGFydCA9IG5vZGUuZ2V0QXR0cihrZXkpO1xuXG4gICAgICBpZiAoS29udmEuVXRpbC5faXNBcnJheShlbmQpKSB7XG4gICAgICAgIGRpZmYgPSBbXTtcbiAgICAgICAgbGVuID0gTWF0aC5tYXgoZW5kLmxlbmd0aCwgc3RhcnQubGVuZ3RoKTtcblxuICAgICAgICBpZiAoa2V5ID09PSAncG9pbnRzJyAmJiBlbmQubGVuZ3RoICE9PSBzdGFydC5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBiZWZvcmUgdHdlZW5pbmcgcG9pbnRzIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgc3RhcnQubGVuZ3RoID09PSBlbmQubGVuZ3RoXG4gICAgICAgICAgLy8gS29udmEuVXRpbC5fcHJlcGFyZUFycmF5Rm9yVHdlZW4gdGhpbmtpbmcgdGhhdCBlbmQubGVuZ3RoID4gc3RhcnQubGVuZ3RoXG5cbiAgICAgICAgICBpZiAoZW5kLmxlbmd0aCA+IHN0YXJ0Lmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gc28gaW4gdGhpcyBjYXNlIHdlIHdpbGwgaW5jcmVhc2UgbnVtYmVyIG9mIHN0YXJ0aW5nIHBvaW50c1xuICAgICAgICAgICAgdHJ1ZVN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICBzdGFydCA9IEtvbnZhLlV0aWwuX3ByZXBhcmVBcnJheUZvclR3ZWVuKHN0YXJ0LCBlbmQsIG5vZGUuY2xvc2VkKCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpbiB0aGlzIGNhc2Ugd2Ugd2lsbCBpbmNyZWFzZSBudW1iZXIgb2YgZWRpbmcgcG9pbnRzXG4gICAgICAgICAgICB0cnVlRW5kID0gZW5kO1xuICAgICAgICAgICAgZW5kID0gS29udmEuVXRpbC5fcHJlcGFyZUFycmF5Rm9yVHdlZW4oZW5kLCBzdGFydCwgbm9kZS5jbG9zZWQoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgICAgZGlmZi5wdXNoKGVuZFtuXSAtIHN0YXJ0W25dKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb2xvckF0dHJzLmluZGV4T2Yoa2V5KSAhPT0gLTEpIHtcbiAgICAgICAgc3RhcnQgPSBLb252YS5VdGlsLmNvbG9yVG9SR0JBKHN0YXJ0KTtcbiAgICAgICAgdmFyIGVuZFJHQkEgPSBLb252YS5VdGlsLmNvbG9yVG9SR0JBKGVuZCk7XG4gICAgICAgIGRpZmYgPSB7XG4gICAgICAgICAgcjogZW5kUkdCQS5yIC0gc3RhcnQucixcbiAgICAgICAgICBnOiBlbmRSR0JBLmcgLSBzdGFydC5nLFxuICAgICAgICAgIGI6IGVuZFJHQkEuYiAtIHN0YXJ0LmIsXG4gICAgICAgICAgYTogZW5kUkdCQS5hIC0gc3RhcnQuYVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlmZiA9IGVuZCAtIHN0YXJ0O1xuICAgICAgfVxuXG4gICAgICBLb252YS5Ud2Vlbi5hdHRyc1tub2RlSWRdW3RoaXMuX2lkXVtrZXldID0ge1xuICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgIGRpZmY6IGRpZmYsXG4gICAgICAgIGVuZDogZW5kLFxuICAgICAgICB0cnVlRW5kOiB0cnVlRW5kLFxuICAgICAgICB0cnVlU3RhcnQ6IHRydWVTdGFydFxuICAgICAgfTtcbiAgICAgIEtvbnZhLlR3ZWVuLnR3ZWVuc1tub2RlSWRdW2tleV0gPSB0aGlzLl9pZDtcbiAgICB9LFxuICAgIF90d2VlbkZ1bmM6IGZ1bmN0aW9uKGkpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlLFxuICAgICAgICBhdHRycyA9IEtvbnZhLlR3ZWVuLmF0dHJzW25vZGUuX2lkXVt0aGlzLl9pZF0sXG4gICAgICAgIGtleSxcbiAgICAgICAgYXR0cixcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIGRpZmYsXG4gICAgICAgIG5ld1ZhbCxcbiAgICAgICAgbixcbiAgICAgICAgbGVuLFxuICAgICAgICBlbmQ7XG5cbiAgICAgIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgICAgIGF0dHIgPSBhdHRyc1trZXldO1xuICAgICAgICBzdGFydCA9IGF0dHIuc3RhcnQ7XG4gICAgICAgIGRpZmYgPSBhdHRyLmRpZmY7XG4gICAgICAgIGVuZCA9IGF0dHIuZW5kO1xuXG4gICAgICAgIGlmIChLb252YS5VdGlsLl9pc0FycmF5KHN0YXJ0KSkge1xuICAgICAgICAgIG5ld1ZhbCA9IFtdO1xuICAgICAgICAgIGxlbiA9IE1hdGgubWF4KHN0YXJ0Lmxlbmd0aCwgZW5kLmxlbmd0aCk7XG4gICAgICAgICAgZm9yIChuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgICAgICBuZXdWYWwucHVzaCgoc3RhcnRbbl0gfHwgMCkgKyBkaWZmW25dICogaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNvbG9yQXR0cnMuaW5kZXhPZihrZXkpICE9PSAtMSkge1xuICAgICAgICAgIG5ld1ZhbCA9XG4gICAgICAgICAgICAncmdiYSgnICtcbiAgICAgICAgICAgIE1hdGgucm91bmQoc3RhcnQuciArIGRpZmYuciAqIGkpICtcbiAgICAgICAgICAgICcsJyArXG4gICAgICAgICAgICBNYXRoLnJvdW5kKHN0YXJ0LmcgKyBkaWZmLmcgKiBpKSArXG4gICAgICAgICAgICAnLCcgK1xuICAgICAgICAgICAgTWF0aC5yb3VuZChzdGFydC5iICsgZGlmZi5iICogaSkgK1xuICAgICAgICAgICAgJywnICtcbiAgICAgICAgICAgIChzdGFydC5hICsgZGlmZi5hICogaSkgK1xuICAgICAgICAgICAgJyknO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1ZhbCA9IHN0YXJ0ICsgZGlmZiAqIGk7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlLnNldEF0dHIoa2V5LCBuZXdWYWwpO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2FkZExpc3RlbmVyczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgIC8vIHN0YXJ0IGxpc3RlbmVyc1xuICAgICAgdGhpcy50d2Vlbi5vblBsYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhhdC5hbmltLnN0YXJ0KCk7XG4gICAgICB9O1xuICAgICAgdGhpcy50d2Vlbi5vblJldmVyc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhhdC5hbmltLnN0YXJ0KCk7XG4gICAgICB9O1xuXG4gICAgICAvLyBzdG9wIGxpc3RlbmVyc1xuICAgICAgdGhpcy50d2Vlbi5vblBhdXNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoYXQuYW5pbS5zdG9wKCk7XG4gICAgICB9O1xuICAgICAgdGhpcy50d2Vlbi5vbkZpbmlzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoYXQubm9kZTtcblxuICAgICAgICAvLyBhZnRlciB0d2VlbmluZyAgcG9pbnRzIG9mIGxpbmUgd2UgbmVlZCB0byBzZXQgb3JpZ2luYWwgZW5kXG4gICAgICAgIHZhciBhdHRycyA9IEtvbnZhLlR3ZWVuLmF0dHJzW25vZGUuX2lkXVt0aGF0Ll9pZF07XG4gICAgICAgIGlmIChhdHRycy5wb2ludHMgJiYgYXR0cnMucG9pbnRzLnRydWVFbmQpIHtcbiAgICAgICAgICBub2RlLnBvaW50cyhhdHRycy5wb2ludHMudHJ1ZUVuZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhhdC5vbkZpbmlzaCkge1xuICAgICAgICAgIHRoYXQub25GaW5pc2guY2FsbCh0aGF0KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMudHdlZW4ub25SZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoYXQubm9kZTtcbiAgICAgICAgLy8gYWZ0ZXIgdHdlZW5pbmcgIHBvaW50cyBvZiBsaW5lIHdlIG5lZWQgdG8gc2V0IG9yaWdpbmFsIHN0YXJ0XG4gICAgICAgIHZhciBhdHRycyA9IEtvbnZhLlR3ZWVuLmF0dHJzW25vZGUuX2lkXVt0aGF0Ll9pZF07XG4gICAgICAgIGlmIChhdHRycy5wb2ludHMgJiYgYXR0cnMucG9pbnRzLnRydWVTdGFydCkge1xuICAgICAgICAgIG5vZGUucG9pbnRzKGF0dHJzLnBvaW50cy50cnVlU3RhcnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoYXQub25SZXNldCkge1xuICAgICAgICAgIHRoYXQub25SZXNldCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIHBsYXlcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVHdlZW4ucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtUd2Vlbn1cbiAgICAgICAgICovXG4gICAgcGxheTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnR3ZWVuLnBsYXkoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIHJldmVyc2VcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVHdlZW4ucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtUd2Vlbn1cbiAgICAgICAgICovXG4gICAgcmV2ZXJzZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnR3ZWVuLnJldmVyc2UoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIHJlc2V0XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlR3ZWVuLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7VHdlZW59XG4gICAgICAgICAqL1xuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudHdlZW4ucmVzZXQoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIHNlZWtcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVHdlZW4ucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gdCB0aW1lIGluIHNlY29uZHMgYmV0d2VlbiAwIGFuZCB0aGUgZHVyYXRpb25cbiAgICAgICAgICogQHJldHVybnMge1R3ZWVufVxuICAgICAgICAgKi9cbiAgICBzZWVrOiBmdW5jdGlvbih0KSB7XG4gICAgICB0aGlzLnR3ZWVuLnNlZWsodCAqIDEwMDApO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogcGF1c2VcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVHdlZW4ucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtUd2Vlbn1cbiAgICAgICAgICovXG4gICAgcGF1c2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy50d2Vlbi5wYXVzZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogZmluaXNoXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlR3ZWVuLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7VHdlZW59XG4gICAgICAgICAqL1xuICAgIGZpbmlzaDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnR3ZWVuLmZpbmlzaCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogZGVzdHJveVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ud2Vlbi5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm9kZUlkID0gdGhpcy5ub2RlLl9pZCxcbiAgICAgICAgdGhpc0lkID0gdGhpcy5faWQsXG4gICAgICAgIGF0dHJzID0gS29udmEuVHdlZW4udHdlZW5zW25vZGVJZF0sXG4gICAgICAgIGtleTtcblxuICAgICAgdGhpcy5wYXVzZSgpO1xuXG4gICAgICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgICAgICBkZWxldGUgS29udmEuVHdlZW4udHdlZW5zW25vZGVJZF1ba2V5XTtcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIEtvbnZhLlR3ZWVuLmF0dHJzW25vZGVJZF1bdGhpc0lkXTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAgICogVHdlZW4gbm9kZSBwcm9wZXJ0aWVzLiBTaG9ydGVyIHVzYWdlIG9mIHtAbGluayBLb252YS5Ud2Vlbn0gb2JqZWN0LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBLb252YS5Ob2RlI3RvXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gdHdlZW4gcGFyYW1zXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGNpcmNsZS50byh7XG4gICAgICogIHggOiA1MCxcbiAgICAgKiAgZHVyYXRpb24gOiAwLjVcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgS29udmEuTm9kZS5wcm90b3R5cGUudG8gPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICB2YXIgb25GaW5pc2ggPSBwYXJhbXMub25GaW5pc2g7XG4gICAgcGFyYW1zLm5vZGUgPSB0aGlzO1xuICAgIHBhcmFtcy5vbkZpbmlzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICBpZiAob25GaW5pc2gpIHtcbiAgICAgICAgb25GaW5pc2goKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciB0d2VlbiA9IG5ldyBLb252YS5Ud2VlbihwYXJhbXMpO1xuICAgIHR3ZWVuLnBsYXkoKTtcbiAgfTtcblxuICAvKlxuICAgICogVGhlc2UgZWFzZXMgd2VyZSBwb3J0ZWQgZnJvbSBhbiBBZG9iZSBGbGFzaCB0d2VlbmluZyBsaWJyYXJ5IHRvIEphdmFTY3JpcHRcbiAgICAqIGJ5IFhhcmljXG4gICAgKi9cblxuICAvKipcbiAgICAgKiBAbmFtZXNwYWNlIEVhc2luZ3NcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKi9cbiAgS29udmEuRWFzaW5ncyA9IHtcbiAgICAvKipcbiAgICAgICAgKiBiYWNrIGVhc2UgaW5cbiAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuRWFzaW5nc1xuICAgICAgICAqL1xuICAgIEJhY2tFYXNlSW46IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgIHZhciBzID0gMS43MDE1ODtcbiAgICAgIHJldHVybiBjICogKHQgLz0gZCkgKiB0ICogKChzICsgMSkgKiB0IC0gcykgKyBiO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICogYmFjayBlYXNlIG91dFxuICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5FYXNpbmdzXG4gICAgICAgICovXG4gICAgQmFja0Vhc2VPdXQ6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgIHZhciBzID0gMS43MDE1ODtcbiAgICAgIHJldHVybiBjICogKCh0ID0gdCAvIGQgLSAxKSAqIHQgKiAoKHMgKyAxKSAqIHQgKyBzKSArIDEpICsgYjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAqIGJhY2sgZWFzZSBpbiBvdXRcbiAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuRWFzaW5nc1xuICAgICAgICAqL1xuICAgIEJhY2tFYXNlSW5PdXQ6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgIHZhciBzID0gMS43MDE1ODtcbiAgICAgIGlmICgodCAvPSBkIC8gMikgPCAxKSB7XG4gICAgICAgIHJldHVybiBjIC8gMiAqICh0ICogdCAqICgoKHMgKj0gMS41MjUpICsgMSkgKiB0IC0gcykpICsgYjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjIC8gMiAqICgodCAtPSAyKSAqIHQgKiAoKChzICo9IDEuNTI1KSArIDEpICogdCArIHMpICsgMikgKyBiO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICogZWxhc3RpYyBlYXNlIGluXG4gICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkVhc2luZ3NcbiAgICAgICAgKi9cbiAgICBFbGFzdGljRWFzZUluOiBmdW5jdGlvbih0LCBiLCBjLCBkLCBhLCBwKSB7XG4gICAgICAvLyBhZGRlZCBzID0gMFxuICAgICAgdmFyIHMgPSAwO1xuICAgICAgaWYgKHQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9XG4gICAgICBpZiAoKHQgLz0gZCkgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGIgKyBjO1xuICAgICAgfVxuICAgICAgaWYgKCFwKSB7XG4gICAgICAgIHAgPSBkICogMC4zO1xuICAgICAgfVxuICAgICAgaWYgKCFhIHx8IGEgPCBNYXRoLmFicyhjKSkge1xuICAgICAgICBhID0gYztcbiAgICAgICAgcyA9IHAgLyA0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcyA9IHAgLyAoMiAqIE1hdGguUEkpICogTWF0aC5hc2luKGMgLyBhKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoXG4gICAgICAgIC0oYSAqXG4gICAgICAgICAgTWF0aC5wb3coMiwgMTAgKiAodCAtPSAxKSkgKlxuICAgICAgICAgIE1hdGguc2luKCh0ICogZCAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApKSArIGJcbiAgICAgICk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgKiBlbGFzdGljIGVhc2Ugb3V0XG4gICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkVhc2luZ3NcbiAgICAgICAgKi9cbiAgICBFbGFzdGljRWFzZU91dDogZnVuY3Rpb24odCwgYiwgYywgZCwgYSwgcCkge1xuICAgICAgLy8gYWRkZWQgcyA9IDBcbiAgICAgIHZhciBzID0gMDtcbiAgICAgIGlmICh0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfVxuICAgICAgaWYgKCh0IC89IGQpID09PSAxKSB7XG4gICAgICAgIHJldHVybiBiICsgYztcbiAgICAgIH1cbiAgICAgIGlmICghcCkge1xuICAgICAgICBwID0gZCAqIDAuMztcbiAgICAgIH1cbiAgICAgIGlmICghYSB8fCBhIDwgTWF0aC5hYnMoYykpIHtcbiAgICAgICAgYSA9IGM7XG4gICAgICAgIHMgPSBwIC8gNDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMgPSBwIC8gKDIgKiBNYXRoLlBJKSAqIE1hdGguYXNpbihjIC8gYSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKFxuICAgICAgICBhICogTWF0aC5wb3coMiwgLTEwICogdCkgKiBNYXRoLnNpbigodCAqIGQgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSArXG4gICAgICAgIGMgK1xuICAgICAgICBiXG4gICAgICApO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICogZWxhc3RpYyBlYXNlIGluIG91dFxuICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5FYXNpbmdzXG4gICAgICAgICovXG4gICAgRWxhc3RpY0Vhc2VJbk91dDogZnVuY3Rpb24odCwgYiwgYywgZCwgYSwgcCkge1xuICAgICAgLy8gYWRkZWQgcyA9IDBcbiAgICAgIHZhciBzID0gMDtcbiAgICAgIGlmICh0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfVxuICAgICAgaWYgKCh0IC89IGQgLyAyKSA9PT0gMikge1xuICAgICAgICByZXR1cm4gYiArIGM7XG4gICAgICB9XG4gICAgICBpZiAoIXApIHtcbiAgICAgICAgcCA9IGQgKiAoMC4zICogMS41KTtcbiAgICAgIH1cbiAgICAgIGlmICghYSB8fCBhIDwgTWF0aC5hYnMoYykpIHtcbiAgICAgICAgYSA9IGM7XG4gICAgICAgIHMgPSBwIC8gNDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMgPSBwIC8gKDIgKiBNYXRoLlBJKSAqIE1hdGguYXNpbihjIC8gYSk7XG4gICAgICB9XG4gICAgICBpZiAodCA8IDEpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAtMC41ICpcbiAgICAgICAgICAgIChhICpcbiAgICAgICAgICAgICAgTWF0aC5wb3coMiwgMTAgKiAodCAtPSAxKSkgKlxuICAgICAgICAgICAgICBNYXRoLnNpbigodCAqIGQgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSkgK1xuICAgICAgICAgIGJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoXG4gICAgICAgIGEgKlxuICAgICAgICAgIE1hdGgucG93KDIsIC0xMCAqICh0IC09IDEpKSAqXG4gICAgICAgICAgTWF0aC5zaW4oKHQgKiBkIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkgKlxuICAgICAgICAgIDAuNSArXG4gICAgICAgIGMgK1xuICAgICAgICBiXG4gICAgICApO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICogYm91bmNlIGVhc2Ugb3V0XG4gICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkVhc2luZ3NcbiAgICAgICAgKi9cbiAgICBCb3VuY2VFYXNlT3V0OiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICBpZiAoKHQgLz0gZCkgPCAxIC8gMi43NSkge1xuICAgICAgICByZXR1cm4gYyAqICg3LjU2MjUgKiB0ICogdCkgKyBiO1xuICAgICAgfSBlbHNlIGlmICh0IDwgMiAvIDIuNzUpIHtcbiAgICAgICAgcmV0dXJuIGMgKiAoNy41NjI1ICogKHQgLT0gMS41IC8gMi43NSkgKiB0ICsgMC43NSkgKyBiO1xuICAgICAgfSBlbHNlIGlmICh0IDwgMi41IC8gMi43NSkge1xuICAgICAgICByZXR1cm4gYyAqICg3LjU2MjUgKiAodCAtPSAyLjI1IC8gMi43NSkgKiB0ICsgMC45Mzc1KSArIGI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYyAqICg3LjU2MjUgKiAodCAtPSAyLjYyNSAvIDIuNzUpICogdCArIDAuOTg0Mzc1KSArIGI7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgKiBib3VuY2UgZWFzZSBpblxuICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5FYXNpbmdzXG4gICAgICAgICovXG4gICAgQm91bmNlRWFzZUluOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICByZXR1cm4gYyAtIEtvbnZhLkVhc2luZ3MuQm91bmNlRWFzZU91dChkIC0gdCwgMCwgYywgZCkgKyBiO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICogYm91bmNlIGVhc2UgaW4gb3V0XG4gICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkVhc2luZ3NcbiAgICAgICAgKi9cbiAgICBCb3VuY2VFYXNlSW5PdXQ6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgIGlmICh0IDwgZCAvIDIpIHtcbiAgICAgICAgcmV0dXJuIEtvbnZhLkVhc2luZ3MuQm91bmNlRWFzZUluKHQgKiAyLCAwLCBjLCBkKSAqIDAuNSArIGI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIEtvbnZhLkVhc2luZ3MuQm91bmNlRWFzZU91dCh0ICogMiAtIGQsIDAsIGMsIGQpICogMC41ICsgYyAqIDAuNSArIGJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAqIGVhc2UgaW5cbiAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuRWFzaW5nc1xuICAgICAgICAqL1xuICAgIEVhc2VJbjogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgcmV0dXJuIGMgKiAodCAvPSBkKSAqIHQgKyBiO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICogZWFzZSBvdXRcbiAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuRWFzaW5nc1xuICAgICAgICAqL1xuICAgIEVhc2VPdXQ6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgIHJldHVybiAtYyAqICh0IC89IGQpICogKHQgLSAyKSArIGI7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgKiBlYXNlIGluIG91dFxuICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5FYXNpbmdzXG4gICAgICAgICovXG4gICAgRWFzZUluT3V0OiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICBpZiAoKHQgLz0gZCAvIDIpIDwgMSkge1xuICAgICAgICByZXR1cm4gYyAvIDIgKiB0ICogdCArIGI7XG4gICAgICB9XG4gICAgICByZXR1cm4gLWMgLyAyICogKC0tdCAqICh0IC0gMikgLSAxKSArIGI7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgKiBzdHJvbmcgZWFzZSBpblxuICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5FYXNpbmdzXG4gICAgICAgICovXG4gICAgU3Ryb25nRWFzZUluOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCAqIHQgKiB0ICogdCArIGI7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgKiBzdHJvbmcgZWFzZSBvdXRcbiAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuRWFzaW5nc1xuICAgICAgICAqL1xuICAgIFN0cm9uZ0Vhc2VPdXQ6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgIHJldHVybiBjICogKCh0ID0gdCAvIGQgLSAxKSAqIHQgKiB0ICogdCAqIHQgKyAxKSArIGI7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgKiBzdHJvbmcgZWFzZSBpbiBvdXRcbiAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuRWFzaW5nc1xuICAgICAgICAqL1xuICAgIFN0cm9uZ0Vhc2VJbk91dDogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgaWYgKCh0IC89IGQgLyAyKSA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGMgLyAyICogdCAqIHQgKiB0ICogdCAqIHQgKyBiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGMgLyAyICogKCh0IC09IDIpICogdCAqIHQgKiB0ICogdCArIDIpICsgYjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAqIGxpbmVhclxuICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5FYXNpbmdzXG4gICAgICAgICovXG4gICAgTGluZWFyOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICByZXR1cm4gYyAqIHQgLyBkICsgYjtcbiAgICB9XG4gIH07XG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgS29udmEuREQgPSB7XG4gICAgLy8gcHJvcGVydGllc1xuICAgIGFuaW06IG5ldyBLb252YS5BbmltYXRpb24oZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYiA9IHRoaXMuZGlydHk7XG4gICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICByZXR1cm4gYjtcbiAgICB9KSxcbiAgICBpc0RyYWdnaW5nOiBmYWxzZSxcbiAgICBqdXN0RHJhZ2dlZDogZmFsc2UsXG4gICAgb2Zmc2V0OiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH0sXG4gICAgbm9kZTogbnVsbCxcblxuICAgIC8vIG1ldGhvZHNcbiAgICBfZHJhZzogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICB2YXIgZGQgPSBLb252YS5ERCxcbiAgICAgICAgbm9kZSA9IGRkLm5vZGU7XG4gICAgICBpZiAobm9kZSkge1xuICAgICAgICBpZiAoIWRkLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICB2YXIgcG9zID0gbm9kZS5nZXRTdGFnZSgpLmdldFBvaW50ZXJQb3NpdGlvbigpO1xuICAgICAgICAgIC8vIGl0IGlzIHBvc3NpYmxlIHRoYXQgcG9zIGlzIHVuZGVmaW5lZFxuICAgICAgICAgIC8vIHJlYXR0YWNoIGl0XG4gICAgICAgICAgaWYgKCFwb3MpIHtcbiAgICAgICAgICAgIG5vZGUuZ2V0U3RhZ2UoKS5fc2V0UG9pbnRlclBvc2l0aW9uKGV2dCk7XG4gICAgICAgICAgICBwb3MgPSBub2RlLmdldFN0YWdlKCkuZ2V0UG9pbnRlclBvc2l0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBkcmFnRGlzdGFuY2UgPSBub2RlLmRyYWdEaXN0YW5jZSgpO1xuICAgICAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGgubWF4KFxuICAgICAgICAgICAgTWF0aC5hYnMocG9zLnggLSBkZC5zdGFydFBvaW50ZXJQb3MueCksXG4gICAgICAgICAgICBNYXRoLmFicyhwb3MueSAtIGRkLnN0YXJ0UG9pbnRlclBvcy55KVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGRpc3RhbmNlIDwgZHJhZ0Rpc3RhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbm9kZS5nZXRTdGFnZSgpLl9zZXRQb2ludGVyUG9zaXRpb24oZXZ0KTtcbiAgICAgICAgbm9kZS5fc2V0RHJhZ1Bvc2l0aW9uKGV2dCk7XG4gICAgICAgIGlmICghZGQuaXNEcmFnZ2luZykge1xuICAgICAgICAgIGRkLmlzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgIG5vZGUuZmlyZShcbiAgICAgICAgICAgICdkcmFnc3RhcnQnLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0eXBlOiAnZHJhZ3N0YXJ0JyxcbiAgICAgICAgICAgICAgdGFyZ2V0OiBub2RlLFxuICAgICAgICAgICAgICBldnQ6IGV2dFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZXhlY3V0ZSBvbmRyYWdtb3ZlIGlmIGRlZmluZWRcbiAgICAgICAgbm9kZS5maXJlKFxuICAgICAgICAgICdkcmFnbW92ZScsXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogJ2RyYWdtb3ZlJyxcbiAgICAgICAgICAgIHRhcmdldDogbm9kZSxcbiAgICAgICAgICAgIGV2dDogZXZ0XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfZW5kRHJhZ0JlZm9yZTogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICB2YXIgZGQgPSBLb252YS5ERCxcbiAgICAgICAgbm9kZSA9IGRkLm5vZGUsXG4gICAgICAgIGxheWVyO1xuXG4gICAgICBpZiAobm9kZSkge1xuICAgICAgICBsYXllciA9IG5vZGUuZ2V0TGF5ZXIoKTtcbiAgICAgICAgZGQuYW5pbS5zdG9wKCk7XG5cbiAgICAgICAgLy8gb25seSBmaXJlIGRyYWdlbmQgZXZlbnQgaWYgdGhlIGRyYWcgYW5kIGRyb3BcbiAgICAgICAgLy8gb3BlcmF0aW9uIGFjdHVhbGx5IHN0YXJ0ZWQuXG4gICAgICAgIGlmIChkZC5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgZGQuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgIGRkLmp1c3REcmFnZ2VkID0gdHJ1ZTtcbiAgICAgICAgICBLb252YS5saXN0ZW5DbGlja1RhcCA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKGV2dCkge1xuICAgICAgICAgICAgZXZ0LmRyYWdFbmROb2RlID0gbm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgZGQubm9kZTtcblxuICAgICAgICBpZiAobm9kZS5nZXRMYXllcigpIHx8IGxheWVyIHx8IG5vZGUgaW5zdGFuY2VvZiBLb252YS5TdGFnZSkge1xuICAgICAgICAgIChsYXllciB8fCBub2RlKS5kcmF3KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIF9lbmREcmFnQWZ0ZXI6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgZXZ0ID0gZXZ0IHx8IHt9O1xuICAgICAgdmFyIGRyYWdFbmROb2RlID0gZXZ0LmRyYWdFbmROb2RlO1xuXG4gICAgICBpZiAoZXZ0ICYmIGRyYWdFbmROb2RlKSB7XG4gICAgICAgIGRyYWdFbmROb2RlLmZpcmUoXG4gICAgICAgICAgJ2RyYWdlbmQnLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6ICdkcmFnZW5kJyxcbiAgICAgICAgICAgIHRhcmdldDogZHJhZ0VuZE5vZGUsXG4gICAgICAgICAgICBldnQ6IGV2dFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBOb2RlIGV4dGVuZGVyc1xuXG4gIC8qKlxuICAgICAqIGluaXRpYXRlIGRyYWcgYW5kIGRyb3BcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICovXG4gIEtvbnZhLk5vZGUucHJvdG90eXBlLnN0YXJ0RHJhZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkZCA9IEtvbnZhLkRELFxuICAgICAgc3RhZ2UgPSB0aGlzLmdldFN0YWdlKCksXG4gICAgICBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKSxcbiAgICAgIHBvcyA9IHN0YWdlLmdldFBvaW50ZXJQb3NpdGlvbigpLFxuICAgICAgYXAgPSB0aGlzLmdldEFic29sdXRlUG9zaXRpb24oKTtcblxuICAgIGlmIChwb3MpIHtcbiAgICAgIGlmIChkZC5ub2RlKSB7XG4gICAgICAgIGRkLm5vZGUuc3RvcERyYWcoKTtcbiAgICAgIH1cblxuICAgICAgZGQubm9kZSA9IHRoaXM7XG4gICAgICBkZC5zdGFydFBvaW50ZXJQb3MgPSBwb3M7XG4gICAgICBkZC5vZmZzZXQueCA9IHBvcy54IC0gYXAueDtcbiAgICAgIGRkLm9mZnNldC55ID0gcG9zLnkgLSBhcC55O1xuICAgICAgZGQuYW5pbS5zZXRMYXllcnMobGF5ZXIgfHwgdGhpcy5nZXRMYXllcnMoKSk7XG4gICAgICBkZC5hbmltLnN0YXJ0KCk7XG5cbiAgICAgIHRoaXMuX3NldERyYWdQb3NpdGlvbigpO1xuICAgIH1cbiAgfTtcblxuICBLb252YS5Ob2RlLnByb3RvdHlwZS5fc2V0RHJhZ1Bvc2l0aW9uID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgdmFyIGRkID0gS29udmEuREQsXG4gICAgICBwb3MgPSB0aGlzLmdldFN0YWdlKCkuZ2V0UG9pbnRlclBvc2l0aW9uKCksXG4gICAgICBkYmYgPSB0aGlzLmdldERyYWdCb3VuZEZ1bmMoKTtcbiAgICBpZiAoIXBvcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbmV3Tm9kZVBvcyA9IHtcbiAgICAgIHg6IHBvcy54IC0gZGQub2Zmc2V0LngsXG4gICAgICB5OiBwb3MueSAtIGRkLm9mZnNldC55XG4gICAgfTtcblxuICAgIGlmIChkYmYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbmV3Tm9kZVBvcyA9IGRiZi5jYWxsKHRoaXMsIG5ld05vZGVQb3MsIGV2dCk7XG4gICAgfVxuICAgIHRoaXMuc2V0QWJzb2x1dGVQb3NpdGlvbihuZXdOb2RlUG9zKTtcblxuICAgIGlmIChcbiAgICAgICF0aGlzLl9sYXN0UG9zIHx8XG4gICAgICB0aGlzLl9sYXN0UG9zLnggIT09IG5ld05vZGVQb3MueCB8fFxuICAgICAgdGhpcy5fbGFzdFBvcy55ICE9PSBuZXdOb2RlUG9zLnlcbiAgICApIHtcbiAgICAgIGRkLmFuaW0uZGlydHkgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuX2xhc3RQb3MgPSBuZXdOb2RlUG9zO1xuICB9O1xuXG4gIC8qKlxuICAgICAqIHN0b3AgZHJhZyBhbmQgZHJvcFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgS29udmEuTm9kZS5wcm90b3R5cGUuc3RvcERyYWcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGQgPSBLb252YS5ERCxcbiAgICAgIGV2dCA9IHt9O1xuICAgIGRkLl9lbmREcmFnQmVmb3JlKGV2dCk7XG4gICAgZGQuX2VuZERyYWdBZnRlcihldnQpO1xuICB9O1xuXG4gIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldERyYWdnYWJsZSA9IGZ1bmN0aW9uKGRyYWdnYWJsZSkge1xuICAgIHRoaXMuX3NldEF0dHIoJ2RyYWdnYWJsZScsIGRyYWdnYWJsZSk7XG4gICAgdGhpcy5fZHJhZ0NoYW5nZSgpO1xuICB9O1xuXG4gIHZhciBvcmlnUmVtb3ZlID0gS29udmEuTm9kZS5wcm90b3R5cGUucmVtb3ZlO1xuXG4gIEtvbnZhLk5vZGUucHJvdG90eXBlLl9fb3JpZ2luYWxSZW1vdmUgPSBvcmlnUmVtb3ZlO1xuICBLb252YS5Ob2RlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGQgPSBLb252YS5ERDtcblxuICAgIC8vIHN0b3AgRERcbiAgICBpZiAoZGQubm9kZSAmJiBkZC5ub2RlLl9pZCA9PT0gdGhpcy5faWQpIHtcbiAgICAgIHRoaXMuc3RvcERyYWcoKTtcbiAgICB9XG5cbiAgICBvcmlnUmVtb3ZlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAgICogZGV0ZXJtaW5lIGlmIG5vZGUgaXMgY3VycmVudGx5IGluIGRyYWcgYW5kIGRyb3AgbW9kZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgS29udmEuTm9kZS5wcm90b3R5cGUuaXNEcmFnZ2luZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkZCA9IEtvbnZhLkREO1xuICAgIHJldHVybiAhIShkZC5ub2RlICYmIGRkLm5vZGUuX2lkID09PSB0aGlzLl9pZCAmJiBkZC5pc0RyYWdnaW5nKTtcbiAgfTtcblxuICBLb252YS5Ob2RlLnByb3RvdHlwZS5fbGlzdGVuRHJhZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgIHRoaXMuX2RyYWdDbGVhbnVwKCk7XG5cbiAgICBpZiAodGhpcy5nZXRDbGFzc05hbWUoKSA9PT0gJ1N0YWdlJykge1xuICAgICAgdGhpcy5vbignY29udGVudE1vdXNlZG93bi5rb252YSBjb250ZW50VG91Y2hzdGFydC5rb252YScsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBpZiAoIUtvbnZhLkRELm5vZGUpIHtcbiAgICAgICAgICB0aGF0LnN0YXJ0RHJhZyhldnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbignbW91c2Vkb3duLmtvbnZhIHRvdWNoc3RhcnQua29udmEnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgLy8gaWdub3JlIHJpZ2h0IGFuZCBtaWRkbGUgYnV0dG9uc1xuICAgICAgICBpZiAoZXZ0LmV2dC5idXR0b24gPT09IDEgfHwgZXZ0LmV2dC5idXR0b24gPT09IDIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFLb252YS5ERC5ub2RlKSB7XG4gICAgICAgICAgdGhhdC5zdGFydERyYWcoZXZ0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gbGlzdGVuaW5nIGlzIHJlcXVpcmVkIGZvciBkcmFnIGFuZCBkcm9wXG4gICAgLypcbiAgICAgICAgdGhpcy5fbGlzdGVuaW5nRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2NsZWFyU2VsZkFuZEFuY2VzdG9yQ2FjaGUoJ2xpc3RlbmluZ0VuYWJsZWQnKTtcbiAgICAgICAgKi9cbiAgfTtcblxuICBLb252YS5Ob2RlLnByb3RvdHlwZS5fZHJhZ0NoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmF0dHJzLmRyYWdnYWJsZSkge1xuICAgICAgdGhpcy5fbGlzdGVuRHJhZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZW1vdmUgZXZlbnQgbGlzdGVuZXJzXG4gICAgICB0aGlzLl9kcmFnQ2xlYW51cCgpO1xuXG4gICAgICAvKlxuICAgICAgICAgICAgICogZm9yY2UgZHJhZyBhbmQgZHJvcCB0byBlbmRcbiAgICAgICAgICAgICAqIGlmIHRoaXMgbm9kZSBpcyBjdXJyZW50bHkgaW5cbiAgICAgICAgICAgICAqIGRyYWcgYW5kIGRyb3AgbW9kZVxuICAgICAgICAgICAgICovXG4gICAgICB2YXIgc3RhZ2UgPSB0aGlzLmdldFN0YWdlKCk7XG4gICAgICB2YXIgZGQgPSBLb252YS5ERDtcbiAgICAgIGlmIChzdGFnZSAmJiBkZC5ub2RlICYmIGRkLm5vZGUuX2lkID09PSB0aGlzLl9pZCkge1xuICAgICAgICBkZC5ub2RlLnN0b3BEcmFnKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEtvbnZhLk5vZGUucHJvdG90eXBlLl9kcmFnQ2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmdldENsYXNzTmFtZSgpID09PSAnU3RhZ2UnKSB7XG4gICAgICB0aGlzLm9mZignY29udGVudE1vdXNlZG93bi5rb252YScpO1xuICAgICAgdGhpcy5vZmYoJ2NvbnRlbnRUb3VjaHN0YXJ0LmtvbnZhJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub2ZmKCdtb3VzZWRvd24ua29udmEnKTtcbiAgICAgIHRoaXMub2ZmKCd0b3VjaHN0YXJ0LmtvbnZhJyk7XG4gICAgfVxuICB9O1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdkcmFnQm91bmRGdW5jJyk7XG5cbiAgLyoqXG4gICAgICogZ2V0L3NldCBkcmFnIGJvdW5kIGZ1bmN0aW9uLiAgVGhpcyBpcyB1c2VkIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0XG4gICAgICogIGRyYWcgYW5kIGRyb3AgcG9zaXRpb25cbiAgICAgKiBAbmFtZSBkcmFnQm91bmRGdW5jXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGRyYWdCb3VuZEZ1bmNcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZHJhZyBib3VuZCBmdW5jdGlvblxuICAgICAqIHZhciBkcmFnQm91bmRGdW5jID0gbm9kZS5kcmFnQm91bmRGdW5jKCk7XG4gICAgICpcbiAgICAgKiAvLyBjcmVhdGUgdmVydGljYWwgZHJhZyBhbmQgZHJvcFxuICAgICAqIG5vZGUuZHJhZ0JvdW5kRnVuYyhmdW5jdGlvbihwb3Mpe1xuICAgICAqICAgcmV0dXJuIHtcbiAgICAgKiAgICAgeDogdGhpcy5nZXRBYnNvbHV0ZVBvc2l0aW9uKCkueCxcbiAgICAgKiAgICAgeTogcG9zLnlcbiAgICAgKiAgIH07XG4gICAgICogfSk7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXIoS29udmEuTm9kZSwgJ2RyYWdnYWJsZScsIGZhbHNlKTtcbiAgS29udmEuRmFjdG9yeS5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdkcmFnZ2FibGUnKTtcblxuICAvKipcbiAgICAgKiBnZXQvc2V0IGRyYWdnYWJsZSBmbGFnXG4gICAgICogQG5hbWUgZHJhZ2dhYmxlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZHJhZ2dhYmxlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZHJhZ2dhYmxlIGZsYWdcbiAgICAgKiB2YXIgZHJhZ2dhYmxlID0gbm9kZS5kcmFnZ2FibGUoKTtcbiAgICAgKlxuICAgICAqIC8vIGVuYWJsZSBkcmFnIGFuZCBkcm9wXG4gICAgICogbm9kZS5kcmFnZ2FibGUodHJ1ZSk7XG4gICAgICpcbiAgICAgKiAvLyBkaXNhYmxlIGRyYWcgYW5kIGRyb3BcbiAgICAgKiBub2RlLmRyYWdnYWJsZShmYWxzZSk7XG4gICAgICovXG5cbiAgaWYgKEtvbnZhLmlzQnJvd3Nlcikge1xuICAgIHZhciBodG1sID0gS29udmEuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIGh0bWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIEtvbnZhLkRELl9lbmREcmFnQmVmb3JlLCB0cnVlKTtcbiAgICBodG1sLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgS29udmEuREQuX2VuZERyYWdCZWZvcmUsIHRydWUpO1xuXG4gICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBLb252YS5ERC5fZHJhZyk7XG4gICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBLb252YS5ERC5fZHJhZyk7XG5cbiAgICBodG1sLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBLb252YS5ERC5fZW5kRHJhZ0FmdGVyLCBmYWxzZSk7XG4gICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIEtvbnZhLkRELl9lbmREcmFnQWZ0ZXIsIGZhbHNlKTtcbiAgfVxufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIC8qKlxuICAgICAqIFJlY3QgY29uc3RydWN0b3JcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKiBAYXVnbWVudHMgS29udmEuU2hhcGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY29ybmVyUmFkaXVzXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxdIGZpbGwgY29sb3JcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBbY29uZmlnLmZpbGxQYXR0ZXJuSW1hZ2VdIGZpbGwgcGF0dGVybiBpbWFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFldIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5Sb3RhdGlvbl1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUGF0dGVyblJlcGVhdF0gY2FuIGJlIFwicmVwZWF0XCIsIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiAgVGhlIGRlZmF1bHQgaXMgXCJuby1yZXBlYXRcIlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WV0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZmlsbEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZmlsbC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUHJpb3JpdHldIGNhbiBiZSBjb2xvciwgbGluZWFyLWdyYWRpZW50LCByYWRpYWwtZ3JhaWRlbnQsIG9yIHBhdHRlcm4uICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBjb2xvci4gIFRoZSBmaWxsUHJpb3JpdHkgcHJvcGVydHkgbWFrZXMgaXQgcmVhbGx5IGVhc3kgdG8gdG9nZ2xlIGJldHdlZW4gZGlmZmVyZW50IGZpbGwgdHlwZXMuICBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gdG9nZ2xlIGJldHdlZW4gYSBmaWxsIGNvbG9yIHN0eWxlIGFuZCBhIGZpbGwgcGF0dGVybiBzdHlsZSwgc2ltcGx5IHNldCB0aGUgZmlsbCBwcm9wZXJ0eSBhbmQgdGhlIGZpbGxQYXR0ZXJuIHByb3BlcnRpZXMsIGFuZCB0aGVuIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ2NvbG9yJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIGEgY29sb3IgZmlsbCwgb3IgdXNlIHNldEZpbGxQcmlvcml0eSgncGF0dGVybicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCB0aGUgcGF0dGVybiBmaWxsIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zdHJva2VdIHN0cm9rZSBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnN0cm9rZVdpZHRoXSBzdHJva2Ugd2lkdGhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlSGl0RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBoaXQgcmVnaW9uLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5wZXJmZWN0RHJhd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB1c2luZyBidWZmZXIgY2FudmFzLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dGb3JTdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc2hhc293IGZvciBzdHJva2UuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZVNjYWxlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBzY2FsZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzdHJva2UuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUpvaW5dIGNhbiBiZSBtaXRlciwgcm91bmQsIG9yIGJldmVsLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgbWl0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lQ2FwXSBjYW4gYmUgYnV0dCwgcm91bmQsIG9yIHNxYXJlLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgYnV0dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnNoYWRvd0NvbG9yXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd0JsdXJdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2hhZG93T2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPcGFjaXR5XSBzaGFkb3cgb3BhY2l0eS4gIENhbiBiZSBhbnkgcmVhbCBudW1iZXJcbiAgICAgKiAgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2hhZG93LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZGFzaF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZGFzaEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZGFzaEFycmF5LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgcmVjdCA9IG5ldyBLb252YS5SZWN0KHtcbiAgICAgKiAgIHdpZHRoOiAxMDAsXG4gICAgICogICBoZWlnaHQ6IDUwLFxuICAgICAqICAgZmlsbDogJ3JlZCcsXG4gICAgICogICBzdHJva2U6ICdibGFjaycsXG4gICAgICogICBzdHJva2VXaWR0aDogNVxuICAgICAqIH0pO1xuICAgICAqL1xuICBLb252YS5SZWN0ID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gIH07XG5cbiAgS29udmEuUmVjdC5wcm90b3R5cGUgPSB7XG4gICAgX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICBLb252YS5TaGFwZS5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdSZWN0JztcbiAgICAgIHRoaXMuc2NlbmVGdW5jKHRoaXMuX3NjZW5lRnVuYyk7XG4gICAgfSxcbiAgICBfc2NlbmVGdW5jOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICB2YXIgY29ybmVyUmFkaXVzID0gdGhpcy5nZXRDb3JuZXJSYWRpdXMoKSxcbiAgICAgICAgd2lkdGggPSB0aGlzLmdldFdpZHRoKCksXG4gICAgICAgIGhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KCk7XG5cbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG5cbiAgICAgIGlmICghY29ybmVyUmFkaXVzKSB7XG4gICAgICAgIC8vIHNpbXBsZSByZWN0IC0gZG9uJ3QgYm90aGVyIGRvaW5nIGFsbCB0aGF0IGNvbXBsaWNhdGVkIG1hdGhzIHN0dWZmLlxuICAgICAgICBjb250ZXh0LnJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBhcmNUbyB3b3VsZCBiZSBuaWNlciwgYnV0IGJyb3dzZXIgc3VwcG9ydCBpcyBwYXRjaHkgKE9wZXJhKVxuICAgICAgICBjb3JuZXJSYWRpdXMgPSBNYXRoLm1pbihjb3JuZXJSYWRpdXMsIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKGNvcm5lclJhZGl1cywgMCk7XG4gICAgICAgIGNvbnRleHQubGluZVRvKHdpZHRoIC0gY29ybmVyUmFkaXVzLCAwKTtcbiAgICAgICAgY29udGV4dC5hcmMoXG4gICAgICAgICAgd2lkdGggLSBjb3JuZXJSYWRpdXMsXG4gICAgICAgICAgY29ybmVyUmFkaXVzLFxuICAgICAgICAgIGNvcm5lclJhZGl1cyxcbiAgICAgICAgICBNYXRoLlBJICogMyAvIDIsXG4gICAgICAgICAgMCxcbiAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh3aWR0aCwgaGVpZ2h0IC0gY29ybmVyUmFkaXVzKTtcbiAgICAgICAgY29udGV4dC5hcmMoXG4gICAgICAgICAgd2lkdGggLSBjb3JuZXJSYWRpdXMsXG4gICAgICAgICAgaGVpZ2h0IC0gY29ybmVyUmFkaXVzLFxuICAgICAgICAgIGNvcm5lclJhZGl1cyxcbiAgICAgICAgICAwLFxuICAgICAgICAgIE1hdGguUEkgLyAyLFxuICAgICAgICAgIGZhbHNlXG4gICAgICAgICk7XG4gICAgICAgIGNvbnRleHQubGluZVRvKGNvcm5lclJhZGl1cywgaGVpZ2h0KTtcbiAgICAgICAgY29udGV4dC5hcmMoXG4gICAgICAgICAgY29ybmVyUmFkaXVzLFxuICAgICAgICAgIGhlaWdodCAtIGNvcm5lclJhZGl1cyxcbiAgICAgICAgICBjb3JuZXJSYWRpdXMsXG4gICAgICAgICAgTWF0aC5QSSAvIDIsXG4gICAgICAgICAgTWF0aC5QSSxcbiAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuICAgICAgICBjb250ZXh0LmxpbmVUbygwLCBjb3JuZXJSYWRpdXMpO1xuICAgICAgICBjb250ZXh0LmFyYyhcbiAgICAgICAgICBjb3JuZXJSYWRpdXMsXG4gICAgICAgICAgY29ybmVyUmFkaXVzLFxuICAgICAgICAgIGNvcm5lclJhZGl1cyxcbiAgICAgICAgICBNYXRoLlBJLFxuICAgICAgICAgIE1hdGguUEkgKiAzIC8gMixcbiAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgIH1cbiAgfTtcblxuICBLb252YS5VdGlsLmV4dGVuZChLb252YS5SZWN0LCBLb252YS5TaGFwZSk7XG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuUmVjdCwgJ2Nvcm5lclJhZGl1cycsIDApO1xuICAvKipcbiAgICAgKiBnZXQvc2V0IGNvcm5lciByYWRpdXNcbiAgICAgKiBAbmFtZSBjb3JuZXJSYWRpdXNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlJlY3QucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvcm5lclJhZGl1c1xuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgY29ybmVyIHJhZGl1c1xuICAgICAqIHZhciBjb3JuZXJSYWRpdXMgPSByZWN0LmNvcm5lclJhZGl1cygpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGNvcm5lciByYWRpdXNcbiAgICAgKiByZWN0LmNvcm5lclJhZGl1cygxMCk7XG4gICAgICovXG5cbiAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLlJlY3QpO1xufSkoKTtcblxuKGZ1bmN0aW9uKEtvbnZhKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLy8gdGhlIDAuMDAwMSBvZmZzZXQgZml4ZXMgYSBidWcgaW4gQ2hyb21lIDI3XG4gIHZhciBQSXgyID0gTWF0aC5QSSAqIDIgLSAwLjAwMDEsIENJUkNMRSA9ICdDaXJjbGUnO1xuXG4gIC8qKlxuICAgICAqIENpcmNsZSBjb25zdHJ1Y3RvclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBhdWdtZW50cyBLb252YS5TaGFwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLnJhZGl1c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxdIGZpbGwgY29sb3JcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBbY29uZmlnLmZpbGxQYXR0ZXJuSW1hZ2VdIGZpbGwgcGF0dGVybiBpbWFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFldIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5Sb3RhdGlvbl1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUGF0dGVyblJlcGVhdF0gY2FuIGJlIFwicmVwZWF0XCIsIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiAgVGhlIGRlZmF1bHQgaXMgXCJuby1yZXBlYXRcIlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WV0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZmlsbEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZmlsbC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUHJpb3JpdHldIGNhbiBiZSBjb2xvciwgbGluZWFyLWdyYWRpZW50LCByYWRpYWwtZ3JhaWRlbnQsIG9yIHBhdHRlcm4uICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBjb2xvci4gIFRoZSBmaWxsUHJpb3JpdHkgcHJvcGVydHkgbWFrZXMgaXQgcmVhbGx5IGVhc3kgdG8gdG9nZ2xlIGJldHdlZW4gZGlmZmVyZW50IGZpbGwgdHlwZXMuICBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gdG9nZ2xlIGJldHdlZW4gYSBmaWxsIGNvbG9yIHN0eWxlIGFuZCBhIGZpbGwgcGF0dGVybiBzdHlsZSwgc2ltcGx5IHNldCB0aGUgZmlsbCBwcm9wZXJ0eSBhbmQgdGhlIGZpbGxQYXR0ZXJuIHByb3BlcnRpZXMsIGFuZCB0aGVuIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ2NvbG9yJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIGEgY29sb3IgZmlsbCwgb3IgdXNlIHNldEZpbGxQcmlvcml0eSgncGF0dGVybicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCB0aGUgcGF0dGVybiBmaWxsIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zdHJva2VdIHN0cm9rZSBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnN0cm9rZVdpZHRoXSBzdHJva2Ugd2lkdGhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlSGl0RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBoaXQgcmVnaW9uLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5wZXJmZWN0RHJhd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB1c2luZyBidWZmZXIgY2FudmFzLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dGb3JTdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc2hhc293IGZvciBzdHJva2UuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZVNjYWxlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBzY2FsZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzdHJva2UuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUpvaW5dIGNhbiBiZSBtaXRlciwgcm91bmQsIG9yIGJldmVsLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgbWl0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lQ2FwXSBjYW4gYmUgYnV0dCwgcm91bmQsIG9yIHNxYXJlLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgYnV0dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnNoYWRvd0NvbG9yXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd0JsdXJdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2hhZG93T2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPcGFjaXR5XSBzaGFkb3cgb3BhY2l0eS4gIENhbiBiZSBhbnkgcmVhbCBudW1iZXJcbiAgICAgKiAgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2hhZG93LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZGFzaF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZGFzaEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZGFzaEFycmF5LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBjcmVhdGUgY2lyY2xlXG4gICAgICogdmFyIGNpcmNsZSA9IG5ldyBLb252YS5DaXJjbGUoe1xuICAgICAqICAgcmFkaXVzOiA0MCxcbiAgICAgKiAgIGZpbGw6ICdyZWQnLFxuICAgICAqICAgc3Ryb2tlOiAnYmxhY2snXG4gICAgICogICBzdHJva2VXaWR0aDogNVxuICAgICAqIH0pO1xuICAgICAqL1xuICBLb252YS5DaXJjbGUgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICB0aGlzLl9fX2luaXQoY29uZmlnKTtcbiAgfTtcblxuICBLb252YS5DaXJjbGUucHJvdG90eXBlID0ge1xuICAgIF9jZW50cm9pZDogdHJ1ZSxcbiAgICBfX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgIEtvbnZhLlNoYXBlLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gQ0lSQ0xFO1xuICAgICAgdGhpcy5zY2VuZUZ1bmModGhpcy5fc2NlbmVGdW5jKTtcbiAgICB9LFxuICAgIF9zY2VuZUZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBjb250ZXh0LmFyYygwLCAwLCB0aGlzLmdldFJhZGl1cygpLCAwLCBQSXgyLCBmYWxzZSk7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgfSxcbiAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5nZXRXaWR0aCgpXG4gICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UmFkaXVzKCkgKiAyO1xuICAgIH0sXG4gICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuZ2V0SGVpZ2h0KClcbiAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UmFkaXVzKCkgKiAyO1xuICAgIH0sXG4gICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuc2V0V2lkdGgoKVxuICAgIHNldFdpZHRoOiBmdW5jdGlvbih3aWR0aCkge1xuICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0V2lkdGguY2FsbCh0aGlzLCB3aWR0aCk7XG4gICAgICBpZiAodGhpcy5yYWRpdXMoKSAhPT0gd2lkdGggLyAyKSB7XG4gICAgICAgIHRoaXMuc2V0UmFkaXVzKHdpZHRoIC8gMik7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5zZXRIZWlnaHQoKVxuICAgIHNldEhlaWdodDogZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRIZWlnaHQuY2FsbCh0aGlzLCBoZWlnaHQpO1xuICAgICAgaWYgKHRoaXMucmFkaXVzKCkgIT09IGhlaWdodCAvIDIpIHtcbiAgICAgICAgdGhpcy5zZXRSYWRpdXMoaGVpZ2h0IC8gMik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBLb252YS5VdGlsLmV4dGVuZChLb252YS5DaXJjbGUsIEtvbnZhLlNoYXBlKTtcblxuICAvLyBhZGQgZ2V0dGVycyBzZXR0ZXJzXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkNpcmNsZSwgJ3JhZGl1cycsIDApO1xuICBLb252YS5GYWN0b3J5LmFkZE92ZXJsb2FkZWRHZXR0ZXJTZXR0ZXIoS29udmEuQ2lyY2xlLCAncmFkaXVzJyk7XG5cbiAgLyoqXG4gICAgICogZ2V0L3NldCByYWRpdXNcbiAgICAgKiBAbmFtZSByYWRpdXNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkNpcmNsZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCByYWRpdXNcbiAgICAgKiB2YXIgcmFkaXVzID0gY2lyY2xlLnJhZGl1cygpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHJhZGl1c1xuICAgICAqIGNpcmNsZS5yYWRpdXMoMTApO1xuICAgICAqL1xuXG4gIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5DaXJjbGUpO1xufSkoS29udmEpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLy8gdGhlIDAuMDAwMSBvZmZzZXQgZml4ZXMgYSBidWcgaW4gQ2hyb21lIDI3XG4gIHZhciBQSXgyID0gTWF0aC5QSSAqIDIgLSAwLjAwMDEsIEVMTElQU0UgPSAnRWxsaXBzZSc7XG5cbiAgLyoqXG4gICAgICogRWxsaXBzZSBjb25zdHJ1Y3RvclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBhdWdtZW50cyBLb252YS5TaGFwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnLnJhZGl1cyBkZWZpbmVzIHggYW5kIHkgcmFkaXVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbF0gZmlsbCBjb2xvclxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IFtjb25maWcuZmlsbFBhdHRlcm5JbWFnZV0gZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5YXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WV0gXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZV0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblJvdGF0aW9uXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQYXR0ZXJuUmVwZWF0XSBjYW4gYmUgXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuICBUaGUgZGVmYXVsdCBpcyBcIm5vLXJlcGVhdFwiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5maWxsRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBmaWxsLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQcmlvcml0eV0gY2FuIGJlIGNvbG9yLCBsaW5lYXItZ3JhZGllbnQsIHJhZGlhbC1ncmFpZGVudCwgb3IgcGF0dGVybi4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGNvbG9yLiAgVGhlIGZpbGxQcmlvcml0eSBwcm9wZXJ0eSBtYWtlcyBpdCByZWFsbHkgZWFzeSB0byB0b2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgZmlsbCB0eXBlcy4gIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byB0b2dnbGUgYmV0d2VlbiBhIGZpbGwgY29sb3Igc3R5bGUgYW5kIGEgZmlsbCBwYXR0ZXJuIHN0eWxlLCBzaW1wbHkgc2V0IHRoZSBmaWxsIHByb3BlcnR5IGFuZCB0aGUgZmlsbFBhdHRlcm4gcHJvcGVydGllcywgYW5kIHRoZW4gdXNlIHNldEZpbGxQcmlvcml0eSgnY29sb3InKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggYSBjb2xvciBmaWxsLCBvciB1c2Ugc2V0RmlsbFByaW9yaXR5KCdwYXR0ZXJuJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIHRoZSBwYXR0ZXJuIGZpbGwgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnN0cm9rZV0gc3Ryb2tlIGNvbG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc3Ryb2tlV2lkdGhdIHN0cm9rZSB3aWR0aFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VIaXRFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIGhpdCByZWdpb24uICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnBlcmZlY3REcmF3RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHVzaW5nIGJ1ZmZlciBjYW52YXMuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzaGFzb3cgZm9yIHN0cm9rZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlU2NhbGVFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIHNjYWxlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHN0cm9rZS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lSm9pbl0gY2FuIGJlIG1pdGVyLCByb3VuZCwgb3IgYmV2ZWwuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBtaXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVDYXBdIGNhbiBiZSBidXR0LCByb3VuZCwgb3Igc3FhcmUuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBidXR0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc2hhZG93Q29sb3JdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93Qmx1cl1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zaGFkb3dPZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09wYWNpdHldIHNoYWRvdyBvcGFjaXR5LiAgQ2FuIGJlIGFueSByZWFsIG51bWJlclxuICAgICAqICBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzaGFkb3cuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5kYXNoXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kYXNoRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBkYXNoQXJyYXkuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBlbGxpcHNlID0gbmV3IEtvbnZhLkVsbGlwc2Uoe1xuICAgICAqICAgcmFkaXVzIDoge1xuICAgICAqICAgICB4IDogNTAsXG4gICAgICogICAgIHkgOiA1MFxuICAgICAqICAgfSxcbiAgICAgKiAgIGZpbGw6ICdyZWQnXG4gICAgICogfSk7XG4gICAgICovXG4gIEtvbnZhLkVsbGlwc2UgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICB0aGlzLl9fX2luaXQoY29uZmlnKTtcbiAgfTtcblxuICBLb252YS5FbGxpcHNlLnByb3RvdHlwZSA9IHtcbiAgICBfY2VudHJvaWQ6IHRydWUsXG4gICAgX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXG4gICAgICBLb252YS5TaGFwZS5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgICB0aGlzLmNsYXNzTmFtZSA9IEVMTElQU0U7XG4gICAgICB0aGlzLnNjZW5lRnVuYyh0aGlzLl9zY2VuZUZ1bmMpO1xuICAgIH0sXG4gICAgX3NjZW5lRnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgdmFyIHJ4ID0gdGhpcy5nZXRSYWRpdXNYKCksIHJ5ID0gdGhpcy5nZXRSYWRpdXNZKCk7XG5cbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgIGlmIChyeCAhPT0gcnkpIHtcbiAgICAgICAgY29udGV4dC5zY2FsZSgxLCByeSAvIHJ4KTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHJ4LCAwLCBQSXgyLCBmYWxzZSk7XG4gICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICB9LFxuICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLmdldFdpZHRoKClcbiAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRSYWRpdXNYKCkgKiAyO1xuICAgIH0sXG4gICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuZ2V0SGVpZ2h0KClcbiAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UmFkaXVzWSgpICogMjtcbiAgICB9LFxuICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLnNldFdpZHRoKClcbiAgICBzZXRXaWR0aDogZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldFdpZHRoLmNhbGwodGhpcywgd2lkdGgpO1xuICAgICAgdGhpcy5zZXRSYWRpdXMoe1xuICAgICAgICB4OiB3aWR0aCAvIDJcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuc2V0SGVpZ2h0KClcbiAgICBzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0SGVpZ2h0LmNhbGwodGhpcywgaGVpZ2h0KTtcbiAgICAgIHRoaXMuc2V0UmFkaXVzKHtcbiAgICAgICAgeTogaGVpZ2h0IC8gMlxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBLb252YS5VdGlsLmV4dGVuZChLb252YS5FbGxpcHNlLCBLb252YS5TaGFwZSk7XG5cbiAgLy8gYWRkIGdldHRlcnMgc2V0dGVyc1xuICBLb252YS5GYWN0b3J5LmFkZENvbXBvbmVudHNHZXR0ZXJTZXR0ZXIoS29udmEuRWxsaXBzZSwgJ3JhZGl1cycsIFsneCcsICd5J10pO1xuXG4gIC8qKlxuICAgICAqIGdldC9zZXQgcmFkaXVzXG4gICAgICogQG5hbWUgcmFkaXVzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5FbGxpcHNlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByYWRpdXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzLnhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzLnlcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHJhZGl1c1xuICAgICAqIHZhciByYWRpdXMgPSBlbGxpcHNlLnJhZGl1cygpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHJhZGl1c1xuICAgICAqIGVsbGlwc2UucmFkaXVzKHtcbiAgICAgKiAgIHg6IDIwMCxcbiAgICAgKiAgIHk6IDEwMFxuICAgICAqIH0pO1xuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkVsbGlwc2UsICdyYWRpdXNYJywgMCk7XG4gIC8qKlxuICAgICAqIGdldC9zZXQgcmFkaXVzIHhcbiAgICAgKiBAbmFtZSByYWRpdXNYXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5FbGxpcHNlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCByYWRpdXMgeFxuICAgICAqIHZhciByYWRpdXNYID0gZWxsaXBzZS5yYWRpdXNYKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgcmFkaXVzIHhcbiAgICAgKiBlbGxpcHNlLnJhZGl1c1goMjAwKTtcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5FbGxpcHNlLCAncmFkaXVzWScsIDApO1xuICAvKipcbiAgICAgKiBnZXQvc2V0IHJhZGl1cyB5XG4gICAgICogQG5hbWUgcmFkaXVzWVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRWxsaXBzZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgcmFkaXVzIHlcbiAgICAgKiB2YXIgcmFkaXVzWSA9IGVsbGlwc2UucmFkaXVzWSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHJhZGl1cyB5XG4gICAgICogZWxsaXBzZS5yYWRpdXNZKDIwMCk7XG4gICAgICovXG5cbiAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLkVsbGlwc2UpO1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIC8vIHRoZSAwLjAwMDEgb2Zmc2V0IGZpeGVzIGEgYnVnIGluIENocm9tZSAyN1xuICB2YXIgUEl4MiA9IE1hdGguUEkgKiAyIC0gMC4wMDAxO1xuICAvKipcbiAgICAgKiBSaW5nIGNvbnN0cnVjdG9yXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcuaW5uZXJSYWRpdXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLm91dGVyUmFkaXVzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmNsb2Nrd2lzZV1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsXSBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW2NvbmZpZy5maWxsUGF0dGVybkltYWdlXSBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5ZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRZXSBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlXSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuUm90YXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFBhdHRlcm5SZXBlYXRdIGNhbiBiZSBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gIFRoZSBkZWZhdWx0IGlzIFwibm8tcmVwZWF0XCJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFldXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFldIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZpbGxFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZpbGwuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFByaW9yaXR5XSBjYW4gYmUgY29sb3IsIGxpbmVhci1ncmFkaWVudCwgcmFkaWFsLWdyYWlkZW50LCBvciBwYXR0ZXJuLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgY29sb3IuICBUaGUgZmlsbFByaW9yaXR5IHByb3BlcnR5IG1ha2VzIGl0IHJlYWxseSBlYXN5IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGEgZmlsbCBjb2xvciBzdHlsZSBhbmQgYSBmaWxsIHBhdHRlcm4gc3R5bGUsIHNpbXBseSBzZXQgdGhlIGZpbGwgcHJvcGVydHkgYW5kIHRoZSBmaWxsUGF0dGVybiBwcm9wZXJ0aWVzLCBhbmQgdGhlbiB1c2Ugc2V0RmlsbFByaW9yaXR5KCdjb2xvcicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCBhIGNvbG9yIGZpbGwsIG9yIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ3BhdHRlcm4nKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggdGhlIHBhdHRlcm4gZmlsbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc3Ryb2tlXSBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdHJva2VXaWR0aF0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUhpdEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2UgaGl0IHJlZ2lvbi4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucGVyZmVjdERyYXdFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdXNpbmcgYnVmZmVyIGNhbnZhcy4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXNvdyBmb3Igc3Ryb2tlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VTY2FsZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2Ugc2NhbGUuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc3Ryb2tlLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVKb2luXSBjYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIG1pdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUNhcF0gY2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcWFyZS4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIGJ1dHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaGFkb3dDb2xvcl1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dCbHVyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNoYWRvd09mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T3BhY2l0eV0gc2hhZG93IG9wYWNpdHkuICBDYW4gYmUgYW55IHJlYWwgbnVtYmVyXG4gICAgICogIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRhc2hdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRhc2hFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGRhc2hBcnJheS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIHJpbmcgPSBuZXcgS29udmEuUmluZyh7XG4gICAgICogICBpbm5lclJhZGl1czogNDAsXG4gICAgICogICBvdXRlclJhZGl1czogODAsXG4gICAgICogICBmaWxsOiAncmVkJyxcbiAgICAgKiAgIHN0cm9rZTogJ2JsYWNrJyxcbiAgICAgKiAgIHN0cm9rZVdpZHRoOiA1XG4gICAgICogfSk7XG4gICAgICovXG4gIEtvbnZhLlJpbmcgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICB0aGlzLl9fX2luaXQoY29uZmlnKTtcbiAgfTtcblxuICBLb252YS5SaW5nLnByb3RvdHlwZSA9IHtcbiAgICBfY2VudHJvaWQ6IHRydWUsXG4gICAgX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXG4gICAgICBLb252YS5TaGFwZS5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdSaW5nJztcbiAgICAgIHRoaXMuc2NlbmVGdW5jKHRoaXMuX3NjZW5lRnVuYyk7XG4gICAgfSxcbiAgICBfc2NlbmVGdW5jOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgY29udGV4dC5hcmMoMCwgMCwgdGhpcy5nZXRJbm5lclJhZGl1cygpLCAwLCBQSXgyLCBmYWxzZSk7XG4gICAgICBjb250ZXh0Lm1vdmVUbyh0aGlzLmdldE91dGVyUmFkaXVzKCksIDApO1xuICAgICAgY29udGV4dC5hcmMoMCwgMCwgdGhpcy5nZXRPdXRlclJhZGl1cygpLCBQSXgyLCAwLCB0cnVlKTtcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICB9LFxuICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLmdldFdpZHRoKClcbiAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRPdXRlclJhZGl1cygpICogMjtcbiAgICB9LFxuICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLmdldEhlaWdodCgpXG4gICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE91dGVyUmFkaXVzKCkgKiAyO1xuICAgIH0sXG4gICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuc2V0V2lkdGgoKVxuICAgIHNldFdpZHRoOiBmdW5jdGlvbih3aWR0aCkge1xuICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0V2lkdGguY2FsbCh0aGlzLCB3aWR0aCk7XG4gICAgICBpZiAodGhpcy5vdXRlclJhZGl1cygpICE9PSB3aWR0aCAvIDIpIHtcbiAgICAgICAgdGhpcy5zZXRPdXRlclJhZGl1cyh3aWR0aCAvIDIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuc2V0SGVpZ2h0KClcbiAgICBzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0SGVpZ2h0LmNhbGwodGhpcywgaGVpZ2h0KTtcbiAgICAgIGlmICh0aGlzLm91dGVyUmFkaXVzKCkgIT09IGhlaWdodCAvIDIpIHtcbiAgICAgICAgdGhpcy5zZXRPdXRlclJhZGl1cyhoZWlnaHQgLyAyKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldE91dGVyUmFkaXVzOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHRoaXMuX3NldEF0dHIoJ291dGVyUmFkaXVzJywgdmFsKTtcbiAgICAgIHRoaXMuc2V0V2lkdGgodmFsICogMik7XG4gICAgICB0aGlzLnNldEhlaWdodCh2YWwgKiAyKTtcbiAgICB9XG4gIH07XG4gIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLlJpbmcsIEtvbnZhLlNoYXBlKTtcblxuICAvLyBhZGQgZ2V0dGVycyBzZXR0ZXJzXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlJpbmcsICdpbm5lclJhZGl1cycsIDApO1xuXG4gIC8qKlxuICAgICAqIGdldC9zZXQgaW5uZXJSYWRpdXNcbiAgICAgKiBAbmFtZSBpbm5lclJhZGl1c1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuUmluZy5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5uZXJSYWRpdXNcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGlubmVyIHJhZGl1c1xuICAgICAqIHZhciBpbm5lclJhZGl1cyA9IHJpbmcuaW5uZXJSYWRpdXMoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBpbm5lciByYWRpdXNcbiAgICAgKiByaW5nLmlubmVyUmFkaXVzKDIwKTtcbiAgICAgKi9cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXIoS29udmEuUmluZywgJ291dGVyUmFkaXVzJywgMCk7XG4gIEtvbnZhLkZhY3RvcnkuYWRkT3ZlcmxvYWRlZEdldHRlclNldHRlcihLb252YS5SaW5nLCAnb3V0ZXJSYWRpdXMnKTtcblxuICAvKipcbiAgICAgKiBnZXQvc2V0IG91dGVyUmFkaXVzXG4gICAgICogQG5hbWUgb3V0ZXJSYWRpdXNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlJpbmcucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG91dGVyUmFkaXVzXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBvdXRlciByYWRpdXNcbiAgICAgKiB2YXIgb3V0ZXJSYWRpdXMgPSByaW5nLm91dGVyUmFkaXVzKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgb3V0ZXIgcmFkaXVzXG4gICAgICogcmluZy5vdXRlclJhZGl1cygyMCk7XG4gICAgICovXG5cbiAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLlJpbmcpO1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIC8qKlxuICAgICAqIFdlZGdlIGNvbnN0cnVjdG9yXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcuYW5nbGUgaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcucmFkaXVzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmNsb2Nrd2lzZV1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsXSBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW2NvbmZpZy5maWxsUGF0dGVybkltYWdlXSBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5ZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRZXSBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlXSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuUm90YXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFBhdHRlcm5SZXBlYXRdIGNhbiBiZSBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gIFRoZSBkZWZhdWx0IGlzIFwibm8tcmVwZWF0XCJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFldXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFldIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZpbGxFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZpbGwuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFByaW9yaXR5XSBjYW4gYmUgY29sb3IsIGxpbmVhci1ncmFkaWVudCwgcmFkaWFsLWdyYWlkZW50LCBvciBwYXR0ZXJuLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgY29sb3IuICBUaGUgZmlsbFByaW9yaXR5IHByb3BlcnR5IG1ha2VzIGl0IHJlYWxseSBlYXN5IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGEgZmlsbCBjb2xvciBzdHlsZSBhbmQgYSBmaWxsIHBhdHRlcm4gc3R5bGUsIHNpbXBseSBzZXQgdGhlIGZpbGwgcHJvcGVydHkgYW5kIHRoZSBmaWxsUGF0dGVybiBwcm9wZXJ0aWVzLCBhbmQgdGhlbiB1c2Ugc2V0RmlsbFByaW9yaXR5KCdjb2xvcicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCBhIGNvbG9yIGZpbGwsIG9yIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ3BhdHRlcm4nKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggdGhlIHBhdHRlcm4gZmlsbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc3Ryb2tlXSBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdHJva2VXaWR0aF0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUhpdEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2UgaGl0IHJlZ2lvbi4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucGVyZmVjdERyYXdFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdXNpbmcgYnVmZmVyIGNhbnZhcy4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXNvdyBmb3Igc3Ryb2tlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VTY2FsZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2Ugc2NhbGUuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc3Ryb2tlLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVKb2luXSBjYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIG1pdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUNhcF0gY2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcWFyZS4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIGJ1dHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaGFkb3dDb2xvcl1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dCbHVyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNoYWRvd09mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T3BhY2l0eV0gc2hhZG93IG9wYWNpdHkuICBDYW4gYmUgYW55IHJlYWwgbnVtYmVyXG4gICAgICogIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRhc2hdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRhc2hFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGRhc2hBcnJheS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZHJhdyBhIHdlZGdlIHRoYXQncyBwb2ludGluZyBkb3dud2FyZHNcbiAgICAgKiB2YXIgd2VkZ2UgPSBuZXcgS29udmEuV2VkZ2Uoe1xuICAgICAqICAgcmFkaXVzOiA0MCxcbiAgICAgKiAgIGZpbGw6ICdyZWQnLFxuICAgICAqICAgc3Ryb2tlOiAnYmxhY2snXG4gICAgICogICBzdHJva2VXaWR0aDogNSxcbiAgICAgKiAgIGFuZ2xlRGVnOiA2MCxcbiAgICAgKiAgIHJvdGF0aW9uRGVnOiAtMTIwXG4gICAgICogfSk7XG4gICAgICovXG4gIEtvbnZhLldlZGdlID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gIH07XG5cbiAgS29udmEuV2VkZ2UucHJvdG90eXBlID0ge1xuICAgIF9jZW50cm9pZDogdHJ1ZSxcbiAgICBfX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgIEtvbnZhLlNoYXBlLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ1dlZGdlJztcbiAgICAgIHRoaXMuc2NlbmVGdW5jKHRoaXMuX3NjZW5lRnVuYyk7XG4gICAgfSxcbiAgICBfc2NlbmVGdW5jOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgY29udGV4dC5hcmMoXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIHRoaXMuZ2V0UmFkaXVzKCksXG4gICAgICAgIDAsXG4gICAgICAgIEtvbnZhLmdldEFuZ2xlKHRoaXMuZ2V0QW5nbGUoKSksXG4gICAgICAgIHRoaXMuZ2V0Q2xvY2t3aXNlKClcbiAgICAgICk7XG4gICAgICBjb250ZXh0LmxpbmVUbygwLCAwKTtcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICB9LFxuICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLmdldFdpZHRoKClcbiAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRSYWRpdXMoKSAqIDI7XG4gICAgfSxcbiAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5nZXRIZWlnaHQoKVxuICAgIGdldEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRSYWRpdXMoKSAqIDI7XG4gICAgfSxcbiAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5zZXRXaWR0aCgpXG4gICAgc2V0V2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XG4gICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRXaWR0aC5jYWxsKHRoaXMsIHdpZHRoKTtcbiAgICAgIGlmICh0aGlzLnJhZGl1cygpICE9PSB3aWR0aCAvIDIpIHtcbiAgICAgICAgdGhpcy5zZXRSYWRpdXMod2lkdGggLyAyKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLnNldEhlaWdodCgpXG4gICAgc2V0SGVpZ2h0OiBmdW5jdGlvbihoZWlnaHQpIHtcbiAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldEhlaWdodC5jYWxsKHRoaXMsIGhlaWdodCk7XG4gICAgICBpZiAodGhpcy5yYWRpdXMoKSAhPT0gaGVpZ2h0IC8gMikge1xuICAgICAgICB0aGlzLnNldFJhZGl1cyhoZWlnaHQgLyAyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLldlZGdlLCBLb252YS5TaGFwZSk7XG5cbiAgLy8gYWRkIGdldHRlcnMgc2V0dGVyc1xuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5XZWRnZSwgJ3JhZGl1cycsIDApO1xuXG4gIC8qKlxuICAgICAqIGdldC9zZXQgcmFkaXVzXG4gICAgICogQG5hbWUgcmFkaXVzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5XZWRnZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCByYWRpdXNcbiAgICAgKiB2YXIgcmFkaXVzID0gd2VkZ2UucmFkaXVzKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgcmFkaXVzXG4gICAgICogd2VkZ2UucmFkaXVzKDEwKTtcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5XZWRnZSwgJ2FuZ2xlJywgMCk7XG5cbiAgLyoqXG4gICAgICogZ2V0L3NldCBhbmdsZSBpbiBkZWdyZWVzXG4gICAgICogQG5hbWUgYW5nbGVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLldlZGdlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgYW5nbGVcbiAgICAgKiB2YXIgYW5nbGUgPSB3ZWRnZS5hbmdsZSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGFuZ2xlXG4gICAgICogd2VkZ2UuYW5nbGUoMjApO1xuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLldlZGdlLCAnY2xvY2t3aXNlJywgZmFsc2UpO1xuXG4gIC8qKlxuICAgICAqIGdldC9zZXQgY2xvY2t3aXNlIGZsYWdcbiAgICAgKiBAbmFtZSBjbG9ja3dpc2VcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLldlZGdlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjbG9ja3dpc2VcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGNsb2Nrd2lzZSBmbGFnXG4gICAgICogdmFyIGNsb2Nrd2lzZSA9IHdlZGdlLmNsb2Nrd2lzZSgpO1xuICAgICAqXG4gICAgICogLy8gZHJhdyB3ZWRnZSBjb3VudGVyLWNsb2Nrd2lzZVxuICAgICAqIHdlZGdlLmNsb2Nrd2lzZShmYWxzZSk7XG4gICAgICpcbiAgICAgKiAvLyBkcmF3IHdlZGdlIGNsb2Nrd2lzZVxuICAgICAqIHdlZGdlLmNsb2Nrd2lzZSh0cnVlKTtcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmJhY2tDb21wYXQoS29udmEuV2VkZ2UsIHtcbiAgICBhbmdsZURlZzogJ2FuZ2xlJyxcbiAgICBnZXRBbmdsZURlZzogJ2dldEFuZ2xlJyxcbiAgICBzZXRBbmdsZURlZzogJ3NldEFuZ2xlJ1xuICB9KTtcblxuICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuV2VkZ2UpO1xufSkoKTtcblxuKGZ1bmN0aW9uKEtvbnZhKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLyoqXG4gICAgICogQXJjIGNvbnN0cnVjdG9yXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcuYW5nbGUgaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcuaW5uZXJSYWRpdXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLm91dGVyUmFkaXVzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmNsb2Nrd2lzZV1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsXSBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW2NvbmZpZy5maWxsUGF0dGVybkltYWdlXSBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5ZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRZXSBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlXSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuUm90YXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFBhdHRlcm5SZXBlYXRdIGNhbiBiZSBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gIFRoZSBkZWZhdWx0IGlzIFwibm8tcmVwZWF0XCJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFldXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFldIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZpbGxFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZpbGwuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFByaW9yaXR5XSBjYW4gYmUgY29sb3IsIGxpbmVhci1ncmFkaWVudCwgcmFkaWFsLWdyYWlkZW50LCBvciBwYXR0ZXJuLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgY29sb3IuICBUaGUgZmlsbFByaW9yaXR5IHByb3BlcnR5IG1ha2VzIGl0IHJlYWxseSBlYXN5IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGEgZmlsbCBjb2xvciBzdHlsZSBhbmQgYSBmaWxsIHBhdHRlcm4gc3R5bGUsIHNpbXBseSBzZXQgdGhlIGZpbGwgcHJvcGVydHkgYW5kIHRoZSBmaWxsUGF0dGVybiBwcm9wZXJ0aWVzLCBhbmQgdGhlbiB1c2Ugc2V0RmlsbFByaW9yaXR5KCdjb2xvcicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCBhIGNvbG9yIGZpbGwsIG9yIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ3BhdHRlcm4nKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggdGhlIHBhdHRlcm4gZmlsbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc3Ryb2tlXSBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdHJva2VXaWR0aF0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUhpdEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2UgaGl0IHJlZ2lvbi4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucGVyZmVjdERyYXdFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdXNpbmcgYnVmZmVyIGNhbnZhcy4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXNvdyBmb3Igc3Ryb2tlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VTY2FsZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2Ugc2NhbGUuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc3Ryb2tlLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVKb2luXSBjYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIG1pdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUNhcF0gY2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcWFyZS4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIGJ1dHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaGFkb3dDb2xvcl1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dCbHVyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNoYWRvd09mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T3BhY2l0eV0gc2hhZG93IG9wYWNpdHkuICBDYW4gYmUgYW55IHJlYWwgbnVtYmVyXG4gICAgICogIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRhc2hdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRhc2hFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGRhc2hBcnJheS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZHJhdyBhIEFyYyB0aGF0J3MgcG9pbnRpbmcgZG93bndhcmRzXG4gICAgICogdmFyIGFyYyA9IG5ldyBLb252YS5BcmMoe1xuICAgICAqICAgaW5uZXJSYWRpdXM6IDQwLFxuICAgICAqICAgb3V0ZXJSYWRpdXM6IDgwLFxuICAgICAqICAgZmlsbDogJ3JlZCcsXG4gICAgICogICBzdHJva2U6ICdibGFjaydcbiAgICAgKiAgIHN0cm9rZVdpZHRoOiA1LFxuICAgICAqICAgYW5nbGU6IDYwLFxuICAgICAqICAgcm90YXRpb25EZWc6IC0xMjBcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgS29udmEuQXJjID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gIH07XG5cbiAgS29udmEuQXJjLnByb3RvdHlwZSA9IHtcbiAgICBfY2VudHJvaWQ6IHRydWUsXG4gICAgX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXG4gICAgICBLb252YS5TaGFwZS5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdBcmMnO1xuICAgICAgdGhpcy5zY2VuZUZ1bmModGhpcy5fc2NlbmVGdW5jKTtcbiAgICB9LFxuICAgIF9zY2VuZUZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgIHZhciBhbmdsZSA9IEtvbnZhLmdldEFuZ2xlKHRoaXMuYW5nbGUoKSksIGNsb2Nrd2lzZSA9IHRoaXMuY2xvY2t3aXNlKCk7XG5cbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBjb250ZXh0LmFyYygwLCAwLCB0aGlzLmdldE91dGVyUmFkaXVzKCksIDAsIGFuZ2xlLCBjbG9ja3dpc2UpO1xuICAgICAgY29udGV4dC5hcmMoMCwgMCwgdGhpcy5nZXRJbm5lclJhZGl1cygpLCBhbmdsZSwgMCwgIWNsb2Nrd2lzZSk7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgfSxcbiAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5nZXRXaWR0aCgpXG4gICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0T3V0ZXJSYWRpdXMoKSAqIDI7XG4gICAgfSxcbiAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5nZXRIZWlnaHQoKVxuICAgIGdldEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRPdXRlclJhZGl1cygpICogMjtcbiAgICB9LFxuICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLnNldFdpZHRoKClcbiAgICBzZXRXaWR0aDogZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldFdpZHRoLmNhbGwodGhpcywgd2lkdGgpO1xuICAgICAgaWYgKHRoaXMuZ2V0T3V0ZXJSYWRpdXMoKSAhPT0gd2lkdGggLyAyKSB7XG4gICAgICAgIHRoaXMuc2V0T3V0ZXJSYWRpdXMod2lkdGggLyAyKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLnNldEhlaWdodCgpXG4gICAgc2V0SGVpZ2h0OiBmdW5jdGlvbihoZWlnaHQpIHtcbiAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldEhlaWdodC5jYWxsKHRoaXMsIGhlaWdodCk7XG4gICAgICBpZiAodGhpcy5nZXRPdXRlclJhZGl1cygpICE9PSBoZWlnaHQgLyAyKSB7XG4gICAgICAgIHRoaXMuc2V0T3V0ZXJSYWRpdXMoaGVpZ2h0IC8gMik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBLb252YS5VdGlsLmV4dGVuZChLb252YS5BcmMsIEtvbnZhLlNoYXBlKTtcblxuICAvLyBhZGQgZ2V0dGVycyBzZXR0ZXJzXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkFyYywgJ2lubmVyUmFkaXVzJywgMCk7XG5cbiAgLyoqXG4gICAgICogZ2V0L3NldCBpbm5lclJhZGl1c1xuICAgICAqIEBuYW1lIGlubmVyUmFkaXVzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5BcmMucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGlubmVyUmFkaXVzXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBpbm5lciByYWRpdXNcbiAgICAgKiB2YXIgaW5uZXJSYWRpdXMgPSBhcmMuaW5uZXJSYWRpdXMoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBpbm5lciByYWRpdXNcbiAgICAgKiBhcmMuaW5uZXJSYWRpdXMoMjApO1xuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkFyYywgJ291dGVyUmFkaXVzJywgMCk7XG5cbiAgLyoqXG4gICAgICogZ2V0L3NldCBvdXRlclJhZGl1c1xuICAgICAqIEBuYW1lIG91dGVyUmFkaXVzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5BcmMucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG91dGVyUmFkaXVzXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBvdXRlciByYWRpdXNcbiAgICAgKiB2YXIgb3V0ZXJSYWRpdXMgPSBhcmMub3V0ZXJSYWRpdXMoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBvdXRlciByYWRpdXNcbiAgICAgKiBhcmMub3V0ZXJSYWRpdXMoMjApO1xuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkFyYywgJ2FuZ2xlJywgMCk7XG5cbiAgLyoqXG4gICAgICogZ2V0L3NldCBhbmdsZSBpbiBkZWdyZWVzXG4gICAgICogQG5hbWUgYW5nbGVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkFyYy5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGFuZ2xlXG4gICAgICogdmFyIGFuZ2xlID0gYXJjLmFuZ2xlKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgYW5nbGVcbiAgICAgKiBhcmMuYW5nbGUoMjApO1xuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkFyYywgJ2Nsb2Nrd2lzZScsIGZhbHNlKTtcblxuICAvKipcbiAgICAgKiBnZXQvc2V0IGNsb2Nrd2lzZSBmbGFnXG4gICAgICogQG5hbWUgY2xvY2t3aXNlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5BcmMucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjbG9ja3dpc2VcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBjbG9ja3dpc2UgZmxhZ1xuICAgICAqIHZhciBjbG9ja3dpc2UgPSBhcmMuY2xvY2t3aXNlKCk7XG4gICAgICpcbiAgICAgKiAvLyBkcmF3IGFyYyBjb3VudGVyLWNsb2Nrd2lzZVxuICAgICAqIGFyYy5jbG9ja3dpc2UoZmFsc2UpO1xuICAgICAqXG4gICAgICogLy8gZHJhdyBhcmMgY2xvY2t3aXNlXG4gICAgICogYXJjLmNsb2Nrd2lzZSh0cnVlKTtcbiAgICAgKi9cblxuICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuQXJjKTtcbn0pKEtvbnZhKTtcblxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIC8vIENPTlNUQU5UU1xuICB2YXIgSU1BR0UgPSAnSW1hZ2UnO1xuXG4gIC8qKlxuICAgICAqIEltYWdlIGNvbnN0cnVjdG9yXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7SW1hZ2V9IGNvbmZpZy5pbWFnZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmNyb3BdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbF0gZmlsbCBjb2xvclxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IFtjb25maWcuZmlsbFBhdHRlcm5JbWFnZV0gZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5YXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WV0gXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZV0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblJvdGF0aW9uXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQYXR0ZXJuUmVwZWF0XSBjYW4gYmUgXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuICBUaGUgZGVmYXVsdCBpcyBcIm5vLXJlcGVhdFwiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5maWxsRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBmaWxsLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQcmlvcml0eV0gY2FuIGJlIGNvbG9yLCBsaW5lYXItZ3JhZGllbnQsIHJhZGlhbC1ncmFpZGVudCwgb3IgcGF0dGVybi4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGNvbG9yLiAgVGhlIGZpbGxQcmlvcml0eSBwcm9wZXJ0eSBtYWtlcyBpdCByZWFsbHkgZWFzeSB0byB0b2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgZmlsbCB0eXBlcy4gIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byB0b2dnbGUgYmV0d2VlbiBhIGZpbGwgY29sb3Igc3R5bGUgYW5kIGEgZmlsbCBwYXR0ZXJuIHN0eWxlLCBzaW1wbHkgc2V0IHRoZSBmaWxsIHByb3BlcnR5IGFuZCB0aGUgZmlsbFBhdHRlcm4gcHJvcGVydGllcywgYW5kIHRoZW4gdXNlIHNldEZpbGxQcmlvcml0eSgnY29sb3InKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggYSBjb2xvciBmaWxsLCBvciB1c2Ugc2V0RmlsbFByaW9yaXR5KCdwYXR0ZXJuJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIHRoZSBwYXR0ZXJuIGZpbGwgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnN0cm9rZV0gc3Ryb2tlIGNvbG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc3Ryb2tlV2lkdGhdIHN0cm9rZSB3aWR0aFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VIaXRFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIGhpdCByZWdpb24uICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnBlcmZlY3REcmF3RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHVzaW5nIGJ1ZmZlciBjYW52YXMuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzaGFzb3cgZm9yIHN0cm9rZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlU2NhbGVFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIHNjYWxlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHN0cm9rZS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lSm9pbl0gY2FuIGJlIG1pdGVyLCByb3VuZCwgb3IgYmV2ZWwuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBtaXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVDYXBdIGNhbiBiZSBidXR0LCByb3VuZCwgb3Igc3FhcmUuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBidXR0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc2hhZG93Q29sb3JdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93Qmx1cl1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zaGFkb3dPZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09wYWNpdHldIHNoYWRvdyBvcGFjaXR5LiAgQ2FuIGJlIGFueSByZWFsIG51bWJlclxuICAgICAqICBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzaGFkb3cuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5kYXNoXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kYXNoRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBkYXNoQXJyYXkuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBpbWFnZU9iaiA9IG5ldyBJbWFnZSgpO1xuICAgICAqIGltYWdlT2JqLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAqICAgdmFyIGltYWdlID0gbmV3IEtvbnZhLkltYWdlKHtcbiAgICAgKiAgICAgeDogMjAwLFxuICAgICAqICAgICB5OiA1MCxcbiAgICAgKiAgICAgaW1hZ2U6IGltYWdlT2JqLFxuICAgICAqICAgICB3aWR0aDogMTAwLFxuICAgICAqICAgICBoZWlnaHQ6IDEwMFxuICAgICAqICAgfSk7XG4gICAgICogfTtcbiAgICAgKiBpbWFnZU9iai5zcmMgPSAnL3BhdGgvdG8vaW1hZ2UuanBnJ1xuICAgICAqL1xuICBLb252YS5JbWFnZSA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHRoaXMuX19faW5pdChjb25maWcpO1xuICB9O1xuXG4gIEtvbnZhLkltYWdlLnByb3RvdHlwZSA9IHtcbiAgICBfX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgIEtvbnZhLlNoYXBlLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gSU1BR0U7XG4gICAgICB0aGlzLnNjZW5lRnVuYyh0aGlzLl9zY2VuZUZ1bmMpO1xuICAgICAgdGhpcy5oaXRGdW5jKHRoaXMuX2hpdEZ1bmMpO1xuICAgIH0sXG4gICAgX3VzZUJ1ZmZlckNhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAodGhpcy5oYXNTaGFkb3coKSB8fCB0aGlzLmdldEFic29sdXRlT3BhY2l0eSgpICE9PSAxKSAmJlxuICAgICAgICB0aGlzLmhhc1N0cm9rZSgpICYmXG4gICAgICAgIHRoaXMuZ2V0U3RhZ2UoKVxuICAgICAgKTtcbiAgICB9LFxuICAgIF9zY2VuZUZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKSxcbiAgICAgICAgaGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoKSxcbiAgICAgICAgaW1hZ2UgPSB0aGlzLmdldEltYWdlKCksXG4gICAgICAgIGNyb3BXaWR0aCxcbiAgICAgICAgY3JvcEhlaWdodCxcbiAgICAgICAgcGFyYW1zO1xuXG4gICAgICBpZiAoaW1hZ2UpIHtcbiAgICAgICAgY3JvcFdpZHRoID0gdGhpcy5nZXRDcm9wV2lkdGgoKTtcbiAgICAgICAgY3JvcEhlaWdodCA9IHRoaXMuZ2V0Q3JvcEhlaWdodCgpO1xuICAgICAgICBpZiAoY3JvcFdpZHRoICYmIGNyb3BIZWlnaHQpIHtcbiAgICAgICAgICBwYXJhbXMgPSBbXG4gICAgICAgICAgICBpbWFnZSxcbiAgICAgICAgICAgIHRoaXMuZ2V0Q3JvcFgoKSxcbiAgICAgICAgICAgIHRoaXMuZ2V0Q3JvcFkoKSxcbiAgICAgICAgICAgIGNyb3BXaWR0aCxcbiAgICAgICAgICAgIGNyb3BIZWlnaHQsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0XG4gICAgICAgICAgXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJhbXMgPSBbaW1hZ2UsIDAsIDAsIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmhhc0ZpbGwoKSB8fCB0aGlzLmhhc1N0cm9rZSgpKSB7XG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIGNvbnRleHQucmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbWFnZSkge1xuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZS5hcHBseShjb250ZXh0LCBwYXJhbXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2hpdEZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKSwgaGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoKTtcblxuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGNvbnRleHQucmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICB9LFxuICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpbWFnZSA9IHRoaXMuZ2V0SW1hZ2UoKTtcbiAgICAgIHJldHVybiB0aGlzLmF0dHJzLndpZHRoIHx8IChpbWFnZSA/IGltYWdlLndpZHRoIDogMCk7XG4gICAgfSxcbiAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGltYWdlID0gdGhpcy5nZXRJbWFnZSgpO1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cnMuaGVpZ2h0IHx8IChpbWFnZSA/IGltYWdlLmhlaWdodCA6IDApO1xuICAgIH1cbiAgfTtcbiAgS29udmEuVXRpbC5leHRlbmQoS29udmEuSW1hZ2UsIEtvbnZhLlNoYXBlKTtcblxuICAvLyBhZGQgZ2V0dGVycyBzZXR0ZXJzXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkltYWdlLCAnaW1hZ2UnKTtcblxuICAvKipcbiAgICAgKiBzZXQgaW1hZ2VcbiAgICAgKiBAbmFtZSBzZXRJbWFnZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuSW1hZ2UucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VcbiAgICAgKi9cblxuICAvKipcbiAgICAgKiBnZXQgaW1hZ2VcbiAgICAgKiBAbmFtZSBnZXRJbWFnZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuSW1hZ2UucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0ltYWdlfVxuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkQ29tcG9uZW50c0dldHRlclNldHRlcihLb252YS5JbWFnZSwgJ2Nyb3AnLCBbXG4gICAgJ3gnLFxuICAgICd5JyxcbiAgICAnd2lkdGgnLFxuICAgICdoZWlnaHQnXG4gIF0pO1xuICAvKipcbiAgICAgKiBnZXQvc2V0IGNyb3BcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG5hbWUgY3JvcFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5JbWFnZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY3JvcFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjcm9wLnhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY3JvcC55XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNyb3Aud2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY3JvcC5oZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGNyb3BcbiAgICAgKiB2YXIgY3JvcCA9IGltYWdlLmNyb3AoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBjcm9wXG4gICAgICogaW1hZ2UuY3JvcCh7XG4gICAgICogICB4OiAyMCxcbiAgICAgKiAgIHk6IDIwLFxuICAgICAqICAgd2lkdGg6IDIwLFxuICAgICAqICAgaGVpZ2h0OiAyMFxuICAgICAqIH0pO1xuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkltYWdlLCAnY3JvcFgnLCAwKTtcbiAgLyoqXG4gICAgICogZ2V0L3NldCBjcm9wIHhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG5hbWUgY3JvcFhcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuSW1hZ2UucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGNyb3AgeFxuICAgICAqIHZhciBjcm9wWCA9IGltYWdlLmNyb3BYKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgY3JvcCB4XG4gICAgICogaW1hZ2UuY3JvcFgoMjApO1xuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkltYWdlLCAnY3JvcFknLCAwKTtcbiAgLyoqXG4gICAgICogZ2V0L3NldCBjcm9wIHlcbiAgICAgKiBAbmFtZSBjcm9wWVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuSW1hZ2UucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGNyb3AgeVxuICAgICAqIHZhciBjcm9wWSA9IGltYWdlLmNyb3BZKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgY3JvcCB5XG4gICAgICogaW1hZ2UuY3JvcFkoMjApO1xuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkltYWdlLCAnY3JvcFdpZHRoJywgMCk7XG4gIC8qKlxuICAgICAqIGdldC9zZXQgY3JvcCB3aWR0aFxuICAgICAqIEBuYW1lIGNyb3BXaWR0aFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuSW1hZ2UucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBjcm9wIHdpZHRoXG4gICAgICogdmFyIGNyb3BXaWR0aCA9IGltYWdlLmNyb3BXaWR0aCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGNyb3Agd2lkdGhcbiAgICAgKiBpbWFnZS5jcm9wV2lkdGgoMjApO1xuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkltYWdlLCAnY3JvcEhlaWdodCcsIDApO1xuICAvKipcbiAgICAgKiBnZXQvc2V0IGNyb3AgaGVpZ2h0XG4gICAgICogQG5hbWUgY3JvcEhlaWdodFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuSW1hZ2UucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgY3JvcCBoZWlnaHRcbiAgICAgKiB2YXIgY3JvcEhlaWdodCA9IGltYWdlLmNyb3BIZWlnaHQoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBjcm9wIGhlaWdodFxuICAgICAqIGltYWdlLmNyb3BIZWlnaHQoMjApO1xuICAgICAqL1xuXG4gIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5JbWFnZSk7XG5cbiAgLyoqXG4gICAgICogbG9hZCBpbWFnZSBmcm9tIGdpdmVuIHVybCBhbmQgY3JlYXRlIGBLb252YS5JbWFnZWAgaW5zdGFuY2VcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkltYWdlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBpbWFnZSBzb3VyY2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB3aXRoIEtvbnZhLkltYWdlIGluc3RhbmNlIGFzIGZpcnN0IGFyZ3VtZW50XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgS29udmEuSW1hZ2UuZnJvbVVSTChpbWFnZVVSTCwgZnVuY3Rpb24oaW1hZ2Upe1xuICAgICAqICAgIC8vIGltYWdlIGlzIEtvbnZhLkltYWdlIGluc3RhbmNlXG4gICAgICogICAgbGF5ZXIuYWRkKGltYWdlKTtcbiAgICAgKiAgICBsYXllci5kcmF3KCk7XG4gICAgICogIH0pO1xuICAgICAqL1xuICBLb252YS5JbWFnZS5mcm9tVVJMID0gZnVuY3Rpb24odXJsLCBjYWxsYmFjaykge1xuICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICBpbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaW1hZ2UgPSBuZXcgS29udmEuSW1hZ2Uoe1xuICAgICAgICBpbWFnZTogaW1nXG4gICAgICB9KTtcbiAgICAgIGNhbGxiYWNrKGltYWdlKTtcbiAgICB9O1xuICAgIGltZy5zcmMgPSB1cmw7XG4gIH07XG59KSgpO1xuXG4vKmVzbGludC1kaXNhYmxlIG1heC1kZXB0aCAqL1xuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIC8vIHZhciBpc0ZpcmVmb3ggPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZmlyZWZveCcpID4gLTE7XG4gIC8vIGNvbnN0YW50c1xuICB2YXIgQVVUTyA9ICdhdXRvJyxcbiAgICAvL0NBTlZBUyA9ICdjYW52YXMnLFxuICAgIENFTlRFUiA9ICdjZW50ZXInLFxuICAgIEpVU1RJRlkgPSAnanVzdGlmeScsXG4gICAgQ0hBTkdFX0tPTlZBID0gJ0NoYW5nZS5rb252YScsXG4gICAgQ09OVEVYVF8yRCA9ICcyZCcsXG4gICAgREFTSCA9ICctJyxcbiAgICBFTVBUWV9TVFJJTkcgPSAnJyxcbiAgICBMRUZUID0gJ2xlZnQnLFxuICAgIFRFWFQgPSAndGV4dCcsXG4gICAgVEVYVF9VUFBFUiA9ICdUZXh0JyxcbiAgICBNSURETEUgPSAnbWlkZGxlJyxcbiAgICBOT1JNQUwgPSAnbm9ybWFsJyxcbiAgICBQWF9TUEFDRSA9ICdweCAnLFxuICAgIFNQQUNFID0gJyAnLFxuICAgIFJJR0hUID0gJ3JpZ2h0JyxcbiAgICBXT1JEID0gJ3dvcmQnLFxuICAgIENIQVIgPSAnY2hhcicsXG4gICAgTk9ORSA9ICdub25lJyxcbiAgICBBVFRSX0NIQU5HRV9MSVNUID0gW1xuICAgICAgJ2ZvbnRGYW1pbHknLFxuICAgICAgJ2ZvbnRTaXplJyxcbiAgICAgICdmb250U3R5bGUnLFxuICAgICAgJ2ZvbnRWYXJpYW50JyxcbiAgICAgICdwYWRkaW5nJyxcbiAgICAgICdhbGlnbicsXG4gICAgICAnbGluZUhlaWdodCcsXG4gICAgICAndGV4dCcsXG4gICAgICAnd2lkdGgnLFxuICAgICAgJ2hlaWdodCcsXG4gICAgICAnd3JhcCcsXG4gICAgICAnbGV0dGVyU3BhY2luZydcbiAgICBdLFxuICAgIC8vIGNhY2hlZCB2YXJpYWJsZXNcbiAgICBhdHRyQ2hhbmdlTGlzdExlbiA9IEFUVFJfQ0hBTkdFX0xJU1QubGVuZ3RoO1xuICB2YXIgZHVtbXlDb250ZXh0O1xuICBmdW5jdGlvbiBnZXREdW1teUNvbnRleHQoKSB7XG4gICAgaWYgKGR1bW15Q29udGV4dCkge1xuICAgICAgcmV0dXJuIGR1bW15Q29udGV4dDtcbiAgICB9XG4gICAgZHVtbXlDb250ZXh0ID0gS29udmEuVXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCkuZ2V0Q29udGV4dChDT05URVhUXzJEKTtcbiAgICByZXR1cm4gZHVtbXlDb250ZXh0O1xuICB9XG5cbiAgLyoqXG4gICAgICogVGV4dCBjb25zdHJ1Y3RvclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBhdWdtZW50cyBLb252YS5TaGFwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5mb250RmFtaWx5XSBkZWZhdWx0IGlzIEFyaWFsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZm9udFNpemVdIGluIHBpeGVscy4gIERlZmF1bHQgaXMgMTJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5mb250U3R5bGVdIGNhbiBiZSBub3JtYWwsIGJvbGQsIG9yIGl0YWxpYy4gIERlZmF1bHQgaXMgbm9ybWFsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZm9udFZhcmlhbnRdIGNhbiBiZSBub3JtYWwgb3Igc21hbGwtY2Fwcy4gIERlZmF1bHQgaXMgbm9ybWFsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy50ZXh0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuYWxpZ25dIGNhbiBiZSBsZWZ0LCBjZW50ZXIsIG9yIHJpZ2h0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucGFkZGluZ11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5saW5lSGVpZ2h0XSBkZWZhdWx0IGlzIDFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy53cmFwXSBjYW4gYmUgd29yZCwgY2hhciwgb3Igbm9uZS4gRGVmYXVsdCBpcyB3b3JkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbF0gZmlsbCBjb2xvclxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IFtjb25maWcuZmlsbFBhdHRlcm5JbWFnZV0gZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5YXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WV0gXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZV0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblJvdGF0aW9uXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQYXR0ZXJuUmVwZWF0XSBjYW4gYmUgXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuICBUaGUgZGVmYXVsdCBpcyBcIm5vLXJlcGVhdFwiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5maWxsRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBmaWxsLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQcmlvcml0eV0gY2FuIGJlIGNvbG9yLCBsaW5lYXItZ3JhZGllbnQsIHJhZGlhbC1ncmFpZGVudCwgb3IgcGF0dGVybi4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGNvbG9yLiAgVGhlIGZpbGxQcmlvcml0eSBwcm9wZXJ0eSBtYWtlcyBpdCByZWFsbHkgZWFzeSB0byB0b2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgZmlsbCB0eXBlcy4gIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byB0b2dnbGUgYmV0d2VlbiBhIGZpbGwgY29sb3Igc3R5bGUgYW5kIGEgZmlsbCBwYXR0ZXJuIHN0eWxlLCBzaW1wbHkgc2V0IHRoZSBmaWxsIHByb3BlcnR5IGFuZCB0aGUgZmlsbFBhdHRlcm4gcHJvcGVydGllcywgYW5kIHRoZW4gdXNlIHNldEZpbGxQcmlvcml0eSgnY29sb3InKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggYSBjb2xvciBmaWxsLCBvciB1c2Ugc2V0RmlsbFByaW9yaXR5KCdwYXR0ZXJuJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIHRoZSBwYXR0ZXJuIGZpbGwgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnN0cm9rZV0gc3Ryb2tlIGNvbG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc3Ryb2tlV2lkdGhdIHN0cm9rZSB3aWR0aFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VIaXRFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIGhpdCByZWdpb24uICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnBlcmZlY3REcmF3RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHVzaW5nIGJ1ZmZlciBjYW52YXMuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzaGFzb3cgZm9yIHN0cm9rZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlU2NhbGVFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIHNjYWxlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHN0cm9rZS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lSm9pbl0gY2FuIGJlIG1pdGVyLCByb3VuZCwgb3IgYmV2ZWwuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBtaXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVDYXBdIGNhbiBiZSBidXR0LCByb3VuZCwgb3Igc3FhcmUuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBidXR0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc2hhZG93Q29sb3JdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93Qmx1cl1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zaGFkb3dPZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09wYWNpdHldIHNoYWRvdyBvcGFjaXR5LiAgQ2FuIGJlIGFueSByZWFsIG51bWJlclxuICAgICAqICBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzaGFkb3cuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5kYXNoXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kYXNoRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBkYXNoQXJyYXkuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciB0ZXh0ID0gbmV3IEtvbnZhLlRleHQoe1xuICAgICAqICAgeDogMTAsXG4gICAgICogICB5OiAxNSxcbiAgICAgKiAgIHRleHQ6ICdTaW1wbGUgVGV4dCcsXG4gICAgICogICBmb250U2l6ZTogMzAsXG4gICAgICogICBmb250RmFtaWx5OiAnQ2FsaWJyaScsXG4gICAgICogICBmaWxsOiAnZ3JlZW4nXG4gICAgICogfSk7XG4gICAgICovXG4gIEtvbnZhLlRleHQgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICB0aGlzLl9fX2luaXQoY29uZmlnKTtcbiAgfTtcbiAgZnVuY3Rpb24gX2ZpbGxGdW5jKGNvbnRleHQpIHtcbiAgICBjb250ZXh0LmZpbGxUZXh0KHRoaXMucGFydGlhbFRleHQsIDAsIDApO1xuICB9XG4gIGZ1bmN0aW9uIF9zdHJva2VGdW5jKGNvbnRleHQpIHtcbiAgICBjb250ZXh0LnN0cm9rZVRleHQodGhpcy5wYXJ0aWFsVGV4dCwgMCwgMCk7XG4gIH1cblxuICBLb252YS5UZXh0LnByb3RvdHlwZSA9IHtcbiAgICBfX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuICAgICAgLy8gc2V0IGRlZmF1bHQgY29sb3IgdG8gYmxhY2tcbiAgICAgIGlmIChcbiAgICAgICAgIWNvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzICYmXG4gICAgICAgICFjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wc1xuICAgICAgKSB7XG4gICAgICAgIGNvbmZpZy5maWxsID0gY29uZmlnLmZpbGwgfHwgJ2JsYWNrJztcbiAgICAgIH1cbiAgICAgIC8vXG4gICAgICAvLyBpZiAoY29uZmlnLndpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vICAgICBjb25maWcud2lkdGggPSBBVVRPO1xuICAgICAgLy8gfVxuICAgICAgLy8gaWYgKGNvbmZpZy5oZWlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gICAgIGNvbmZpZy5oZWlnaHQgPSBBVVRPO1xuICAgICAgLy8gfVxuXG4gICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXG4gICAgICBLb252YS5TaGFwZS5jYWxsKHRoaXMsIGNvbmZpZyk7XG5cbiAgICAgIHRoaXMuX2ZpbGxGdW5jID0gX2ZpbGxGdW5jO1xuICAgICAgdGhpcy5fc3Ryb2tlRnVuYyA9IF9zdHJva2VGdW5jO1xuICAgICAgdGhpcy5jbGFzc05hbWUgPSBURVhUX1VQUEVSO1xuXG4gICAgICAvLyB1cGRhdGUgdGV4dCBkYXRhIGZvciBjZXJ0YWluIGF0dHIgY2hhbmdlc1xuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBhdHRyQ2hhbmdlTGlzdExlbjsgbisrKSB7XG4gICAgICAgIHRoaXMub24oQVRUUl9DSEFOR0VfTElTVFtuXSArIENIQU5HRV9LT05WQSwgdGhpcy5fc2V0VGV4dERhdGEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zZXRUZXh0RGF0YSgpO1xuICAgICAgdGhpcy5zY2VuZUZ1bmModGhpcy5fc2NlbmVGdW5jKTtcbiAgICAgIHRoaXMuaGl0RnVuYyh0aGlzLl9oaXRGdW5jKTtcbiAgICB9LFxuICAgIF9zY2VuZUZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgIHZhciBwID0gdGhpcy5nZXRQYWRkaW5nKCksXG4gICAgICAgIHRleHRIZWlnaHQgPSB0aGlzLmdldFRleHRIZWlnaHQoKSxcbiAgICAgICAgbGluZUhlaWdodFB4ID0gdGhpcy5nZXRMaW5lSGVpZ2h0KCkgKiB0ZXh0SGVpZ2h0LFxuICAgICAgICB0ZXh0QXJyID0gdGhpcy50ZXh0QXJyLFxuICAgICAgICB0ZXh0QXJyTGVuID0gdGV4dEFyci5sZW5ndGgsXG4gICAgICAgIGFsaWduID0gdGhpcy5nZXRBbGlnbigpLFxuICAgICAgICB0b3RhbFdpZHRoID0gdGhpcy5nZXRXaWR0aCgpLFxuICAgICAgICBsZXR0ZXJTcGFjaW5nID0gdGhpcy5nZXRMZXR0ZXJTcGFjaW5nKCksXG4gICAgICAgIHRleHREZWNvcmF0aW9uID0gdGhpcy50ZXh0RGVjb3JhdGlvbigpLFxuICAgICAgICBmaWxsID0gdGhpcy5maWxsKCksXG4gICAgICAgIGZvbnRTaXplID0gdGhpcy5mb250U2l6ZSgpLFxuICAgICAgICBuO1xuXG4gICAgICBjb250ZXh0LnNldEF0dHIoJ2ZvbnQnLCB0aGlzLl9nZXRDb250ZXh0Rm9udCgpKTtcblxuICAgICAgY29udGV4dC5zZXRBdHRyKCd0ZXh0QmFzZWxpbmUnLCBNSURETEUpO1xuICAgICAgY29udGV4dC5zZXRBdHRyKCd0ZXh0QWxpZ24nLCBMRUZUKTtcbiAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgaWYgKHApIHtcbiAgICAgICAgY29udGV4dC50cmFuc2xhdGUocCwgMCk7XG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKDAsIHAgKyB0ZXh0SGVpZ2h0IC8gMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSgwLCB0ZXh0SGVpZ2h0IC8gMik7XG4gICAgICB9XG5cbiAgICAgIC8vIGRyYXcgdGV4dCBsaW5lc1xuICAgICAgZm9yIChuID0gMDsgbiA8IHRleHRBcnJMZW47IG4rKykge1xuICAgICAgICB2YXIgb2JqID0gdGV4dEFycltuXSxcbiAgICAgICAgICB0ZXh0ID0gb2JqLnRleHQsXG4gICAgICAgICAgd2lkdGggPSBvYmoud2lkdGg7XG5cbiAgICAgICAgLy8gaG9yaXpvbnRhbCBhbGlnbm1lbnRcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgIGlmIChhbGlnbiA9PT0gUklHSFQpIHtcbiAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSh0b3RhbFdpZHRoIC0gd2lkdGggLSBwICogMiwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09IENFTlRFUikge1xuICAgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKCh0b3RhbFdpZHRoIC0gd2lkdGggLSBwICogMikgLyAyLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ZXh0RGVjb3JhdGlvbi5pbmRleE9mKCd1bmRlcmxpbmUnKSAhPT0gLTEpIHtcbiAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgIGNvbnRleHQubW92ZVRvKDAsIE1hdGgucm91bmQobGluZUhlaWdodFB4IC8gMikpO1xuICAgICAgICAgIGNvbnRleHQubGluZVRvKE1hdGgucm91bmQod2lkdGgpLCBNYXRoLnJvdW5kKGxpbmVIZWlnaHRQeCAvIDIpKTtcbiAgICAgICAgICAvLyBUT0RPOiBJIGhhdmUgbm8gaWRlYSB3aGF0IGlzIHJlYWwgcmF0aW9cbiAgICAgICAgICAvLyBqdXN0IC8yMCBsb29rcyBnb29kIGVub3VnaFxuICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gZm9udFNpemUgLyAxNTtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gZmlsbDtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0RGVjb3JhdGlvbi5pbmRleE9mKCdsaW5lLXRocm91Z2gnKSAhPT0gLTEpIHtcbiAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgIGNvbnRleHQubW92ZVRvKDAsIDApO1xuICAgICAgICAgIGNvbnRleHQubGluZVRvKE1hdGgucm91bmQod2lkdGgpLCAwKTtcbiAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGZvbnRTaXplIC8gMTU7XG4gICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGZpbGw7XG4gICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGV0dGVyU3BhY2luZyAhPT0gMCB8fCBhbGlnbiA9PT0gSlVTVElGWSkge1xuICAgICAgICAgIC8vICAgdmFyIHdvcmRzID0gdGV4dC5zcGxpdCgnICcpO1xuICAgICAgICAgIHZhciBzcGFjZXNOdW1iZXIgPSB0ZXh0LnNwbGl0KCcgJykubGVuZ3RoIC0gMTtcbiAgICAgICAgICBmb3IgKHZhciBsaSA9IDA7IGxpIDwgdGV4dC5sZW5ndGg7IGxpKyspIHtcbiAgICAgICAgICAgIHZhciBsZXR0ZXIgPSB0ZXh0W2xpXTtcbiAgICAgICAgICAgIC8vIHNraXAganVzdGlmeSBmb3IgdGhlIGxhc3QgbGluZVxuICAgICAgICAgICAgaWYgKGxldHRlciA9PT0gJyAnICYmIG4gIT09IHRleHRBcnJMZW4gLSAxICYmIGFsaWduID09PSBKVVNUSUZZKSB7XG4gICAgICAgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKFxuICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoKHRvdGFsV2lkdGggLSB3aWR0aCkgLyBzcGFjZXNOdW1iZXIpLFxuICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucGFydGlhbFRleHQgPSBsZXR0ZXI7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICAgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKFxuICAgICAgICAgICAgICBNYXRoLnJvdW5kKHRoaXMuX2dldFRleHRTaXplKGxldHRlcikud2lkdGgpICsgbGV0dGVyU3BhY2luZyxcbiAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wYXJ0aWFsVGV4dCA9IHRleHQ7XG5cbiAgICAgICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgY29udGV4dC50cmFuc2xhdGUoMCwgbGluZUhlaWdodFB4KTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH0sXG4gICAgX2hpdEZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKSxcbiAgICAgICAgaGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoKTtcblxuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGNvbnRleHQucmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICB9LFxuICAgIC8vIF91c2VCdWZmZXJDYW52YXM6IGZ1bmN0aW9uKGNhY2hpbmcpIHtcbiAgICAvLyAgICAgdmFyIHVzZUl0ID0gS29udmEuU2hhcGUucHJvdG90eXBlLl91c2VCdWZmZXJDYW52YXMuY2FsbCh0aGlzLCBjYWNoaW5nKTtcbiAgICAvLyAgICAgaWYgKHVzZUl0KSB7XG4gICAgLy8gICAgICAgcmV0dXJuIHRydWU7XG4gICAgLy8gICAgIH1cbiAgICAvLyAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vICAgICAvLyByZXR1cm4gaXNGaXJlZm94ICYmIHRoaXMuaGFzRmlsbCgpICYmIHRoaXMuaGFzU2hhZG93KCk7XG4gICAgLy8gfSxcbiAgICBzZXRUZXh0OiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICB2YXIgc3RyID0gS29udmEuVXRpbC5faXNTdHJpbmcodGV4dCkgPyB0ZXh0IDogKHRleHQgfHwgJycpLnRvU3RyaW5nKCk7XG4gICAgICB0aGlzLl9zZXRBdHRyKFRFWFQsIHN0cik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiBnZXQgd2lkdGggb2YgdGV4dCBhcmVhLCB3aGljaCBpbmNsdWRlcyBwYWRkaW5nXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHQucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpc0F1dG8gPSB0aGlzLmF0dHJzLndpZHRoID09PSBBVVRPIHx8IHRoaXMuYXR0cnMud2lkdGggPT09IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBpc0F1dG9cbiAgICAgICAgPyB0aGlzLmdldFRleHRXaWR0aCgpICsgdGhpcy5nZXRQYWRkaW5nKCkgKiAyXG4gICAgICAgIDogdGhpcy5hdHRycy53aWR0aDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiBnZXQgdGhlIGhlaWdodCBvZiB0aGUgdGV4dCBhcmVhLCB3aGljaCB0YWtlcyBpbnRvIGFjY291bnQgbXVsdGktbGluZSB0ZXh0LCBsaW5lIGhlaWdodHMsIGFuZCBwYWRkaW5nXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHQucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgIGdldEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaXNBdXRvID1cbiAgICAgICAgdGhpcy5hdHRycy5oZWlnaHQgPT09IEFVVE8gfHwgdGhpcy5hdHRycy5oZWlnaHQgPT09IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBpc0F1dG9cbiAgICAgICAgPyB0aGlzLmdldFRleHRIZWlnaHQoKSAqIHRoaXMudGV4dEFyci5sZW5ndGggKiB0aGlzLmdldExpbmVIZWlnaHQoKSArXG4gICAgICAgICAgdGhpcy5nZXRQYWRkaW5nKCkgKiAyXG4gICAgICAgIDogdGhpcy5hdHRycy5oZWlnaHQ7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogZ2V0IHRleHQgd2lkdGhcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dC5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgICAgICovXG4gICAgZ2V0VGV4dFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHRXaWR0aDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiBnZXQgdGV4dCBoZWlnaHRcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dC5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgICAgICovXG4gICAgZ2V0VGV4dEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0SGVpZ2h0O1xuICAgIH0sXG4gICAgX2dldFRleHRTaXplOiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICB2YXIgX2NvbnRleHQgPSBnZXREdW1teUNvbnRleHQoKSxcbiAgICAgICAgZm9udFNpemUgPSB0aGlzLmdldEZvbnRTaXplKCksXG4gICAgICAgIG1ldHJpY3M7XG5cbiAgICAgIF9jb250ZXh0LnNhdmUoKTtcbiAgICAgIF9jb250ZXh0LmZvbnQgPSB0aGlzLl9nZXRDb250ZXh0Rm9udCgpO1xuXG4gICAgICBtZXRyaWNzID0gX2NvbnRleHQubWVhc3VyZVRleHQodGV4dCk7XG4gICAgICBfY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogbWV0cmljcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBwYXJzZUludChmb250U2l6ZSwgMTApXG4gICAgICB9O1xuICAgIH0sXG4gICAgX2dldENvbnRleHRGb250OiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIElFIGRvbid0IHdhbnQgdG8gd29yayB3aXRoIHVzdWFsIGZvbnQgc3R5bGVcbiAgICAgIC8vIGJvbGQgd2FzIG5vdCB3b3JraW5nXG4gICAgICAvLyByZW1vdmluZyBmb250IHZhcmlhbnQgd2lsbCBzb2x2ZVxuICAgICAgLy8gZml4IGZvcjogaHR0cHM6Ly9naXRodWIuY29tL2tvbnZhanMva29udmEvaXNzdWVzLzk0XG4gICAgICBpZiAoS29udmEuVUEuaXNJRSkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHRoaXMuZ2V0Rm9udFN0eWxlKCkgK1xuICAgICAgICAgIFNQQUNFICtcbiAgICAgICAgICB0aGlzLmdldEZvbnRTaXplKCkgK1xuICAgICAgICAgIFBYX1NQQUNFICtcbiAgICAgICAgICB0aGlzLmdldEZvbnRGYW1pbHkoKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy5nZXRGb250U3R5bGUoKSArXG4gICAgICAgIFNQQUNFICtcbiAgICAgICAgdGhpcy5nZXRGb250VmFyaWFudCgpICtcbiAgICAgICAgU1BBQ0UgK1xuICAgICAgICB0aGlzLmdldEZvbnRTaXplKCkgK1xuICAgICAgICBQWF9TUEFDRSArXG4gICAgICAgIHRoaXMuZ2V0Rm9udEZhbWlseSgpXG4gICAgICApO1xuICAgIH0sXG4gICAgX2FkZFRleHRMaW5lOiBmdW5jdGlvbihsaW5lKSB7XG4gICAgICBpZiAodGhpcy5hbGlnbigpID09PSBKVVNUSUZZKSB7XG4gICAgICAgIGxpbmUgPSBsaW5lLnRyaW0oKTtcbiAgICAgIH1cbiAgICAgIHZhciB3aWR0aCA9IHRoaXMuX2dldFRleHRXaWR0aChsaW5lKTtcbiAgICAgIHJldHVybiB0aGlzLnRleHRBcnIucHVzaCh7IHRleHQ6IGxpbmUsIHdpZHRoOiB3aWR0aCB9KTtcbiAgICB9LFxuICAgIF9nZXRUZXh0V2lkdGg6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgIHZhciBsYXR0ZXJTcGFjaW5nID0gdGhpcy5nZXRMZXR0ZXJTcGFjaW5nKCk7XG4gICAgICB2YXIgbGVuZ3RoID0gdGV4dC5sZW5ndGg7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBnZXREdW1teUNvbnRleHQoKS5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aCArXG4gICAgICAgIChsZW5ndGggPyBsYXR0ZXJTcGFjaW5nICogKGxlbmd0aCAtIDEpIDogMClcbiAgICAgICk7XG4gICAgfSxcbiAgICBfc2V0VGV4dERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxpbmVzID0gdGhpcy5nZXRUZXh0KCkuc3BsaXQoJ1xcbicpLFxuICAgICAgICBmb250U2l6ZSA9ICt0aGlzLmdldEZvbnRTaXplKCksXG4gICAgICAgIHRleHRXaWR0aCA9IDAsXG4gICAgICAgIGxpbmVIZWlnaHRQeCA9IHRoaXMuZ2V0TGluZUhlaWdodCgpICogZm9udFNpemUsXG4gICAgICAgIHdpZHRoID0gdGhpcy5hdHRycy53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gdGhpcy5hdHRycy5oZWlnaHQsXG4gICAgICAgIGZpeGVkV2lkdGggPSB3aWR0aCAhPT0gQVVUTyxcbiAgICAgICAgZml4ZWRIZWlnaHQgPSBoZWlnaHQgIT09IEFVVE8sXG4gICAgICAgIHBhZGRpbmcgPSB0aGlzLmdldFBhZGRpbmcoKSxcbiAgICAgICAgbWF4V2lkdGggPSB3aWR0aCAtIHBhZGRpbmcgKiAyLFxuICAgICAgICBtYXhIZWlnaHRQeCA9IGhlaWdodCAtIHBhZGRpbmcgKiAyLFxuICAgICAgICBjdXJyZW50SGVpZ2h0UHggPSAwLFxuICAgICAgICB3cmFwID0gdGhpcy5nZXRXcmFwKCksXG4gICAgICAgIHNob3VsZFdyYXAgPSB3cmFwICE9PSBOT05FLFxuICAgICAgICB3cmFwQXRXb3JkID0gd3JhcCAhPT0gQ0hBUiAmJiBzaG91bGRXcmFwO1xuXG4gICAgICB0aGlzLnRleHRBcnIgPSBbXTtcbiAgICAgIGdldER1bW15Q29udGV4dCgpLnNhdmUoKTtcbiAgICAgIGdldER1bW15Q29udGV4dCgpLmZvbnQgPSB0aGlzLl9nZXRDb250ZXh0Rm9udCgpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIG1heCA9IGxpbmVzLmxlbmd0aDsgaSA8IG1heDsgKytpKSB7XG4gICAgICAgIHZhciBsaW5lID0gbGluZXNbaV07XG5cbiAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHRoaXMuX2dldFRleHRXaWR0aChsaW5lKTtcbiAgICAgICAgaWYgKGZpeGVkV2lkdGggJiYgbGluZVdpZHRoID4gbWF4V2lkdGgpIHtcbiAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgKiBpZiB3aWR0aCBpcyBmaXhlZCBhbmQgbGluZSBkb2VzIG5vdCBmaXQgZW50aXJlbHlcbiAgICAgICAgICAgICAgICAgICAgICogYnJlYWsgdGhlIGxpbmUgaW50byBtdWx0aXBsZSBmaXR0aW5nIGxpbmVzXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgIHdoaWxlIChsaW5lLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiB1c2UgYmluYXJ5IHNlYXJjaCB0byBmaW5kIHRoZSBsb25nZXN0IHN1YnN0cmluZyB0aGF0XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiB0aGF0IHdvdWxkIGZpdCBpbiB0aGUgc3BlY2lmaWVkIHdpZHRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBsb3cgPSAwLFxuICAgICAgICAgICAgICBoaWdoID0gbGluZS5sZW5ndGgsXG4gICAgICAgICAgICAgIG1hdGNoID0gJycsXG4gICAgICAgICAgICAgIG1hdGNoV2lkdGggPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgICAgICAgdmFyIG1pZCA9IChsb3cgKyBoaWdoKSA+Pj4gMSxcbiAgICAgICAgICAgICAgICBzdWJzdHIgPSBsaW5lLnNsaWNlKDAsIG1pZCArIDEpLFxuICAgICAgICAgICAgICAgIHN1YnN0cldpZHRoID0gdGhpcy5fZ2V0VGV4dFdpZHRoKHN1YnN0cik7XG4gICAgICAgICAgICAgIGlmIChzdWJzdHJXaWR0aCA8PSBtYXhXaWR0aCkge1xuICAgICAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBzdWJzdHI7XG4gICAgICAgICAgICAgICAgbWF0Y2hXaWR0aCA9IHN1YnN0cldpZHRoO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiAnbG93JyBpcyBub3cgdGhlIGluZGV4IG9mIHRoZSBzdWJzdHJpbmcgZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiAnbWF0Y2gnIGlzIHRoZSBzdWJzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAqICdtYXRjaFdpZHRoJyBpcyB0aGUgc3Vic3RyaW5nIHdpZHRoIGluIHB4XG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAvLyBhIGZpdHRpbmcgc3Vic3RyaW5nIHdhcyBmb3VuZFxuICAgICAgICAgICAgICBpZiAod3JhcEF0V29yZCkge1xuICAgICAgICAgICAgICAgIC8vIHRyeSB0byBmaW5kIGEgc3BhY2Ugb3IgZGFzaCB3aGVyZSB3cmFwcGluZyBjb3VsZCBiZSBkb25lXG4gICAgICAgICAgICAgICAgdmFyIHdyYXBJbmRleCA9XG4gICAgICAgICAgICAgICAgICBNYXRoLm1heChtYXRjaC5sYXN0SW5kZXhPZihTUEFDRSksIG1hdGNoLmxhc3RJbmRleE9mKERBU0gpKSArXG4gICAgICAgICAgICAgICAgICAxO1xuICAgICAgICAgICAgICAgIGlmICh3cmFwSW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAvLyByZS1jdXQgdGhlIHN1YnN0cmluZyBmb3VuZCBhdCB0aGUgc3BhY2UvZGFzaCBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgbG93ID0gd3JhcEluZGV4O1xuICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBtYXRjaC5zbGljZSgwLCBsb3cpO1xuICAgICAgICAgICAgICAgICAgbWF0Y2hXaWR0aCA9IHRoaXMuX2dldFRleHRXaWR0aChtYXRjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX2FkZFRleHRMaW5lKG1hdGNoKTtcbiAgICAgICAgICAgICAgdGV4dFdpZHRoID0gTWF0aC5tYXgodGV4dFdpZHRoLCBtYXRjaFdpZHRoKTtcbiAgICAgICAgICAgICAgY3VycmVudEhlaWdodFB4ICs9IGxpbmVIZWlnaHRQeDtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICFzaG91bGRXcmFwIHx8XG4gICAgICAgICAgICAgICAgKGZpeGVkSGVpZ2h0ICYmIGN1cnJlbnRIZWlnaHRQeCArIGxpbmVIZWlnaHRQeCA+IG1heEhlaWdodFB4KVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBzdG9wIHdyYXBwaW5nIGlmIHdyYXBwaW5nIGlzIGRpc2FibGVkIG9yIGlmIGFkZGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBvbmUgbW9yZSBsaW5lIHdvdWxkIG92ZXJmbG93IHRoZSBmaXhlZCBoZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc2xpY2UobG93KTtcbiAgICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSByZW1haW5pbmcgdGV4dCB3b3VsZCBmaXQgb24gb25lIGxpbmVcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGggPSB0aGlzLl9nZXRUZXh0V2lkdGgobGluZSk7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmVXaWR0aCA8PSBtYXhXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgLy8gaWYgaXQgZG9lcywgYWRkIHRoZSBsaW5lIGFuZCBicmVhayBvdXQgb2YgdGhlIGxvb3BcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRleHRMaW5lKGxpbmUpO1xuICAgICAgICAgICAgICAgICAgY3VycmVudEhlaWdodFB4ICs9IGxpbmVIZWlnaHRQeDtcbiAgICAgICAgICAgICAgICAgIHRleHRXaWR0aCA9IE1hdGgubWF4KHRleHRXaWR0aCwgbGluZVdpZHRoKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gbm90IGV2ZW4gb25lIGNoYXJhY3RlciBjb3VsZCBmaXQgaW4gdGhlIGVsZW1lbnQsIGFib3J0XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBlbGVtZW50IHdpZHRoIGlzIGF1dG9tYXRpY2FsbHkgYWRqdXN0ZWQgdG8gbWF4IGxpbmUgd2lkdGhcbiAgICAgICAgICB0aGlzLl9hZGRUZXh0TGluZShsaW5lKTtcbiAgICAgICAgICBjdXJyZW50SGVpZ2h0UHggKz0gbGluZUhlaWdodFB4O1xuICAgICAgICAgIHRleHRXaWR0aCA9IE1hdGgubWF4KHRleHRXaWR0aCwgbGluZVdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBlbGVtZW50IGhlaWdodCBpcyBmaXhlZCwgYWJvcnQgaWYgYWRkaW5nIG9uZSBtb3JlIGxpbmUgd291bGQgb3ZlcmZsb3dcbiAgICAgICAgaWYgKGZpeGVkSGVpZ2h0ICYmIGN1cnJlbnRIZWlnaHRQeCArIGxpbmVIZWlnaHRQeCA+IG1heEhlaWdodFB4KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGdldER1bW15Q29udGV4dCgpLnJlc3RvcmUoKTtcbiAgICAgIHRoaXMudGV4dEhlaWdodCA9IGZvbnRTaXplO1xuICAgICAgLy8gdmFyIG1heFRleHRXaWR0aCA9IDA7XG4gICAgICAvLyBmb3IodmFyIGogPSAwOyBqIDwgdGhpcy50ZXh0QXJyLmxlbmd0aDsgaisrKSB7XG4gICAgICAvLyAgICAgbWF4VGV4dFdpZHRoID0gTWF0aC5tYXgobWF4VGV4dFdpZHRoLCB0aGlzLnRleHRBcnJbal0ud2lkdGgpO1xuICAgICAgLy8gfVxuICAgICAgdGhpcy50ZXh0V2lkdGggPSB0ZXh0V2lkdGg7XG4gICAgfVxuICB9O1xuICBLb252YS5VdGlsLmV4dGVuZChLb252YS5UZXh0LCBLb252YS5TaGFwZSk7XG5cbiAgLy8gYWRkIGdldHRlcnMgc2V0dGVyc1xuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UZXh0LCAnZm9udEZhbWlseScsICdBcmlhbCcpO1xuXG4gIC8qKlxuICAgICAqIGdldC9zZXQgZm9udCBmYW1pbHlcbiAgICAgKiBAbmFtZSBmb250RmFtaWx5XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmb250RmFtaWx5XG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmb250IGZhbWlseVxuICAgICAqIHZhciBmb250RmFtaWx5ID0gdGV4dC5mb250RmFtaWx5KCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZm9udCBmYW1pbHlcbiAgICAgKiB0ZXh0LmZvbnRGYW1pbHkoJ0FyaWFsJyk7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGV4dCwgJ2ZvbnRTaXplJywgMTIpO1xuXG4gIC8qKlxuICAgICAqIGdldC9zZXQgZm9udCBzaXplIGluIHBpeGVsc1xuICAgICAqIEBuYW1lIGZvbnRTaXplXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmb250U2l6ZVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZm9udCBzaXplXG4gICAgICogdmFyIGZvbnRTaXplID0gdGV4dC5mb250U2l6ZSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGZvbnQgc2l6ZSB0byAyMnB4XG4gICAgICogdGV4dC5mb250U2l6ZSgyMik7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGV4dCwgJ2ZvbnRTdHlsZScsIE5PUk1BTCk7XG5cbiAgLyoqXG4gICAgICogc2V0IGZvbnQgc3R5bGUuICBDYW4gYmUgJ25vcm1hbCcsICdpdGFsaWMnLCBvciAnYm9sZCcuICAnbm9ybWFsJyBpcyB0aGUgZGVmYXVsdC5cbiAgICAgKiBAbmFtZSBmb250U3R5bGVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZvbnRTdHlsZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZm9udCBzdHlsZVxuICAgICAqIHZhciBmb250U3R5bGUgPSB0ZXh0LmZvbnRTdHlsZSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGZvbnQgc3R5bGVcbiAgICAgKiB0ZXh0LmZvbnRTdHlsZSgnYm9sZCcpO1xuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRleHQsICdmb250VmFyaWFudCcsIE5PUk1BTCk7XG5cbiAgLyoqXG4gICAgICogc2V0IGZvbnQgdmFyaWFudC4gIENhbiBiZSAnbm9ybWFsJyBvciAnc21hbGwtY2FwcycuICAnbm9ybWFsJyBpcyB0aGUgZGVmYXVsdC5cbiAgICAgKiBAbmFtZSBmb250VmFyaWFudFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZm9udFZhcmlhbnRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZvbnQgdmFyaWFudFxuICAgICAqIHZhciBmb250VmFyaWFudCA9IHRleHQuZm9udFZhcmlhbnQoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBmb250IHZhcmlhbnRcbiAgICAgKiB0ZXh0LmZvbnRWYXJpYW50KCdzbWFsbC1jYXBzJyk7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGV4dCwgJ3BhZGRpbmcnLCAwKTtcblxuICAvKipcbiAgICAgKiBzZXQgcGFkZGluZ1xuICAgICAqIEBuYW1lIHBhZGRpbmdcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHBhZGRpbmdcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHBhZGRpbmdcbiAgICAgKiB2YXIgcGFkZGluZyA9IHRleHQucGFkZGluZygpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHBhZGRpbmcgdG8gMTAgcGl4ZWxzXG4gICAgICogdGV4dC5wYWRkaW5nKDEwKTtcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UZXh0LCAnYWxpZ24nLCBMRUZUKTtcblxuICAvKipcbiAgICAgKiBnZXQvc2V0IGhvcml6b250YWwgYWxpZ24gb2YgdGV4dC4gIENhbiBiZSAnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnIG9yICdqdXN0aWZ5J1xuICAgICAqIEBuYW1lIGFsaWduXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhbGlnblxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgdGV4dCBhbGlnblxuICAgICAqIHZhciBhbGlnbiA9IHRleHQuYWxpZ24oKTtcbiAgICAgKlxuICAgICAqIC8vIGNlbnRlciB0ZXh0XG4gICAgICogdGV4dC5hbGlnbignY2VudGVyJyk7XG4gICAgICpcbiAgICAgKiAvLyBhbGlnbiB0ZXh0IHRvIHJpZ2h0XG4gICAgICogdGV4dC5hbGlnbigncmlnaHQnKTtcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UZXh0LCAnbGluZUhlaWdodCcsIDEpO1xuXG4gIC8qKlxuICAgICAqIGdldC9zZXQgbGluZSBoZWlnaHQuICBUaGUgZGVmYXVsdCBpcyAxLlxuICAgICAqIEBuYW1lIGxpbmVIZWlnaHRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVIZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGxpbmUgaGVpZ2h0XG4gICAgICogdmFyIGxpbmVIZWlnaHQgPSB0ZXh0LmxpbmVIZWlnaHQoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCB0aGUgbGluZSBoZWlnaHRcbiAgICAgKiB0ZXh0LmxpbmVIZWlnaHQoMik7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGV4dCwgJ3dyYXAnLCBXT1JEKTtcblxuICAvKipcbiAgICAgKiBnZXQvc2V0IHdyYXAuICBDYW4gYmUgd29yZCwgY2hhciwgb3Igbm9uZS4gRGVmYXVsdCBpcyB3b3JkLlxuICAgICAqIEBuYW1lIHdyYXBcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHdyYXBcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHdyYXBcbiAgICAgKiB2YXIgd3JhcCA9IHRleHQud3JhcCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHdyYXBcbiAgICAgKiB0ZXh0LndyYXAoJ3dvcmQnKTtcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UZXh0LCAnbGV0dGVyU3BhY2luZycsIDApO1xuXG4gIC8qKlxuICAgICAgICogc2V0IGxldHRlciBzcGFjaW5nIHByb3BlcnR5LiBEZWZhdWx0IHZhbHVlIGlzIDAuXG4gICAgICAgKiBAbmFtZSBsZXR0ZXJTcGFjaW5nXG4gICAgICAgKiBAbWV0aG9kXG4gICAgICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dFBhdGgucHJvdG90eXBlXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gbGV0dGVyU3BhY2luZ1xuICAgICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXIoS29udmEuVGV4dCwgJ3RleHQnLCBFTVBUWV9TVFJJTkcpO1xuICBLb252YS5GYWN0b3J5LmFkZE92ZXJsb2FkZWRHZXR0ZXJTZXR0ZXIoS29udmEuVGV4dCwgJ3RleHQnKTtcblxuICAvKipcbiAgICAgKiBnZXQvc2V0IHRleHRcbiAgICAgKiBAbmFtZSBnZXRUZXh0XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCB0ZXh0XG4gICAgICogdmFyIHRleHQgPSB0ZXh0LnRleHQoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCB0ZXh0XG4gICAgICogdGV4dC50ZXh0KCdIZWxsbyB3b3JsZCEnKTtcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UZXh0LCAndGV4dERlY29yYXRpb24nLCBFTVBUWV9TVFJJTkcpO1xuXG4gIC8qKlxuICAgICAgKiBnZXQvc2V0IHRleHQgZGVjb3JhdGlvbiBvZiBhIHRleHQuICBQb3NzaWJsZSB2YWx1ZXMgYXJlICd1bmRlcmxpbmUnLCAnbGluZS10aHJvdWdoJyBvciBjb21iaW5hdGlvbiBvZiB0aGVzZSB2YWx1ZXMgc2VwYXJhdGVkIGJ5IHNwYWNlXG4gICAgICAqIEBuYW1lIHRleHREZWNvcmF0aW9uXG4gICAgICAqIEBtZXRob2RcbiAgICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHQucHJvdG90eXBlXG4gICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0RGVjb3JhdGlvblxuICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAgKiBAZXhhbXBsZVxuICAgICAgKiAvLyBnZXQgdGV4dCBkZWNvcmF0aW9uXG4gICAgICAqIHZhciB0ZXh0RGVjb3JhdGlvbiA9IHRleHQudGV4dERlY29yYXRpb24oKTtcbiAgICAgICpcbiAgICAgICogLy8gdW5kZXJsaW5lIHRleHRcbiAgICAgICogdGV4dC50ZXh0RGVjb3JhdGlvbigndW5kZXJsaW5lJyk7XG4gICAgICAqXG4gICAgICAqIC8vIHN0cmlrZSB0ZXh0XG4gICAgICAqIHRleHQudGV4dERlY29yYXRpb24oJ2xpbmUtdGhyb3VnaCcpO1xuICAgICAgKlxuICAgICAgKiAvLyB1bmRlcmxpbmUgYW5kIHN0cmlrZSB0ZXh0XG4gICAgICAqIHRleHQudGV4dERlY29yYXRpb24oJ3VuZGVybGluZSBsaW5lLXRocm91Z2gnKTtcbiAgICAgICovXG5cbiAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLlRleHQpO1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIC8qKlxuICAgICAqIExpbmUgY29uc3RydWN0b3IuJm5ic3A7IExpbmVzIGFyZSBkZWZpbmVkIGJ5IGFuIGFycmF5IG9mIHBvaW50cyBhbmRcbiAgICAgKiAgYSB0ZW5zaW9uXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvbmZpZy5wb2ludHNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy50ZW5zaW9uXSBIaWdoZXIgdmFsdWVzIHdpbGwgcmVzdWx0IGluIGEgbW9yZSBjdXJ2eSBsaW5lLiAgQSB2YWx1ZSBvZiAwIHdpbGwgcmVzdWx0IGluIG5vIGludGVycG9sYXRpb24uXG4gICAgICogICBUaGUgZGVmYXVsdCBpcyAwXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmNsb3NlZF0gZGVmaW5lcyB3aGV0aGVyIG9yIG5vdCB0aGUgbGluZSBzaGFwZSBpcyBjbG9zZWQsIGNyZWF0aW5nIGEgcG9seWdvbiBvciBibG9iXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmJlemllcl0gaWYgbm8gdGVuc2lvbiBpcyBwcm92aWRlZCBidXQgYmV6aWVyPXRydWUsIHdlIGRyYXcgdGhlIGxpbmUgYXMgYSBiZXppZXIgdXNpbmcgdGhlIHBhc3NlZCBwb2ludHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsXSBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW2NvbmZpZy5maWxsUGF0dGVybkltYWdlXSBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5ZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRZXSBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlXSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuUm90YXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFBhdHRlcm5SZXBlYXRdIGNhbiBiZSBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gIFRoZSBkZWZhdWx0IGlzIFwibm8tcmVwZWF0XCJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFldXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFldIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZpbGxFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZpbGwuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFByaW9yaXR5XSBjYW4gYmUgY29sb3IsIGxpbmVhci1ncmFkaWVudCwgcmFkaWFsLWdyYWlkZW50LCBvciBwYXR0ZXJuLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgY29sb3IuICBUaGUgZmlsbFByaW9yaXR5IHByb3BlcnR5IG1ha2VzIGl0IHJlYWxseSBlYXN5IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGEgZmlsbCBjb2xvciBzdHlsZSBhbmQgYSBmaWxsIHBhdHRlcm4gc3R5bGUsIHNpbXBseSBzZXQgdGhlIGZpbGwgcHJvcGVydHkgYW5kIHRoZSBmaWxsUGF0dGVybiBwcm9wZXJ0aWVzLCBhbmQgdGhlbiB1c2Ugc2V0RmlsbFByaW9yaXR5KCdjb2xvcicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCBhIGNvbG9yIGZpbGwsIG9yIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ3BhdHRlcm4nKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggdGhlIHBhdHRlcm4gZmlsbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc3Ryb2tlXSBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdHJva2VXaWR0aF0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUhpdEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2UgaGl0IHJlZ2lvbi4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucGVyZmVjdERyYXdFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdXNpbmcgYnVmZmVyIGNhbnZhcy4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXNvdyBmb3Igc3Ryb2tlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VTY2FsZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2Ugc2NhbGUuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc3Ryb2tlLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVKb2luXSBjYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIG1pdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUNhcF0gY2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcWFyZS4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIGJ1dHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaGFkb3dDb2xvcl1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dCbHVyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNoYWRvd09mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T3BhY2l0eV0gc2hhZG93IG9wYWNpdHkuICBDYW4gYmUgYW55IHJlYWwgbnVtYmVyXG4gICAgICogIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRhc2hdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRhc2hFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGRhc2hBcnJheS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGxpbmUgPSBuZXcgS29udmEuTGluZSh7XG4gICAgICogICB4OiAxMDAsXG4gICAgICogICB5OiA1MCxcbiAgICAgKiAgIHBvaW50czogWzczLCA3MCwgMzQwLCAyMywgNDUwLCA2MCwgNTAwLCAyMF0sXG4gICAgICogICBzdHJva2U6ICdyZWQnLFxuICAgICAqICAgdGVuc2lvbjogMVxuICAgICAqIH0pO1xuICAgICAqL1xuICBLb252YS5MaW5lID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gIH07XG5cbiAgS29udmEuTGluZS5wcm90b3R5cGUgPSB7XG4gICAgX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXG4gICAgICBLb252YS5TaGFwZS5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdMaW5lJztcblxuICAgICAgdGhpcy5vbihcbiAgICAgICAgJ3BvaW50c0NoYW5nZS5rb252YSB0ZW5zaW9uQ2hhbmdlLmtvbnZhIGNsb3NlZENoYW5nZS5rb252YSBiZXppZXJDaGFuZ2Uua29udmEnLFxuICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLl9jbGVhckNhY2hlKCd0ZW5zaW9uUG9pbnRzJyk7XG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIHRoaXMuc2NlbmVGdW5jKHRoaXMuX3NjZW5lRnVuYyk7XG4gICAgfSxcbiAgICBfc2NlbmVGdW5jOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICB2YXIgcG9pbnRzID0gdGhpcy5nZXRQb2ludHMoKSxcbiAgICAgICAgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aCxcbiAgICAgICAgdGVuc2lvbiA9IHRoaXMuZ2V0VGVuc2lvbigpLFxuICAgICAgICBjbG9zZWQgPSB0aGlzLmdldENsb3NlZCgpLFxuICAgICAgICBiZXppZXIgPSB0aGlzLmdldEJlemllcigpLFxuICAgICAgICB0cCxcbiAgICAgICAgbGVuLFxuICAgICAgICBuO1xuXG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBjb250ZXh0Lm1vdmVUbyhwb2ludHNbMF0sIHBvaW50c1sxXSk7XG5cbiAgICAgIC8vIHRlbnNpb25cbiAgICAgIGlmICh0ZW5zaW9uICE9PSAwICYmIGxlbmd0aCA+IDQpIHtcbiAgICAgICAgdHAgPSB0aGlzLmdldFRlbnNpb25Qb2ludHMoKTtcbiAgICAgICAgbGVuID0gdHAubGVuZ3RoO1xuICAgICAgICBuID0gY2xvc2VkID8gMCA6IDQ7XG5cbiAgICAgICAgaWYgKCFjbG9zZWQpIHtcbiAgICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8odHBbMF0sIHRwWzFdLCB0cFsyXSwgdHBbM10pO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKG4gPCBsZW4gLSAyKSB7XG4gICAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgICAgdHBbbisrXSxcbiAgICAgICAgICAgIHRwW24rK10sXG4gICAgICAgICAgICB0cFtuKytdLFxuICAgICAgICAgICAgdHBbbisrXSxcbiAgICAgICAgICAgIHRwW24rK10sXG4gICAgICAgICAgICB0cFtuKytdXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY2xvc2VkKSB7XG4gICAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgICAgdHBbbGVuIC0gMl0sXG4gICAgICAgICAgICB0cFtsZW4gLSAxXSxcbiAgICAgICAgICAgIHBvaW50c1tsZW5ndGggLSAyXSxcbiAgICAgICAgICAgIHBvaW50c1tsZW5ndGggLSAxXVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYmV6aWVyKSB7XG4gICAgICAgIC8vIG5vIHRlbnNpb24gYnV0IGJlemllclxuICAgICAgICBuID0gMjtcblxuICAgICAgICB3aGlsZSAobiA8IGxlbmd0aCkge1xuICAgICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICAgIHBvaW50c1tuKytdLFxuICAgICAgICAgICAgcG9pbnRzW24rK10sXG4gICAgICAgICAgICBwb2ludHNbbisrXSxcbiAgICAgICAgICAgIHBvaW50c1tuKytdLFxuICAgICAgICAgICAgcG9pbnRzW24rK10sXG4gICAgICAgICAgICBwb2ludHNbbisrXVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vIHRlbnNpb25cbiAgICAgICAgZm9yIChuID0gMjsgbiA8IGxlbmd0aDsgbiArPSAyKSB7XG4gICAgICAgICAgY29udGV4dC5saW5lVG8ocG9pbnRzW25dLCBwb2ludHNbbiArIDFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBjbG9zZWQgZS5nLiBwb2x5Z29ucyBhbmQgYmxvYnNcbiAgICAgIGlmIChjbG9zZWQpIHtcbiAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvcGVuIGUuZy4gbGluZXMgYW5kIHNwbGluZXNcbiAgICAgICAgY29udGV4dC5zdHJva2VTaGFwZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldFRlbnNpb25Qb2ludHM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldENhY2hlKCd0ZW5zaW9uUG9pbnRzJywgdGhpcy5fZ2V0VGVuc2lvblBvaW50cyk7XG4gICAgfSxcbiAgICBfZ2V0VGVuc2lvblBvaW50czogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5nZXRDbG9zZWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VGVuc2lvblBvaW50c0Nsb3NlZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIEtvbnZhLlV0aWwuX2V4cGFuZFBvaW50cyh0aGlzLmdldFBvaW50cygpLCB0aGlzLmdldFRlbnNpb24oKSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfZ2V0VGVuc2lvblBvaW50c0Nsb3NlZDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcCA9IHRoaXMuZ2V0UG9pbnRzKCksXG4gICAgICAgIGxlbiA9IHAubGVuZ3RoLFxuICAgICAgICB0ZW5zaW9uID0gdGhpcy5nZXRUZW5zaW9uKCksXG4gICAgICAgIHV0aWwgPSBLb252YS5VdGlsLFxuICAgICAgICBmaXJzdENvbnRyb2xQb2ludHMgPSB1dGlsLl9nZXRDb250cm9sUG9pbnRzKFxuICAgICAgICAgIHBbbGVuIC0gMl0sXG4gICAgICAgICAgcFtsZW4gLSAxXSxcbiAgICAgICAgICBwWzBdLFxuICAgICAgICAgIHBbMV0sXG4gICAgICAgICAgcFsyXSxcbiAgICAgICAgICBwWzNdLFxuICAgICAgICAgIHRlbnNpb25cbiAgICAgICAgKSxcbiAgICAgICAgbGFzdENvbnRyb2xQb2ludHMgPSB1dGlsLl9nZXRDb250cm9sUG9pbnRzKFxuICAgICAgICAgIHBbbGVuIC0gNF0sXG4gICAgICAgICAgcFtsZW4gLSAzXSxcbiAgICAgICAgICBwW2xlbiAtIDJdLFxuICAgICAgICAgIHBbbGVuIC0gMV0sXG4gICAgICAgICAgcFswXSxcbiAgICAgICAgICBwWzFdLFxuICAgICAgICAgIHRlbnNpb25cbiAgICAgICAgKSxcbiAgICAgICAgbWlkZGxlID0gS29udmEuVXRpbC5fZXhwYW5kUG9pbnRzKHAsIHRlbnNpb24pLFxuICAgICAgICB0cCA9IFtmaXJzdENvbnRyb2xQb2ludHNbMl0sIGZpcnN0Q29udHJvbFBvaW50c1szXV1cbiAgICAgICAgICAuY29uY2F0KG1pZGRsZSlcbiAgICAgICAgICAuY29uY2F0KFtcbiAgICAgICAgICAgIGxhc3RDb250cm9sUG9pbnRzWzBdLFxuICAgICAgICAgICAgbGFzdENvbnRyb2xQb2ludHNbMV0sXG4gICAgICAgICAgICBwW2xlbiAtIDJdLFxuICAgICAgICAgICAgcFtsZW4gLSAxXSxcbiAgICAgICAgICAgIGxhc3RDb250cm9sUG9pbnRzWzJdLFxuICAgICAgICAgICAgbGFzdENvbnRyb2xQb2ludHNbM10sXG4gICAgICAgICAgICBmaXJzdENvbnRyb2xQb2ludHNbMF0sXG4gICAgICAgICAgICBmaXJzdENvbnRyb2xQb2ludHNbMV0sXG4gICAgICAgICAgICBwWzBdLFxuICAgICAgICAgICAgcFsxXVxuICAgICAgICAgIF0pO1xuXG4gICAgICByZXR1cm4gdHA7XG4gICAgfSxcbiAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRTZWxmUmVjdCgpLndpZHRoO1xuICAgIH0sXG4gICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFNlbGZSZWN0KCkuaGVpZ2h0O1xuICAgIH0sXG4gICAgLy8gb3ZlcmxvYWQgc2l6ZSBkZXRlY3Rpb25cbiAgICBnZXRTZWxmUmVjdDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcG9pbnRzO1xuICAgICAgaWYgKHRoaXMuZ2V0VGVuc2lvbigpICE9PSAwKSB7XG4gICAgICAgIHBvaW50cyA9IHRoaXMuX2dldFRlbnNpb25Qb2ludHMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvaW50cyA9IHRoaXMuZ2V0UG9pbnRzKCk7XG4gICAgICB9XG4gICAgICB2YXIgbWluWCA9IHBvaW50c1swXTtcbiAgICAgIHZhciBtYXhYID0gcG9pbnRzWzBdO1xuICAgICAgdmFyIG1pblkgPSBwb2ludHNbMV07XG4gICAgICB2YXIgbWF4WSA9IHBvaW50c1sxXTtcbiAgICAgIHZhciB4LCB5O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICAgIHggPSBwb2ludHNbaSAqIDJdO1xuICAgICAgICB5ID0gcG9pbnRzW2kgKiAyICsgMV07XG4gICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB4KTtcbiAgICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIHgpO1xuICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgeSk7XG4gICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCB5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IE1hdGgucm91bmQobWluWCksXG4gICAgICAgIHk6IE1hdGgucm91bmQobWluWSksXG4gICAgICAgIHdpZHRoOiBNYXRoLnJvdW5kKG1heFggLSBtaW5YKSxcbiAgICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKG1heFkgLSBtaW5ZKVxuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLkxpbmUsIEtvbnZhLlNoYXBlKTtcblxuICAvLyBhZGQgZ2V0dGVycyBzZXR0ZXJzXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkxpbmUsICdjbG9zZWQnLCBmYWxzZSk7XG5cbiAgLyoqXG4gICAgICogZ2V0L3NldCBjbG9zZWQgZmxhZy4gIFRoZSBkZWZhdWx0IGlzIGZhbHNlXG4gICAgICogQG5hbWUgY2xvc2VkXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5MaW5lLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2xvc2VkXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgY2xvc2VkIGZsYWdcbiAgICAgKiB2YXIgY2xvc2VkID0gbGluZS5jbG9zZWQoKTtcbiAgICAgKlxuICAgICAqIC8vIGNsb3NlIHRoZSBzaGFwZVxuICAgICAqIGxpbmUuY2xvc2VkKHRydWUpO1xuICAgICAqXG4gICAgICogLy8gb3BlbiB0aGUgc2hhcGVcbiAgICAgKiBsaW5lLmNsb3NlZChmYWxzZSk7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTGluZSwgJ2JlemllcicsIGZhbHNlKTtcblxuICAvKipcbiAgICAqIGdldC9zZXQgYmV6aWVyIGZsYWcuICBUaGUgZGVmYXVsdCBpcyBmYWxzZVxuICAgICogQG5hbWUgYmV6aWVyXG4gICAgKiBAbWV0aG9kXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTGluZS5wcm90b3R5cGVcbiAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYmV6aWVyXG4gICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAqIEBleGFtcGxlXG4gICAgKiAvLyBnZXQgd2hldGhlciB0aGUgbGluZSBpcyBhIGJlemllclxuICAgICogdmFyIGlzQmV6aWVyID0gbGluZS5iZXppZXIoKTtcbiAgICAqXG4gICAgKiAvLyBzZXQgd2hldGhlciB0aGUgbGluZSBpcyBhIGJlemllclxuICAgICogbGluZS5iZXppZXIodHJ1ZSk7XG4gICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5MaW5lLCAndGVuc2lvbicsIDApO1xuXG4gIC8qKlxuICAgICAqIGdldC9zZXQgdGVuc2lvblxuICAgICAqIEBuYW1lIHRlbnNpb25cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkxpbmUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IEhpZ2hlciB2YWx1ZXMgd2lsbCByZXN1bHQgaW4gYSBtb3JlIGN1cnZ5IGxpbmUuICBBIHZhbHVlIG9mIDAgd2lsbCByZXN1bHQgaW4gbm8gaW50ZXJwb2xhdGlvbi5cbiAgICAgKiAgIFRoZSBkZWZhdWx0IGlzIDBcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHRlbnNpb25cbiAgICAgKiB2YXIgdGVuc2lvbiA9IGxpbmUudGVuc2lvbigpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHRlbnNpb25cbiAgICAgKiBsaW5lLnRlbnNpb24oMyk7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTGluZSwgJ3BvaW50cycsIFtdKTtcbiAgLyoqXG4gICAgICogZ2V0L3NldCBwb2ludHMgYXJyYXlcbiAgICAgKiBAbmFtZSBwb2ludHNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkxpbmUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHBvaW50c1xuICAgICAqIHZhciBwb2ludHMgPSBsaW5lLnBvaW50cygpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHBvaW50c1xuICAgICAqIGxpbmUucG9pbnRzKFsxMCwgMjAsIDMwLCA0MCwgNTAsIDYwXSk7XG4gICAgICpcbiAgICAgKiAvLyBwdXNoIGEgbmV3IHBvaW50XG4gICAgICogbGluZS5wb2ludHMobGluZS5wb2ludHMoKS5jb25jYXQoWzcwLCA4MF0pKTtcbiAgICAgKi9cblxuICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuTGluZSk7XG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLyoqXG4gICAgICogU3ByaXRlIGNvbnN0cnVjdG9yXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcuYW5pbWF0aW9uIGFuaW1hdGlvbiBrZXlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnLmFuaW1hdGlvbnMgYW5pbWF0aW9uIG1hcFxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gW2NvbmZpZy5mcmFtZUluZGV4XSBhbmltYXRpb24gZnJhbWUgaW5kZXhcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBjb25maWcuaW1hZ2UgaW1hZ2Ugb2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbF0gZmlsbCBjb2xvclxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IFtjb25maWcuZmlsbFBhdHRlcm5JbWFnZV0gZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5YXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WV0gXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZV0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblJvdGF0aW9uXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQYXR0ZXJuUmVwZWF0XSBjYW4gYmUgXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuICBUaGUgZGVmYXVsdCBpcyBcIm5vLXJlcGVhdFwiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5maWxsRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBmaWxsLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQcmlvcml0eV0gY2FuIGJlIGNvbG9yLCBsaW5lYXItZ3JhZGllbnQsIHJhZGlhbC1ncmFpZGVudCwgb3IgcGF0dGVybi4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGNvbG9yLiAgVGhlIGZpbGxQcmlvcml0eSBwcm9wZXJ0eSBtYWtlcyBpdCByZWFsbHkgZWFzeSB0byB0b2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgZmlsbCB0eXBlcy4gIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byB0b2dnbGUgYmV0d2VlbiBhIGZpbGwgY29sb3Igc3R5bGUgYW5kIGEgZmlsbCBwYXR0ZXJuIHN0eWxlLCBzaW1wbHkgc2V0IHRoZSBmaWxsIHByb3BlcnR5IGFuZCB0aGUgZmlsbFBhdHRlcm4gcHJvcGVydGllcywgYW5kIHRoZW4gdXNlIHNldEZpbGxQcmlvcml0eSgnY29sb3InKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggYSBjb2xvciBmaWxsLCBvciB1c2Ugc2V0RmlsbFByaW9yaXR5KCdwYXR0ZXJuJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIHRoZSBwYXR0ZXJuIGZpbGwgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnN0cm9rZV0gc3Ryb2tlIGNvbG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc3Ryb2tlV2lkdGhdIHN0cm9rZSB3aWR0aFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VIaXRFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIGhpdCByZWdpb24uICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnBlcmZlY3REcmF3RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHVzaW5nIGJ1ZmZlciBjYW52YXMuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzaGFzb3cgZm9yIHN0cm9rZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlU2NhbGVFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIHNjYWxlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHN0cm9rZS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lSm9pbl0gY2FuIGJlIG1pdGVyLCByb3VuZCwgb3IgYmV2ZWwuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBtaXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVDYXBdIGNhbiBiZSBidXR0LCByb3VuZCwgb3Igc3FhcmUuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBidXR0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc2hhZG93Q29sb3JdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93Qmx1cl1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zaGFkb3dPZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09wYWNpdHldIHNoYWRvdyBvcGFjaXR5LiAgQ2FuIGJlIGFueSByZWFsIG51bWJlclxuICAgICAqICBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzaGFkb3cuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5kYXNoXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kYXNoRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBkYXNoQXJyYXkuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBpbWFnZU9iaiA9IG5ldyBJbWFnZSgpO1xuICAgICAqIGltYWdlT2JqLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAqICAgdmFyIHNwcml0ZSA9IG5ldyBLb252YS5TcHJpdGUoe1xuICAgICAqICAgICB4OiAyMDAsXG4gICAgICogICAgIHk6IDEwMCxcbiAgICAgKiAgICAgaW1hZ2U6IGltYWdlT2JqLFxuICAgICAqICAgICBhbmltYXRpb246ICdzdGFuZGluZycsXG4gICAgICogICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgKiAgICAgICBzdGFuZGluZzogW1xuICAgICAqICAgICAgICAgLy8geCwgeSwgd2lkdGgsIGhlaWdodCAoNiBmcmFtZXMpXG4gICAgICogICAgICAgICAwLCAwLCA0OSwgMTA5LFxuICAgICAqICAgICAgICAgNTIsIDAsIDQ5LCAxMDksXG4gICAgICogICAgICAgICAxMDUsIDAsIDQ5LCAxMDksXG4gICAgICogICAgICAgICAxNTgsIDAsIDQ5LCAxMDksXG4gICAgICogICAgICAgICAyMTAsIDAsIDQ5LCAxMDksXG4gICAgICogICAgICAgICAyNjIsIDAsIDQ5LCAxMDlcbiAgICAgKiAgICAgICBdLFxuICAgICAqICAgICAgIGtpY2tpbmc6IFtcbiAgICAgKiAgICAgICAgIC8vIHgsIHksIHdpZHRoLCBoZWlnaHQgKDYgZnJhbWVzKVxuICAgICAqICAgICAgICAgMCwgMTA5LCA0NSwgOTgsXG4gICAgICogICAgICAgICA0NSwgMTA5LCA0NSwgOTgsXG4gICAgICogICAgICAgICA5NSwgMTA5LCA2MywgOTgsXG4gICAgICogICAgICAgICAxNTYsIDEwOSwgNzAsIDk4LFxuICAgICAqICAgICAgICAgMjI5LCAxMDksIDYwLCA5OCxcbiAgICAgKiAgICAgICAgIDI4NywgMTA5LCA0MSwgOThcbiAgICAgKiAgICAgICBdXG4gICAgICogICAgIH0sXG4gICAgICogICAgIGZyYW1lUmF0ZTogNyxcbiAgICAgKiAgICAgZnJhbWVJbmRleDogMFxuICAgICAqICAgfSk7XG4gICAgICogfTtcbiAgICAgKiBpbWFnZU9iai5zcmMgPSAnL3BhdGgvdG8vaW1hZ2UuanBnJ1xuICAgICAqL1xuICBLb252YS5TcHJpdGUgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICB0aGlzLl9fX2luaXQoY29uZmlnKTtcbiAgfTtcblxuICBLb252YS5TcHJpdGUucHJvdG90eXBlID0ge1xuICAgIF9fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxuICAgICAgS29udmEuU2hhcGUuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnU3ByaXRlJztcblxuICAgICAgdGhpcy5fdXBkYXRlZCA9IHRydWU7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB0aGlzLmFuaW0gPSBuZXcgS29udmEuQW5pbWF0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBpZiB3ZSBkb24ndCBuZWVkIHRvIHJlZHJhdyBsYXllciB3ZSBzaG91bGQgcmV0dXJuIGZhbHNlXG4gICAgICAgIHZhciB1cGRhdGVkID0gdGhhdC5fdXBkYXRlZDtcbiAgICAgICAgdGhhdC5fdXBkYXRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdXBkYXRlZDtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5vbignYW5pbWF0aW9uQ2hhbmdlLmtvbnZhJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIHJlc2V0IGluZGV4IHdoZW4gYW5pbWF0aW9uIGNoYW5nZXNcbiAgICAgICAgdGhpcy5mcmFtZUluZGV4KDApO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm9uKCdmcmFtZUluZGV4Q2hhbmdlLmtvbnZhJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZWQgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICAvLyBzbW9vdGggY2hhbmdlIGZvciBmcmFtZVJhdGVcbiAgICAgIHRoaXMub24oJ2ZyYW1lUmF0ZUNoYW5nZS5rb252YScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuYW5pbS5pc1J1bm5pbmcoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWwpO1xuICAgICAgICB0aGlzLl9zZXRJbnRlcnZhbCgpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuc2NlbmVGdW5jKHRoaXMuX3NjZW5lRnVuYyk7XG4gICAgICB0aGlzLmhpdEZ1bmModGhpcy5faGl0RnVuYyk7XG4gICAgfSxcbiAgICBfc2NlbmVGdW5jOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICB2YXIgYW5pbSA9IHRoaXMuZ2V0QW5pbWF0aW9uKCksXG4gICAgICAgIGluZGV4ID0gdGhpcy5mcmFtZUluZGV4KCksXG4gICAgICAgIGl4NCA9IGluZGV4ICogNCxcbiAgICAgICAgc2V0ID0gdGhpcy5nZXRBbmltYXRpb25zKClbYW5pbV0sXG4gICAgICAgIG9mZnNldHMgPSB0aGlzLmZyYW1lT2Zmc2V0cygpLFxuICAgICAgICB4ID0gc2V0W2l4NCArIDBdLFxuICAgICAgICB5ID0gc2V0W2l4NCArIDFdLFxuICAgICAgICB3aWR0aCA9IHNldFtpeDQgKyAyXSxcbiAgICAgICAgaGVpZ2h0ID0gc2V0W2l4NCArIDNdLFxuICAgICAgICBpbWFnZSA9IHRoaXMuZ2V0SW1hZ2UoKTtcblxuICAgICAgaWYgKHRoaXMuaGFzRmlsbCgpIHx8IHRoaXMuaGFzU3Ryb2tlKCkpIHtcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgY29udGV4dC5yZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGltYWdlKSB7XG4gICAgICAgIGlmIChvZmZzZXRzKSB7XG4gICAgICAgICAgdmFyIG9mZnNldCA9IG9mZnNldHNbYW5pbV0sIGl4MiA9IGluZGV4ICogMjtcbiAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShcbiAgICAgICAgICAgIGltYWdlLFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHksXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIG9mZnNldFtpeDIgKyAwXSxcbiAgICAgICAgICAgIG9mZnNldFtpeDIgKyAxXSxcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIF9oaXRGdW5jOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICB2YXIgYW5pbSA9IHRoaXMuZ2V0QW5pbWF0aW9uKCksXG4gICAgICAgIGluZGV4ID0gdGhpcy5mcmFtZUluZGV4KCksXG4gICAgICAgIGl4NCA9IGluZGV4ICogNCxcbiAgICAgICAgc2V0ID0gdGhpcy5nZXRBbmltYXRpb25zKClbYW5pbV0sXG4gICAgICAgIG9mZnNldHMgPSB0aGlzLmZyYW1lT2Zmc2V0cygpLFxuICAgICAgICB3aWR0aCA9IHNldFtpeDQgKyAyXSxcbiAgICAgICAgaGVpZ2h0ID0gc2V0W2l4NCArIDNdO1xuXG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgaWYgKG9mZnNldHMpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IG9mZnNldHNbYW5pbV07XG4gICAgICAgIHZhciBpeDIgPSBpbmRleCAqIDI7XG4gICAgICAgIGNvbnRleHQucmVjdChvZmZzZXRbaXgyICsgMF0sIG9mZnNldFtpeDIgKyAxXSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LnJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgY29udGV4dC5maWxsU2hhcGUodGhpcyk7XG4gICAgfSxcbiAgICBfdXNlQnVmZmVyQ2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgICh0aGlzLmhhc1NoYWRvdygpIHx8IHRoaXMuZ2V0QWJzb2x1dGVPcGFjaXR5KCkgIT09IDEpICYmXG4gICAgICAgIHRoaXMuaGFzU3Ryb2tlKClcbiAgICAgICk7XG4gICAgfSxcbiAgICBfc2V0SW50ZXJ2YWw6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgdGhpcy5pbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGF0Ll91cGRhdGVJbmRleCgpO1xuICAgICAgfSwgMTAwMCAvIHRoaXMuZ2V0RnJhbWVSYXRlKCkpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIHN0YXJ0IHNwcml0ZSBhbmltYXRpb25cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU3ByaXRlLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICBzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKCk7XG5cbiAgICAgIC8qXG4gICAgICAgICAgICAgKiBhbmltYXRpb24gb2JqZWN0IGhhcyBubyBleGVjdXRhYmxlIGZ1bmN0aW9uIGJlY2F1c2VcbiAgICAgICAgICAgICAqICB0aGUgdXBkYXRlcyBhcmUgZG9uZSB3aXRoIGEgZml4ZWQgRlBTIHdpdGggdGhlIHNldEludGVydmFsXG4gICAgICAgICAgICAgKiAgYmVsb3cuICBUaGUgYW5pbSBvYmplY3Qgb25seSBuZWVkcyB0aGUgbGF5ZXIgcmVmZXJlbmNlIGZvclxuICAgICAgICAgICAgICogIHJlZHJhd1xuICAgICAgICAgICAgICovXG4gICAgICB0aGlzLmFuaW0uc2V0TGF5ZXJzKGxheWVyKTtcbiAgICAgIHRoaXMuX3NldEludGVydmFsKCk7XG4gICAgICB0aGlzLmFuaW0uc3RhcnQoKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiBzdG9wIHNwcml0ZSBhbmltYXRpb25cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU3ByaXRlLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuYW5pbS5zdG9wKCk7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWwpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIGRldGVybWluZSBpZiBhbmltYXRpb24gb2Ygc3ByaXRlIGlzIHJ1bm5pbmcgb3Igbm90LiAgcmV0dXJucyB0cnVlIG9yIGZhbHNlXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkFuaW1hdGlvbi5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgIGlzUnVubmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5hbmltLmlzUnVubmluZygpO1xuICAgIH0sXG4gICAgX3VwZGF0ZUluZGV4OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuZnJhbWVJbmRleCgpLFxuICAgICAgICBhbmltYXRpb24gPSB0aGlzLmdldEFuaW1hdGlvbigpLFxuICAgICAgICBhbmltYXRpb25zID0gdGhpcy5nZXRBbmltYXRpb25zKCksXG4gICAgICAgIGFuaW0gPSBhbmltYXRpb25zW2FuaW1hdGlvbl0sXG4gICAgICAgIGxlbiA9IGFuaW0ubGVuZ3RoIC8gNDtcblxuICAgICAgaWYgKGluZGV4IDwgbGVuIC0gMSkge1xuICAgICAgICB0aGlzLmZyYW1lSW5kZXgoaW5kZXggKyAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZnJhbWVJbmRleCgwKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLlNwcml0ZSwgS29udmEuU2hhcGUpO1xuXG4gIC8vIGFkZCBnZXR0ZXJzIHNldHRlcnNcbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU3ByaXRlLCAnYW5pbWF0aW9uJyk7XG5cbiAgLyoqXG4gICAgICogZ2V0L3NldCBhbmltYXRpb24ga2V5XG4gICAgICogQG5hbWUgYW5pbWF0aW9uXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TcHJpdGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFuaW0gYW5pbWF0aW9uIGtleVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgYW5pbWF0aW9uIGtleVxuICAgICAqIHZhciBhbmltYXRpb24gPSBzcHJpdGUuYW5pbWF0aW9uKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgYW5pbWF0aW9uIGtleVxuICAgICAqIHNwcml0ZS5hbmltYXRpb24oJ2tpY2tpbmcnKTtcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TcHJpdGUsICdhbmltYXRpb25zJyk7XG5cbiAgLyoqXG4gICAgICogZ2V0L3NldCBhbmltYXRpb25zIG1hcFxuICAgICAqIEBuYW1lIGFuaW1hdGlvbnNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNwcml0ZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYW5pbWF0aW9uc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgYW5pbWF0aW9ucyBtYXBcbiAgICAgKiB2YXIgYW5pbWF0aW9ucyA9IHNwcml0ZS5hbmltYXRpb25zKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgYW5pbWF0aW9ucyBtYXBcbiAgICAgKiBzcHJpdGUuYW5pbWF0aW9ucyh7XG4gICAgICogICBzdGFuZGluZzogW1xuICAgICAqICAgICAvLyB4LCB5LCB3aWR0aCwgaGVpZ2h0ICg2IGZyYW1lcylcbiAgICAgKiAgICAgMCwgMCwgNDksIDEwOSxcbiAgICAgKiAgICAgNTIsIDAsIDQ5LCAxMDksXG4gICAgICogICAgIDEwNSwgMCwgNDksIDEwOSxcbiAgICAgKiAgICAgMTU4LCAwLCA0OSwgMTA5LFxuICAgICAqICAgICAyMTAsIDAsIDQ5LCAxMDksXG4gICAgICogICAgIDI2MiwgMCwgNDksIDEwOVxuICAgICAqICAgXSxcbiAgICAgKiAgIGtpY2tpbmc6IFtcbiAgICAgKiAgICAgLy8geCwgeSwgd2lkdGgsIGhlaWdodCAoNiBmcmFtZXMpXG4gICAgICogICAgIDAsIDEwOSwgNDUsIDk4LFxuICAgICAqICAgICA0NSwgMTA5LCA0NSwgOTgsXG4gICAgICogICAgIDk1LCAxMDksIDYzLCA5OCxcbiAgICAgKiAgICAgMTU2LCAxMDksIDcwLCA5OCxcbiAgICAgKiAgICAgMjI5LCAxMDksIDYwLCA5OCxcbiAgICAgKiAgICAgMjg3LCAxMDksIDQxLCA5OFxuICAgICAqICAgXVxuICAgICAqIH0pO1xuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNwcml0ZSwgJ2ZyYW1lT2Zmc2V0cycpO1xuXG4gIC8qKlxuICAgICogZ2V0L3NldCBvZmZzZXRzIG1hcFxuICAgICogQG5hbWUgb2Zmc2V0c1xuICAgICogQG1ldGhvZFxuICAgICogQG1lbWJlcm9mIEtvbnZhLlNwcml0ZS5wcm90b3R5cGVcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBvZmZzZXRzXG4gICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICogQGV4YW1wbGVcbiAgICAqIC8vIGdldCBvZmZzZXRzIG1hcFxuICAgICogdmFyIG9mZnNldHMgPSBzcHJpdGUub2Zmc2V0cygpO1xuICAgICpcbiAgICAqIC8vIHNldCBvZmZzZXRzIG1hcFxuICAgICogc3ByaXRlLm9mZnNldHMoe1xuICAgICogICBzdGFuZGluZzogW1xuICAgICogICAgIC8vIHgsIHkgKDYgZnJhbWVzKVxuICAgICogICAgIDAsIDAsXG4gICAgKiAgICAgMCwgMCxcbiAgICAqICAgICA1LCAwLFxuICAgICogICAgIDAsIDAsXG4gICAgKiAgICAgMCwgMyxcbiAgICAqICAgICAyLCAwXG4gICAgKiAgIF0sXG4gICAgKiAgIGtpY2tpbmc6IFtcbiAgICAqICAgICAvLyB4LCB5ICg2IGZyYW1lcylcbiAgICAqICAgICAwLCA1LFxuICAgICogICAgIDUsIDAsXG4gICAgKiAgICAgMTAsIDAsXG4gICAgKiAgICAgMCwgMCxcbiAgICAqICAgICAyLCAxLFxuICAgICogICAgIDAsIDBcbiAgICAqICAgXVxuICAgICogfSk7XG4gICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TcHJpdGUsICdpbWFnZScpO1xuXG4gIC8qKlxuICAgICAqIGdldC9zZXQgaW1hZ2VcbiAgICAgKiBAbmFtZSBpbWFnZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU3ByaXRlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IGltYWdlXG4gICAgICogQHJldHVybnMge0ltYWdlfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGltYWdlXG4gICAgICogdmFyIGltYWdlID0gc3ByaXRlLmltYWdlKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgaW1hZ2VcbiAgICAgKiBzcHJpdGUuaW1hZ2UoaW1hZ2VPYmopO1xuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNwcml0ZSwgJ2ZyYW1lSW5kZXgnLCAwKTtcblxuICAvKipcbiAgICAgKiBzZXQvc2V0IGFuaW1hdGlvbiBmcmFtZSBpbmRleFxuICAgICAqIEBuYW1lIGZyYW1lSW5kZXhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNwcml0ZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IGZyYW1lSW5kZXhcbiAgICAgKiBAcmV0dXJucyB7SW50ZWdlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBhbmltYXRpb24gZnJhbWUgaW5kZXhcbiAgICAgKiB2YXIgZnJhbWVJbmRleCA9IHNwcml0ZS5mcmFtZUluZGV4KCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgYW5pbWF0aW9uIGZyYW1lIGluZGV4XG4gICAgICogc3ByaXRlLmZyYW1lSW5kZXgoMyk7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU3ByaXRlLCAnZnJhbWVSYXRlJywgMTcpO1xuXG4gIC8qKlxuICAgICAqIGdldC9zZXQgZnJhbWUgcmF0ZSBpbiBmcmFtZXMgcGVyIHNlY29uZC4gIEluY3JlYXNlIHRoaXMgbnVtYmVyIHRvIG1ha2UgdGhlIHNwcml0ZVxuICAgICAqICBhbmltYXRpb24gcnVuIGZhc3RlciwgYW5kIGRlY3JlYXNlIHRoZSBudW1iZXIgdG8gbWFrZSB0aGUgc3ByaXRlIGFuaW1hdGlvbiBydW4gc2xvd2VyXG4gICAgICogIFRoZSBkZWZhdWx0IGlzIDE3IGZyYW1lcyBwZXIgc2Vjb25kXG4gICAgICogQG5hbWUgZnJhbWVSYXRlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TcHJpdGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBmcmFtZVJhdGVcbiAgICAgKiBAcmV0dXJucyB7SW50ZWdlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmcmFtZSByYXRlXG4gICAgICogdmFyIGZyYW1lUmF0ZSA9IHNwcml0ZS5mcmFtZVJhdGUoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBmcmFtZSByYXRlIHRvIDIgZnJhbWVzIHBlciBzZWNvbmRcbiAgICAgKiBzcHJpdGUuZnJhbWVSYXRlKDIpO1xuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYmFja0NvbXBhdChLb252YS5TcHJpdGUsIHtcbiAgICBpbmRleDogJ2ZyYW1lSW5kZXgnLFxuICAgIGdldEluZGV4OiAnZ2V0RnJhbWVJbmRleCcsXG4gICAgc2V0SW5kZXg6ICdzZXRGcmFtZUluZGV4J1xuICB9KTtcblxuICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuU3ByaXRlKTtcbn0pKCk7XG5cbi8qZXNsaW50LWRpc2FibGUgIG5vLXNoYWRvdywgbWF4LWxlbiwgbWF4LWRlcHRoICovXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLyoqXG4gICAgICogUGF0aCBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAYXV0aG9yIEphc29uIEZvbGxhc1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBhdWdtZW50cyBLb252YS5TaGFwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLmRhdGEgU1ZHIGRhdGEgc3RyaW5nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbF0gZmlsbCBjb2xvclxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IFtjb25maWcuZmlsbFBhdHRlcm5JbWFnZV0gZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5YXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WV0gXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZV0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblJvdGF0aW9uXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQYXR0ZXJuUmVwZWF0XSBjYW4gYmUgXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuICBUaGUgZGVmYXVsdCBpcyBcIm5vLXJlcGVhdFwiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5maWxsRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBmaWxsLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQcmlvcml0eV0gY2FuIGJlIGNvbG9yLCBsaW5lYXItZ3JhZGllbnQsIHJhZGlhbC1ncmFpZGVudCwgb3IgcGF0dGVybi4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGNvbG9yLiAgVGhlIGZpbGxQcmlvcml0eSBwcm9wZXJ0eSBtYWtlcyBpdCByZWFsbHkgZWFzeSB0byB0b2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgZmlsbCB0eXBlcy4gIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byB0b2dnbGUgYmV0d2VlbiBhIGZpbGwgY29sb3Igc3R5bGUgYW5kIGEgZmlsbCBwYXR0ZXJuIHN0eWxlLCBzaW1wbHkgc2V0IHRoZSBmaWxsIHByb3BlcnR5IGFuZCB0aGUgZmlsbFBhdHRlcm4gcHJvcGVydGllcywgYW5kIHRoZW4gdXNlIHNldEZpbGxQcmlvcml0eSgnY29sb3InKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggYSBjb2xvciBmaWxsLCBvciB1c2Ugc2V0RmlsbFByaW9yaXR5KCdwYXR0ZXJuJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIHRoZSBwYXR0ZXJuIGZpbGwgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnN0cm9rZV0gc3Ryb2tlIGNvbG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc3Ryb2tlV2lkdGhdIHN0cm9rZSB3aWR0aFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VIaXRFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIGhpdCByZWdpb24uICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnBlcmZlY3REcmF3RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHVzaW5nIGJ1ZmZlciBjYW52YXMuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzaGFzb3cgZm9yIHN0cm9rZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlU2NhbGVFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIHNjYWxlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHN0cm9rZS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lSm9pbl0gY2FuIGJlIG1pdGVyLCByb3VuZCwgb3IgYmV2ZWwuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBtaXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVDYXBdIGNhbiBiZSBidXR0LCByb3VuZCwgb3Igc3FhcmUuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBidXR0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc2hhZG93Q29sb3JdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93Qmx1cl1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zaGFkb3dPZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09wYWNpdHldIHNoYWRvdyBvcGFjaXR5LiAgQ2FuIGJlIGFueSByZWFsIG51bWJlclxuICAgICAqICBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzaGFkb3cuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5kYXNoXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kYXNoRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBkYXNoQXJyYXkuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBwYXRoID0gbmV3IEtvbnZhLlBhdGgoe1xuICAgICAqICAgeDogMjQwLFxuICAgICAqICAgeTogNDAsXG4gICAgICogICBkYXRhOiAnTTEyLjU4Miw5LjU1MUMzLjI1MSwxNi4yMzcsMC45MjEsMjkuMDIxLDcuMDgsMzguNTY0bC0yLjM2LDEuNjg5bDQuODkzLDIuMjYybDQuODkzLDIuMjYybC0wLjU2OC01LjM2bC0wLjU2Ny01LjM1OWwtMi4zNjUsMS42OTRjLTQuNjU3LTcuMzc1LTIuODMtMTcuMTg1LDQuMzUyLTIyLjMzYzcuNDUxLTUuMzM4LDE3LjgxNy0zLjYyNSwyMy4xNTYsMy44MjRjNS4zMzcsNy40NDksMy42MjUsMTcuODEzLTMuODIxLDIzLjE1MmwyLjg1NywzLjk4OGM5LjYxNy02Ljg5MywxMS44MjctMjAuMjc3LDQuOTM1LTI5Ljg5NkMzNS41OTEsNC44NywyMi4yMDQsMi42NTgsMTIuNTgyLDkuNTUxeicsXG4gICAgICogICBmaWxsOiAnZ3JlZW4nLFxuICAgICAqICAgc2NhbGU6IDJcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgS29udmEuUGF0aCA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHRoaXMuX19faW5pdChjb25maWcpO1xuICB9O1xuXG4gIEtvbnZhLlBhdGgucHJvdG90eXBlID0ge1xuICAgIF9fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgdGhpcy5kYXRhQXJyYXkgPSBbXTtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxuICAgICAgS29udmEuU2hhcGUuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnUGF0aCc7XG5cbiAgICAgIHRoaXMuZGF0YUFycmF5ID0gS29udmEuUGF0aC5wYXJzZVBhdGhEYXRhKHRoaXMuZ2V0RGF0YSgpKTtcbiAgICAgIHRoaXMub24oJ2RhdGFDaGFuZ2Uua29udmEnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhhdC5kYXRhQXJyYXkgPSBLb252YS5QYXRoLnBhcnNlUGF0aERhdGEodGhpcy5nZXREYXRhKCkpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuc2NlbmVGdW5jKHRoaXMuX3NjZW5lRnVuYyk7XG4gICAgfSxcbiAgICBfc2NlbmVGdW5jOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICB2YXIgY2EgPSB0aGlzLmRhdGFBcnJheTtcblxuICAgICAgLy8gY29udGV4dCBwb3NpdGlvblxuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgY2EubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgdmFyIGMgPSBjYVtuXS5jb21tYW5kO1xuICAgICAgICB2YXIgcCA9IGNhW25dLnBvaW50cztcbiAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhwWzBdLCBwWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8ocFswXSwgcFsxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyhwWzBdLCBwWzFdLCBwWzJdLCBwWzNdLCBwWzRdLCBwWzVdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ1EnOlxuICAgICAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHBbMF0sIHBbMV0sIHBbMl0sIHBbM10pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICB2YXIgY3ggPSBwWzBdLFxuICAgICAgICAgICAgICBjeSA9IHBbMV0sXG4gICAgICAgICAgICAgIHJ4ID0gcFsyXSxcbiAgICAgICAgICAgICAgcnkgPSBwWzNdLFxuICAgICAgICAgICAgICB0aGV0YSA9IHBbNF0sXG4gICAgICAgICAgICAgIGRUaGV0YSA9IHBbNV0sXG4gICAgICAgICAgICAgIHBzaSA9IHBbNl0sXG4gICAgICAgICAgICAgIGZzID0gcFs3XTtcblxuICAgICAgICAgICAgdmFyIHIgPSByeCA+IHJ5ID8gcnggOiByeTtcbiAgICAgICAgICAgIHZhciBzY2FsZVggPSByeCA+IHJ5ID8gMSA6IHJ4IC8gcnk7XG4gICAgICAgICAgICB2YXIgc2NhbGVZID0gcnggPiByeSA/IHJ5IC8gcnggOiAxO1xuXG4gICAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZShjeCwgY3kpO1xuICAgICAgICAgICAgY29udGV4dC5yb3RhdGUocHNpKTtcbiAgICAgICAgICAgIGNvbnRleHQuc2NhbGUoc2NhbGVYLCBzY2FsZVkpO1xuICAgICAgICAgICAgY29udGV4dC5hcmMoMCwgMCwgciwgdGhldGEsIHRoZXRhICsgZFRoZXRhLCAxIC0gZnMpO1xuICAgICAgICAgICAgY29udGV4dC5zY2FsZSgxIC8gc2NhbGVYLCAxIC8gc2NhbGVZKTtcbiAgICAgICAgICAgIGNvbnRleHQucm90YXRlKC1wc2kpO1xuICAgICAgICAgICAgY29udGV4dC50cmFuc2xhdGUoLWN4LCAtY3kpO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd6JzpcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICB9LFxuICAgIGdldFNlbGZSZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICAgIHRoaXMuZGF0YUFycmF5LmZvckVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBwb2ludHMgPSBwb2ludHMuY29uY2F0KGRhdGEucG9pbnRzKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIG1pblggPSBwb2ludHNbMF07XG4gICAgICB2YXIgbWF4WCA9IHBvaW50c1swXTtcbiAgICAgIHZhciBtaW5ZID0gcG9pbnRzWzFdO1xuICAgICAgdmFyIG1heFkgPSBwb2ludHNbMV07XG4gICAgICB2YXIgeCwgeTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgICB4ID0gcG9pbnRzW2kgKiAyXTtcbiAgICAgICAgeSA9IHBvaW50c1tpICogMiArIDFdO1xuICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgeCk7XG4gICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCB4KTtcbiAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIHkpO1xuICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgeSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBNYXRoLnJvdW5kKG1pblgpLFxuICAgICAgICB5OiBNYXRoLnJvdW5kKG1pblkpLFxuICAgICAgICB3aWR0aDogTWF0aC5yb3VuZChtYXhYIC0gbWluWCksXG4gICAgICAgIGhlaWdodDogTWF0aC5yb3VuZChtYXhZIC0gbWluWSlcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICBLb252YS5VdGlsLmV4dGVuZChLb252YS5QYXRoLCBLb252YS5TaGFwZSk7XG5cbiAgS29udmEuUGF0aC5nZXRMaW5lTGVuZ3RoID0gZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KCh4MiAtIHgxKSAqICh4MiAtIHgxKSArICh5MiAtIHkxKSAqICh5MiAtIHkxKSk7XG4gIH07XG4gIEtvbnZhLlBhdGguZ2V0UG9pbnRPbkxpbmUgPSBmdW5jdGlvbihkaXN0LCBQMXgsIFAxeSwgUDJ4LCBQMnksIGZyb21YLCBmcm9tWSkge1xuICAgIGlmIChmcm9tWCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmcm9tWCA9IFAxeDtcbiAgICB9XG4gICAgaWYgKGZyb21ZID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZyb21ZID0gUDF5O1xuICAgIH1cblxuICAgIHZhciBtID0gKFAyeSAtIFAxeSkgLyAoUDJ4IC0gUDF4ICsgMC4wMDAwMDAwMSk7XG4gICAgdmFyIHJ1biA9IE1hdGguc3FydChkaXN0ICogZGlzdCAvICgxICsgbSAqIG0pKTtcbiAgICBpZiAoUDJ4IDwgUDF4KSB7XG4gICAgICBydW4gKj0gLTE7XG4gICAgfVxuICAgIHZhciByaXNlID0gbSAqIHJ1bjtcbiAgICB2YXIgcHQ7XG5cbiAgICBpZiAoUDJ4ID09PSBQMXgpIHtcbiAgICAgIC8vIHZlcnRpY2FsIGxpbmVcbiAgICAgIHB0ID0ge1xuICAgICAgICB4OiBmcm9tWCxcbiAgICAgICAgeTogZnJvbVkgKyByaXNlXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoKGZyb21ZIC0gUDF5KSAvIChmcm9tWCAtIFAxeCArIDAuMDAwMDAwMDEpID09PSBtKSB7XG4gICAgICBwdCA9IHtcbiAgICAgICAgeDogZnJvbVggKyBydW4sXG4gICAgICAgIHk6IGZyb21ZICsgcmlzZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGl4LCBpeTtcblxuICAgICAgdmFyIGxlbiA9IHRoaXMuZ2V0TGluZUxlbmd0aChQMXgsIFAxeSwgUDJ4LCBQMnkpO1xuICAgICAgaWYgKGxlbiA8IDAuMDAwMDAwMDEpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHZhciB1ID0gKGZyb21YIC0gUDF4KSAqIChQMnggLSBQMXgpICsgKGZyb21ZIC0gUDF5KSAqIChQMnkgLSBQMXkpO1xuICAgICAgdSA9IHUgLyAobGVuICogbGVuKTtcbiAgICAgIGl4ID0gUDF4ICsgdSAqIChQMnggLSBQMXgpO1xuICAgICAgaXkgPSBQMXkgKyB1ICogKFAyeSAtIFAxeSk7XG5cbiAgICAgIHZhciBwUmlzZSA9IHRoaXMuZ2V0TGluZUxlbmd0aChmcm9tWCwgZnJvbVksIGl4LCBpeSk7XG4gICAgICB2YXIgcFJ1biA9IE1hdGguc3FydChkaXN0ICogZGlzdCAtIHBSaXNlICogcFJpc2UpO1xuICAgICAgcnVuID0gTWF0aC5zcXJ0KHBSdW4gKiBwUnVuIC8gKDEgKyBtICogbSkpO1xuICAgICAgaWYgKFAyeCA8IFAxeCkge1xuICAgICAgICBydW4gKj0gLTE7XG4gICAgICB9XG4gICAgICByaXNlID0gbSAqIHJ1bjtcbiAgICAgIHB0ID0ge1xuICAgICAgICB4OiBpeCArIHJ1bixcbiAgICAgICAgeTogaXkgKyByaXNlXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBwdDtcbiAgfTtcblxuICBLb252YS5QYXRoLmdldFBvaW50T25DdWJpY0JlemllciA9IGZ1bmN0aW9uKFxuICAgIHBjdCxcbiAgICBQMXgsXG4gICAgUDF5LFxuICAgIFAyeCxcbiAgICBQMnksXG4gICAgUDN4LFxuICAgIFAzeSxcbiAgICBQNHgsXG4gICAgUDR5XG4gICkge1xuICAgIGZ1bmN0aW9uIENCMSh0KSB7XG4gICAgICByZXR1cm4gdCAqIHQgKiB0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBDQjIodCkge1xuICAgICAgcmV0dXJuIDMgKiB0ICogdCAqICgxIC0gdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIENCMyh0KSB7XG4gICAgICByZXR1cm4gMyAqIHQgKiAoMSAtIHQpICogKDEgLSB0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQ0I0KHQpIHtcbiAgICAgIHJldHVybiAoMSAtIHQpICogKDEgLSB0KSAqICgxIC0gdCk7XG4gICAgfVxuICAgIHZhciB4ID0gUDR4ICogQ0IxKHBjdCkgKyBQM3ggKiBDQjIocGN0KSArIFAyeCAqIENCMyhwY3QpICsgUDF4ICogQ0I0KHBjdCk7XG4gICAgdmFyIHkgPSBQNHkgKiBDQjEocGN0KSArIFAzeSAqIENCMihwY3QpICsgUDJ5ICogQ0IzKHBjdCkgKyBQMXkgKiBDQjQocGN0KTtcblxuICAgIHJldHVybiB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeVxuICAgIH07XG4gIH07XG4gIEtvbnZhLlBhdGguZ2V0UG9pbnRPblF1YWRyYXRpY0JlemllciA9IGZ1bmN0aW9uKFxuICAgIHBjdCxcbiAgICBQMXgsXG4gICAgUDF5LFxuICAgIFAyeCxcbiAgICBQMnksXG4gICAgUDN4LFxuICAgIFAzeVxuICApIHtcbiAgICBmdW5jdGlvbiBRQjEodCkge1xuICAgICAgcmV0dXJuIHQgKiB0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBRQjIodCkge1xuICAgICAgcmV0dXJuIDIgKiB0ICogKDEgLSB0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUUIzKHQpIHtcbiAgICAgIHJldHVybiAoMSAtIHQpICogKDEgLSB0KTtcbiAgICB9XG4gICAgdmFyIHggPSBQM3ggKiBRQjEocGN0KSArIFAyeCAqIFFCMihwY3QpICsgUDF4ICogUUIzKHBjdCk7XG4gICAgdmFyIHkgPSBQM3kgKiBRQjEocGN0KSArIFAyeSAqIFFCMihwY3QpICsgUDF5ICogUUIzKHBjdCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHlcbiAgICB9O1xuICB9O1xuICBLb252YS5QYXRoLmdldFBvaW50T25FbGxpcHRpY2FsQXJjID0gZnVuY3Rpb24oY3gsIGN5LCByeCwgcnksIHRoZXRhLCBwc2kpIHtcbiAgICB2YXIgY29zUHNpID0gTWF0aC5jb3MocHNpKSwgc2luUHNpID0gTWF0aC5zaW4ocHNpKTtcbiAgICB2YXIgcHQgPSB7XG4gICAgICB4OiByeCAqIE1hdGguY29zKHRoZXRhKSxcbiAgICAgIHk6IHJ5ICogTWF0aC5zaW4odGhldGEpXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogY3ggKyAocHQueCAqIGNvc1BzaSAtIHB0LnkgKiBzaW5Qc2kpLFxuICAgICAgeTogY3kgKyAocHQueCAqIHNpblBzaSArIHB0LnkgKiBjb3NQc2kpXG4gICAgfTtcbiAgfTtcbiAgLypcbiAgICAgKiBnZXQgcGFyc2VkIGRhdGEgYXJyYXkgZnJvbSB0aGUgZGF0YVxuICAgICAqICBzdHJpbmcuICBWLCB2LCBILCBoLCBhbmQgbCBkYXRhIGFyZSBjb252ZXJ0ZWQgdG9cbiAgICAgKiAgTCBkYXRhIGZvciB0aGUgcHVycG9zZSBvZiBoaWdoIHBlcmZvcm1hbmNlIFBhdGhcbiAgICAgKiAgcmVuZGVyaW5nXG4gICAgICovXG4gIEtvbnZhLlBhdGgucGFyc2VQYXRoRGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAvLyBQYXRoIERhdGEgU2VnbWVudCBtdXN0IGJlZ2luIHdpdGggYSBtb3ZlVG9cbiAgICAvL20gKHggeSkrICBSZWxhdGl2ZSBtb3ZlVG8gKHN1YnNlcXVlbnQgcG9pbnRzIGFyZSB0cmVhdGVkIGFzIGxpbmVUbylcbiAgICAvL00gKHggeSkrICBBYnNvbHV0ZSBtb3ZlVG8gKHN1YnNlcXVlbnQgcG9pbnRzIGFyZSB0cmVhdGVkIGFzIGxpbmVUbylcbiAgICAvL2wgKHggeSkrICBSZWxhdGl2ZSBsaW5lVG9cbiAgICAvL0wgKHggeSkrICBBYnNvbHV0ZSBMaW5lVG9cbiAgICAvL2ggKHgpKyAgICBSZWxhdGl2ZSBob3Jpem9udGFsIGxpbmVUb1xuICAgIC8vSCAoeCkrICAgIEFic29sdXRlIGhvcml6b250YWwgbGluZVRvXG4gICAgLy92ICh5KSsgICAgUmVsYXRpdmUgdmVydGljYWwgbGluZVRvXG4gICAgLy9WICh5KSsgICAgQWJzb2x1dGUgdmVydGljYWwgbGluZVRvXG4gICAgLy96IChjbG9zZXBhdGgpXG4gICAgLy9aIChjbG9zZXBhdGgpXG4gICAgLy9jICh4MSB5MSB4MiB5MiB4IHkpKyBSZWxhdGl2ZSBCZXppZXIgY3VydmVcbiAgICAvL0MgKHgxIHkxIHgyIHkyIHggeSkrIEFic29sdXRlIEJlemllciBjdXJ2ZVxuICAgIC8vcSAoeDEgeTEgeCB5KSsgICAgICAgUmVsYXRpdmUgUXVhZHJhdGljIEJlemllclxuICAgIC8vUSAoeDEgeTEgeCB5KSsgICAgICAgQWJzb2x1dGUgUXVhZHJhdGljIEJlemllclxuICAgIC8vdCAoeCB5KSsgICAgU2hvcnRoYW5kL1Ntb290aCBSZWxhdGl2ZSBRdWFkcmF0aWMgQmV6aWVyXG4gICAgLy9UICh4IHkpKyAgICBTaG9ydGhhbmQvU21vb3RoIEFic29sdXRlIFF1YWRyYXRpYyBCZXppZXJcbiAgICAvL3MgKHgyIHkyIHggeSkrICAgICAgIFNob3J0aGFuZC9TbW9vdGggUmVsYXRpdmUgQmV6aWVyIGN1cnZlXG4gICAgLy9TICh4MiB5MiB4IHkpKyAgICAgICBTaG9ydGhhbmQvU21vb3RoIEFic29sdXRlIEJlemllciBjdXJ2ZVxuICAgIC8vYSAocnggcnkgeC1heGlzLXJvdGF0aW9uIGxhcmdlLWFyYy1mbGFnIHN3ZWVwLWZsYWcgeCB5KSsgICAgIFJlbGF0aXZlIEVsbGlwdGljYWwgQXJjXG4gICAgLy9BIChyeCByeSB4LWF4aXMtcm90YXRpb24gbGFyZ2UtYXJjLWZsYWcgc3dlZXAtZmxhZyB4IHkpKyAgQWJzb2x1dGUgRWxsaXB0aWNhbCBBcmNcblxuICAgIC8vIHJldHVybiBlYXJseSBpZiBkYXRhIGlzIG5vdCBkZWZpbmVkXG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLy8gY29tbWFuZCBzdHJpbmdcbiAgICB2YXIgY3MgPSBkYXRhO1xuXG4gICAgLy8gY29tbWFuZCBjaGFyc1xuICAgIHZhciBjYyA9IFtcbiAgICAgICdtJyxcbiAgICAgICdNJyxcbiAgICAgICdsJyxcbiAgICAgICdMJyxcbiAgICAgICd2JyxcbiAgICAgICdWJyxcbiAgICAgICdoJyxcbiAgICAgICdIJyxcbiAgICAgICd6JyxcbiAgICAgICdaJyxcbiAgICAgICdjJyxcbiAgICAgICdDJyxcbiAgICAgICdxJyxcbiAgICAgICdRJyxcbiAgICAgICd0JyxcbiAgICAgICdUJyxcbiAgICAgICdzJyxcbiAgICAgICdTJyxcbiAgICAgICdhJyxcbiAgICAgICdBJ1xuICAgIF07XG4gICAgLy8gY29udmVydCB3aGl0ZSBzcGFjZXMgdG8gY29tbWFzXG4gICAgY3MgPSBjcy5yZXBsYWNlKG5ldyBSZWdFeHAoJyAnLCAnZycpLCAnLCcpO1xuICAgIC8vIGNyZWF0ZSBwaXBlcyBzbyB0aGF0IHdlIGNhbiBzcGxpdCB0aGUgZGF0YVxuICAgIGZvciAodmFyIG4gPSAwOyBuIDwgY2MubGVuZ3RoOyBuKyspIHtcbiAgICAgIGNzID0gY3MucmVwbGFjZShuZXcgUmVnRXhwKGNjW25dLCAnZycpLCAnfCcgKyBjY1tuXSk7XG4gICAgfVxuICAgIC8vIGNyZWF0ZSBhcnJheVxuICAgIHZhciBhcnIgPSBjcy5zcGxpdCgnfCcpO1xuICAgIHZhciBjYSA9IFtdO1xuICAgIC8vIGluaXQgY29udGV4dCBwb2ludFxuICAgIHZhciBjcHggPSAwO1xuICAgIHZhciBjcHkgPSAwO1xuICAgIGZvciAobiA9IDE7IG4gPCBhcnIubGVuZ3RoOyBuKyspIHtcbiAgICAgIHZhciBzdHIgPSBhcnJbbl07XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoMCk7XG4gICAgICBzdHIgPSBzdHIuc2xpY2UoMSk7XG4gICAgICAvLyByZW1vdmUgLC0gZm9yIGNvbnNpc3RlbmN5XG4gICAgICBzdHIgPSBzdHIucmVwbGFjZShuZXcgUmVnRXhwKCcsLScsICdnJyksICctJyk7XG4gICAgICAvLyBhZGQgY29tbWFzIHNvIHRoYXQgaXQncyBlYXN5IHRvIHNwbGl0XG4gICAgICBzdHIgPSBzdHIucmVwbGFjZShuZXcgUmVnRXhwKCctJywgJ2cnKSwgJywtJyk7XG4gICAgICBzdHIgPSBzdHIucmVwbGFjZShuZXcgUmVnRXhwKCdlLC0nLCAnZycpLCAnZS0nKTtcbiAgICAgIHZhciBwID0gc3RyLnNwbGl0KCcsJyk7XG4gICAgICBpZiAocC5sZW5ndGggPiAwICYmIHBbMF0gPT09ICcnKSB7XG4gICAgICAgIHAuc2hpZnQoKTtcbiAgICAgIH1cbiAgICAgIC8vIGNvbnZlcnQgc3RyaW5ncyB0byBmbG9hdHNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICBwW2ldID0gcGFyc2VGbG9hdChwW2ldKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChwLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGlzTmFOKHBbMF0pKSB7XG4gICAgICAgICAgLy8gY2FzZSBmb3IgYSB0cmFpbGluZyBjb21tYSBiZWZvcmUgbmV4dCBjb21tYW5kXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY21kID0gbnVsbDtcbiAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xuICAgICAgICB2YXIgc3RhcnRYID0gY3B4LCBzdGFydFkgPSBjcHk7XG4gICAgICAgIC8vIE1vdmUgdmFyIGZyb20gd2l0aGluIHRoZSBzd2l0Y2ggdG8gdXAgaGVyZSAoanNoaW50KVxuICAgICAgICB2YXIgcHJldkNtZCwgY3RsUHR4LCBjdGxQdHk7IC8vIFNzLCBUdFxuICAgICAgICB2YXIgcngsIHJ5LCBwc2ksIGZhLCBmcywgeDEsIHkxOyAvLyBBYVxuXG4gICAgICAgIC8vIGNvbnZlcnQgbCwgSCwgaCwgViwgYW5kIHYgdG8gTFxuICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICAvLyBOb3RlOiBLZWVwIHRoZSBsaW5lVG8ncyBhYm92ZSB0aGUgbW92ZVRvJ3MgaW4gdGhpcyBzd2l0Y2hcbiAgICAgICAgICBjYXNlICdsJzpcbiAgICAgICAgICAgIGNweCArPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBjcHkgKz0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgY21kID0gJ0wnO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgICBjcHggPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBjcHkgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAvLyBOb3RlOiBsaW5lVG8gaGFuZGxlcnMgbmVlZCB0byBiZSBhYm92ZSB0aGlzIHBvaW50XG4gICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICB2YXIgZHggPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICB2YXIgZHkgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBjcHggKz0gZHg7XG4gICAgICAgICAgICBjcHkgKz0gZHk7XG4gICAgICAgICAgICBjbWQgPSAnTSc7XG4gICAgICAgICAgICAvLyBBZnRlciBjbG9zaW5nIHRoZSBwYXRoIG1vdmUgdGhlIGN1cnJlbnQgcG9zaXRpb25cbiAgICAgICAgICAgIC8vIHRvIHRoZSB0aGUgZmlyc3QgcG9pbnQgb2YgdGhlIHBhdGggKGlmIGFueSkuXG4gICAgICAgICAgICBpZiAoY2EubGVuZ3RoID4gMiAmJiBjYVtjYS5sZW5ndGggLSAxXS5jb21tYW5kID09PSAneicpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaWR4ID0gY2EubGVuZ3RoIC0gMjsgaWR4ID49IDA7IGlkeC0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhW2lkeF0uY29tbWFuZCA9PT0gJ00nKSB7XG4gICAgICAgICAgICAgICAgICBjcHggPSBjYVtpZHhdLnBvaW50c1swXSArIGR4O1xuICAgICAgICAgICAgICAgICAgY3B5ID0gY2FbaWR4XS5wb2ludHNbMV0gKyBkeTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xuICAgICAgICAgICAgYyA9ICdsJztcbiAgICAgICAgICAgIC8vIHN1YnNlcXVlbnQgcG9pbnRzIGFyZSB0cmVhdGVkIGFzIHJlbGF0aXZlIGxpbmVUb1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgICBjcHggPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBjcHkgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBjbWQgPSAnTSc7XG4gICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XG4gICAgICAgICAgICBjID0gJ0wnO1xuICAgICAgICAgICAgLy8gc3Vic2VxdWVudCBwb2ludHMgYXJlIHRyZWF0ZWQgYXMgYWJzb2x1dGUgbGluZVRvXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICAgICAgY3B4ICs9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgIGNtZCA9ICdMJztcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0gnOlxuICAgICAgICAgICAgY3B4ID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgY21kID0gJ0wnO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgICBjcHkgKz0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgY21kID0gJ0wnO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnVic6XG4gICAgICAgICAgICBjcHkgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBjbWQgPSAnTCc7XG4gICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHAuc2hpZnQoKSwgcC5zaGlmdCgpLCBwLnNoaWZ0KCksIHAuc2hpZnQoKSk7XG4gICAgICAgICAgICBjcHggPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBjcHkgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKFxuICAgICAgICAgICAgICBjcHggKyBwLnNoaWZ0KCksXG4gICAgICAgICAgICAgIGNweSArIHAuc2hpZnQoKSxcbiAgICAgICAgICAgICAgY3B4ICsgcC5zaGlmdCgpLFxuICAgICAgICAgICAgICBjcHkgKyBwLnNoaWZ0KClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjcHggKz0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgY3B5ICs9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgIGNtZCA9ICdDJztcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ1MnOlxuICAgICAgICAgICAgY3RsUHR4ID0gY3B4O1xuICAgICAgICAgICAgY3RsUHR5ID0gY3B5O1xuICAgICAgICAgICAgcHJldkNtZCA9IGNhW2NhLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKHByZXZDbWQuY29tbWFuZCA9PT0gJ0MnKSB7XG4gICAgICAgICAgICAgIGN0bFB0eCA9IGNweCArIChjcHggLSBwcmV2Q21kLnBvaW50c1syXSk7XG4gICAgICAgICAgICAgIGN0bFB0eSA9IGNweSArIChjcHkgLSBwcmV2Q21kLnBvaW50c1szXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2ludHMucHVzaChjdGxQdHgsIGN0bFB0eSwgcC5zaGlmdCgpLCBwLnNoaWZ0KCkpO1xuICAgICAgICAgICAgY3B4ID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgY3B5ID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgY21kID0gJ0MnO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgICBwcmV2Q21kID0gY2FbY2EubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAocHJldkNtZC5jb21tYW5kID09PSAnQycpIHtcbiAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4ICsgKGNweCAtIHByZXZDbWQucG9pbnRzWzJdKTtcbiAgICAgICAgICAgICAgY3RsUHR5ID0gY3B5ICsgKGNweSAtIHByZXZDbWQucG9pbnRzWzNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvaW50cy5wdXNoKGN0bFB0eCwgY3RsUHR5LCBjcHggKyBwLnNoaWZ0KCksIGNweSArIHAuc2hpZnQoKSk7XG4gICAgICAgICAgICBjcHggKz0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgY3B5ICs9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgIGNtZCA9ICdDJztcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ1EnOlxuICAgICAgICAgICAgcG9pbnRzLnB1c2gocC5zaGlmdCgpLCBwLnNoaWZ0KCkpO1xuICAgICAgICAgICAgY3B4ID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgY3B5ID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAncSc6XG4gICAgICAgICAgICBwb2ludHMucHVzaChjcHggKyBwLnNoaWZ0KCksIGNweSArIHAuc2hpZnQoKSk7XG4gICAgICAgICAgICBjcHggKz0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgY3B5ICs9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgIGNtZCA9ICdRJztcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ1QnOlxuICAgICAgICAgICAgY3RsUHR4ID0gY3B4O1xuICAgICAgICAgICAgY3RsUHR5ID0gY3B5O1xuICAgICAgICAgICAgcHJldkNtZCA9IGNhW2NhLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKHByZXZDbWQuY29tbWFuZCA9PT0gJ1EnKSB7XG4gICAgICAgICAgICAgIGN0bFB0eCA9IGNweCArIChjcHggLSBwcmV2Q21kLnBvaW50c1swXSk7XG4gICAgICAgICAgICAgIGN0bFB0eSA9IGNweSArIChjcHkgLSBwcmV2Q21kLnBvaW50c1sxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjcHggPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBjcHkgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBjbWQgPSAnUSc7XG4gICAgICAgICAgICBwb2ludHMucHVzaChjdGxQdHgsIGN0bFB0eSwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgICBwcmV2Q21kID0gY2FbY2EubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAocHJldkNtZC5jb21tYW5kID09PSAnUScpIHtcbiAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4ICsgKGNweCAtIHByZXZDbWQucG9pbnRzWzBdKTtcbiAgICAgICAgICAgICAgY3RsUHR5ID0gY3B5ICsgKGNweSAtIHByZXZDbWQucG9pbnRzWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNweCArPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBjcHkgKz0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgY21kID0gJ1EnO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goY3RsUHR4LCBjdGxQdHksIGNweCwgY3B5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgICAgcnggPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICByeSA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgIHBzaSA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgIGZhID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgZnMgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICB4MSA9IGNweDtcbiAgICAgICAgICAgIHkxID0gY3B5O1xuICAgICAgICAgICAgY3B4ID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgY3B5ID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgY21kID0gJ0EnO1xuICAgICAgICAgICAgcG9pbnRzID0gdGhpcy5jb252ZXJ0RW5kcG9pbnRUb0NlbnRlclBhcmFtZXRlcml6YXRpb24oXG4gICAgICAgICAgICAgIHgxLFxuICAgICAgICAgICAgICB5MSxcbiAgICAgICAgICAgICAgY3B4LFxuICAgICAgICAgICAgICBjcHksXG4gICAgICAgICAgICAgIGZhLFxuICAgICAgICAgICAgICBmcyxcbiAgICAgICAgICAgICAgcngsXG4gICAgICAgICAgICAgIHJ5LFxuICAgICAgICAgICAgICBwc2lcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgIHJ4ID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgcnkgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBwc2kgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBmYSA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgIGZzID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgeDEgPSBjcHg7XG4gICAgICAgICAgICB5MSA9IGNweTtcbiAgICAgICAgICAgIGNweCArPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBjcHkgKz0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgY21kID0gJ0EnO1xuICAgICAgICAgICAgcG9pbnRzID0gdGhpcy5jb252ZXJ0RW5kcG9pbnRUb0NlbnRlclBhcmFtZXRlcml6YXRpb24oXG4gICAgICAgICAgICAgIHgxLFxuICAgICAgICAgICAgICB5MSxcbiAgICAgICAgICAgICAgY3B4LFxuICAgICAgICAgICAgICBjcHksXG4gICAgICAgICAgICAgIGZhLFxuICAgICAgICAgICAgICBmcyxcbiAgICAgICAgICAgICAgcngsXG4gICAgICAgICAgICAgIHJ5LFxuICAgICAgICAgICAgICBwc2lcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNhLnB1c2goe1xuICAgICAgICAgIGNvbW1hbmQ6IGNtZCB8fCBjLFxuICAgICAgICAgIHBvaW50czogcG9pbnRzLFxuICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICB4OiBzdGFydFgsXG4gICAgICAgICAgICB5OiBzdGFydFlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHBhdGhMZW5ndGg6IHRoaXMuY2FsY0xlbmd0aChzdGFydFgsIHN0YXJ0WSwgY21kIHx8IGMsIHBvaW50cylcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjID09PSAneicgfHwgYyA9PT0gJ1onKSB7XG4gICAgICAgIGNhLnB1c2goe1xuICAgICAgICAgIGNvbW1hbmQ6ICd6JyxcbiAgICAgICAgICBwb2ludHM6IFtdLFxuICAgICAgICAgIHN0YXJ0OiB1bmRlZmluZWQsXG4gICAgICAgICAgcGF0aExlbmd0aDogMFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2E7XG4gIH07XG4gIEtvbnZhLlBhdGguY2FsY0xlbmd0aCA9IGZ1bmN0aW9uKHgsIHksIGNtZCwgcG9pbnRzKSB7XG4gICAgdmFyIGxlbiwgcDEsIHAyLCB0O1xuICAgIHZhciBwYXRoID0gS29udmEuUGF0aDtcblxuICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICBjYXNlICdMJzpcbiAgICAgICAgcmV0dXJuIHBhdGguZ2V0TGluZUxlbmd0aCh4LCB5LCBwb2ludHNbMF0sIHBvaW50c1sxXSk7XG4gICAgICBjYXNlICdDJzpcbiAgICAgICAgLy8gQXBwcm94aW1hdGVzIGJ5IGJyZWFraW5nIGN1cnZlIGludG8gMTAwIGxpbmUgc2VnbWVudHNcbiAgICAgICAgbGVuID0gMC4wO1xuICAgICAgICBwMSA9IHBhdGguZ2V0UG9pbnRPbkN1YmljQmV6aWVyKFxuICAgICAgICAgIDAsXG4gICAgICAgICAgeCxcbiAgICAgICAgICB5LFxuICAgICAgICAgIHBvaW50c1swXSxcbiAgICAgICAgICBwb2ludHNbMV0sXG4gICAgICAgICAgcG9pbnRzWzJdLFxuICAgICAgICAgIHBvaW50c1szXSxcbiAgICAgICAgICBwb2ludHNbNF0sXG4gICAgICAgICAgcG9pbnRzWzVdXG4gICAgICAgICk7XG4gICAgICAgIGZvciAodCA9IDAuMDE7IHQgPD0gMTsgdCArPSAwLjAxKSB7XG4gICAgICAgICAgcDIgPSBwYXRoLmdldFBvaW50T25DdWJpY0JlemllcihcbiAgICAgICAgICAgIHQsXG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgeSxcbiAgICAgICAgICAgIHBvaW50c1swXSxcbiAgICAgICAgICAgIHBvaW50c1sxXSxcbiAgICAgICAgICAgIHBvaW50c1syXSxcbiAgICAgICAgICAgIHBvaW50c1szXSxcbiAgICAgICAgICAgIHBvaW50c1s0XSxcbiAgICAgICAgICAgIHBvaW50c1s1XVxuICAgICAgICAgICk7XG4gICAgICAgICAgbGVuICs9IHBhdGguZ2V0TGluZUxlbmd0aChwMS54LCBwMS55LCBwMi54LCBwMi55KTtcbiAgICAgICAgICBwMSA9IHAyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZW47XG4gICAgICBjYXNlICdRJzpcbiAgICAgICAgLy8gQXBwcm94aW1hdGVzIGJ5IGJyZWFraW5nIGN1cnZlIGludG8gMTAwIGxpbmUgc2VnbWVudHNcbiAgICAgICAgbGVuID0gMC4wO1xuICAgICAgICBwMSA9IHBhdGguZ2V0UG9pbnRPblF1YWRyYXRpY0JlemllcihcbiAgICAgICAgICAwLFxuICAgICAgICAgIHgsXG4gICAgICAgICAgeSxcbiAgICAgICAgICBwb2ludHNbMF0sXG4gICAgICAgICAgcG9pbnRzWzFdLFxuICAgICAgICAgIHBvaW50c1syXSxcbiAgICAgICAgICBwb2ludHNbM11cbiAgICAgICAgKTtcbiAgICAgICAgZm9yICh0ID0gMC4wMTsgdCA8PSAxOyB0ICs9IDAuMDEpIHtcbiAgICAgICAgICBwMiA9IHBhdGguZ2V0UG9pbnRPblF1YWRyYXRpY0JlemllcihcbiAgICAgICAgICAgIHQsXG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgeSxcbiAgICAgICAgICAgIHBvaW50c1swXSxcbiAgICAgICAgICAgIHBvaW50c1sxXSxcbiAgICAgICAgICAgIHBvaW50c1syXSxcbiAgICAgICAgICAgIHBvaW50c1szXVxuICAgICAgICAgICk7XG4gICAgICAgICAgbGVuICs9IHBhdGguZ2V0TGluZUxlbmd0aChwMS54LCBwMS55LCBwMi54LCBwMi55KTtcbiAgICAgICAgICBwMSA9IHAyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZW47XG4gICAgICBjYXNlICdBJzpcbiAgICAgICAgLy8gQXBwcm94aW1hdGVzIGJ5IGJyZWFraW5nIGN1cnZlIGludG8gbGluZSBzZWdtZW50c1xuICAgICAgICBsZW4gPSAwLjA7XG4gICAgICAgIHZhciBzdGFydCA9IHBvaW50c1s0XTtcbiAgICAgICAgLy8gNCA9IHRoZXRhXG4gICAgICAgIHZhciBkVGhldGEgPSBwb2ludHNbNV07XG4gICAgICAgIC8vIDUgPSBkVGhldGFcbiAgICAgICAgdmFyIGVuZCA9IHBvaW50c1s0XSArIGRUaGV0YTtcbiAgICAgICAgdmFyIGluYyA9IE1hdGguUEkgLyAxODAuMDtcbiAgICAgICAgLy8gMSBkZWdyZWUgcmVzb2x1dGlvblxuICAgICAgICBpZiAoTWF0aC5hYnMoc3RhcnQgLSBlbmQpIDwgaW5jKSB7XG4gICAgICAgICAgaW5jID0gTWF0aC5hYnMoc3RhcnQgLSBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGU6IGZvciBwdXJwb3NlIG9mIGNhbGN1bGF0aW5nIGFyYyBsZW5ndGgsIG5vdCBnb2luZyB0byB3b3JyeSBhYm91dCByb3RhdGluZyBYLWF4aXMgYnkgYW5nbGUgcHNpXG4gICAgICAgIHAxID0gcGF0aC5nZXRQb2ludE9uRWxsaXB0aWNhbEFyYyhcbiAgICAgICAgICBwb2ludHNbMF0sXG4gICAgICAgICAgcG9pbnRzWzFdLFxuICAgICAgICAgIHBvaW50c1syXSxcbiAgICAgICAgICBwb2ludHNbM10sXG4gICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgMFxuICAgICAgICApO1xuICAgICAgICBpZiAoZFRoZXRhIDwgMCkge1xuICAgICAgICAgIC8vIGNsb2Nrd2lzZVxuICAgICAgICAgIGZvciAodCA9IHN0YXJ0IC0gaW5jOyB0ID4gZW5kOyB0IC09IGluYykge1xuICAgICAgICAgICAgcDIgPSBwYXRoLmdldFBvaW50T25FbGxpcHRpY2FsQXJjKFxuICAgICAgICAgICAgICBwb2ludHNbMF0sXG4gICAgICAgICAgICAgIHBvaW50c1sxXSxcbiAgICAgICAgICAgICAgcG9pbnRzWzJdLFxuICAgICAgICAgICAgICBwb2ludHNbM10sXG4gICAgICAgICAgICAgIHQsXG4gICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsZW4gKz0gcGF0aC5nZXRMaW5lTGVuZ3RoKHAxLngsIHAxLnksIHAyLngsIHAyLnkpO1xuICAgICAgICAgICAgcDEgPSBwMjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY291bnRlci1jbG9ja3dpc2VcbiAgICAgICAgICBmb3IgKHQgPSBzdGFydCArIGluYzsgdCA8IGVuZDsgdCArPSBpbmMpIHtcbiAgICAgICAgICAgIHAyID0gcGF0aC5nZXRQb2ludE9uRWxsaXB0aWNhbEFyYyhcbiAgICAgICAgICAgICAgcG9pbnRzWzBdLFxuICAgICAgICAgICAgICBwb2ludHNbMV0sXG4gICAgICAgICAgICAgIHBvaW50c1syXSxcbiAgICAgICAgICAgICAgcG9pbnRzWzNdLFxuICAgICAgICAgICAgICB0LFxuICAgICAgICAgICAgICAwXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbGVuICs9IHBhdGguZ2V0TGluZUxlbmd0aChwMS54LCBwMS55LCBwMi54LCBwMi55KTtcbiAgICAgICAgICAgIHAxID0gcDI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHAyID0gcGF0aC5nZXRQb2ludE9uRWxsaXB0aWNhbEFyYyhcbiAgICAgICAgICBwb2ludHNbMF0sXG4gICAgICAgICAgcG9pbnRzWzFdLFxuICAgICAgICAgIHBvaW50c1syXSxcbiAgICAgICAgICBwb2ludHNbM10sXG4gICAgICAgICAgZW5kLFxuICAgICAgICAgIDBcbiAgICAgICAgKTtcbiAgICAgICAgbGVuICs9IHBhdGguZ2V0TGluZUxlbmd0aChwMS54LCBwMS55LCBwMi54LCBwMi55KTtcblxuICAgICAgICByZXR1cm4gbGVuO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9O1xuICBLb252YS5QYXRoLmNvbnZlcnRFbmRwb2ludFRvQ2VudGVyUGFyYW1ldGVyaXphdGlvbiA9IGZ1bmN0aW9uKFxuICAgIHgxLFxuICAgIHkxLFxuICAgIHgyLFxuICAgIHkyLFxuICAgIGZhLFxuICAgIGZzLFxuICAgIHJ4LFxuICAgIHJ5LFxuICAgIHBzaURlZ1xuICApIHtcbiAgICAvLyBEZXJpdmVkIGZyb206IGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9pbXBsbm90ZS5odG1sI0FyY0ltcGxlbWVudGF0aW9uTm90ZXNcbiAgICB2YXIgcHNpID0gcHNpRGVnICogKE1hdGguUEkgLyAxODAuMCk7XG4gICAgdmFyIHhwID0gTWF0aC5jb3MocHNpKSAqICh4MSAtIHgyKSAvIDIuMCArIE1hdGguc2luKHBzaSkgKiAoeTEgLSB5MikgLyAyLjA7XG4gICAgdmFyIHlwID1cbiAgICAgIC0xICogTWF0aC5zaW4ocHNpKSAqICh4MSAtIHgyKSAvIDIuMCArIE1hdGguY29zKHBzaSkgKiAoeTEgLSB5MikgLyAyLjA7XG5cbiAgICB2YXIgbGFtYmRhID0geHAgKiB4cCAvIChyeCAqIHJ4KSArIHlwICogeXAgLyAocnkgKiByeSk7XG5cbiAgICBpZiAobGFtYmRhID4gMSkge1xuICAgICAgcnggKj0gTWF0aC5zcXJ0KGxhbWJkYSk7XG4gICAgICByeSAqPSBNYXRoLnNxcnQobGFtYmRhKTtcbiAgICB9XG5cbiAgICB2YXIgZiA9IE1hdGguc3FydChcbiAgICAgIChyeCAqIHJ4ICogKHJ5ICogcnkpIC0gcnggKiByeCAqICh5cCAqIHlwKSAtIHJ5ICogcnkgKiAoeHAgKiB4cCkpIC9cbiAgICAgICAgKHJ4ICogcnggKiAoeXAgKiB5cCkgKyByeSAqIHJ5ICogKHhwICogeHApKVxuICAgICk7XG5cbiAgICBpZiAoZmEgPT09IGZzKSB7XG4gICAgICBmICo9IC0xO1xuICAgIH1cbiAgICBpZiAoaXNOYU4oZikpIHtcbiAgICAgIGYgPSAwO1xuICAgIH1cblxuICAgIHZhciBjeHAgPSBmICogcnggKiB5cCAvIHJ5O1xuICAgIHZhciBjeXAgPSBmICogLXJ5ICogeHAgLyByeDtcblxuICAgIHZhciBjeCA9ICh4MSArIHgyKSAvIDIuMCArIE1hdGguY29zKHBzaSkgKiBjeHAgLSBNYXRoLnNpbihwc2kpICogY3lwO1xuICAgIHZhciBjeSA9ICh5MSArIHkyKSAvIDIuMCArIE1hdGguc2luKHBzaSkgKiBjeHAgKyBNYXRoLmNvcyhwc2kpICogY3lwO1xuXG4gICAgdmFyIHZNYWcgPSBmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KHZbMF0gKiB2WzBdICsgdlsxXSAqIHZbMV0pO1xuICAgIH07XG4gICAgdmFyIHZSYXRpbyA9IGZ1bmN0aW9uKHUsIHYpIHtcbiAgICAgIHJldHVybiAodVswXSAqIHZbMF0gKyB1WzFdICogdlsxXSkgLyAodk1hZyh1KSAqIHZNYWcodikpO1xuICAgIH07XG4gICAgdmFyIHZBbmdsZSA9IGZ1bmN0aW9uKHUsIHYpIHtcbiAgICAgIHJldHVybiAodVswXSAqIHZbMV0gPCB1WzFdICogdlswXSA/IC0xIDogMSkgKiBNYXRoLmFjb3ModlJhdGlvKHUsIHYpKTtcbiAgICB9O1xuICAgIHZhciB0aGV0YSA9IHZBbmdsZShbMSwgMF0sIFsoeHAgLSBjeHApIC8gcngsICh5cCAtIGN5cCkgLyByeV0pO1xuICAgIHZhciB1ID0gWyh4cCAtIGN4cCkgLyByeCwgKHlwIC0gY3lwKSAvIHJ5XTtcbiAgICB2YXIgdiA9IFsoLTEgKiB4cCAtIGN4cCkgLyByeCwgKC0xICogeXAgLSBjeXApIC8gcnldO1xuICAgIHZhciBkVGhldGEgPSB2QW5nbGUodSwgdik7XG5cbiAgICBpZiAodlJhdGlvKHUsIHYpIDw9IC0xKSB7XG4gICAgICBkVGhldGEgPSBNYXRoLlBJO1xuICAgIH1cbiAgICBpZiAodlJhdGlvKHUsIHYpID49IDEpIHtcbiAgICAgIGRUaGV0YSA9IDA7XG4gICAgfVxuICAgIGlmIChmcyA9PT0gMCAmJiBkVGhldGEgPiAwKSB7XG4gICAgICBkVGhldGEgPSBkVGhldGEgLSAyICogTWF0aC5QSTtcbiAgICB9XG4gICAgaWYgKGZzID09PSAxICYmIGRUaGV0YSA8IDApIHtcbiAgICAgIGRUaGV0YSA9IGRUaGV0YSArIDIgKiBNYXRoLlBJO1xuICAgIH1cbiAgICByZXR1cm4gW2N4LCBjeSwgcngsIHJ5LCB0aGV0YSwgZFRoZXRhLCBwc2ksIGZzXTtcbiAgfTtcbiAgLy8gYWRkIGdldHRlcnMgc2V0dGVyc1xuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5QYXRoLCAnZGF0YScpO1xuXG4gIC8qKlxuICAgICAqIHNldCBTVkcgcGF0aCBkYXRhIHN0cmluZy4gIFRoaXMgbWV0aG9kXG4gICAgICogIGFsc28gYXV0b21hdGljYWxseSBwYXJzZXMgdGhlIGRhdGEgc3RyaW5nXG4gICAgICogIGludG8gYSBkYXRhIGFycmF5LiAgQ3VycmVudGx5IHN1cHBvcnRlZCBTVkcgZGF0YTpcbiAgICAgKiAgTSwgbSwgTCwgbCwgSCwgaCwgViwgdiwgUSwgcSwgVCwgdCwgQywgYywgUywgcywgQSwgYSwgWiwgelxuICAgICAqIEBuYW1lIHNldERhdGFcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlBhdGgucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFNWRyBwYXRoIGNvbW1hbmQgc3RyaW5nXG4gICAgICovXG5cbiAgLyoqXG4gICAgICogZ2V0IFNWRyBwYXRoIGRhdGEgc3RyaW5nXG4gICAgICogQG5hbWUgZ2V0RGF0YVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuUGF0aC5wcm90b3R5cGVcbiAgICAgKi9cblxuICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuUGF0aCk7XG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgdmFyIEVNUFRZX1NUUklORyA9ICcnLFxuICAgIC8vQ0FMSUJSSSA9ICdDYWxpYnJpJyxcbiAgICBOT1JNQUwgPSAnbm9ybWFsJztcblxuICAvKipcbiAgICAgKiBQYXRoIGNvbnN0cnVjdG9yLlxuICAgICAqIEBhdXRob3IgSmFzb24gRm9sbGFzXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZvbnRGYW1pbHldIGRlZmF1bHQgaXMgQ2FsaWJyaVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZvbnRTaXplXSBkZWZhdWx0IGlzIDEyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZm9udFN0eWxlXSBjYW4gYmUgbm9ybWFsLCBib2xkLCBvciBpdGFsaWMuICBEZWZhdWx0IGlzIG5vcm1hbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZvbnRWYXJpYW50XSBjYW4gYmUgbm9ybWFsIG9yIHNtYWxsLWNhcHMuICBEZWZhdWx0IGlzIG5vcm1hbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcudGV4dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcuZGF0YSBTVkcgZGF0YSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsXSBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW2NvbmZpZy5maWxsUGF0dGVybkltYWdlXSBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5ZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRZXSBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlXSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuUm90YXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFBhdHRlcm5SZXBlYXRdIGNhbiBiZSBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gIFRoZSBkZWZhdWx0IGlzIFwibm8tcmVwZWF0XCJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFldXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFldIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZpbGxFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZpbGwuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFByaW9yaXR5XSBjYW4gYmUgY29sb3IsIGxpbmVhci1ncmFkaWVudCwgcmFkaWFsLWdyYWlkZW50LCBvciBwYXR0ZXJuLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgY29sb3IuICBUaGUgZmlsbFByaW9yaXR5IHByb3BlcnR5IG1ha2VzIGl0IHJlYWxseSBlYXN5IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGEgZmlsbCBjb2xvciBzdHlsZSBhbmQgYSBmaWxsIHBhdHRlcm4gc3R5bGUsIHNpbXBseSBzZXQgdGhlIGZpbGwgcHJvcGVydHkgYW5kIHRoZSBmaWxsUGF0dGVybiBwcm9wZXJ0aWVzLCBhbmQgdGhlbiB1c2Ugc2V0RmlsbFByaW9yaXR5KCdjb2xvcicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCBhIGNvbG9yIGZpbGwsIG9yIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ3BhdHRlcm4nKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggdGhlIHBhdHRlcm4gZmlsbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc3Ryb2tlXSBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdHJva2VXaWR0aF0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUhpdEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2UgaGl0IHJlZ2lvbi4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucGVyZmVjdERyYXdFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdXNpbmcgYnVmZmVyIGNhbnZhcy4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXNvdyBmb3Igc3Ryb2tlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VTY2FsZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2Ugc2NhbGUuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc3Ryb2tlLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVKb2luXSBjYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIG1pdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUNhcF0gY2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcWFyZS4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIGJ1dHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaGFkb3dDb2xvcl1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dCbHVyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNoYWRvd09mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T3BhY2l0eV0gc2hhZG93IG9wYWNpdHkuICBDYW4gYmUgYW55IHJlYWwgbnVtYmVyXG4gICAgICogIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRhc2hdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRhc2hFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGRhc2hBcnJheS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIHRleHRwYXRoID0gbmV3IEtvbnZhLlRleHRQYXRoKHtcbiAgICAgKiAgIHg6IDEwMCxcbiAgICAgKiAgIHk6IDUwLFxuICAgICAqICAgZmlsbDogJyMzMzMnLFxuICAgICAqICAgZm9udFNpemU6ICcyNCcsXG4gICAgICogICBmb250RmFtaWx5OiAnQXJpYWwnLFxuICAgICAqICAgdGV4dDogJ0FsbCB0aGUgd29ybGRcXCdzIGEgc3RhZ2UsIGFuZCBhbGwgdGhlIG1lbiBhbmQgd29tZW4gbWVyZWx5IHBsYXllcnMuJyxcbiAgICAgKiAgIGRhdGE6ICdNMTAsMTAgQzAsMCAxMCwxNTAgMTAwLDEwMCBTMzAwLDE1MCA0MDAsNTAnXG4gICAgICogfSk7XG4gICAgICovXG4gIEtvbnZhLlRleHRQYXRoID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gX2ZpbGxGdW5jKGNvbnRleHQpIHtcbiAgICBjb250ZXh0LmZpbGxUZXh0KHRoaXMucGFydGlhbFRleHQsIDAsIDApO1xuICB9XG4gIGZ1bmN0aW9uIF9zdHJva2VGdW5jKGNvbnRleHQpIHtcbiAgICBjb250ZXh0LnN0cm9rZVRleHQodGhpcy5wYXJ0aWFsVGV4dCwgMCwgMCk7XG4gIH1cblxuICBLb252YS5UZXh0UGF0aC5wcm90b3R5cGUgPSB7XG4gICAgX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB0aGlzLmR1bW15Q2FudmFzID0gS29udmEuVXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICB0aGlzLmRhdGFBcnJheSA9IFtdO1xuXG4gICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXG4gICAgICBLb252YS5TaGFwZS5jYWxsKHRoaXMsIGNvbmZpZyk7XG5cbiAgICAgIC8vIG92ZXJyaWRlc1xuICAgICAgLy8gVE9ETzogc2hvdWxkbid0IHRoaXMgYmUgb24gdGhlIHByb3RvdHlwZT9cbiAgICAgIHRoaXMuX2ZpbGxGdW5jID0gX2ZpbGxGdW5jO1xuICAgICAgdGhpcy5fc3Ryb2tlRnVuYyA9IF9zdHJva2VGdW5jO1xuICAgICAgdGhpcy5fZmlsbEZ1bmNIaXQgPSBfZmlsbEZ1bmM7XG4gICAgICB0aGlzLl9zdHJva2VGdW5jSGl0ID0gX3N0cm9rZUZ1bmM7XG5cbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ1RleHRQYXRoJztcblxuICAgICAgdGhpcy5kYXRhQXJyYXkgPSBLb252YS5QYXRoLnBhcnNlUGF0aERhdGEodGhpcy5hdHRycy5kYXRhKTtcbiAgICAgIHRoaXMub24oJ2RhdGFDaGFuZ2Uua29udmEnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhhdC5kYXRhQXJyYXkgPSBLb252YS5QYXRoLnBhcnNlUGF0aERhdGEodGhpcy5hdHRycy5kYXRhKTtcbiAgICAgICAgdGhhdC5fc2V0VGV4dERhdGEoKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyB1cGRhdGUgdGV4dCBkYXRhIGZvciBjZXJ0YWluIGF0dHIgY2hhbmdlc1xuICAgICAgdGhpcy5vbihcbiAgICAgICAgJ3RleHRDaGFuZ2Uua29udmEgYWxpZ25DaGFuZ2Uua29udmEgbGV0dGVyU3BhY2luZ0NoYW5nZS5rb252YScsXG4gICAgICAgIHRoYXQuX3NldFRleHREYXRhXG4gICAgICApO1xuICAgICAgdGhhdC5fc2V0VGV4dERhdGEoKTtcbiAgICAgIHRoaXMuc2NlbmVGdW5jKHRoaXMuX3NjZW5lRnVuYyk7XG4gICAgICB0aGlzLmhpdEZ1bmModGhpcy5faGl0RnVuYyk7XG4gICAgfSxcbiAgICBfc2NlbmVGdW5jOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICBjb250ZXh0LnNldEF0dHIoJ2ZvbnQnLCB0aGlzLl9nZXRDb250ZXh0Rm9udCgpKTtcbiAgICAgIGNvbnRleHQuc2V0QXR0cigndGV4dEJhc2VsaW5lJywgdGhpcy5nZXRUZXh0QmFzZWxpbmUoKSk7XG4gICAgICBjb250ZXh0LnNldEF0dHIoJ3RleHRBbGlnbicsICdsZWZ0Jyk7XG4gICAgICBjb250ZXh0LnNhdmUoKTtcblxuICAgICAgdmFyIHRleHREZWNvcmF0aW9uID0gdGhpcy50ZXh0RGVjb3JhdGlvbigpO1xuICAgICAgdmFyIGZpbGwgPSB0aGlzLmZpbGwoKTtcbiAgICAgIHZhciBmb250U2l6ZSA9IHRoaXMuZm9udFNpemUoKTtcblxuICAgICAgdmFyIGdseXBoSW5mbyA9IHRoaXMuZ2x5cGhJbmZvO1xuICAgICAgaWYgKHRleHREZWNvcmF0aW9uID09PSAndW5kZXJsaW5lJykge1xuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaEluZm8ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG5cbiAgICAgICAgdmFyIHAwID0gZ2x5cGhJbmZvW2ldLnAwO1xuXG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKHAwLngsIHAwLnkpO1xuICAgICAgICBjb250ZXh0LnJvdGF0ZShnbHlwaEluZm9baV0ucm90YXRpb24pO1xuICAgICAgICB0aGlzLnBhcnRpYWxUZXh0ID0gZ2x5cGhJbmZvW2ldLnRleHQ7XG5cbiAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgICAgIGlmICh0ZXh0RGVjb3JhdGlvbiA9PT0gJ3VuZGVybGluZScpIHtcbiAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oMCwgZm9udFNpemUgLyAyICsgMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5saW5lVG8oZm9udFNpemUsIGZvbnRTaXplIC8gMiArIDEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuXG4gICAgICAgIC8vLy8gVG8gYXNzaXN0IHdpdGggZGVidWdnaW5nIHZpc3VhbGx5LCB1bmNvbW1lbnQgZm9sbG93aW5nXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGlmIChpICUgMilcbiAgICAgICAgLy8gY29udGV4dC5zdHJva2VTdHlsZSA9ICdjeWFuJztcbiAgICAgICAgLy8gZWxzZVxuICAgICAgICAvLyBjb250ZXh0LnN0cm9rZVN0eWxlID0gJ2dyZWVuJztcbiAgICAgICAgLy8gdmFyIHAxID0gZ2x5cGhJbmZvW2ldLnAxO1xuICAgICAgICAvLyBjb250ZXh0Lm1vdmVUbyhwMC54LCBwMC55KTtcbiAgICAgICAgLy8gY29udGV4dC5saW5lVG8ocDEueCwgcDEueSk7XG4gICAgICAgIC8vIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgICBpZiAodGV4dERlY29yYXRpb24gPT09ICd1bmRlcmxpbmUnKSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBmaWxsO1xuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGZvbnRTaXplIC8gMjA7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH0sXG4gICAgX2hpdEZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG5cbiAgICAgIHZhciBnbHlwaEluZm8gPSB0aGlzLmdseXBoSW5mbztcbiAgICAgIGlmIChnbHlwaEluZm8ubGVuZ3RoID49IDEpIHtcbiAgICAgICAgdmFyIHAwID0gZ2x5cGhJbmZvWzBdLnAwO1xuICAgICAgICBjb250ZXh0Lm1vdmVUbyhwMC54LCBwMC55KTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGhJbmZvLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwMSA9IGdseXBoSW5mb1tpXS5wMTtcbiAgICAgICAgY29udGV4dC5saW5lVG8ocDEueCwgcDEueSk7XG4gICAgICB9XG4gICAgICBjb250ZXh0LnNldEF0dHIoJ2xpbmVXaWR0aCcsIHRoaXMuZ2V0Rm9udFNpemUoKSk7XG4gICAgICBjb250ZXh0LnNldEF0dHIoJ3N0cm9rZVN0eWxlJywgdGhpcy5jb2xvcktleSk7XG4gICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIGdldCB0ZXh0IHdpZHRoIGluIHBpeGVsc1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0UGF0aC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgZ2V0VGV4dFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHRXaWR0aDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiBnZXQgdGV4dCBoZWlnaHQgaW4gcGl4ZWxzXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICBnZXRUZXh0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHRIZWlnaHQ7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogc2V0IHRleHRcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dFBhdGgucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gICAgICAgICAqL1xuICAgIHNldFRleHQ6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgIEtvbnZhLlRleHQucHJvdG90eXBlLnNldFRleHQuY2FsbCh0aGlzLCB0ZXh0KTtcbiAgICB9LFxuICAgIF9nZXRUZXh0U2l6ZTogZnVuY3Rpb24odGV4dCkge1xuICAgICAgdmFyIGR1bW15Q2FudmFzID0gdGhpcy5kdW1teUNhbnZhcztcbiAgICAgIHZhciBfY29udGV4dCA9IGR1bW15Q2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgIF9jb250ZXh0LnNhdmUoKTtcblxuICAgICAgX2NvbnRleHQuZm9udCA9IHRoaXMuX2dldENvbnRleHRGb250KCk7XG4gICAgICB2YXIgbWV0cmljcyA9IF9jb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpO1xuXG4gICAgICBfY29udGV4dC5yZXN0b3JlKCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBtZXRyaWNzLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHBhcnNlSW50KHRoaXMuYXR0cnMuZm9udFNpemUsIDEwKVxuICAgICAgfTtcbiAgICB9LFxuICAgIF9zZXRUZXh0RGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB2YXIgc2l6ZSA9IHRoaXMuX2dldFRleHRTaXplKHRoaXMuYXR0cnMudGV4dCk7XG4gICAgICB2YXIgbGV0dGVyU3BhY2luZyA9IHRoaXMuZ2V0TGV0dGVyU3BhY2luZygpO1xuICAgICAgdmFyIGFsaWduID0gdGhpcy5hbGlnbigpO1xuXG4gICAgICB0aGlzLnRleHRXaWR0aCA9IHNpemUud2lkdGg7XG4gICAgICB0aGlzLnRleHRIZWlnaHQgPSBzaXplLmhlaWdodDtcblxuICAgICAgdmFyIHRleHRGdWxsV2lkdGggPSBNYXRoLm1heChcbiAgICAgICAgdGhpcy50ZXh0V2lkdGggKyAoKHRoaXMuYXR0cnMudGV4dCB8fCAnJykubGVuZ3RoIC0gMSkgKiBsZXR0ZXJTcGFjaW5nLFxuICAgICAgICAwXG4gICAgICApO1xuXG4gICAgICB0aGlzLmdseXBoSW5mbyA9IFtdO1xuXG4gICAgICB2YXIgZnVsbFBhdGhXaWR0aCA9IDA7XG4gICAgICBmb3IgKHZhciBsID0gMDsgbCA8IHRoYXQuZGF0YUFycmF5Lmxlbmd0aDsgbCsrKSB7XG4gICAgICAgIGlmICh0aGF0LmRhdGFBcnJheVtsXS5wYXRoTGVuZ3RoID4gMCkge1xuICAgICAgICAgIGZ1bGxQYXRoV2lkdGggKz0gdGhhdC5kYXRhQXJyYXlbbF0ucGF0aExlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgIGlmIChhbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgb2Zmc2V0ID0gTWF0aC5tYXgoMCwgZnVsbFBhdGhXaWR0aCAvIDIgLSB0ZXh0RnVsbFdpZHRoIC8gMik7XG4gICAgICB9XG4gICAgICBpZiAoYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgb2Zmc2V0ID0gTWF0aC5tYXgoMCwgZnVsbFBhdGhXaWR0aCAtIHRleHRGdWxsV2lkdGgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hhckFyciA9IHRoaXMuZ2V0VGV4dCgpLnNwbGl0KCcnKTtcbiAgICAgIHZhciBzcGFjZXNOdW1iZXIgPSB0aGlzLmdldFRleHQoKS5zcGxpdCgnICcpLmxlbmd0aCAtIDE7XG5cbiAgICAgIHZhciBwMCwgcDEsIHBhdGhDbWQ7XG5cbiAgICAgIHZhciBwSW5kZXggPSAtMTtcbiAgICAgIHZhciBjdXJyZW50VCA9IDA7XG4gICAgICAvLyB2YXIgc3VtTGVuZ3RoID0gMDtcbiAgICAgIC8vIGZvcih2YXIgaiA9IDA7IGogPCB0aGF0LmRhdGFBcnJheS5sZW5ndGg7IGorKykge1xuICAgICAgLy8gICBpZih0aGF0LmRhdGFBcnJheVtqXS5wYXRoTGVuZ3RoID4gMCkge1xuICAgICAgLy9cbiAgICAgIC8vICAgICBpZiAoc3VtTGVuZ3RoICsgdGhhdC5kYXRhQXJyYXlbal0ucGF0aExlbmd0aCA+IG9mZnNldCkge31cbiAgICAgIC8vICAgICAgIGZ1bGxQYXRoV2lkdGggKz0gdGhhdC5kYXRhQXJyYXlbal0ucGF0aExlbmd0aDtcbiAgICAgIC8vICAgfVxuICAgICAgLy8gfVxuXG4gICAgICB2YXIgZ2V0TmV4dFBhdGhTZWdtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGN1cnJlbnRUID0gMDtcbiAgICAgICAgdmFyIHBhdGhEYXRhID0gdGhhdC5kYXRhQXJyYXk7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IHBJbmRleCArIDE7IGogPCBwYXRoRGF0YS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGlmIChwYXRoRGF0YVtqXS5wYXRoTGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcEluZGV4ID0gajtcblxuICAgICAgICAgICAgcmV0dXJuIHBhdGhEYXRhW2pdO1xuICAgICAgICAgIH0gZWxzZSBpZiAocGF0aERhdGFbal0uY29tbWFuZCA9PT0gJ00nKSB7XG4gICAgICAgICAgICBwMCA9IHtcbiAgICAgICAgICAgICAgeDogcGF0aERhdGFbal0ucG9pbnRzWzBdLFxuICAgICAgICAgICAgICB5OiBwYXRoRGF0YVtqXS5wb2ludHNbMV1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfTtcblxuICAgICAgdmFyIGZpbmRTZWdtZW50VG9GaXRDaGFyYWN0ZXIgPSBmdW5jdGlvbihjKSB7XG4gICAgICAgIHZhciBnbHlwaFdpZHRoID0gdGhhdC5fZ2V0VGV4dFNpemUoYykud2lkdGggKyBsZXR0ZXJTcGFjaW5nO1xuXG4gICAgICAgIGlmIChjID09PSAnICcgJiYgYWxpZ24gPT09ICdqdXN0aWZ5Jykge1xuICAgICAgICAgIGdseXBoV2lkdGggKz0gKGZ1bGxQYXRoV2lkdGggLSB0ZXh0RnVsbFdpZHRoKSAvIHNwYWNlc051bWJlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjdXJyTGVuID0gMDtcbiAgICAgICAgdmFyIGF0dGVtcHRzID0gMDtcblxuICAgICAgICBwMSA9IHVuZGVmaW5lZDtcbiAgICAgICAgd2hpbGUgKFxuICAgICAgICAgIE1hdGguYWJzKGdseXBoV2lkdGggLSBjdXJyTGVuKSAvIGdseXBoV2lkdGggPiAwLjAxICYmXG4gICAgICAgICAgYXR0ZW1wdHMgPCAyNVxuICAgICAgICApIHtcbiAgICAgICAgICBhdHRlbXB0cysrO1xuICAgICAgICAgIHZhciBjdW11bGF0aXZlUGF0aExlbmd0aCA9IGN1cnJMZW47XG4gICAgICAgICAgd2hpbGUgKHBhdGhDbWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGF0aENtZCA9IGdldE5leHRQYXRoU2VnbWVudCgpO1xuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHBhdGhDbWQgJiZcbiAgICAgICAgICAgICAgY3VtdWxhdGl2ZVBhdGhMZW5ndGggKyBwYXRoQ21kLnBhdGhMZW5ndGggPCBnbHlwaFdpZHRoXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgY3VtdWxhdGl2ZVBhdGhMZW5ndGggKz0gcGF0aENtZC5wYXRoTGVuZ3RoO1xuICAgICAgICAgICAgICBwYXRoQ21kID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwYXRoQ21kID09PSB7fSB8fCBwMCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBuZWVkTmV3U2VnbWVudCA9IGZhbHNlO1xuXG4gICAgICAgICAgc3dpdGNoIChwYXRoQ21kLmNvbW1hbmQpIHtcbiAgICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgS29udmEuUGF0aC5nZXRMaW5lTGVuZ3RoKFxuICAgICAgICAgICAgICAgICAgcDAueCxcbiAgICAgICAgICAgICAgICAgIHAwLnksXG4gICAgICAgICAgICAgICAgICBwYXRoQ21kLnBvaW50c1swXSxcbiAgICAgICAgICAgICAgICAgIHBhdGhDbWQucG9pbnRzWzFdXG4gICAgICAgICAgICAgICAgKSA+IGdseXBoV2lkdGhcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcDEgPSBLb252YS5QYXRoLmdldFBvaW50T25MaW5lKFxuICAgICAgICAgICAgICAgICAgZ2x5cGhXaWR0aCxcbiAgICAgICAgICAgICAgICAgIHAwLngsXG4gICAgICAgICAgICAgICAgICBwMC55LFxuICAgICAgICAgICAgICAgICAgcGF0aENtZC5wb2ludHNbMF0sXG4gICAgICAgICAgICAgICAgICBwYXRoQ21kLnBvaW50c1sxXSxcbiAgICAgICAgICAgICAgICAgIHAwLngsXG4gICAgICAgICAgICAgICAgICBwMC55XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXRoQ21kID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICAgIHZhciBzdGFydCA9IHBhdGhDbWQucG9pbnRzWzRdO1xuICAgICAgICAgICAgICAvLyA0ID0gdGhldGFcbiAgICAgICAgICAgICAgdmFyIGRUaGV0YSA9IHBhdGhDbWQucG9pbnRzWzVdO1xuICAgICAgICAgICAgICAvLyA1ID0gZFRoZXRhXG4gICAgICAgICAgICAgIHZhciBlbmQgPSBwYXRoQ21kLnBvaW50c1s0XSArIGRUaGV0YTtcblxuICAgICAgICAgICAgICBpZiAoY3VycmVudFQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50VCA9IHN0YXJ0ICsgMC4wMDAwMDAwMTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChnbHlwaFdpZHRoID4gY3Vyckxlbikge1xuICAgICAgICAgICAgICAgIC8vIEp1c3QgaW4gY2FzZSBzdGFydCBpcyAwXG4gICAgICAgICAgICAgICAgY3VycmVudFQgKz0gTWF0aC5QSSAvIDE4MC4wICogZFRoZXRhIC8gTWF0aC5hYnMoZFRoZXRhKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50VCAtPSBNYXRoLlBJIC8gMzYwLjAgKiBkVGhldGEgLyBNYXRoLmFicyhkVGhldGEpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gQ3JlZGl0IGZvciBidWcgZml4OiBAdGhlcnRoIGh0dHBzOi8vZ2l0aHViLmNvbS9lcmljZHJvd2VsbC9Lb252YUpTL2lzc3Vlcy8yNDlcbiAgICAgICAgICAgICAgLy8gT2xkIGNvZGUgZmFpbGVkIHRvIHJlbmRlciB0ZXh0IGFsb25nIGFyYyBvZiB0aGlzIHBhdGg6IFwiTSA1MCA1MCBhIDE1MCA1MCAwIDAgMSAyNTAgNTAgbCA1MCAwXCJcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIChkVGhldGEgPCAwICYmIGN1cnJlbnRUIDwgZW5kKSB8fFxuICAgICAgICAgICAgICAgIChkVGhldGEgPj0gMCAmJiBjdXJyZW50VCA+IGVuZClcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFQgPSBlbmQ7XG4gICAgICAgICAgICAgICAgbmVlZE5ld1NlZ21lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHAxID0gS29udmEuUGF0aC5nZXRQb2ludE9uRWxsaXB0aWNhbEFyYyhcbiAgICAgICAgICAgICAgICBwYXRoQ21kLnBvaW50c1swXSxcbiAgICAgICAgICAgICAgICBwYXRoQ21kLnBvaW50c1sxXSxcbiAgICAgICAgICAgICAgICBwYXRoQ21kLnBvaW50c1syXSxcbiAgICAgICAgICAgICAgICBwYXRoQ21kLnBvaW50c1szXSxcbiAgICAgICAgICAgICAgICBjdXJyZW50VCxcbiAgICAgICAgICAgICAgICBwYXRoQ21kLnBvaW50c1s2XVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgICBpZiAoY3VycmVudFQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2x5cGhXaWR0aCA+IHBhdGhDbWQucGF0aExlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgY3VycmVudFQgPSAwLjAwMDAwMDAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50VCA9IGdseXBoV2lkdGggLyBwYXRoQ21kLnBhdGhMZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGdseXBoV2lkdGggPiBjdXJyTGVuKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFQgKz0gKGdseXBoV2lkdGggLSBjdXJyTGVuKSAvIHBhdGhDbWQucGF0aExlbmd0aDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50VCAtPSAoY3VyckxlbiAtIGdseXBoV2lkdGgpIC8gcGF0aENtZC5wYXRoTGVuZ3RoO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRUID4gMS4wKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFQgPSAxLjA7XG4gICAgICAgICAgICAgICAgbmVlZE5ld1NlZ21lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHAxID0gS29udmEuUGF0aC5nZXRQb2ludE9uQ3ViaWNCZXppZXIoXG4gICAgICAgICAgICAgICAgY3VycmVudFQsXG4gICAgICAgICAgICAgICAgcGF0aENtZC5zdGFydC54LFxuICAgICAgICAgICAgICAgIHBhdGhDbWQuc3RhcnQueSxcbiAgICAgICAgICAgICAgICBwYXRoQ21kLnBvaW50c1swXSxcbiAgICAgICAgICAgICAgICBwYXRoQ21kLnBvaW50c1sxXSxcbiAgICAgICAgICAgICAgICBwYXRoQ21kLnBvaW50c1syXSxcbiAgICAgICAgICAgICAgICBwYXRoQ21kLnBvaW50c1szXSxcbiAgICAgICAgICAgICAgICBwYXRoQ21kLnBvaW50c1s0XSxcbiAgICAgICAgICAgICAgICBwYXRoQ21kLnBvaW50c1s1XVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1EnOlxuICAgICAgICAgICAgICBpZiAoY3VycmVudFQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50VCA9IGdseXBoV2lkdGggLyBwYXRoQ21kLnBhdGhMZW5ndGg7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZ2x5cGhXaWR0aCA+IGN1cnJMZW4pIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50VCArPSAoZ2x5cGhXaWR0aCAtIGN1cnJMZW4pIC8gcGF0aENtZC5wYXRoTGVuZ3RoO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUIC09IChjdXJyTGVuIC0gZ2x5cGhXaWR0aCkgLyBwYXRoQ21kLnBhdGhMZW5ndGg7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoY3VycmVudFQgPiAxLjApIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50VCA9IDEuMDtcbiAgICAgICAgICAgICAgICBuZWVkTmV3U2VnbWVudCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcDEgPSBLb252YS5QYXRoLmdldFBvaW50T25RdWFkcmF0aWNCZXppZXIoXG4gICAgICAgICAgICAgICAgY3VycmVudFQsXG4gICAgICAgICAgICAgICAgcGF0aENtZC5zdGFydC54LFxuICAgICAgICAgICAgICAgIHBhdGhDbWQuc3RhcnQueSxcbiAgICAgICAgICAgICAgICBwYXRoQ21kLnBvaW50c1swXSxcbiAgICAgICAgICAgICAgICBwYXRoQ21kLnBvaW50c1sxXSxcbiAgICAgICAgICAgICAgICBwYXRoQ21kLnBvaW50c1syXSxcbiAgICAgICAgICAgICAgICBwYXRoQ21kLnBvaW50c1szXVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocDEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY3VyckxlbiA9IEtvbnZhLlBhdGguZ2V0TGluZUxlbmd0aChwMC54LCBwMC55LCBwMS54LCBwMS55KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobmVlZE5ld1NlZ21lbnQpIHtcbiAgICAgICAgICAgIG5lZWROZXdTZWdtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBwYXRoQ21kID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gZmFrZSBzZWFyY2ggZm9yIG9mZnNldCwgdGhpcyBpcyB2ZXJ5IGJhZCBhcHByb2FjaFxuICAgICAgLy8gVE9ETzogZmluZCBvdGhlciB3YXkgdG8gYWRkIG9mZnNldCBmcm9tIHN0YXJ0IChmb3IgYWxpZ24pXG4gICAgICB2YXIgdGVzdENoYXIgPSAnQyc7XG4gICAgICB2YXIgZ2x5cGhXaWR0aCA9IHRoYXQuX2dldFRleHRTaXplKHRlc3RDaGFyKS53aWR0aCArIGxldHRlclNwYWNpbmc7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IG9mZnNldCAvIGdseXBoV2lkdGg7IGsrKykge1xuICAgICAgICBmaW5kU2VnbWVudFRvRml0Q2hhcmFjdGVyKHRlc3RDaGFyKTtcbiAgICAgICAgaWYgKHAwID09PSB1bmRlZmluZWQgfHwgcDEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHAwID0gcDE7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhckFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBGaW5kIHAxIHN1Y2ggdGhhdCBsaW5lIHNlZ21lbnQgYmV0d2VlbiBwMCBhbmQgcDEgaXMgYXBwcm94LiB3aWR0aCBvZiBnbHlwaFxuICAgICAgICBmaW5kU2VnbWVudFRvRml0Q2hhcmFjdGVyKGNoYXJBcnJbaV0pO1xuXG4gICAgICAgIGlmIChwMCA9PT0gdW5kZWZpbmVkIHx8IHAxID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3aWR0aCA9IEtvbnZhLlBhdGguZ2V0TGluZUxlbmd0aChwMC54LCBwMC55LCBwMS54LCBwMS55KTtcblxuICAgICAgICAvLyBOb3RlOiBTaW5jZSBnbHlwaHMgYXJlIHJlbmRlcmVkIG9uZSBhdCBhIHRpbWUsIGFueSBrZXJuaW5nIHBhaXIgZGF0YSBidWlsdCBpbnRvIHRoZSBmb250IHdpbGwgbm90IGJlIHVzZWQuXG4gICAgICAgIC8vIENhbiBmb3Jlc2VlIGhhdmluZyBhIHJvdWdoIHBhaXIgdGFibGUgYnVpbHQgaW4gdGhhdCB0aGUgZGV2ZWxvcGVyIGNhbiBvdmVycmlkZSBhcyBuZWVkZWQuXG5cbiAgICAgICAgdmFyIGtlcm4gPSAwO1xuICAgICAgICAvLyBwbGFjZWhvbGRlciBmb3IgZnV0dXJlIGltcGxlbWVudGF0aW9uXG5cbiAgICAgICAgdmFyIG1pZHBvaW50ID0gS29udmEuUGF0aC5nZXRQb2ludE9uTGluZShcbiAgICAgICAgICBrZXJuICsgd2lkdGggLyAyLjAsXG4gICAgICAgICAgcDAueCxcbiAgICAgICAgICBwMC55LFxuICAgICAgICAgIHAxLngsXG4gICAgICAgICAgcDEueVxuICAgICAgICApO1xuXG4gICAgICAgIHZhciByb3RhdGlvbiA9IE1hdGguYXRhbjIocDEueSAtIHAwLnksIHAxLnggLSBwMC54KTtcbiAgICAgICAgdGhpcy5nbHlwaEluZm8ucHVzaCh7XG4gICAgICAgICAgdHJhbnNwb3NlWDogbWlkcG9pbnQueCxcbiAgICAgICAgICB0cmFuc3Bvc2VZOiBtaWRwb2ludC55LFxuICAgICAgICAgIHRleHQ6IGNoYXJBcnJbaV0sXG4gICAgICAgICAgcm90YXRpb246IHJvdGF0aW9uLFxuICAgICAgICAgIHAwOiBwMCxcbiAgICAgICAgICBwMTogcDFcbiAgICAgICAgfSk7XG4gICAgICAgIHAwID0gcDE7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRTZWxmUmVjdDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcG9pbnRzID0gW107XG5cbiAgICAgIHRoaXMuZ2x5cGhJbmZvLmZvckVhY2goZnVuY3Rpb24oaW5mbykge1xuICAgICAgICBwb2ludHMucHVzaChpbmZvLnAwLngpO1xuICAgICAgICBwb2ludHMucHVzaChpbmZvLnAwLnkpO1xuICAgICAgICBwb2ludHMucHVzaChpbmZvLnAxLngpO1xuICAgICAgICBwb2ludHMucHVzaChpbmZvLnAxLnkpO1xuICAgICAgfSk7XG4gICAgICB2YXIgbWluWCA9IHBvaW50c1swXTtcbiAgICAgIHZhciBtYXhYID0gcG9pbnRzWzBdO1xuICAgICAgdmFyIG1pblkgPSBwb2ludHNbMF07XG4gICAgICB2YXIgbWF4WSA9IHBvaW50c1swXTtcbiAgICAgIHZhciB4LCB5O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICAgIHggPSBwb2ludHNbaSAqIDJdO1xuICAgICAgICB5ID0gcG9pbnRzW2kgKiAyICsgMV07XG4gICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB4KTtcbiAgICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIHgpO1xuICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgeSk7XG4gICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCB5KTtcbiAgICAgIH1cbiAgICAgIHZhciBmb250U2l6ZSA9IHRoaXMuZm9udFNpemUoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IE1hdGgucm91bmQobWluWCkgLSBmb250U2l6ZSAvIDIsXG4gICAgICAgIHk6IE1hdGgucm91bmQobWluWSkgLSBmb250U2l6ZSAvIDIsXG4gICAgICAgIHdpZHRoOiBNYXRoLnJvdW5kKG1heFggLSBtaW5YKSArIGZvbnRTaXplLFxuICAgICAgICBoZWlnaHQ6IE1hdGgucm91bmQobWF4WSAtIG1pblkpICsgZm9udFNpemVcbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG4gIC8vIG1hcCBUZXh0UGF0aCBtZXRob2RzIHRvIFRleHRcbiAgS29udmEuVGV4dFBhdGgucHJvdG90eXBlLl9nZXRDb250ZXh0Rm9udCA9XG4gICAgS29udmEuVGV4dC5wcm90b3R5cGUuX2dldENvbnRleHRGb250O1xuXG4gIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLlRleHRQYXRoLCBLb252YS5TaGFwZSk7XG5cbiAgLy8gYWRkIHNldHRlcnMgYW5kIGdldHRlcnNcbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGV4dFBhdGgsICdmb250RmFtaWx5JywgJ0FyaWFsJyk7XG5cbiAgLyoqXG4gICAgICogc2V0IGZvbnQgZmFtaWx5XG4gICAgICogQG5hbWUgc2V0Rm9udEZhbWlseVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dFBhdGgucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZvbnRGYW1pbHlcbiAgICAgKi9cblxuICAvKipcbiAgICAgKiBnZXQgZm9udCBmYW1pbHlcbiAgICAgKiBAbmFtZSBnZXRGb250RmFtaWx5XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0UGF0aC5wcm90b3R5cGVcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UZXh0UGF0aCwgJ2ZvbnRTaXplJywgMTIpO1xuXG4gIC8qKlxuICAgICAqIHNldCBmb250IHNpemVcbiAgICAgKiBAbmFtZSBzZXRGb250U2l6ZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dFBhdGgucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtpbnR9IGZvbnRTaXplXG4gICAgICovXG5cbiAgLyoqXG4gICAgICogZ2V0IGZvbnQgc2l6ZVxuICAgICAqIEBuYW1lIGdldEZvbnRTaXplXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0UGF0aC5wcm90b3R5cGVcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UZXh0UGF0aCwgJ2ZvbnRTdHlsZScsIE5PUk1BTCk7XG5cbiAgLyoqXG4gICAgICogc2V0IGZvbnQgc3R5bGUuICBDYW4gYmUgJ25vcm1hbCcsICdpdGFsaWMnLCBvciAnYm9sZCcuICAnbm9ybWFsJyBpcyB0aGUgZGVmYXVsdC5cbiAgICAgKiBAbmFtZSBzZXRGb250U3R5bGVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmb250U3R5bGVcbiAgICAgKi9cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGV4dFBhdGgsICdhbGlnbicsICdsZWZ0Jyk7XG5cbiAgLyoqXG4gICAgICAqIGdldC9zZXQgaG9yaXpvbnRhbCBhbGlnbiBvZiB0ZXh0LiAgQ2FuIGJlICdsZWZ0JywgJ2NlbnRlcicsICdyaWdodCcgb3IgJ2p1c3RpZnknXG4gICAgICAqIEBuYW1lIGFsaWduXG4gICAgICAqIEBtZXRob2RcbiAgICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHQucHJvdG90eXBlXG4gICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhbGlnblxuICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAgKiBAZXhhbXBsZVxuICAgICAgKiAvLyBnZXQgdGV4dCBhbGlnblxuICAgICAgKiB2YXIgYWxpZ24gPSB0ZXh0LmFsaWduKCk7XG4gICAgICAqXG4gICAgICAqIC8vIGNlbnRlciB0ZXh0XG4gICAgICAqIHRleHQuYWxpZ24oJ2NlbnRlcicpO1xuICAgICAgKlxuICAgICAgKiAvLyBhbGlnbiB0ZXh0IHRvIHJpZ2h0XG4gICAgICAqIHRleHQuYWxpZ24oJ3JpZ2h0Jyk7XG4gICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRleHRQYXRoLCAnbGV0dGVyU3BhY2luZycsIDApO1xuXG4gIC8qKlxuICAgICAgKiBzZXQgbGV0dGVyIHNwYWNpbmcgcHJvcGVydHkuIERlZmF1bHQgdmFsdWUgaXMgMC5cbiAgICAgICogQG5hbWUgbGV0dGVyU3BhY2luZ1xuICAgICAgKiBAbWV0aG9kXG4gICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0UGF0aC5wcm90b3R5cGVcbiAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGxldHRlclNwYWNpbmdcbiAgICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGV4dFBhdGgsICd0ZXh0QmFzZWxpbmUnLCAnbWlkZGxlJyk7XG5cbiAgLyoqXG4gICAgICAqIHNldCB0ZXh0QmFzZWxpbmUgcHJvcGVydHkuIERlZmF1bHQgdmFsdWUgaXMgJ21pZGRsZScuXG4gICAgICAqIENhbiBiZSAndG9wJywgJ2JvdHRvbScsICdtaWRkbGUnLCAnYWxwaGFiZXRpYycsICdoYW5naW5nJ1xuICAgICAgKiBAbmFtZSB0ZXh0QmFzZWxpbmVcbiAgICAgICogQG1ldGhvZFxuICAgICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dFBhdGgucHJvdG90eXBlXG4gICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0ZXh0QmFzZWxpbmVcbiAgICAgICovXG5cbiAgLyoqXG4gICAgICogZ2V0IGZvbnQgc3R5bGVcbiAgICAgKiBAbmFtZSBnZXRGb250U3R5bGVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZVxuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRleHRQYXRoLCAnZm9udFZhcmlhbnQnLCBOT1JNQUwpO1xuXG4gIC8qKlxuICAgICAqIHNldCBmb250IHZhcmlhbnQuICBDYW4gYmUgJ25vcm1hbCcgb3IgJ3NtYWxsLWNhcHMnLiAgJ25vcm1hbCcgaXMgdGhlIGRlZmF1bHQuXG4gICAgICogQG5hbWUgc2V0Rm9udFZhcmlhbnRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmb250VmFyaWFudFxuICAgICAqL1xuXG4gIC8qKlxuICAgICAqIEBnZXQgZm9udCB2YXJpYW50XG4gICAgICogQG5hbWUgZ2V0Rm9udFZhcmlhbnRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZVxuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyKEtvbnZhLlRleHRQYXRoLCAndGV4dCcsIEVNUFRZX1NUUklORyk7XG5cbiAgLyoqXG4gICAgICogZ2V0IHRleHRcbiAgICAgKiBAbmFtZSBnZXRUZXh0XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0UGF0aC5wcm90b3R5cGVcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UZXh0UGF0aCwgJ3RleHREZWNvcmF0aW9uJywgbnVsbCk7XG5cbiAgLyoqXG4gICAgICAqIGdldC9zZXQgdGV4dCBkZWNvcmF0aW9uIG9mIGEgdGV4dC4gIENhbiBiZSAnJyBvciAndW5kZXJsaW5lJ1xuICAgICAgKiBAbmFtZSB0ZXh0RGVjb3JhdGlvblxuICAgICAgKiBAbWV0aG9kXG4gICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0LnByb3RvdHlwZVxuICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dERlY29yYXRpb25cbiAgICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgICogQGV4YW1wbGVcbiAgICAgICogLy8gZ2V0IHRleHQgZGVjb3JhdGlvblxuICAgICAgKiB2YXIgdGV4dERlY29yYXRpb24gPSB0ZXh0LnRleHREZWNvcmF0aW9uKCk7XG4gICAgICAqXG4gICAgICAqIC8vIGNlbnRlciB0ZXh0XG4gICAgICAqIHRleHQudGV4dERlY29yYXRpb24oJ3VuZGVybGluZScpO1xuICAgICAgKi9cblxuICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuVGV4dFBhdGgpO1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIC8qKlxuICAgICAqIFJlZ3VsYXJQb2x5Z29uIGNvbnN0cnVjdG9yLiZuYnNwOyBFeGFtcGxlcyBpbmNsdWRlIHRyaWFuZ2xlcywgc3F1YXJlcywgcGVudGFnb25zLCBoZXhhZ29ucywgZXRjLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBhdWdtZW50cyBLb252YS5TaGFwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLnNpZGVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5yYWRpdXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsXSBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW2NvbmZpZy5maWxsUGF0dGVybkltYWdlXSBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5ZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRZXSBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlXSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuUm90YXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFBhdHRlcm5SZXBlYXRdIGNhbiBiZSBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gIFRoZSBkZWZhdWx0IGlzIFwibm8tcmVwZWF0XCJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFldXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFldIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZpbGxFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZpbGwuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFByaW9yaXR5XSBjYW4gYmUgY29sb3IsIGxpbmVhci1ncmFkaWVudCwgcmFkaWFsLWdyYWlkZW50LCBvciBwYXR0ZXJuLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgY29sb3IuICBUaGUgZmlsbFByaW9yaXR5IHByb3BlcnR5IG1ha2VzIGl0IHJlYWxseSBlYXN5IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGEgZmlsbCBjb2xvciBzdHlsZSBhbmQgYSBmaWxsIHBhdHRlcm4gc3R5bGUsIHNpbXBseSBzZXQgdGhlIGZpbGwgcHJvcGVydHkgYW5kIHRoZSBmaWxsUGF0dGVybiBwcm9wZXJ0aWVzLCBhbmQgdGhlbiB1c2Ugc2V0RmlsbFByaW9yaXR5KCdjb2xvcicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCBhIGNvbG9yIGZpbGwsIG9yIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ3BhdHRlcm4nKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggdGhlIHBhdHRlcm4gZmlsbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc3Ryb2tlXSBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdHJva2VXaWR0aF0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUhpdEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2UgaGl0IHJlZ2lvbi4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucGVyZmVjdERyYXdFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdXNpbmcgYnVmZmVyIGNhbnZhcy4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXNvdyBmb3Igc3Ryb2tlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VTY2FsZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2Ugc2NhbGUuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc3Ryb2tlLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVKb2luXSBjYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIG1pdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUNhcF0gY2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcWFyZS4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIGJ1dHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaGFkb3dDb2xvcl1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dCbHVyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNoYWRvd09mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T3BhY2l0eV0gc2hhZG93IG9wYWNpdHkuICBDYW4gYmUgYW55IHJlYWwgbnVtYmVyXG4gICAgICogIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRhc2hdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRhc2hFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGRhc2hBcnJheS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGhleGFnb24gPSBuZXcgS29udmEuUmVndWxhclBvbHlnb24oe1xuICAgICAqICAgeDogMTAwLFxuICAgICAqICAgeTogMjAwLFxuICAgICAqICAgc2lkZXM6IDYsXG4gICAgICogICByYWRpdXM6IDcwLFxuICAgICAqICAgZmlsbDogJ3JlZCcsXG4gICAgICogICBzdHJva2U6ICdibGFjaycsXG4gICAgICogICBzdHJva2VXaWR0aDogNFxuICAgICAqIH0pO1xuICAgICAqL1xuICBLb252YS5SZWd1bGFyUG9seWdvbiA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHRoaXMuX19faW5pdChjb25maWcpO1xuICB9O1xuXG4gIEtvbnZhLlJlZ3VsYXJQb2x5Z29uLnByb3RvdHlwZSA9IHtcbiAgICBfY2VudHJvaWQ6IHRydWUsXG4gICAgX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXG4gICAgICBLb252YS5TaGFwZS5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdSZWd1bGFyUG9seWdvbic7XG4gICAgICB0aGlzLnNjZW5lRnVuYyh0aGlzLl9zY2VuZUZ1bmMpO1xuICAgIH0sXG4gICAgX3NjZW5lRnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgdmFyIHNpZGVzID0gdGhpcy5hdHRycy5zaWRlcywgcmFkaXVzID0gdGhpcy5hdHRycy5yYWRpdXMsIG4sIHgsIHk7XG5cbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBjb250ZXh0Lm1vdmVUbygwLCAwIC0gcmFkaXVzKTtcblxuICAgICAgZm9yIChuID0gMTsgbiA8IHNpZGVzOyBuKyspIHtcbiAgICAgICAgeCA9IHJhZGl1cyAqIE1hdGguc2luKG4gKiAyICogTWF0aC5QSSAvIHNpZGVzKTtcbiAgICAgICAgeSA9IC0xICogcmFkaXVzICogTWF0aC5jb3MobiAqIDIgKiBNYXRoLlBJIC8gc2lkZXMpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh4LCB5KTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICB9LFxuICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJhZGl1cygpICogMjtcbiAgICB9LFxuICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLmdldEhlaWdodCgpXG4gICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJhZGl1cygpICogMjtcbiAgICB9LFxuICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLnNldFdpZHRoKClcbiAgICBzZXRXaWR0aDogZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldFdpZHRoLmNhbGwodGhpcywgd2lkdGgpO1xuICAgICAgaWYgKHRoaXMucmFkaXVzKCkgIT09IHdpZHRoIC8gMikge1xuICAgICAgICB0aGlzLnNldFJhZGl1cyh3aWR0aCAvIDIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuc2V0SGVpZ2h0KClcbiAgICBzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0SGVpZ2h0LmNhbGwodGhpcywgaGVpZ2h0KTtcbiAgICAgIGlmICh0aGlzLnJhZGl1cygpICE9PSBoZWlnaHQgLyAyKSB7XG4gICAgICAgIHRoaXMuc2V0UmFkaXVzKGhlaWdodCAvIDIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgS29udmEuVXRpbC5leHRlbmQoS29udmEuUmVndWxhclBvbHlnb24sIEtvbnZhLlNoYXBlKTtcblxuICAvLyBhZGQgZ2V0dGVycyBzZXR0ZXJzXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlJlZ3VsYXJQb2x5Z29uLCAncmFkaXVzJywgMCk7XG5cbiAgLyoqXG4gICAgICogc2V0IHJhZGl1c1xuICAgICAqIEBuYW1lIHNldFJhZGl1c1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuUmVndWxhclBvbHlnb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuICAgICAqL1xuXG4gIC8qKlxuICAgICAqIGdldCByYWRpdXNcbiAgICAgKiBAbmFtZSBnZXRSYWRpdXNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlJlZ3VsYXJQb2x5Z29uLnByb3RvdHlwZVxuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlJlZ3VsYXJQb2x5Z29uLCAnc2lkZXMnLCAwKTtcblxuICAvKipcbiAgICAgKiBzZXQgbnVtYmVyIG9mIHNpZGVzXG4gICAgICogQG5hbWUgc2V0U2lkZXNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlJlZ3VsYXJQb2x5Z29uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7aW50fSBzaWRlc1xuICAgICAqL1xuXG4gIC8qKlxuICAgICAqIGdldCBudW1iZXIgb2Ygc2lkZXNcbiAgICAgKiBAbmFtZSBnZXRTaWRlc1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuUmVndWxhclBvbHlnb24ucHJvdG90eXBlXG4gICAgICovXG5cbiAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLlJlZ3VsYXJQb2x5Z29uKTtcbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvKipcbiAgICAgKiBTdGFyIGNvbnN0cnVjdG9yXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gY29uZmlnLm51bVBvaW50c1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcuaW5uZXJSYWRpdXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLm91dGVyUmFkaXVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbF0gZmlsbCBjb2xvclxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IFtjb25maWcuZmlsbFBhdHRlcm5JbWFnZV0gZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5YXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WV0gXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZV0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblJvdGF0aW9uXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQYXR0ZXJuUmVwZWF0XSBjYW4gYmUgXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuICBUaGUgZGVmYXVsdCBpcyBcIm5vLXJlcGVhdFwiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5maWxsRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBmaWxsLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQcmlvcml0eV0gY2FuIGJlIGNvbG9yLCBsaW5lYXItZ3JhZGllbnQsIHJhZGlhbC1ncmFpZGVudCwgb3IgcGF0dGVybi4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGNvbG9yLiAgVGhlIGZpbGxQcmlvcml0eSBwcm9wZXJ0eSBtYWtlcyBpdCByZWFsbHkgZWFzeSB0byB0b2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgZmlsbCB0eXBlcy4gIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byB0b2dnbGUgYmV0d2VlbiBhIGZpbGwgY29sb3Igc3R5bGUgYW5kIGEgZmlsbCBwYXR0ZXJuIHN0eWxlLCBzaW1wbHkgc2V0IHRoZSBmaWxsIHByb3BlcnR5IGFuZCB0aGUgZmlsbFBhdHRlcm4gcHJvcGVydGllcywgYW5kIHRoZW4gdXNlIHNldEZpbGxQcmlvcml0eSgnY29sb3InKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggYSBjb2xvciBmaWxsLCBvciB1c2Ugc2V0RmlsbFByaW9yaXR5KCdwYXR0ZXJuJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIHRoZSBwYXR0ZXJuIGZpbGwgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnN0cm9rZV0gc3Ryb2tlIGNvbG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc3Ryb2tlV2lkdGhdIHN0cm9rZSB3aWR0aFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VIaXRFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIGhpdCByZWdpb24uICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnBlcmZlY3REcmF3RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHVzaW5nIGJ1ZmZlciBjYW52YXMuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzaGFzb3cgZm9yIHN0cm9rZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlU2NhbGVFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIHNjYWxlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHN0cm9rZS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lSm9pbl0gY2FuIGJlIG1pdGVyLCByb3VuZCwgb3IgYmV2ZWwuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBtaXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVDYXBdIGNhbiBiZSBidXR0LCByb3VuZCwgb3Igc3FhcmUuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBidXR0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc2hhZG93Q29sb3JdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93Qmx1cl1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zaGFkb3dPZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09wYWNpdHldIHNoYWRvdyBvcGFjaXR5LiAgQ2FuIGJlIGFueSByZWFsIG51bWJlclxuICAgICAqICBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzaGFkb3cuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5kYXNoXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kYXNoRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBkYXNoQXJyYXkuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBzdGFyID0gbmV3IEtvbnZhLlN0YXIoe1xuICAgICAqICAgeDogMTAwLFxuICAgICAqICAgeTogMjAwLFxuICAgICAqICAgbnVtUG9pbnRzOiA1LFxuICAgICAqICAgaW5uZXJSYWRpdXM6IDcwLFxuICAgICAqICAgb3V0ZXJSYWRpdXM6IDcwLFxuICAgICAqICAgZmlsbDogJ3JlZCcsXG4gICAgICogICBzdHJva2U6ICdibGFjaycsXG4gICAgICogICBzdHJva2VXaWR0aDogNFxuICAgICAqIH0pO1xuICAgICAqL1xuICBLb252YS5TdGFyID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gIH07XG5cbiAgS29udmEuU3Rhci5wcm90b3R5cGUgPSB7XG4gICAgX2NlbnRyb2lkOiB0cnVlLFxuICAgIF9fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxuICAgICAgS29udmEuU2hhcGUuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnU3Rhcic7XG4gICAgICB0aGlzLnNjZW5lRnVuYyh0aGlzLl9zY2VuZUZ1bmMpO1xuICAgIH0sXG4gICAgX3NjZW5lRnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgdmFyIGlubmVyUmFkaXVzID0gdGhpcy5pbm5lclJhZGl1cygpLFxuICAgICAgICBvdXRlclJhZGl1cyA9IHRoaXMub3V0ZXJSYWRpdXMoKSxcbiAgICAgICAgbnVtUG9pbnRzID0gdGhpcy5udW1Qb2ludHMoKTtcblxuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGNvbnRleHQubW92ZVRvKDAsIDAgLSBvdXRlclJhZGl1cyk7XG5cbiAgICAgIGZvciAodmFyIG4gPSAxOyBuIDwgbnVtUG9pbnRzICogMjsgbisrKSB7XG4gICAgICAgIHZhciByYWRpdXMgPSBuICUgMiA9PT0gMCA/IG91dGVyUmFkaXVzIDogaW5uZXJSYWRpdXM7XG4gICAgICAgIHZhciB4ID0gcmFkaXVzICogTWF0aC5zaW4obiAqIE1hdGguUEkgLyBudW1Qb2ludHMpO1xuICAgICAgICB2YXIgeSA9IC0xICogcmFkaXVzICogTWF0aC5jb3MobiAqIE1hdGguUEkgLyBudW1Qb2ludHMpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh4LCB5KTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG5cbiAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgIH0sXG4gICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuZ2V0V2lkdGgoKVxuICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE91dGVyUmFkaXVzKCkgKiAyO1xuICAgIH0sXG4gICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuZ2V0SGVpZ2h0KClcbiAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0T3V0ZXJSYWRpdXMoKSAqIDI7XG4gICAgfSxcbiAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5zZXRXaWR0aCgpXG4gICAgc2V0V2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XG4gICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRXaWR0aC5jYWxsKHRoaXMsIHdpZHRoKTtcbiAgICAgIGlmICh0aGlzLm91dGVyUmFkaXVzKCkgIT09IHdpZHRoIC8gMikge1xuICAgICAgICB0aGlzLnNldE91dGVyUmFkaXVzKHdpZHRoIC8gMik7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5zZXRIZWlnaHQoKVxuICAgIHNldEhlaWdodDogZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRIZWlnaHQuY2FsbCh0aGlzLCBoZWlnaHQpO1xuICAgICAgaWYgKHRoaXMub3V0ZXJSYWRpdXMoKSAhPT0gaGVpZ2h0IC8gMikge1xuICAgICAgICB0aGlzLnNldE91dGVyUmFkaXVzKGhlaWdodCAvIDIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgS29udmEuVXRpbC5leHRlbmQoS29udmEuU3RhciwgS29udmEuU2hhcGUpO1xuXG4gIC8vIGFkZCBnZXR0ZXJzIHNldHRlcnNcbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU3RhciwgJ251bVBvaW50cycsIDUpO1xuXG4gIC8qKlxuICAgICAqIHNldCBudW1iZXIgb2YgcG9pbnRzXG4gICAgICogQG5hbWUgc2V0TnVtUG9pbnRzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFyLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gcG9pbnRzXG4gICAgICovXG5cbiAgLyoqXG4gICAgICogZ2V0IG51bWJlciBvZiBwb2ludHNcbiAgICAgKiBAbmFtZSBnZXROdW1Qb2ludHNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YXIucHJvdG90eXBlXG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU3RhciwgJ2lubmVyUmFkaXVzJywgMCk7XG5cbiAgLyoqXG4gICAgICogc2V0IGlubmVyIHJhZGl1c1xuICAgICAqIEBuYW1lIHNldElubmVyUmFkaXVzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFyLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcbiAgICAgKi9cblxuICAvKipcbiAgICAgKiBnZXQgaW5uZXIgcmFkaXVzXG4gICAgICogQG5hbWUgZ2V0SW5uZXJSYWRpdXNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YXIucHJvdG90eXBlXG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU3RhciwgJ291dGVyUmFkaXVzJywgMCk7XG5cbiAgLyoqXG4gICAgICogc2V0IG91dGVyIHJhZGl1c1xuICAgICAqIEBuYW1lIHNldE91dGVyUmFkaXVzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFyLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcbiAgICAgKi9cblxuICAvKipcbiAgICAgKiBnZXQgb3V0ZXIgcmFkaXVzXG4gICAgICogQG5hbWUgZ2V0T3V0ZXJSYWRpdXNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YXIucHJvdG90eXBlXG4gICAgICovXG5cbiAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLlN0YXIpO1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIC8vIGNvbnN0YW50c1xuICB2YXIgQVRUUl9DSEFOR0VfTElTVCA9IFtcbiAgICAnZm9udEZhbWlseScsXG4gICAgJ2ZvbnRTaXplJyxcbiAgICAnZm9udFN0eWxlJyxcbiAgICAncGFkZGluZycsXG4gICAgJ2xpbmVIZWlnaHQnLFxuICAgICd0ZXh0JyxcbiAgICAnd2lkdGgnXG4gIF0sXG4gICAgQ0hBTkdFX0tPTlZBID0gJ0NoYW5nZS5rb252YScsXG4gICAgTk9ORSA9ICdub25lJyxcbiAgICBVUCA9ICd1cCcsXG4gICAgUklHSFQgPSAncmlnaHQnLFxuICAgIERPV04gPSAnZG93bicsXG4gICAgTEVGVCA9ICdsZWZ0JyxcbiAgICBMQUJFTCA9ICdMYWJlbCcsXG4gICAgLy8gY2FjaGVkIHZhcmlhYmxlc1xuICAgIGF0dHJDaGFuZ2VMaXN0TGVuID0gQVRUUl9DSEFOR0VfTElTVC5sZW5ndGg7XG5cbiAgLyoqXG4gICAgICogTGFiZWwgY29uc3RydWN0b3IuJm5ic3A7IExhYmVscyBhcmUgZ3JvdXBzIHRoYXQgY29udGFpbiBhIFRleHQgYW5kIFRhZyBzaGFwZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gY3JlYXRlIGxhYmVsXG4gICAgICogdmFyIGxhYmVsID0gbmV3IEtvbnZhLkxhYmVsKHtcbiAgICAgKiAgIHg6IDEwMCxcbiAgICAgKiAgIHk6IDEwMCxcbiAgICAgKiAgIGRyYWdnYWJsZTogdHJ1ZVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gYWRkIGEgdGFnIHRvIHRoZSBsYWJlbFxuICAgICAqIGxhYmVsLmFkZChuZXcgS29udmEuVGFnKHtcbiAgICAgKiAgIGZpbGw6ICcjYmJiJyxcbiAgICAgKiAgIHN0cm9rZTogJyMzMzMnLFxuICAgICAqICAgc2hhZG93Q29sb3I6ICdibGFjaycsXG4gICAgICogICBzaGFkb3dCbHVyOiAxMCxcbiAgICAgKiAgIHNoYWRvd09mZnNldDogWzEwLCAxMF0sXG4gICAgICogICBzaGFkb3dPcGFjaXR5OiAwLjIsXG4gICAgICogICBsaW5lSm9pbjogJ3JvdW5kJyxcbiAgICAgKiAgIHBvaW50ZXJEaXJlY3Rpb246ICd1cCcsXG4gICAgICogICBwb2ludGVyV2lkdGg6IDIwLFxuICAgICAqICAgcG9pbnRlckhlaWdodDogMjAsXG4gICAgICogICBjb3JuZXJSYWRpdXM6IDVcbiAgICAgKiB9KSk7XG4gICAgICpcbiAgICAgKiAvLyBhZGQgdGV4dCB0byB0aGUgbGFiZWxcbiAgICAgKiBsYWJlbC5hZGQobmV3IEtvbnZhLlRleHQoe1xuICAgICAqICAgdGV4dDogJ0hlbGxvIFdvcmxkIScsXG4gICAgICogICBmb250U2l6ZTogNTAsXG4gICAgICogICBsaW5lSGVpZ2h0OiAxLjIsXG4gICAgICogICBwYWRkaW5nOiAxMCxcbiAgICAgKiAgIGZpbGw6ICdncmVlbidcbiAgICAgKiAgfSkpO1xuICAgICAqL1xuICBLb252YS5MYWJlbCA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHRoaXMuX19fX2luaXQoY29uZmlnKTtcbiAgfTtcblxuICBLb252YS5MYWJlbC5wcm90b3R5cGUgPSB7XG4gICAgX19fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICBLb252YS5Hcm91cC5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgICB0aGlzLmNsYXNzTmFtZSA9IExBQkVMO1xuXG4gICAgICB0aGlzLm9uKCdhZGQua29udmEnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgdGhhdC5fYWRkTGlzdGVuZXJzKGV2dC5jaGlsZCk7XG4gICAgICAgIHRoYXQuX3N5bmMoKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIGdldCBUZXh0IHNoYXBlIGZvciB0aGUgbGFiZWwuICBZb3UgbmVlZCB0byBhY2Nlc3MgdGhlIFRleHQgc2hhcGUgaW4gb3JkZXIgdG8gdXBkYXRlXG4gICAgICAgICAqIHRoZSB0ZXh0IHByb3BlcnRpZXNcbiAgICAgICAgICogQG5hbWUgZ2V0VGV4dFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5MYWJlbC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgZ2V0VGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5kKCdUZXh0JylbMF07XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogZ2V0IFRhZyBzaGFwZSBmb3IgdGhlIGxhYmVsLiAgWW91IG5lZWQgdG8gYWNjZXNzIHRoZSBUYWcgc2hhcGUgaW4gb3JkZXIgdG8gdXBkYXRlXG4gICAgICAgICAqIHRoZSBwb2ludGVyIHByb3BlcnRpZXMgYW5kIHRoZSBjb3JuZXIgcmFkaXVzXG4gICAgICAgICAqIEBuYW1lIGdldFRhZ1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5MYWJlbC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgZ2V0VGFnOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmQoJ1RhZycpWzBdO1xuICAgIH0sXG4gICAgX2FkZExpc3RlbmVyczogZnVuY3Rpb24odGV4dCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzLCBuO1xuICAgICAgdmFyIGZ1bmMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhhdC5fc3luYygpO1xuICAgICAgfTtcblxuICAgICAgLy8gdXBkYXRlIHRleHQgZGF0YSBmb3IgY2VydGFpbiBhdHRyIGNoYW5nZXNcbiAgICAgIGZvciAobiA9IDA7IG4gPCBhdHRyQ2hhbmdlTGlzdExlbjsgbisrKSB7XG4gICAgICAgIHRleHQub24oQVRUUl9DSEFOR0VfTElTVFtuXSArIENIQU5HRV9LT05WQSwgZnVuYyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRUZXh0KCkuZ2V0V2lkdGgoKTtcbiAgICB9LFxuICAgIGdldEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRUZXh0KCkuZ2V0SGVpZ2h0KCk7XG4gICAgfSxcbiAgICBfc3luYzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdGV4dCA9IHRoaXMuZ2V0VGV4dCgpLFxuICAgICAgICB0YWcgPSB0aGlzLmdldFRhZygpLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICBwb2ludGVyRGlyZWN0aW9uLFxuICAgICAgICBwb2ludGVyV2lkdGgsXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHBvaW50ZXJIZWlnaHQ7XG5cbiAgICAgIGlmICh0ZXh0ICYmIHRhZykge1xuICAgICAgICB3aWR0aCA9IHRleHQuZ2V0V2lkdGgoKTtcbiAgICAgICAgaGVpZ2h0ID0gdGV4dC5nZXRIZWlnaHQoKTtcbiAgICAgICAgcG9pbnRlckRpcmVjdGlvbiA9IHRhZy5nZXRQb2ludGVyRGlyZWN0aW9uKCk7XG4gICAgICAgIHBvaW50ZXJXaWR0aCA9IHRhZy5nZXRQb2ludGVyV2lkdGgoKTtcbiAgICAgICAgcG9pbnRlckhlaWdodCA9IHRhZy5nZXRQb2ludGVySGVpZ2h0KCk7XG4gICAgICAgIHggPSAwO1xuICAgICAgICB5ID0gMDtcblxuICAgICAgICBzd2l0Y2ggKHBvaW50ZXJEaXJlY3Rpb24pIHtcbiAgICAgICAgICBjYXNlIFVQOlxuICAgICAgICAgICAgeCA9IHdpZHRoIC8gMjtcbiAgICAgICAgICAgIHkgPSAtMSAqIHBvaW50ZXJIZWlnaHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFJJR0hUOlxuICAgICAgICAgICAgeCA9IHdpZHRoICsgcG9pbnRlcldpZHRoO1xuICAgICAgICAgICAgeSA9IGhlaWdodCAvIDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIERPV046XG4gICAgICAgICAgICB4ID0gd2lkdGggLyAyO1xuICAgICAgICAgICAgeSA9IGhlaWdodCArIHBvaW50ZXJIZWlnaHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIExFRlQ6XG4gICAgICAgICAgICB4ID0gLTEgKiBwb2ludGVyV2lkdGg7XG4gICAgICAgICAgICB5ID0gaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFnLnNldEF0dHJzKHtcbiAgICAgICAgICB4OiAtMSAqIHgsXG4gICAgICAgICAgeTogLTEgKiB5LFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICB9KTtcblxuICAgICAgICB0ZXh0LnNldEF0dHJzKHtcbiAgICAgICAgICB4OiAtMSAqIHgsXG4gICAgICAgICAgeTogLTEgKiB5XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBLb252YS5VdGlsLmV4dGVuZChLb252YS5MYWJlbCwgS29udmEuR3JvdXApO1xuXG4gIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5MYWJlbCk7XG5cbiAgLyoqXG4gICAgICogVGFnIGNvbnN0cnVjdG9yLiZuYnNwOyBBIFRhZyBjYW4gYmUgY29uZmlndXJlZFxuICAgICAqICB0byBoYXZlIGEgcG9pbnRlciBlbGVtZW50IHRoYXQgcG9pbnRzIHVwLCByaWdodCwgZG93biwgb3IgbGVmdFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5wb2ludGVyRGlyZWN0aW9uXSBjYW4gYmUgdXAsIHJpZ2h0LCBkb3duLCBsZWZ0LCBvciBub25lOyB0aGUgZGVmYXVsdFxuICAgICAqICBpcyBub25lLiAgV2hlbiBhIHBvaW50ZXIgaXMgcHJlc2VudCwgdGhlIHBvc2l0aW9uaW5nIG9mIHRoZSBsYWJlbCBpcyByZWxhdGl2ZSB0byB0aGUgdGlwIG9mIHRoZSBwb2ludGVyLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnBvaW50ZXJXaWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5wb2ludGVySGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNvcm5lclJhZGl1c11cbiAgICAgKi9cbiAgS29udmEuVGFnID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gIH07XG5cbiAgS29udmEuVGFnLnByb3RvdHlwZSA9IHtcbiAgICBfX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIEtvbnZhLlNoYXBlLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ1RhZyc7XG4gICAgICB0aGlzLnNjZW5lRnVuYyh0aGlzLl9zY2VuZUZ1bmMpO1xuICAgIH0sXG4gICAgX3NjZW5lRnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgdmFyIHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpLFxuICAgICAgICBoZWlnaHQgPSB0aGlzLmdldEhlaWdodCgpLFxuICAgICAgICBwb2ludGVyRGlyZWN0aW9uID0gdGhpcy5nZXRQb2ludGVyRGlyZWN0aW9uKCksXG4gICAgICAgIHBvaW50ZXJXaWR0aCA9IHRoaXMuZ2V0UG9pbnRlcldpZHRoKCksXG4gICAgICAgIHBvaW50ZXJIZWlnaHQgPSB0aGlzLmdldFBvaW50ZXJIZWlnaHQoKSxcbiAgICAgICAgY29ybmVyUmFkaXVzID0gTWF0aC5taW4odGhpcy5nZXRDb3JuZXJSYWRpdXMoKSwgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcblxuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGlmICghY29ybmVyUmFkaXVzKSB7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKDAsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5tb3ZlVG8oY29ybmVyUmFkaXVzLCAwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBvaW50ZXJEaXJlY3Rpb24gPT09IFVQKSB7XG4gICAgICAgIGNvbnRleHQubGluZVRvKCh3aWR0aCAtIHBvaW50ZXJXaWR0aCkgLyAyLCAwKTtcbiAgICAgICAgY29udGV4dC5saW5lVG8od2lkdGggLyAyLCAtMSAqIHBvaW50ZXJIZWlnaHQpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbygod2lkdGggKyBwb2ludGVyV2lkdGgpIC8gMiwgMCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghY29ybmVyUmFkaXVzKSB7XG4gICAgICAgIGNvbnRleHQubGluZVRvKHdpZHRoLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQubGluZVRvKHdpZHRoIC0gY29ybmVyUmFkaXVzLCAwKTtcbiAgICAgICAgY29udGV4dC5hcmMoXG4gICAgICAgICAgd2lkdGggLSBjb3JuZXJSYWRpdXMsXG4gICAgICAgICAgY29ybmVyUmFkaXVzLFxuICAgICAgICAgIGNvcm5lclJhZGl1cyxcbiAgICAgICAgICBNYXRoLlBJICogMyAvIDIsXG4gICAgICAgICAgMCxcbiAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9pbnRlckRpcmVjdGlvbiA9PT0gUklHSFQpIHtcbiAgICAgICAgY29udGV4dC5saW5lVG8od2lkdGgsIChoZWlnaHQgLSBwb2ludGVySGVpZ2h0KSAvIDIpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh3aWR0aCArIHBvaW50ZXJXaWR0aCwgaGVpZ2h0IC8gMik7XG4gICAgICAgIGNvbnRleHQubGluZVRvKHdpZHRoLCAoaGVpZ2h0ICsgcG9pbnRlckhlaWdodCkgLyAyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjb3JuZXJSYWRpdXMpIHtcbiAgICAgICAgY29udGV4dC5saW5lVG8od2lkdGgsIGhlaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh3aWR0aCwgaGVpZ2h0IC0gY29ybmVyUmFkaXVzKTtcbiAgICAgICAgY29udGV4dC5hcmMoXG4gICAgICAgICAgd2lkdGggLSBjb3JuZXJSYWRpdXMsXG4gICAgICAgICAgaGVpZ2h0IC0gY29ybmVyUmFkaXVzLFxuICAgICAgICAgIGNvcm5lclJhZGl1cyxcbiAgICAgICAgICAwLFxuICAgICAgICAgIE1hdGguUEkgLyAyLFxuICAgICAgICAgIGZhbHNlXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwb2ludGVyRGlyZWN0aW9uID09PSBET1dOKSB7XG4gICAgICAgIGNvbnRleHQubGluZVRvKCh3aWR0aCArIHBvaW50ZXJXaWR0aCkgLyAyLCBoZWlnaHQpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh3aWR0aCAvIDIsIGhlaWdodCArIHBvaW50ZXJIZWlnaHQpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbygod2lkdGggLSBwb2ludGVyV2lkdGgpIC8gMiwgaGVpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjb3JuZXJSYWRpdXMpIHtcbiAgICAgICAgY29udGV4dC5saW5lVG8oMCwgaGVpZ2h0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQubGluZVRvKGNvcm5lclJhZGl1cywgaGVpZ2h0KTtcbiAgICAgICAgY29udGV4dC5hcmMoXG4gICAgICAgICAgY29ybmVyUmFkaXVzLFxuICAgICAgICAgIGhlaWdodCAtIGNvcm5lclJhZGl1cyxcbiAgICAgICAgICBjb3JuZXJSYWRpdXMsXG4gICAgICAgICAgTWF0aC5QSSAvIDIsXG4gICAgICAgICAgTWF0aC5QSSxcbiAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9pbnRlckRpcmVjdGlvbiA9PT0gTEVGVCkge1xuICAgICAgICBjb250ZXh0LmxpbmVUbygwLCAoaGVpZ2h0ICsgcG9pbnRlckhlaWdodCkgLyAyKTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oLTEgKiBwb2ludGVyV2lkdGgsIGhlaWdodCAvIDIpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbygwLCAoaGVpZ2h0IC0gcG9pbnRlckhlaWdodCkgLyAyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvcm5lclJhZGl1cykge1xuICAgICAgICBjb250ZXh0LmxpbmVUbygwLCBjb3JuZXJSYWRpdXMpO1xuICAgICAgICBjb250ZXh0LmFyYyhcbiAgICAgICAgICBjb3JuZXJSYWRpdXMsXG4gICAgICAgICAgY29ybmVyUmFkaXVzLFxuICAgICAgICAgIGNvcm5lclJhZGl1cyxcbiAgICAgICAgICBNYXRoLlBJLFxuICAgICAgICAgIE1hdGguUEkgKiAzIC8gMixcbiAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgfSxcbiAgICBnZXRTZWxmUmVjdDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgeCA9IDAsXG4gICAgICAgIHkgPSAwLFxuICAgICAgICBwb2ludGVyV2lkdGggPSB0aGlzLmdldFBvaW50ZXJXaWR0aCgpLFxuICAgICAgICBwb2ludGVySGVpZ2h0ID0gdGhpcy5nZXRQb2ludGVySGVpZ2h0KCksXG4gICAgICAgIGRpcmVjdGlvbiA9IHRoaXMucG9pbnRlckRpcmVjdGlvbigpLFxuICAgICAgICB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKSxcbiAgICAgICAgaGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoKTtcblxuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gVVApIHtcbiAgICAgICAgeSAtPSBwb2ludGVySGVpZ2h0O1xuICAgICAgICBoZWlnaHQgKz0gcG9pbnRlckhlaWdodDtcbiAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBET1dOKSB7XG4gICAgICAgIGhlaWdodCArPSBwb2ludGVySGVpZ2h0O1xuICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09IExFRlQpIHtcbiAgICAgICAgLy8gQVJHSCEhISBJIGhhdmUgbm8gaWRlYSB3aHkgc2hvdWxkIEkgdXNlZCBtYWdpYyAxLjUhISEhISEhISFcbiAgICAgICAgeCAtPSBwb2ludGVyV2lkdGggKiAxLjU7XG4gICAgICAgIHdpZHRoICs9IHBvaW50ZXJXaWR0aDtcbiAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBSSUdIVCkge1xuICAgICAgICB3aWR0aCArPSBwb2ludGVyV2lkdGggKiAxLjU7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICBLb252YS5VdGlsLmV4dGVuZChLb252YS5UYWcsIEtvbnZhLlNoYXBlKTtcbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGFnLCAncG9pbnRlckRpcmVjdGlvbicsIE5PTkUpO1xuXG4gIC8qKlxuICAgICAqIHNldCBwb2ludGVyIERpcmVjdGlvblxuICAgICAqIEBuYW1lIHNldFBvaW50ZXJEaXJlY3Rpb25cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRhZy5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcG9pbnRlckRpcmVjdGlvbiBjYW4gYmUgdXAsIHJpZ2h0LCBkb3duLCBsZWZ0LCBvciBub25lLiAgVGhlXG4gICAgICogIGRlZmF1bHQgaXMgbm9uZVxuICAgICAqL1xuXG4gIC8qKlxuICAgICAqIGdldCBwb2ludGVyIERpcmVjdGlvblxuICAgICAqIEBuYW1lIGdldFBvaW50ZXJEaXJlY3Rpb25cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRhZy5wcm90b3R5cGVcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UYWcsICdwb2ludGVyV2lkdGgnLCAwKTtcblxuICAvKipcbiAgICAgKiBzZXQgcG9pbnRlciB3aWR0aFxuICAgICAqIEBuYW1lIHNldFBvaW50ZXJXaWR0aFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVGFnLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb2ludGVyV2lkdGhcbiAgICAgKi9cblxuICAvKipcbiAgICAgKiBnZXQgcG9pbnRlciB3aWR0aFxuICAgICAqIEBuYW1lIGdldFBvaW50ZXJXaWR0aFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVGFnLnByb3RvdHlwZVxuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRhZywgJ3BvaW50ZXJIZWlnaHQnLCAwKTtcblxuICAvKipcbiAgICAgKiBzZXQgcG9pbnRlciBoZWlnaHRcbiAgICAgKiBAbmFtZSBzZXRQb2ludGVySGVpZ2h0XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UYWcucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvaW50ZXJIZWlnaHRcbiAgICAgKi9cblxuICAvKipcbiAgICAgKiBnZXQgcG9pbnRlciBoZWlnaHRcbiAgICAgKiBAbmFtZSBnZXRQb2ludGVySGVpZ2h0XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UYWcucHJvdG90eXBlXG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGFnLCAnY29ybmVyUmFkaXVzJywgMCk7XG5cbiAgLyoqXG4gICAgICogc2V0IGNvcm5lciByYWRpdXNcbiAgICAgKiBAbmFtZSBzZXRDb3JuZXJSYWRpdXNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRhZy5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29ybmVyIHJhZGl1c1xuICAgICAqL1xuXG4gIC8qKlxuICAgICAqIGdldCBjb3JuZXIgcmFkaXVzXG4gICAgICogQG5hbWUgZ2V0Q29ybmVyUmFkaXVzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UYWcucHJvdG90eXBlXG4gICAgICovXG5cbiAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLlRhZyk7XG59KSgpO1xuXG4oZnVuY3Rpb24oS29udmEpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvKipcbiAgICAgKiBBcnJvdyBjb25zdHJ1Y3RvclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBhdWdtZW50cyBLb252YS5TaGFwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjb25maWcucG9pbnRzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcudGVuc2lvbl0gSGlnaGVyIHZhbHVlcyB3aWxsIHJlc3VsdCBpbiBhIG1vcmUgY3VydnkgbGluZS4gIEEgdmFsdWUgb2YgMCB3aWxsIHJlc3VsdCBpbiBubyBpbnRlcnBvbGF0aW9uLlxuICAgICAqICAgVGhlIGRlZmF1bHQgaXMgMFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcucG9pbnRlckxlbmd0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcucG9pbnRlcldpZHRoXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbF0gZmlsbCBjb2xvclxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IFtjb25maWcuZmlsbFBhdHRlcm5JbWFnZV0gZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5YXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WV0gXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZV0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblJvdGF0aW9uXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQYXR0ZXJuUmVwZWF0XSBjYW4gYmUgXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuICBUaGUgZGVmYXVsdCBpcyBcIm5vLXJlcGVhdFwiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5maWxsRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBmaWxsLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQcmlvcml0eV0gY2FuIGJlIGNvbG9yLCBsaW5lYXItZ3JhZGllbnQsIHJhZGlhbC1ncmFpZGVudCwgb3IgcGF0dGVybi4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGNvbG9yLiAgVGhlIGZpbGxQcmlvcml0eSBwcm9wZXJ0eSBtYWtlcyBpdCByZWFsbHkgZWFzeSB0byB0b2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgZmlsbCB0eXBlcy4gIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byB0b2dnbGUgYmV0d2VlbiBhIGZpbGwgY29sb3Igc3R5bGUgYW5kIGEgZmlsbCBwYXR0ZXJuIHN0eWxlLCBzaW1wbHkgc2V0IHRoZSBmaWxsIHByb3BlcnR5IGFuZCB0aGUgZmlsbFBhdHRlcm4gcHJvcGVydGllcywgYW5kIHRoZW4gdXNlIHNldEZpbGxQcmlvcml0eSgnY29sb3InKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggYSBjb2xvciBmaWxsLCBvciB1c2Ugc2V0RmlsbFByaW9yaXR5KCdwYXR0ZXJuJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIHRoZSBwYXR0ZXJuIGZpbGwgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnN0cm9rZV0gc3Ryb2tlIGNvbG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc3Ryb2tlV2lkdGhdIHN0cm9rZSB3aWR0aFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VIaXRFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIGhpdCByZWdpb24uICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnBlcmZlY3REcmF3RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHVzaW5nIGJ1ZmZlciBjYW52YXMuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzaGFzb3cgZm9yIHN0cm9rZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlU2NhbGVFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIHNjYWxlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHN0cm9rZS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lSm9pbl0gY2FuIGJlIG1pdGVyLCByb3VuZCwgb3IgYmV2ZWwuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBtaXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVDYXBdIGNhbiBiZSBidXR0LCByb3VuZCwgb3Igc3FhcmUuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBidXR0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc2hhZG93Q29sb3JdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93Qmx1cl1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zaGFkb3dPZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09wYWNpdHldIHNoYWRvdyBvcGFjaXR5LiAgQ2FuIGJlIGFueSByZWFsIG51bWJlclxuICAgICAqICBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzaGFkb3cuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5kYXNoXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kYXNoRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBkYXNoQXJyYXkuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBsaW5lID0gbmV3IEtvbnZhLkxpbmUoe1xuICAgICAqICAgcG9pbnRzOiBbNzMsIDcwLCAzNDAsIDIzLCA0NTAsIDYwLCA1MDAsIDIwXSxcbiAgICAgKiAgIHN0cm9rZTogJ3JlZCcsXG4gICAgICogICB0ZW5zaW9uOiAxLFxuICAgICAqICAgcG9pbnRlckxlbmd0aCA6IDEwLFxuICAgICAqICAgcG9pbnRlcldpZHRoIDogMTJcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgS29udmEuQXJyb3cgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICB0aGlzLl9fX19pbml0KGNvbmZpZyk7XG4gIH07XG5cbiAgS29udmEuQXJyb3cucHJvdG90eXBlID0ge1xuICAgIF9fX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgIEtvbnZhLkxpbmUuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnQXJyb3cnO1xuICAgIH0sXG4gICAgX3NjZW5lRnVuYzogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBLb252YS5MaW5lLnByb3RvdHlwZS5fc2NlbmVGdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB2YXIgUEkyID0gTWF0aC5QSSAqIDI7XG4gICAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHMoKTtcbiAgICAgIHZhciBuID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgIHZhciBkeCA9IHBvaW50c1tuIC0gMl0gLSBwb2ludHNbbiAtIDRdO1xuICAgICAgdmFyIGR5ID0gcG9pbnRzW24gLSAxXSAtIHBvaW50c1tuIC0gM107XG4gICAgICB2YXIgcmFkaWFucyA9IChNYXRoLmF0YW4yKGR5LCBkeCkgKyBQSTIpICUgUEkyO1xuICAgICAgdmFyIGxlbmd0aCA9IHRoaXMucG9pbnRlckxlbmd0aCgpO1xuICAgICAgdmFyIHdpZHRoID0gdGhpcy5wb2ludGVyV2lkdGgoKTtcblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC50cmFuc2xhdGUocG9pbnRzW24gLSAyXSwgcG9pbnRzW24gLSAxXSk7XG4gICAgICBjdHgucm90YXRlKHJhZGlhbnMpO1xuICAgICAgY3R4Lm1vdmVUbygwLCAwKTtcbiAgICAgIGN0eC5saW5lVG8oLWxlbmd0aCwgd2lkdGggLyAyKTtcbiAgICAgIGN0eC5saW5lVG8oLWxlbmd0aCwgLXdpZHRoIC8gMik7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICBpZiAodGhpcy5wb2ludGVyQXRCZWdpbm5pbmcoKSkge1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKHBvaW50c1swXSwgcG9pbnRzWzFdKTtcbiAgICAgICAgZHggPSBwb2ludHNbMl0gLSBwb2ludHNbMF07XG4gICAgICAgIGR5ID0gcG9pbnRzWzNdIC0gcG9pbnRzWzFdO1xuICAgICAgICBjdHgucm90YXRlKChNYXRoLmF0YW4yKC1keSwgLWR4KSArIFBJMikgJSBQSTIpO1xuICAgICAgICBjdHgubW92ZVRvKDAsIDApO1xuICAgICAgICBjdHgubGluZVRvKC1sZW5ndGgsIHdpZHRoIC8gMik7XG4gICAgICAgIGN0eC5saW5lVG8oLWxlbmd0aCwgLXdpZHRoIC8gMik7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICAgIGN0eC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgfVxuICB9O1xuXG4gIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLkFycm93LCBLb252YS5MaW5lKTtcbiAgLyoqXG4gICAgICogZ2V0L3NldCBwb2ludGVyTGVuZ3RoXG4gICAgICogQG5hbWUgcG9pbnRlckxlbmd0aFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQXJyb3cucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IExlbmd0aCBvZiBwb2ludGVyIG9mIGFycm93LlxuICAgICAqICAgVGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCB0ZW5zaW9uXG4gICAgICogdmFyIHBvaW50ZXJMZW5ndGggPSBsaW5lLnBvaW50ZXJMZW5ndGgoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCB0ZW5zaW9uXG4gICAgICogbGluZS5wb2ludGVyTGVuZ3RoKDE1KTtcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5BcnJvdywgJ3BvaW50ZXJMZW5ndGgnLCAxMCk7XG4gIC8qKlxuICAgICAqIGdldC9zZXQgcG9pbnRlcldpZHRoXG4gICAgICogQG5hbWUgcG9pbnRlcldpZHRoXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5BcnJvdy5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gV2lkdGggb2YgcG9pbnRlciBvZiBhcnJvdy5cbiAgICAgKiAgIFRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgdGVuc2lvblxuICAgICAqIHZhciBwb2ludGVyV2lkdGggPSBsaW5lLnBvaW50ZXJXaWR0aCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHRlbnNpb25cbiAgICAgKiBsaW5lLnBvaW50ZXJXaWR0aCgxNSk7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuQXJyb3csICdwb2ludGVyV2lkdGgnLCAxMCk7XG4gIC8qKlxuICAgICAqIGdldC9zZXQgcG9pbnRlckF0QmVnaW5uaW5nXG4gICAgICogQG5hbWUgcG9pbnRlckF0QmVnaW5uaW5nXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5BcnJvdy5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gU2hvdWxkIHBvaW50ZXIgZGlzcGxheWVkIGF0IGJlZ2lubmluZyBvZiBhcnJvdy5cbiAgICAgKiAgIFRoZSBkZWZhdWx0IGlzIGZhbHNlLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHRlbnNpb25cbiAgICAgKiB2YXIgcG9pbnRlckF0QmVnaW5uaW5nID0gbGluZS5wb2ludGVyQXRCZWdpbm5pbmcoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCB0ZW5zaW9uXG4gICAgICogbGluZS5wb2ludGVyQXRCZWdpbm5pbmcodHJ1ZSk7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuQXJyb3csICdwb2ludGVyQXRCZWdpbm5pbmcnLCBmYWxzZSk7XG4gIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5BcnJvdyk7XG59KShLb252YSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9rb252YS9rb252YS5qc1xuLy8gbW9kdWxlIGlkID0gOTExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIFN5bWJvbC5mb3IgJiZcbiAgICBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykpIHx8XG4gICAgMHhlYWM3O1xuXG4gIHZhciBpc1ZhbGlkRWxlbWVudCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgb2JqZWN0ICE9PSBudWxsICYmXG4gICAgICBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfTtcblxuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFR5cGVDaGVja2VycycpKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbn0gZWxzZSB7XG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcycpKCk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1rb252YS9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gOTEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vY2hlY2tQcm9wVHlwZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAvKiBnbG9iYWwgU3ltYm9sICovXG4gIHZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbiAgdmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAgICpcbiAgICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gICAqXG4gICAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gICAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gICAqICAgICAgIC4uLlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvckZuO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxuICAgKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICAgKlxuICAgKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XG4gICAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXG4gICAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cbiAgICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cbiAgICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICAgKiAgICAgfSxcbiAgICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcbiAgICpcbiAgICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG4gICAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xuICAgKlxuICAgKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG4gICAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAgICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAgICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICAgKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICogICAgICAgICAgKTtcbiAgICogICAgICAgIH1cbiAgICogICAgICB9XG4gICAqICAgIH0sXG4gICAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICAgKiAgfSk7XG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICB2YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xuXG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuICAgIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG4gICAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG4gICAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gICAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG4gICAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG4gICAgc3ltYm9sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3ltYm9sJyksXG5cbiAgICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gICAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxuICAgIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxuICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gICAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICAgIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlclxuICB9O1xuXG4gIC8qKlxuICAgKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICAgKi9cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuICBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gICAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICAgIH1cbiAgfVxuICAvKmVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlKi9cblxuICAvKipcbiAgICogV2UgdXNlIGFuIEVycm9yLWxpa2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFzIHBlb3BsZSBtYXkgY2FsbFxuICAgKiBQcm9wVHlwZXMgZGlyZWN0bHkgYW5kIGluc3BlY3QgdGhlaXIgb3V0cHV0LiBIb3dldmVyLCB3ZSBkb24ndCB1c2UgcmVhbFxuICAgKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXG4gICAqIGlzIHByb2hpYml0aXZlbHkgZXhwZW5zaXZlIGlmIHRoZXkgYXJlIGNyZWF0ZWQgdG9vIG9mdGVuLCBzdWNoIGFzIHdoYXRcbiAgICogaGFwcGVucyBpbiBvbmVPZlR5cGUoKSBmb3IgYW55IHR5cGUgYmVmb3JlIHRoZSBvbmUgdGhhdCBtYXRjaGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gUHJvcFR5cGVFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnN0YWNrID0gJyc7XG4gIH1cbiAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgICBpZiAodGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAgICAgICAgIC8vIE5ldyBiZWhhdmlvciBvbmx5IGZvciB1c2VycyBvZiBgcHJvcC10eXBlc2AgcGFja2FnZVxuICAgICAgICAgIGludmFyaWFudChcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgJ1VzZSBgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKClgIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAgICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gT2xkIGJlaGF2aW9yIGZvciBwZW9wbGUgdXNpbmcgUmVhY3QuUHJvcFR5cGVzXG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gJiZcbiAgICAgICAgICAgIC8vIEF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlIGJlY2F1c2UgdGhleSBhcmUgb2Z0ZW4gbm90IGFjdGlvbmFibGUgZXhjZXB0IGZvciBsaWIgYXV0aG9yc1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPCAzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJXNgIHByb3Agb24gYCVzYC4gVGhpcyBpcyBkZXByZWNhdGVkICcgK1xuICAgICAgICAgICAgICAnYW5kIHdpbGwgdGhyb3cgaW4gdGhlIHN0YW5kYWxvbmUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgICAnWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byBhIHRoaXJkLXBhcnR5IFByb3BUeXBlcyAnICtcbiAgICAgICAgICAgICAgJ2xpYnJhcnkuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctZG9udC1jYWxsLXByb3B0eXBlcyAnICsgJ2ZvciBkZXRhaWxzLicsXG4gICAgICAgICAgICAgIHByb3BGdWxsTmFtZSxcbiAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgYXJyYXlPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBhcnJheS4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnWycgKyBpICsgJ10nLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIWlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50LicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcyk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgcHJvcFZhbHVlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIG9iamVjdE9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XG4gICAgICAgIGlmIChwcm9wVmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5pb25UeXBlQ2hlY2tlcihhcnJheU9mVHlwZUNoZWNrZXJzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWQgdG8gb25lT2ZUeXBlLiBFeHBlY3RlZCBhbiBhcnJheSBvZiBjaGVjayBmdW5jdGlvbnMsIGJ1dCAnICtcbiAgICAgICAgICAncmVjZWl2ZWQgJXMgYXQgaW5kZXggJXMuJyxcbiAgICAgICAgICBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcoY2hlY2tlciksXG4gICAgICAgICAgaVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgICBpZiAoY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVOb2RlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gICAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuICAgIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbiAgZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gICAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbiAgLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG4gIGZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJyArIHByb3BWYWx1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgaXMgcG9zdGZpeGVkIHRvIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIHR5cGUuXG4gIC8vIEZvciBleGFtcGxlLCBcInVuZGVmaW5lZFwiIG9yIFwib2YgdHlwZSBhcnJheVwiXG4gIGZ1bmN0aW9uIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmV0dXJuICdhbiAnICsgdHlwZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICByZXR1cm4gJ2EgJyArIHR5cGU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gICAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICByZXR1cm4gQU5PTllNT1VTO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGNoZWNrUHJvcFR5cGVzO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qta29udmEvbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanNcbi8vIG1vZHVsZSBpZCA9IDkxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbiAgdmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZ2V0U3RhY2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAodHlwZVNwZWNzLmhhc093blByb3BlcnR5KHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaW52YXJpYW50KHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSA9PT0gJ2Z1bmN0aW9uJywgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gJyArICdSZWFjdC5Qcm9wVHlwZXMuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lKTtcbiAgICAgICAgICBlcnJvciA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yID0gZXg7XG4gICAgICAgIH1cbiAgICAgICAgd2FybmluZyghZXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciwgJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yKTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblxuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgJXMgdHlwZTogJXMlcycsIGxvY2F0aW9uLCBlcnJvci5tZXNzYWdlLCBzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1Byb3BUeXBlcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWtvbnZhL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA5MTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIHNoaW0ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICBpZiAoc2VjcmV0ID09PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgLy8gSXQgaXMgc3RpbGwgc2FmZSB3aGVuIGNhbGxlZCBmcm9tIFJlYWN0LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoXG4gICAgICBmYWxzZSxcbiAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICdVc2UgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCkgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICk7XG4gIH07XG4gIHNoaW0uaXNSZXF1aXJlZCA9IHNoaW07XG4gIGZ1bmN0aW9uIGdldFNoaW0oKSB7XG4gICAgcmV0dXJuIHNoaW07XG4gIH07XG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogc2hpbSxcbiAgICBib29sOiBzaGltLFxuICAgIGZ1bmM6IHNoaW0sXG4gICAgbnVtYmVyOiBzaGltLFxuICAgIG9iamVjdDogc2hpbSxcbiAgICBzdHJpbmc6IHNoaW0sXG4gICAgc3ltYm9sOiBzaGltLFxuXG4gICAgYW55OiBzaGltLFxuICAgIGFycmF5T2Y6IGdldFNoaW0sXG4gICAgZWxlbWVudDogc2hpbSxcbiAgICBpbnN0YW5jZU9mOiBnZXRTaGltLFxuICAgIG5vZGU6IHNoaW0sXG4gICAgb2JqZWN0T2Y6IGdldFNoaW0sXG4gICAgb25lT2Y6IGdldFNoaW0sXG4gICAgb25lT2ZUeXBlOiBnZXRTaGltLFxuICAgIHNoYXBlOiBnZXRTaGltXG4gIH07XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBlbXB0eUZ1bmN0aW9uO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qta29udmEvbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzXG4vLyBtb2R1bGUgaWQgPSA5MTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlPYmplY3QgPSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eU9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlPYmplY3Q7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qta29udmEvbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5T2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA5MTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgb25FbGVtZW50UmVzaXplID0gcmVxdWlyZSgnZWxlbWVudC1yZXNpemUtZXZlbnQnKTtcblxudmFyIGRlZmF1bHRDb250YWluZXJTdHlsZSA9IHtcbiAgd2lkdGg6ICcxMDAlJyxcbiAgaGVpZ2h0OiAnMTAwJScsXG4gIHBhZGRpbmc6IDAsXG4gIGJvcmRlcjogMFxufTtcblxuZnVuY3Rpb24gZGVmYXVsdEdldFdpZHRoKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQuY2xpZW50V2lkdGg7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRHZXRIZWlnaHQoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudC5jbGllbnRIZWlnaHQ7XG59XG5cbi8qKlxuICogV3JhcHMgYSByZWFjdCBjb21wb25lbnQgYW5kIGFkZHMgcHJvcGVydGllcyBgY29udGFpbmVySGVpZ2h0YCBhbmRcbiAqIGBjb250YWluZXJXaWR0aGAuIFVzZWZ1bCBmb3IgcmVzcG9uc2l2ZSBkZXNpZ24uIFByb3BlcnRpZXMgdXBkYXRlIG9uXG4gKiB3aW5kb3cgcmVzaXplLiAqKk5vdGUqKiB0aGF0IHRoZSBwYXJlbnQgZWxlbWVudCBtdXN0IGhhdmUgZWl0aGVyIGFcbiAqIGhlaWdodCBvciBhIHdpZHRoLCBvciBub3RoaW5nIHdpbGwgYmUgcmVuZGVyZWRcbiAqXG4gKiBDYW4gYmUgdXNlZCBhcyBhXG4gKiBbaGlnaGVyLW9yZGVyIGNvbXBvbmVudF0oaHR0cDovL2JhYmVsanMuaW8vYmxvZy8yMDE1LzA2LzA3L3JlYWN0LW9uLWVzNi1wbHVzLyNwcm9wZXJ0eS1pbml0aWFsaXplcnMpXG4gKiBvciBhcyBhbiBbRVM3IGNsYXNzIGRlY29yYXRvcl0oaHR0cHM6Ly9naXRodWIuY29tL3d5Y2F0cy9qYXZhc2NyaXB0LWRlY29yYXRvcnMpXG4gKiAoc2VlIGV4YW1wbGVzKVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmdldEhlaWdodF0gQSBmdW5jdGlvbiB0aGF0IGlzIHBhc3NlZCBhbiBlbGVtZW50IGFuZCByZXR1cm5zIGVsZW1lbnRcbiAqIGhlaWdodCwgd2hlcmUgZWxlbWVudCBpcyB0aGUgd3JhcHBlciBkaXYuIERlZmF1bHRzIHRvIGAoZWxlbWVudCkgPT4gZWxlbWVudC5jbGllbnRIZWlnaHRgXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5nZXRXaWR0aF0gIEEgZnVuY3Rpb24gdGhhdCBpcyBwYXNzZWQgYW4gZWxlbWVudCBhbmQgcmV0dXJucyBlbGVtZW50XG4gKiB3aWR0aCwgd2hlcmUgZWxlbWVudCBpcyB0aGUgd3JhcHBlciBkaXYuIERlZmF1bHRzIHRvIGAoZWxlbWVudCkgPT4gZWxlbWVudC5jbGllbnRXaWR0aGBcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5jb250YWluZXJTdHlsZV0gQSBzdHlsZSBvYmplY3QgZm9yIHRoZSBgPGRpdj5gIHRoYXQgd2lsbCB3cmFwIHlvdXIgY29tcG9uZW50LlxuICogVGhlIGRpbWVuc2lvbnMgb2YgdGhpcyBgZGl2YCBhcmUgd2hhdCBhcmUgcGFzc2VkIGFzIHByb3BzIHRvIHlvdXIgY29tcG9uZW50LiBUaGUgZGVmYXVsdCBzdHlsZSBpc1xuICogYHsgd2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnMTAwJScsIHBhZGRpbmc6IDAsIGJvcmRlcjogMCB9YCB3aGljaCB3aWxsIGNhdXNlIHRoZSBgZGl2YCB0byBmaWxsIGl0c1xuICogcGFyZW50IGluIG1vc3QgY2FzZXMuIElmIHlvdSBhcmUgdXNpbmcgYSBmbGV4Ym94IGxheW91dCB5b3Ugd2lsbCB3YW50IHRvIGNoYW5nZSB0aGlzIGRlZmF1bHQgc3R5bGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY2xhc3NOYW1lXSBDb250cm9sIHRoZSBjbGFzcyBuYW1lIHNldCBvbiB0aGUgd3JhcHBlciBgPGRpdj5gXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmVsZW1lbnRSZXNpemU9ZmFsc2VdIFNldCB0cnVlIHRvIHdhdGNoIHRoZSB3cmFwcGVyIGBkaXZgIGZvciBjaGFuZ2VzIGluXG4gKiBzaXplIHdoaWNoIGFyZSBub3QgYSByZXN1bHQgb2Ygd2luZG93IHJlc2l6aW5nIC0gZS5nLiBjaGFuZ2VzIHRvIHRoZSBmbGV4Ym94IGFuZCBvdGhlciBsYXlvdXQuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gICAgICAgICAgICAgICAgICAgQSBoaWdoZXItb3JkZXIgY29tcG9uZW50IHRoYXQgY2FuIGJlXG4gKiB1c2VkIHRvIGVuaGFuY2UgYSByZWFjdCBjb21wb25lbnQgYERpbWVuc2lvbnMoKShNeUNvbXBvbmVudClgXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEVTMjAxNVxuICogaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuICogaW1wb3J0IERpbWVuc2lvbnMgZnJvbSAncmVhY3QtZGltZW5zaW9ucydcbiAqXG4gKiBjbGFzcyBNeUNvbXBvbmVudCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gKiAgIHJlbmRlcigpIChcbiAqICAgICA8ZGl2XG4gKiAgICAgICBjb250YWluZXJXaWR0aD17dGhpcy5wcm9wcy5jb250YWluZXJXaWR0aH1cbiAqICAgICAgIGNvbnRhaW5lckhlaWdodD17dGhpcy5wcm9wcy5jb250YWluZXJIZWlnaHR9XG4gKiAgICAgPlxuICogICAgIDwvZGl2PlxuICogICApXG4gKiB9XG4gKlxuICogZXhwb3J0IGRlZmF1bHQgRGltZW5zaW9ucygpKE15Q29tcG9uZW50KSAvLyBFbmhhbmNlZCBjb21wb25lbnRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRVM1XG4gKiB2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpXG4gKiB2YXIgRGltZW5zaW9ucyA9IHJlcXVpcmUoJ3JlYWN0LWRpbWVuc2lvbnMnKVxuICpcbiAqIHZhciBNeUNvbXBvbmVudCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgcmVuZGVyOiBmdW5jdGlvbigpIHsoXG4gKiAgICAgPGRpdlxuICogICAgICAgY29udGFpbmVyV2lkdGg9e3RoaXMucHJvcHMuY29udGFpbmVyV2lkdGh9XG4gKiAgICAgICBjb250YWluZXJIZWlnaHQ9e3RoaXMucHJvcHMuY29udGFpbmVySGVpZ2h0fVxuICogICAgID5cbiAqICAgICA8L2Rpdj5cbiAqICAgKX1cbiAqIH1cbiAqXG4gKiBtb2R1bGUuZXhwb3J0cyA9IERpbWVuc2lvbnMoKShNeUNvbXBvbmVudCkgLy8gRW5oYW5jZWQgY29tcG9uZW50XG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIERpbWVuc2lvbnMoKSB7XG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgIF9yZWYkZ2V0SGVpZ2h0ID0gX3JlZi5nZXRIZWlnaHQsXG4gICAgICBnZXRIZWlnaHQgPSBfcmVmJGdldEhlaWdodCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdEdldEhlaWdodCA6IF9yZWYkZ2V0SGVpZ2h0LFxuICAgICAgX3JlZiRnZXRXaWR0aCA9IF9yZWYuZ2V0V2lkdGgsXG4gICAgICBnZXRXaWR0aCA9IF9yZWYkZ2V0V2lkdGggPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRHZXRXaWR0aCA6IF9yZWYkZ2V0V2lkdGgsXG4gICAgICBfcmVmJGNvbnRhaW5lclN0eWxlID0gX3JlZi5jb250YWluZXJTdHlsZSxcbiAgICAgIGNvbnRhaW5lclN0eWxlID0gX3JlZiRjb250YWluZXJTdHlsZSA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdENvbnRhaW5lclN0eWxlIDogX3JlZiRjb250YWluZXJTdHlsZSxcbiAgICAgIF9yZWYkY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmJGNsYXNzTmFtZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IF9yZWYkY2xhc3NOYW1lLFxuICAgICAgX3JlZiRlbGVtZW50UmVzaXplID0gX3JlZi5lbGVtZW50UmVzaXplLFxuICAgICAgZWxlbWVudFJlc2l6ZSA9IF9yZWYkZWxlbWVudFJlc2l6ZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJGVsZW1lbnRSZXNpemU7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb21wb3NlZENvbXBvbmVudCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICAgICAgX2luaGVyaXRzKERpbWVuc2lvbnNIT0MsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gICAgICBmdW5jdGlvbiBEaW1lbnNpb25zSE9DKCkge1xuICAgICAgICB2YXIgX3JlZjI7XG5cbiAgICAgICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGltZW5zaW9uc0hPQyk7XG5cbiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZjIgPSBEaW1lbnNpb25zSE9DLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRGltZW5zaW9uc0hPQykpLmNhbGwuYXBwbHkoX3JlZjIsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5zdGF0ZSA9IHt9LCBfdGhpcy51cGRhdGVEaW1lbnNpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBjb250YWluZXIgPSBfdGhpcy5yZWZzLmNvbnRhaW5lcjtcbiAgICAgICAgICB2YXIgY29udGFpbmVyV2lkdGggPSBnZXRXaWR0aChjb250YWluZXIpO1xuICAgICAgICAgIHZhciBjb250YWluZXJIZWlnaHQgPSBnZXRIZWlnaHQoY29udGFpbmVyKTtcblxuICAgICAgICAgIGlmIChjb250YWluZXJXaWR0aCAhPT0gX3RoaXMuc3RhdGUuY29udGFpbmVyV2lkdGggfHwgY29udGFpbmVySGVpZ2h0ICE9PSBfdGhpcy5zdGF0ZS5jb250YWluZXJIZWlnaHQpIHtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgY29udGFpbmVyV2lkdGg6IGNvbnRhaW5lcldpZHRoLCBjb250YWluZXJIZWlnaHQ6IGNvbnRhaW5lckhlaWdodCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF90aGlzLm9uUmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChfdGhpcy5ycWYpIHJldHVybjtcbiAgICAgICAgICBfdGhpcy5ycWYgPSBfdGhpcy5nZXRXaW5kb3coKS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMucnFmID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzLnVwZGF0ZURpbWVuc2lvbnMoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgX3RlbXApLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gICAgICB9XG4gICAgICAvLyBFUzcgQ2xhc3MgcHJvcGVydGllc1xuICAgICAgLy8gaHR0cDovL2JhYmVsanMuaW8vYmxvZy8yMDE1LzA2LzA3L3JlYWN0LW9uLWVzNi1wbHVzLyNwcm9wZXJ0eS1pbml0aWFsaXplcnNcblxuXG4gICAgICAvLyBVc2luZyBhcnJvdyBmdW5jdGlvbnMgYW5kIEVTNyBDbGFzcyBwcm9wZXJ0aWVzIHRvIGF1dG9iaW5kXG4gICAgICAvLyBodHRwOi8vYmFiZWxqcy5pby9ibG9nLzIwMTUvMDYvMDcvcmVhY3Qtb24tZXM2LXBsdXMvI2Fycm93LWZ1bmN0aW9uc1xuXG5cbiAgICAgIF9jcmVhdGVDbGFzcyhEaW1lbnNpb25zSE9DLCBbe1xuICAgICAgICBrZXk6ICdnZXRXaW5kb3cnLFxuXG5cbiAgICAgICAgLy8gSWYgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkIGluIGEgZGlmZmVyZW50IHdpbmRvdyB0byB0aGUgamF2YXNjcmlwdFxuICAgICAgICAvLyBjb250ZXh0LCBhcyB3aXRoIGh0dHBzOi8vZ2l0aHViLmNvbS9KYWtlR2lubml2YW4vcmVhY3QtcG9wb3V0XG4gICAgICAgIC8vIHRoZW4gdGhlIGB3aW5kb3dgIGdsb2JhbCB3aWxsIGJlIGRpZmZlcmVudCBmcm9tIHRoZSBgd2luZG93YCB0aGF0XG4gICAgICAgIC8vIGNvbnRhaW5zIHRoZSBjb21wb25lbnQuXG4gICAgICAgIC8vIERlcGVuZHMgb24gYGRlZmF1bHRWaWV3YCB3aGljaCBpcyBub3Qgc3VwcG9ydGVkIDxJRTlcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFdpbmRvdygpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5yZWZzLmNvbnRhaW5lciA/IHRoaXMucmVmcy5jb250YWluZXIub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3cgOiB3aW5kb3c7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnY29tcG9uZW50RGlkTW91bnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLnJlZnMuY29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIGNvbnRhaW5lciBkaXYnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy51cGRhdGVEaW1lbnNpb25zKCk7XG4gICAgICAgICAgaWYgKGVsZW1lbnRSZXNpemUpIHtcbiAgICAgICAgICAgIC8vIEV4cGVyaW1lbnRhbDogYGVsZW1lbnQtcmVzaXplLWV2ZW50YCBmaXJlcyB3aGVuIGFuIGVsZW1lbnQgcmVzaXplcy5cbiAgICAgICAgICAgIC8vIEl0IGF0dGFjaGVzIGl0cyBvd24gd2luZG93IHJlc2l6ZSBsaXN0ZW5lciBhbmQgYWxzbyB1c2VzXG4gICAgICAgICAgICAvLyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIHNvIHdlIGNhbiBqdXN0IGNhbGwgYHRoaXMudXBkYXRlRGltZW5zaW9uc2AuXG4gICAgICAgICAgICBvbkVsZW1lbnRSZXNpemUodGhpcy5yZWZzLmNvbnRhaW5lciwgdGhpcy51cGRhdGVEaW1lbnNpb25zKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5nZXRXaW5kb3coKS5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLm9uUmVzaXplLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2NvbXBvbmVudFdpbGxVbm1vdW50JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICAgIHRoaXMuZ2V0V2luZG93KCkucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5vblJlc2l6ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgdW5kZXJseWluZyB3cmFwcGVkIGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgICAgICAgICogVXNlZnVsIGlmIHlvdSBuZWVkIHRvIGFjY2VzcyBhIG1ldGhvZCBvciBwcm9wZXJ0eSBvZiB0aGUgY29tcG9uZW50XG4gICAgICAgICAqIHBhc3NlZCB0byByZWFjdC1kaW1lbnNpb25zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSByZW5kZXJlZCBSZWFjdCBjb21wb25lbnRcbiAgICAgICAgICoqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldFdyYXBwZWRJbnN0YW5jZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRXcmFwcGVkSW5zdGFuY2UoKSB7XG4gICAgICAgICAgdGhpcy5yZWZzLndyYXBwZWRJbnN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdyZW5kZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICAgIHZhciBfc3RhdGUgPSB0aGlzLnN0YXRlLFxuICAgICAgICAgICAgICBjb250YWluZXJXaWR0aCA9IF9zdGF0ZS5jb250YWluZXJXaWR0aCxcbiAgICAgICAgICAgICAgY29udGFpbmVySGVpZ2h0ID0gX3N0YXRlLmNvbnRhaW5lckhlaWdodDtcblxuICAgICAgICAgIGlmICghY29udGFpbmVyV2lkdGggJiYgIWNvbnRhaW5lckhlaWdodCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdXcmFwcGVyIGRpdiBoYXMgbm8gaGVpZ2h0IG9yIHdpZHRoLCB0cnkgb3ZlcnJpZGluZyBzdHlsZSB3aXRoIGBjb250YWluZXJTdHlsZWAgb3B0aW9uJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogY2xhc3NOYW1lLCBzdHlsZTogY29udGFpbmVyU3R5bGUsIHJlZjogJ2NvbnRhaW5lcicgfSxcbiAgICAgICAgICAgIChjb250YWluZXJXaWR0aCB8fCBjb250YWluZXJIZWlnaHQpICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9zZWRDb21wb25lbnQsIF9leHRlbmRzKHt9LCB0aGlzLnN0YXRlLCB0aGlzLnByb3BzLCB7XG4gICAgICAgICAgICAgIHVwZGF0ZURpbWVuc2lvbnM6IHRoaXMudXBkYXRlRGltZW5zaW9ucyxcbiAgICAgICAgICAgICAgcmVmOiAnd3JhcHBlZEluc3RhbmNlJ1xuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfV0pO1xuXG4gICAgICByZXR1cm4gRGltZW5zaW9uc0hPQztcbiAgICB9KFJlYWN0LkNvbXBvbmVudCk7XG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZGltZW5zaW9ucy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gOTE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciByZXF1ZXN0RnJhbWUgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgd2luZG93ID0gdGhpc1xuICB2YXIgcmFmID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgZnVuY3Rpb24gZmFsbGJhY2tSQUYoZnVuYykge1xuICAgICAgcmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmMsIDIwKVxuICAgIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIHJlcXVlc3RGcmFtZUZ1bmN0aW9uKGZ1bmMpIHtcbiAgICByZXR1cm4gcmFmKGZ1bmMpXG4gIH1cbn0pKClcblxudmFyIGNhbmNlbEZyYW1lID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHdpbmRvdyA9IHRoaXNcbiAgdmFyIGNhbmNlbCA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy5tb3pDYW5jZWxBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy5jbGVhclRpbWVvdXRcbiAgcmV0dXJuIGZ1bmN0aW9uIGNhbmNlbEZyYW1lRnVuY3Rpb24oaWQpIHtcbiAgICByZXR1cm4gY2FuY2VsKGlkKVxuICB9XG59KSgpXG5cbmZ1bmN0aW9uIHJlc2l6ZUxpc3RlbmVyKGUpIHtcbiAgdmFyIHdpbiA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudFxuICBpZiAod2luLl9fcmVzaXplUkFGX18pIHtcbiAgICBjYW5jZWxGcmFtZSh3aW4uX19yZXNpemVSQUZfXylcbiAgfVxuICB3aW4uX19yZXNpemVSQUZfXyA9IHJlcXVlc3RGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRyaWdnZXIgPSB3aW4uX19yZXNpemVUcmlnZ2VyX19cbiAgICB0cmlnZ2VyLl9fcmVzaXplTGlzdGVuZXJzX18uZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgIGZuLmNhbGwodHJpZ2dlciwgZSlcbiAgICB9KVxuICB9KVxufVxuXG52YXIgZXhwb3J0cyA9IGZ1bmN0aW9uIGV4cG9ydHMoZWxlbWVudCwgZm4pIHtcbiAgdmFyIHdpbmRvdyA9IHRoaXNcbiAgdmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50XG4gIHZhciBpc0lFXG5cbiAgdmFyIGF0dGFjaEV2ZW50ID0gZG9jdW1lbnQuYXR0YWNoRXZlbnRcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaXNJRSA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1RyaWRlbnQvKSB8fFxuICAgICAgbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvRWRnZS8pXG4gIH1cblxuICBmdW5jdGlvbiBvYmplY3RMb2FkKCkge1xuICAgIHRoaXMuY29udGVudERvY3VtZW50LmRlZmF1bHRWaWV3Ll9fcmVzaXplVHJpZ2dlcl9fID0gdGhpcy5fX3Jlc2l6ZUVsZW1lbnRfX1xuICAgIHRoaXMuY29udGVudERvY3VtZW50LmRlZmF1bHRWaWV3LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHJlc2l6ZUxpc3RlbmVyKVxuICB9XG5cbiAgaWYgKCFlbGVtZW50Ll9fcmVzaXplTGlzdGVuZXJzX18pIHtcbiAgICBlbGVtZW50Ll9fcmVzaXplTGlzdGVuZXJzX18gPSBbXVxuICAgIGlmIChhdHRhY2hFdmVudCkge1xuICAgICAgZWxlbWVudC5fX3Jlc2l6ZVRyaWdnZXJfXyA9IGVsZW1lbnRcbiAgICAgIGVsZW1lbnQuYXR0YWNoRXZlbnQoJ29ucmVzaXplJywgcmVzaXplTGlzdGVuZXIpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJykge1xuICAgICAgICBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJ1xuICAgICAgfVxuICAgICAgdmFyIG9iaiA9IChlbGVtZW50Ll9fcmVzaXplVHJpZ2dlcl9fID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb2JqZWN0JykpXG4gICAgICBvYmouc2V0QXR0cmlidXRlKFxuICAgICAgICAnc3R5bGUnLFxuICAgICAgICAnZGlzcGxheTogYmxvY2s7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAwOyBsZWZ0OiAwOyBoZWlnaHQ6IDEwMCU7IHdpZHRoOiAxMDAlOyBvdmVyZmxvdzogaGlkZGVuOyBwb2ludGVyLWV2ZW50czogbm9uZTsgei1pbmRleDogLTE7IG9wYWNpdHk6IDA7J1xuICAgICAgKVxuICAgICAgb2JqLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAncmVzaXplLXNlbnNvcicpXG4gICAgICBvYmouX19yZXNpemVFbGVtZW50X18gPSBlbGVtZW50XG4gICAgICBvYmoub25sb2FkID0gb2JqZWN0TG9hZFxuICAgICAgb2JqLnR5cGUgPSAndGV4dC9odG1sJ1xuICAgICAgaWYgKGlzSUUpIHtcbiAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChvYmopXG4gICAgICB9XG4gICAgICBvYmouZGF0YSA9ICdhYm91dDpibGFuaydcbiAgICAgIGlmICghaXNJRSkge1xuICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKG9iailcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZWxlbWVudC5fX3Jlc2l6ZUxpc3RlbmVyc19fLnB1c2goZm4pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogZXhwb3J0cy5iaW5kKHdpbmRvdylcblxubW9kdWxlLmV4cG9ydHMudW5iaW5kID0gZnVuY3Rpb24gKGVsZW1lbnQsIGZuKSB7XG4gIHZhciBhdHRhY2hFdmVudCA9IGRvY3VtZW50LmF0dGFjaEV2ZW50XG4gIGlmIChmbikge1xuICAgIGVsZW1lbnQuX19yZXNpemVMaXN0ZW5lcnNfXy5zcGxpY2UoXG4gICAgICBlbGVtZW50Ll9fcmVzaXplTGlzdGVuZXJzX18uaW5kZXhPZihmbiksXG4gICAgICAxXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIGVsZW1lbnQuX19yZXNpemVMaXN0ZW5lcnNfXyA9IFtdXG4gIH1cbiAgaWYgKCFlbGVtZW50Ll9fcmVzaXplTGlzdGVuZXJzX18ubGVuZ3RoKSB7XG4gICAgaWYgKGF0dGFjaEV2ZW50KSB7XG4gICAgICBlbGVtZW50LmRldGFjaEV2ZW50KCdvbnJlc2l6ZScsIHJlc2l6ZUxpc3RlbmVyKVxuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50Ll9fcmVzaXplVHJpZ2dlcl9fLmNvbnRlbnREb2N1bWVudC5kZWZhdWx0Vmlldy5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAncmVzaXplJyxcbiAgICAgICAgcmVzaXplTGlzdGVuZXJcbiAgICAgIClcbiAgICAgIGRlbGV0ZSBlbGVtZW50Ll9fcmVzaXplVHJpZ2dlcl9fLmNvbnRlbnREb2N1bWVudC5kZWZhdWx0Vmlldy5fX3Jlc2l6ZVRyaWdnZXJfX1xuICAgICAgZWxlbWVudC5fX3Jlc2l6ZVRyaWdnZXJfXyA9ICFlbGVtZW50LnJlbW92ZUNoaWxkKFxuICAgICAgICBlbGVtZW50Ll9fcmVzaXplVHJpZ2dlcl9fXG4gICAgICApXG4gICAgfVxuICAgIGRlbGV0ZSBlbGVtZW50Ll9fcmVzaXplTGlzdGVuZXJzX19cbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWxlbWVudC1yZXNpemUtZXZlbnQvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDkxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9